/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(bettor)/gameView/page",{

/***/ "(app-client)/./node_modules/mux-embed/dist/mux.js":
/*!********************************************!*\
  !*** ./node_modules/mux-embed/dist/mux.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n * mux-embed\n * @version 4.26.0\n * @copyright 2023 Mux, Inc\n */\n!function(){var e,t;e=this,t=function(){return function(){var e={80:function(e,t,r){e.exports=r(728).default},728:function(e,t,r){\"use strict\";r.d(t,{default:function(){return er}});var a=r(48),n=r.n(a),i=function(){return\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g,(function(e){var t=16*Math.random()|0;return(\"x\"===e?t:3&t|8).toString(16)}))},o=function(){return(\"000000\"+(Math.random()*Math.pow(36,6)<<0).toString(36)).slice(-6)},s=function(e){return e&&void 0!==e.nodeName?(e.muxId||(e.muxId=e.id||o()),e.muxId):e},u=function(e){var t;e&&void 0!==e.nodeName?e=s(t=e):t=document.querySelector(e);var r=t&&t.nodeName?t.nodeName.toLowerCase():\"\";return[t,e,r]},l=r(640),d=r.n(l),c=d().methodFactory;d().methodFactory=function(e,t,r){var a=c(e,t,r);return function(){for(var e=[\"[mux]\"],t=0;t<arguments.length;t++)e.push(arguments[t]);a.apply(void 0,e)}},d().setLevel(d().getLevel());var f=d();function p(){return\"1\"===(n().doNotTrack||n().navigator&&n().navigator.doNotTrack)}var _={now:function(){var e=n().performance,t=e&&e.timing,r=t&&t.navigationStart,a=\"number\"==typeof r&&\"function\"==typeof e.now?r+e.now():Date.now();return Math.round(a)}},h=function(e){return v(e)[0]},v=function(e){if(\"string\"!=typeof e||\"\"===e)return[\"localhost\"];var t,r=(e.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/)||[])[4];return r&&(t=(r.match(/[^\\.]+\\.[^\\.]+$/)||[])[0]),[r,t]},m={exists:function(){var e=n().performance;return void 0!==(e&&e.timing)},domContentLoadedEventEnd:function(){var e=n().performance,t=e&&e.timing;return t&&t.domContentLoadedEventEnd},navigationStart:function(){var e=n().performance,t=e&&e.timing;return t&&t.navigationStart}};function y(e,t,r){r=void 0===r?1:r,e[t]=e[t]||0,e[t]+=r}var b=[\"x-request-id\",\"cf-ray\",\"x-amz-cf-id\",\"x-akamai-request-id\"],g=[\"x-cdn\",\"content-type\"].concat(b);function w(e){var t={};return(e=e||\"\").trim().split(/[\\r\\n]+/).forEach((function(e){if(e){var r=e.split(\": \"),a=r.shift();a&&(g.indexOf(a.toLowerCase())>=0||0===a.toLowerCase().indexOf(\"x-litix-\"))&&(t[a]=r.join(\": \"))}})),t}function T(e){if(e){var t=b.find((function(t){return void 0!==e[t]}));return t?e[t]:void 0}}var E=function(e){var t={};for(var r in e){var a=e[r];-1!==a[\"DATA-ID\"].search(\"io.litix.data.\")&&(t[a[\"DATA-ID\"].replace(\"io.litix.data.\",\"\")]=a.VALUE)}return t};function k(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function O(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?k(Object(r),!0).forEach((function(t){D(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):k(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function D(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var x=function(e){if(!e)return{};var t=m.navigationStart(),r=e.loading,a=r?r.start:e.trequest,n=r?r.first:e.tfirst,i=r?r.end:e.tload;return{bytesLoaded:e.total,requestStart:Math.round(t+a),responseStart:Math.round(t+n),responseEnd:Math.round(t+i)}},S=function(e){if(e&&\"function\"==typeof e.getAllResponseHeaders)return w(e.getAllResponseHeaders())};function q(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function P(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?q(Object(r),!0).forEach((function(t){A(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):q(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function A(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var R=function(e,t){if(!e||\"function\"!=typeof e.getRequests)return{};var r=e.getRequests({state:\"executed\"});if(0===r.length)return{};var a,n=r[r.length-1],i=h(n.url),o=n.url,s=n.bytesLoaded,u=new Date(n.requestStartDate).getTime(),l=new Date(n.firstByteDate).getTime(),d=new Date(n.requestEndDate).getTime(),c=isNaN(n.duration)?0:n.duration,f=\"function\"==typeof t.getMetricsFor?t.getMetricsFor(n.mediaType).HttpList:t.getDashMetrics().getHttpRequests(n.mediaType);return f.length>0&&(a=w(f[f.length-1]._responseHeaders||\"\")),{requestStart:u,requestResponseStart:l,requestResponseEnd:d,requestBytesLoaded:s,requestResponseHeaders:a,requestMediaDuration:c,requestHostname:i,requestUrl:o,requestId:a?T(a):void 0}},I=function(e,t){var r=t.getQualityFor(e),a=t.getCurrentTrackFor(e).bitrateList;return a?{currentLevel:r,renditionWidth:a[r].width||null,renditionHeight:a[r].height||null,renditionBitrate:a[r].bandwidth}:{}},j=function(e){var t;return null===(t=e.match(/.*codecs\\*?=\"(.*)\"/))||void 0===t?void 0:t[1]};function L(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var C=0,N=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e)}var t,r,a;return t=e,r=[{key:\"on\",value:function(e,t,r){return t._eventEmitterGuid=t._eventEmitterGuid||++C,this._listeners=this._listeners||{},this._listeners[e]=this._listeners[e]||[],r&&(t=t.bind(r)),this._listeners[e].push(t),t}},{key:\"off\",value:function(e,t){var r=this._listeners&&this._listeners[e];r&&r.forEach((function(e,a){e._eventEmitterGuid===t._eventEmitterGuid&&r.splice(a,1)}))}},{key:\"one\",value:function(e,t,r){var a=this;t._eventEmitterGuid=t._eventEmitterGuid||++C;var n=function n(){a.off(e,n),t.apply(r||this,arguments)};n._eventEmitterGuid=t._eventEmitterGuid,this.on(e,n)}},{key:\"emit\",value:function(e,t){var r=this;if(this._listeners){t=t||{};var a=this._listeners[\"before*\"]||[],n=this._listeners[e]||[],i=this._listeners[\"after\"+e]||[],o=function(t,a){(t=t.slice()).forEach((function(t){t.call(r,{type:e},a)}))};o(a,t),o(n,t),o(i,t)}}}],r&&L(t.prototype,r),a&&L(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}(),H=N;function M(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var B=function(){function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,this._playbackHeartbeatInterval=null,this._playheadShouldBeProgressing=!1,t.on(\"playing\",(function(){r._playheadShouldBeProgressing=!0})),t.on(\"play\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"playing\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"adbreakstart\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"adplay\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"adplaying\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"seeking\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"devicewake\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"viewstart\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"rebufferstart\",this._startPlaybackHeartbeatInterval.bind(this)),t.on(\"pause\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"ended\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"viewend\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"error\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"aderror\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"adpause\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"adended\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"adbreakend\",this._stopPlaybackHeartbeatInterval.bind(this)),t.on(\"seeked\",(function(){t.data.player_is_paused?r._stopPlaybackHeartbeatInterval():r._startPlaybackHeartbeatInterval()})),t.on(\"timeupdate\",(function(){null!==r._playbackHeartbeatInterval&&t.emit(\"playbackheartbeat\")})),t.on(\"devicesleep\",(function(e,a){null!==r._playbackHeartbeatInterval&&(n().clearInterval(r._playbackHeartbeatInterval),t.emit(\"playbackheartbeatend\",{viewer_time:a.viewer_time}),r._playbackHeartbeatInterval=null)}))}var t,r,a;return t=e,(r=[{key:\"_startPlaybackHeartbeatInterval\",value:function(){var e=this;null===this._playbackHeartbeatInterval&&(this.pm.emit(\"playbackheartbeat\"),this._playbackHeartbeatInterval=n().setInterval((function(){e.pm.emit(\"playbackheartbeat\")}),this.pm.playbackHeartbeatTime))}},{key:\"_stopPlaybackHeartbeatInterval\",value:function(){this._playheadShouldBeProgressing=!1,null!==this._playbackHeartbeatInterval&&(n().clearInterval(this._playbackHeartbeatInterval),this.pm.emit(\"playbackheartbeatend\"),this._playbackHeartbeatInterval=null)}}])&&M(t.prototype,r),a&&M(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function U(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function F(e,t,r){return t&&U(e.prototype,t),r&&U(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var G=F((function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),t.on(\"viewinit\",(function(){r.viewErrored=!1})),t.on(\"error\",(function(e,a){try{var n=t.errorTranslator({player_error_code:a.player_error_code,player_error_message:a.player_error_message,player_error_context:a.player_error_context});n?(t.data.player_error_code=n.player_error_code||a.player_error_code,t.data.player_error_message=n.player_error_message||a.player_error_message,t.data.player_error_context=n.player_error_context||a.player_error_context,r.viewErrored=!0):(delete t.data.player_error_code,delete t.data.player_error_message,delete t.data.player_error_context)}catch(e){t.mux.log.warn(\"Exception in error translator callback.\",e),r.viewErrored=!0}}))}));function W(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var Q=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,this._watchTimeTrackerLastCheckedTime=null,t.on(\"playbackheartbeat\",this._updateWatchTime.bind(this)),t.on(\"playbackheartbeatend\",this._clearWatchTimeState.bind(this))}var t,r,a;return t=e,(r=[{key:\"_updateWatchTime\",value:function(e,t){var r=t.viewer_time;null===this._watchTimeTrackerLastCheckedTime&&(this._watchTimeTrackerLastCheckedTime=r),y(this.pm.data,\"view_watch_time\",r-this._watchTimeTrackerLastCheckedTime),this._watchTimeTrackerLastCheckedTime=r}},{key:\"_clearWatchTimeState\",value:function(e,t){this._updateWatchTime(e,t),this._watchTimeTrackerLastCheckedTime=null}}])&&W(t.prototype,r),a&&W(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function V(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var J=function(){function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,this._playbackTimeTrackerLastPlayheadPosition=-1,this._lastTime=_.now(),this._isAdPlaying=!1,t.on(\"playbackheartbeat\",this._updatePlaybackTime.bind(this)),t.on(\"playbackheartbeatend\",this._clearPlaybackTimeState.bind(this)),t.on(\"seeking\",this._clearPlaybackTimeState.bind(this)),t.on(\"adplaying\",(function(){r._isAdPlaying=!0})),t.on(\"adended\",(function(){r._isAdPlaying=!1})),t.on(\"adpause\",(function(){r._isAdPlaying=!1})),t.on(\"adbreakstart\",(function(){r._isAdPlaying=!1})),t.on(\"adbreakend\",(function(){r._isAdPlaying=!1})),t.on(\"adplay\",(function(){r._isAdPlaying=!1}))}var t,r,a;return t=e,(r=[{key:\"_updatePlaybackTime\",value:function(){var e=this.pm.data.player_playhead_time,t=_.now(),r=-1;this._playbackTimeTrackerLastPlayheadPosition>=0&&e>this._playbackTimeTrackerLastPlayheadPosition?r=e-this._playbackTimeTrackerLastPlayheadPosition:this._isAdPlaying&&(r=t-this._lastTime),r>0&&r<=1e3&&y(this.pm.data,\"view_content_playback_time\",r),this._playbackTimeTrackerLastPlayheadPosition=e,this._lastTime=t}},{key:\"_clearPlaybackTimeState\",value:function(){this._updatePlaybackTime(),this._playbackTimeTrackerLastPlayheadPosition=-1}}])&&V(t.prototype,r),a&&V(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function K(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var z=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t;var r=this._updatePlayheadTime.bind(this);t.on(\"playbackheartbeat\",r),t.on(\"playbackheartbeatend\",r),t.on(\"timeupdate\",r),t.on(\"destroy\",(function(){t.off(\"timeupdate\",r)}))}var t,r,a;return t=e,(r=[{key:\"_updateMaxPlayheadPosition\",value:function(){this.pm.data.view_max_playhead_position=void 0===this.pm.data.view_max_playhead_position?this.pm.data.player_playhead_time:Math.max(this.pm.data.view_max_playhead_position,this.pm.data.player_playhead_time)}},{key:\"_updatePlayheadTime\",value:function(e,t){var r=this,a=function(){r.pm.currentFragmentPDT&&r.pm.currentFragmentStart&&(r.pm.data.player_program_time=r.pm.currentFragmentPDT+r.pm.data.player_playhead_time-r.pm.currentFragmentStart)};if(t&&t.player_playhead_time)this.pm.data.player_playhead_time=t.player_playhead_time,a(),this._updateMaxPlayheadPosition();else if(this.pm.getPlayheadTime){var n=this.pm.getPlayheadTime();void 0!==n&&(this.pm.data.player_playhead_time=n,a(),this._updateMaxPlayheadPosition())}}}])&&K(t.prototype,r),a&&K(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function Y(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function X(e,t,r){return t&&Y(e.prototype,t),r&&Y(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var $=3e5,Z=X((function e(t){if(function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),!t.disableRebufferTracking){var r,a=function(e,t){n(t),r=void 0},n=function(e){if(r){var a=e.viewer_time-r;y(t.data,\"view_rebuffer_duration\",a),r=e.viewer_time,t.data.view_rebuffer_duration>$&&(t.emit(\"viewend\"),t.send(\"viewend\"),t.mux.log.warn(\"Ending view after rebuffering for longer than \".concat($,\"ms, future events will be ignored unless a programchange or videochange occurs.\")))}t.data.view_watch_time>=0&&t.data.view_rebuffer_count>0&&(t.data.view_rebuffer_frequency=t.data.view_rebuffer_count/t.data.view_watch_time,t.data.view_rebuffer_percentage=t.data.view_rebuffer_duration/t.data.view_watch_time)};t.on(\"playbackheartbeat\",(function(e,t){return n(t)})),t.on(\"rebufferstart\",(function(e,n){r||(y(t.data,\"view_rebuffer_count\",1),r=n.viewer_time,t.one(\"rebufferend\",a))})),t.on(\"viewinit\",(function(){r=void 0,t.off(\"rebufferend\",a)}))}}));function ee(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var te=function(){function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,t.disableRebufferTracking||t.disablePlayheadRebufferTracking||(this._lastCheckedTime=null,this._lastPlayheadTime=null,this._lastPlayheadTimeUpdatedTime=null,t.on(\"playbackheartbeat\",this._checkIfRebuffering.bind(this)),t.on(\"playbackheartbeatend\",this._cleanupRebufferTracker.bind(this)),t.on(\"seeking\",(function(){r._cleanupRebufferTracker(null,{viewer_time:_.now()})})))}var t,r,a;return t=e,r=[{key:\"_checkIfRebuffering\",value:function(e,t){if(this.pm.seekingTracker.isSeeking||this.pm.adTracker.isAdBreak||!this.pm.playbackHeartbeat._playheadShouldBeProgressing)this._cleanupRebufferTracker(e,t);else if(null!==this._lastCheckedTime)if(this._lastPlayheadTime===this.pm.data.player_playhead_time){var r=t.viewer_time-this._lastPlayheadTimeUpdatedTime;\"number\"==typeof this.pm.sustainedRebufferThreshold&&r>=this.pm.sustainedRebufferThreshold&&(this._rebuffering||(this._rebuffering=!0,this.pm.emit(\"rebufferstart\",{viewer_time:this._lastPlayheadTimeUpdatedTime}))),this._lastCheckedTime=t.viewer_time}else this._cleanupRebufferTracker(e,t,!0);else this._prepareRebufferTrackerState(t.viewer_time)}},{key:\"_clearRebufferTrackerState\",value:function(){this._lastCheckedTime=null,this._lastPlayheadTime=null,this._lastPlayheadTimeUpdatedTime=null}},{key:\"_prepareRebufferTrackerState\",value:function(e){this._lastCheckedTime=e,this._lastPlayheadTime=this.pm.data.player_playhead_time,this._lastPlayheadTimeUpdatedTime=e}},{key:\"_cleanupRebufferTracker\",value:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(this._rebuffering)this._rebuffering=!1,this.pm.emit(\"rebufferend\",{viewer_time:t.viewer_time});else{if(null===this._lastCheckedTime)return;var a=this.pm.data.player_playhead_time-this._lastPlayheadTime,n=t.viewer_time-this._lastPlayheadTimeUpdatedTime;\"number\"==typeof this.pm.minimumRebufferDuration&&a>0&&n-a>this.pm.minimumRebufferDuration&&(this._lastCheckedTime=null,this.pm.emit(\"rebufferstart\",{viewer_time:this._lastPlayheadTimeUpdatedTime}),this.pm.emit(\"rebufferend\",{viewer_time:this._lastPlayheadTimeUpdatedTime+n-a}))}r?this._prepareRebufferTrackerState(t.viewer_time):this._clearRebufferTrackerState()}}],r&&ee(t.prototype,r),a&&ee(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}(),re=te;function ae(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var ne=function(){function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,t.on(\"viewinit\",(function(){var e=t.data,a=e.view_id;if(!e.view_program_changed){var n=function(e,n){var i=n.viewer_time;\"playing\"===e.type&&void 0===t.data.view_time_to_first_frame?r.calculateTimeToFirstFrame(i||_.now(),a):\"adplaying\"!==e.type||void 0!==t.data.view_time_to_first_frame&&!r._inPrerollPosition()||r.calculateTimeToFirstFrame(i||_.now(),a)};t.one(\"playing\",n),t.one(\"adplaying\",n),t.one(\"viewend\",(function(){t.off(\"playing\",n),t.off(\"adplaying\",n)}))}}))}var t,r,a;return t=e,(r=[{key:\"_inPrerollPosition\",value:function(){return void 0===this.pm.data.view_content_playback_time||this.pm.data.view_content_playback_time<=1e3}},{key:\"calculateTimeToFirstFrame\",value:function(e,t){t===this.pm.data.view_id&&(this.pm.watchTimeTracker._updateWatchTime(null,{viewer_time:e}),this.pm.data.view_time_to_first_frame=this.pm.data.view_watch_time,(this.pm.data.player_autoplay_on||this.pm.data.video_is_autoplay)&&this.NAVIGATION_START&&(this.pm.data.view_aggregate_startup_time=this.pm.data.view_start+this.pm.data.view_watch_time-this.NAVIGATION_START))}}])&&ae(t.prototype,r),a&&ae(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function ie(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function oe(e,t,r){return t&&ie(e.prototype,t),r&&ie(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var se=oe((function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),t.on(\"viewinit\",(function(){r._lastPlayheadPosition=-1})),[\"pause\",\"rebufferstart\",\"seeking\",\"error\",\"adbreakstart\",\"hb\"].forEach((function(e){t.on(e,(function(){if(r._lastPlayheadPosition>=0&&t.data.player_playhead_time>=0&&r._lastPlayerWidth>=0&&r._lastSourceWidth>0&&r._lastPlayerHeight>=0&&r._lastSourceHeight>0){var e=t.data.player_playhead_time-r._lastPlayheadPosition;if(e<0)return void(r._lastPlayheadPosition=-1);var a=Math.min(r._lastPlayerWidth/r._lastSourceWidth,r._lastPlayerHeight/r._lastSourceHeight),n=Math.max(0,a-1),i=Math.max(0,1-a);t.data.view_max_upscale_percentage=Math.max(t.data.view_max_upscale_percentage||0,n),t.data.view_max_downscale_percentage=Math.max(t.data.view_max_downscale_percentage||0,i),y(t.data,\"view_total_content_playback_time\",e),y(t.data,\"view_total_upscaling\",n*e),y(t.data,\"view_total_downscaling\",i*e)}r._lastPlayheadPosition=-1}))})),[\"playing\",\"hb\"].forEach((function(e){t.on(e,(function(){r._lastPlayheadPosition=t.data.player_playhead_time,r._lastPlayerWidth=t.data.player_width,r._lastPlayerHeight=t.data.player_height,r._lastSourceWidth=t.data.video_source_width,r._lastSourceHeight=t.data.video_source_height}))}))}));function ue(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function le(e,t,r){return t&&ue(e.prototype,t),r&&ue(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var de=le((function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.isSeeking=!1,t.on(\"seeking\",(function(e,a){Object.assign(t.data,a),r._lastSeekingTime=_.now(),!1===r.isSeeking&&(r.isSeeking=!0,t.send(\"seeking\"))})),t.on(\"seeked\",(function(){r.isSeeking=!1;var e=r._lastSeekingTime||_.now(),a=_.now()-e;y(t.data,\"view_seek_count\",1),y(t.data,\"view_seek_duration\",a);var n=t.data.view_max_seek_time||0;t.data.view_max_seek_time=Math.max(n,a)})),t.on(\"viewend\",(function(){r.isSeeking=!1}))}));function ce(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,i=[],o=!0,s=!1;try{for(r=r.call(e);!(o=(a=r.next()).done)&&(i.push(a.value),!t||i.length!==t);o=!0);}catch(e){s=!0,n=e}finally{try{o||null==r.return||r.return()}finally{if(s)throw n}}return i}}(e,t)||function(e,t){if(e){if(\"string\"==typeof e)return fe(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?fe(e,t):void 0}}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function fe(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}function pe(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}var _e=function(e,t){e.push(t),e.sort((function(e,t){return e.viewer_time-t.viewer_time}))},he=[\"adbreakstart\",\"adrequest\",\"adresponse\",\"adplay\",\"adplaying\",\"adpause\",\"adended\",\"adbreakend\",\"aderror\"],ve=function(){function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.pm=t,t.on(\"viewinit\",(function(){r.isAdBreak=!1,r._currentAdRequestNumber=0,r._currentAdResponseNumber=0,r._adRequests=[],r._adResponses=[],r._adHasPlayed=!1,r._wouldBeNewAdPlay=!0,r._prerollPlayTime=void 0})),he.forEach((function(e){return t.on(e,r._updateAdData.bind(r))}));var a=function(){r.isAdBreak=!1};t.on(\"adbreakstart\",(function(){r.isAdBreak=!0})),t.on(\"play\",a),t.on(\"playing\",a),t.on(\"viewend\",a),t.on(\"adrequest\",(function(e,a){a=Object.assign({ad_request_id:\"generatedAdRequestId\"+r._currentAdRequestNumber++},a),_e(r._adRequests,a),y(t.data,\"view_ad_request_count\"),r.inPrerollPosition()&&(t.data.view_preroll_requested=!0,r._adHasPlayed||y(t.data,\"view_preroll_request_count\"))})),t.on(\"adresponse\",(function(e,a){a=Object.assign({ad_request_id:\"generatedAdRequestId\"+r._currentAdResponseNumber++},a),_e(r._adResponses,a);var n=r.findAdRequest(a.ad_request_id);n&&y(t.data,\"view_ad_request_time\",Math.max(0,a.viewer_time-n.viewer_time))})),t.on(\"adplay\",(function(e,a){r._adHasPlayed=!0,r._wouldBeNewAdPlay&&(r._wouldBeNewAdPlay=!1,y(t.data,\"view_ad_played_count\")),r.inPrerollPosition()&&!t.data.view_preroll_played&&(t.data.view_preroll_played=!0,r._adRequests.length>0&&(t.data.view_preroll_request_time=Math.max(0,a.viewer_time-r._adRequests[0].viewer_time)),t.data.view_start&&(t.data.view_startup_preroll_request_time=Math.max(0,a.viewer_time-t.data.view_start)),r._prerollPlayTime=a.viewer_time)})),t.on(\"adplaying\",(function(e,a){r.inPrerollPosition()&&void 0===t.data.view_preroll_load_time&&void 0!==r._prerollPlayTime&&(t.data.view_preroll_load_time=a.viewer_time-r._prerollPlayTime,t.data.view_startup_preroll_load_time=a.viewer_time-r._prerollPlayTime)})),t.on(\"adended\",(function(){r._wouldBeNewAdPlay=!0})),t.on(\"aderror\",(function(){r._wouldBeNewAdPlay=!0}))}var t,r,a;return t=e,(r=[{key:\"inPrerollPosition\",value:function(){return void 0===this.pm.data.view_content_playback_time||this.pm.data.view_content_playback_time<=1e3}},{key:\"findAdRequest\",value:function(e){for(var t=0;t<this._adRequests.length;t++)if(this._adRequests[t].ad_request_id===e)return this._adRequests[t]}},{key:\"_updateAdData\",value:function(e,t){if(this.inPrerollPosition()){if(!this.pm.data.view_preroll_ad_tag_hostname&&t.ad_tag_url){var r=ce(v(t.ad_tag_url),2),a=r[0],n=r[1];this.pm.data.view_preroll_ad_tag_domain=n,this.pm.data.view_preroll_ad_tag_hostname=a}if(!this.pm.data.view_preroll_ad_asset_hostname&&t.ad_asset_url){var i=ce(v(t.ad_asset_url),2),o=i[0],s=i[1];this.pm.data.view_preroll_ad_asset_domain=s,this.pm.data.view_preroll_ad_asset_hostname=o}}this.pm.data.ad_asset_url=null==t?void 0:t.ad_asset_url,this.pm.data.ad_tag_url=null==t?void 0:t.ad_tag_url,this.pm.data.ad_creative_id=null==t?void 0:t.ad_creative_id,this.pm.data.ad_id=null==t?void 0:t.ad_id,this.pm.data.ad_universal_id=null==t?void 0:t.ad_universal_id}}])&&pe(t.prototype,r),a&&pe(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function me(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function ye(e,t,r){return t&&me(e.prototype,t),r&&me(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var be=ye((function e(t){var r,a;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e);var i=function(){t.disableRebufferTracking||r&&(y(t.data,\"view_waiting_rebuffer_duration\",_.now()-r),r=!1,n().clearInterval(a))},o=!1,s=function(){o=!1,i()};t.on(\"waiting\",(function(){o&&(t.disableRebufferTracking||(y(t.data,\"view_waiting_rebuffer_count\",1),r=_.now(),a=n().setInterval((function(){if(r){var e=_.now();y(t.data,\"view_waiting_rebuffer_duration\",e-r),r=e}}),250)))})),t.on(\"playing\",(function(){i(),o=!0})),t.on(\"pause\",s),t.on(\"seeking\",s)}));function ge(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function we(e,t,r){return t&&ge(e.prototype,t),r&&ge(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var Te=we((function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e);var a=function(){r.lastWallClockTime=_.now(),t.on(\"before*\",n)},n=function(e){var a=_.now(),n=r.lastWallClockTime;r.lastWallClockTime=a,a-n>3e4&&(t.emit(\"devicesleep\",{viewer_time:n}),Object.assign(t.data,{viewer_time:n}),t.send(\"devicesleep\"),t.emit(\"devicewake\",{viewer_time:a}),Object.assign(t.data,{viewer_time:a}),t.send(\"devicewake\"))};t.one(\"playbackheartbeat\",a),t.on(\"playbackheartbeatend\",(function(){t.off(\"before*\",n),t.one(\"playbackheartbeat\",a)}))})),Ee=r(375),ke=r(655),Oe=r.n(ke),De=\"muxData\",xe=function(){var e;try{e=Ee.parse(Oe().get(De)||\"\")}catch(t){e={}}return e},Se=function(e){try{Oe().set(De,Ee.stringify(e),{expires:365})}catch(e){}},qe=function(){var e=xe();return e.mux_viewer_id=e.mux_viewer_id||i(),e.msn=e.msn||Math.random(),Se(e),{mux_viewer_id:e.mux_viewer_id,mux_sample_number:e.msn}};function Pe(e,t){var r=t.beaconCollectionDomain,a=t.beaconDomain;if(r)return\"https://\"+r;var n=a||\"litix.io\";return(e=e||\"inferred\").match(/^[a-z0-9]+$/)?\"https://\"+e+\".\"+n:\"https://img.litix.io/a.gif\"}var Ae=function(){var e;switch(Re()){case\"cellular\":e=\"cellular\";break;case\"ethernet\":e=\"wired\";break;case\"wifi\":e=\"wifi\";break;case void 0:break;default:e=\"other\"}return e},Re=function(){var e=n().navigator,t=e&&(e.connection||e.mozConnection||e.webkitConnection);return t&&t.type};Ae.getConnectionFromAPI=Re;var Ie=Ae,je=Ce({a:\"env\",b:\"beacon\",c:\"custom\",d:\"ad\",e:\"event\",f:\"experiment\",i:\"internal\",m:\"mux\",n:\"response\",p:\"player\",q:\"request\",r:\"retry\",s:\"session\",t:\"timestamp\",u:\"viewer\",v:\"video\",w:\"page\",x:\"view\",y:\"sub\"}),Le=Ce({ad:\"ad\",ag:\"aggregate\",ap:\"api\",al:\"application\",ar:\"architecture\",as:\"asset\",au:\"autoplay\",av:\"average\",bi:\"bitrate\",br:\"break\",bw:\"browser\",by:\"bytes\",ca:\"cached\",cb:\"cancel\",cc:\"codec\",cd:\"code\",cg:\"category\",ch:\"changed\",cl:\"canceled\",cn:\"config\",co:\"count\",ce:\"counter\",cp:\"complete\",cr:\"creative\",ct:\"content\",cu:\"current\",cx:\"connection\",cz:\"context\",dg:\"downscaling\",dm:\"domain\",dn:\"cdn\",do:\"downscale\",dr:\"drm\",dp:\"dropped\",du:\"duration\",dv:\"device\",ec:\"encoding\",ed:\"edge\",en:\"end\",eg:\"engine\",em:\"embed\",er:\"error\",es:\"errorcode\",et:\"errortext\",ee:\"event\",ev:\"events\",ex:\"expires\",ep:\"experiments\",fa:\"failed\",fi:\"first\",fm:\"family\",ft:\"format\",fp:\"fps\",fq:\"frequency\",fr:\"frame\",fs:\"fullscreen\",ha:\"has\",hb:\"holdback\",he:\"headers\",ho:\"host\",hn:\"hostname\",ht:\"height\",id:\"id\",ii:\"init\",in:\"instance\",ip:\"ip\",is:\"is\",ke:\"key\",la:\"language\",lb:\"labeled\",le:\"level\",li:\"live\",ld:\"loaded\",lo:\"load\",ls:\"lists\",lt:\"latency\",ma:\"max\",md:\"media\",me:\"message\",mf:\"manifest\",mi:\"mime\",ml:\"midroll\",mm:\"min\",mn:\"manufacturer\",mo:\"model\",mx:\"mux\",ne:\"newest\",nm:\"name\",no:\"number\",on:\"on\",os:\"os\",pa:\"paused\",pb:\"playback\",pd:\"producer\",pe:\"percentage\",pf:\"played\",pg:\"program\",ph:\"playhead\",pi:\"plugin\",pl:\"preroll\",pn:\"playing\",po:\"poster\",pr:\"preload\",ps:\"position\",pt:\"part\",py:\"property\",ra:\"rate\",rd:\"requested\",re:\"rebuffer\",rf:\"rendition\",rm:\"remote\",ro:\"ratio\",rp:\"response\",rq:\"request\",rs:\"requests\",sa:\"sample\",se:\"session\",sk:\"seek\",sm:\"stream\",so:\"source\",sq:\"sequence\",sr:\"series\",st:\"start\",su:\"startup\",sv:\"server\",sw:\"software\",ta:\"tag\",tc:\"tech\",te:\"text\",tg:\"target\",th:\"throughput\",ti:\"time\",tl:\"total\",to:\"to\",tt:\"title\",ty:\"type\",ug:\"upscaling\",un:\"universal\",up:\"upscale\",ur:\"url\",us:\"user\",va:\"variant\",vd:\"viewed\",vi:\"video\",ve:\"version\",vw:\"view\",vr:\"viewer\",wd:\"width\",wa:\"watch\",wt:\"waiting\"});function Ce(e){var t={};for(var r in e)e.hasOwnProperty(r)&&(t[e[r]]=r);return t}function Ne(e){var t={},r={};return Object.keys(e).forEach((function(a){var n=!1;if(e.hasOwnProperty(a)&&void 0!==e[a]){var i=a.split(\"_\"),o=i[0],s=je[o];s||(f.info(\"Data key word `\"+i[0]+\"` not expected in \"+a),s=o+\"_\"),i.splice(1).forEach((function(e){\"url\"===e&&(n=!0),Le[e]?s+=Le[e]:Number(e)&&Math.floor(Number(e))===Number(e)?s+=e:(f.info(\"Data key word `\"+e+\"` not expected in \"+a),s+=\"_\"+e+\"_\")})),n?r[s]=e[a]:t[s]=e[a]}})),Object.assign(t,r)}var He={maxBeaconSize:300,maxQueueLength:3600,baseTimeBetweenBeacons:1e4,maxPayloadKBSize:500},Me=[\"hb\",\"requestcompleted\",\"requestfailed\",\"requestcanceled\"],Be=\"https://img.litix.io\",Ue=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._beaconUrl=e||Be,this._eventQueue=[],this._postInFlight=!1,this._failureCount=0,this._sendTimeout=!1,this._options=Object.assign({},He,t)};Ue.prototype.queueEvent=function(e,t){var r=Object.assign({},t);return(this._eventQueue.length<=this._options.maxQueueLength||\"eventrateexceeded\"===e)&&(this._eventQueue.push(r),this._sendTimeout||this._startBeaconSending(),this._eventQueue.length<=this._options.maxQueueLength)},Ue.prototype.flushEvents=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];e&&1===this._eventQueue.length?this._eventQueue.pop():(this._eventQueue.length&&this._sendBeaconQueue(),this._startBeaconSending())},Ue.prototype.destroy=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.destroyed=!0,e?this._clearBeaconQueue():this.flushEvents(),n().clearTimeout(this._sendTimeout)},Ue.prototype._clearBeaconQueue=function(){var e=this._eventQueue.length>this._options.maxBeaconSize?this._eventQueue.length-this._options.maxBeaconSize:0,t=this._eventQueue.slice(e);e>0&&Object.assign(t[t.length-1],Ne({mux_view_message:\"event queue truncated\"}));var r=this._createPayload(t);Ge(this._beaconUrl,r,!0,(function(){}))},Ue.prototype._sendBeaconQueue=function(){var e=this;if(!this._postInFlight){var t=this._eventQueue.slice(0,this._options.maxBeaconSize);this._eventQueue=this._eventQueue.slice(this._options.maxBeaconSize),this._postInFlight=!0;var r=this._createPayload(t),a=_.now();Ge(this._beaconUrl,r,!1,(function(r,n){n?(e._eventQueue=t.concat(e._eventQueue),e._failureCount+=1,f.info(\"Error sending beacon: \"+n)):e._failureCount=0,e._roundTripTime=_.now()-a,e._postInFlight=!1}))}},Ue.prototype._getNextBeaconTime=function(){if(!this._failureCount)return this._options.baseTimeBetweenBeacons;var e=Math.pow(2,this._failureCount-1);return(1+(e*=Math.random()))*this._options.baseTimeBetweenBeacons},Ue.prototype._startBeaconSending=function(){var e=this;n().clearTimeout(this._sendTimeout),this.destroyed||(this._sendTimeout=n().setTimeout((function(){e._eventQueue.length&&e._sendBeaconQueue(),e._startBeaconSending()}),this._getNextBeaconTime()))},Ue.prototype._createPayload=function(e){var t,r,a,n=this,i={transmission_timestamp:Math.round(_.now())};this._roundTripTime&&(i.rtt_ms=Math.round(this._roundTripTime));var o=function(){t=JSON.stringify({metadata:i,events:r||e}),a=t.length/1024},s=function(){return a<=n._options.maxPayloadKBSize};return o(),s()||(f.info(\"Payload size is too big (\"+a+\" kb). Removing unnecessary events.\"),r=e.filter((function(e){return-1===Me.indexOf(e.e)})),o()),s()||(f.info(\"Payload size still too big (\"+a+\" kb). Cropping fields..\"),r.forEach((function(e){for(var t in e){var r=e[t];\"string\"==typeof r&&r.length>51200&&(e[t]=r.substring(0,51200))}})),o()),t};var Fe=function(e){return e.length<=57344},Ge=function(e,t,r,a){if(r&&navigator&&navigator.sendBeacon&&navigator.sendBeacon(e,t))a();else if(n().fetch)n().fetch(e,{method:\"POST\",body:t,headers:{\"Content-Type\":\"text/plain\"},keepalive:Fe(t)}).then((function(e){return a(null,e.ok?null:\"Error\")})).catch((function(e){return a(null,e)}));else{if(n().XMLHttpRequest){var i=new(n().XMLHttpRequest);return i.onreadystatechange=function(){if(4===i.readyState)return a(null,200!==i.status?\"error\":void 0)},i.open(\"POST\",e),i.setRequestHeader(\"Content-Type\",\"text/plain\"),void i.send(t)}a()}},We=Ue;function Qe(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,i=[],o=!0,s=!1;try{for(r=r.call(e);!(o=(a=r.next()).done)&&(i.push(a.value),!t||i.length!==t);o=!0);}catch(e){s=!0,n=e}finally{try{o||null==r.return||r.return()}finally{if(s)throw n}}return i}}(e,t)||function(e,t){if(e){if(\"string\"==typeof e)return Ve(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Ve(e,t):void 0}}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Ve(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}function Je(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function Ke(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Je(Object(r),!0).forEach((function(t){$e(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Je(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function ze(e){return ze=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},ze(e)}function Ye(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function Xe(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function $e(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var Ze=[\"env_key\",\"view_id\",\"view_sequence_number\",\"player_sequence_number\",\"beacon_domain\",\"player_playhead_time\",\"viewer_time\",\"mux_api_version\",\"event\",\"video_id\",\"player_instance_id\"],et=[\"adplay\",\"adplaying\",\"adpause\",\"adfirstquartile\",\"admidpoint\",\"adthirdquartile\",\"adended\",\"adresponse\",\"adrequest\"],tt=[\"ad_id\",\"ad_creative_id\",\"ad_universal_id\"],rt=[\"viewstart\",\"error\",\"ended\",\"viewend\"],at=function(){function e(t,r){var a,i,o,s,u,l,d,c,f,p,_,h,v,m,y,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ye(this,e),$e(this,\"previousBeaconData\",null),$e(this,\"lastEventTime\",0),$e(this,\"rateLimited\",!1),this.mux=t,this.envKey=r,this.options=b,this.eventQueue=new We(Pe(this.envKey,this.options)),this.sampleRate=null!==(a=this.options.sampleRate)&&void 0!==a?a:1,this.disableCookies=null!==(i=this.options.disableCookies)&&void 0!==i&&i,this.respectDoNotTrack=null!==(o=this.options.respectDoNotTrack)&&void 0!==o&&o,this.previousBeaconData=null,this.lastEventTime=0,this.rateLimited=!1,this.pageLevelData={mux_api_version:this.mux.API_VERSION,mux_embed:this.mux.NAME,mux_embed_version:this.mux.VERSION,viewer_application_name:null===(s=this.options.platform)||void 0===s?void 0:s.name,viewer_application_version:null===(u=this.options.platform)||void 0===u?void 0:u.version,viewer_application_engine:null===(l=this.options.platform)||void 0===l?void 0:l.layout,viewer_device_name:null===(d=this.options.platform)||void 0===d?void 0:d.product,viewer_device_category:\"\",viewer_device_manufacturer:null===(c=this.options.platform)||void 0===c?void 0:c.manufacturer,viewer_os_family:null===(f=this.options.platform)||void 0===f||null===(p=f.os)||void 0===p?void 0:p.family,viewer_os_architecture:null===(_=this.options.platform)||void 0===_||null===(h=_.os)||void 0===h?void 0:h.architecture,viewer_os_version:null===(v=this.options.platform)||void 0===v||null===(m=v.os)||void 0===m?void 0:m.version,viewer_connection_type:Ie(),page_url:null===n()||void 0===n()||null===(y=n().location)||void 0===y?void 0:y.href},this.viewerData=this.disableCookies?{}:qe()}var t,r,a;return t=e,(r=[{key:\"send\",value:function(e,t){var r;if(e&&null!=t&&t.view_id){if(this.respectDoNotTrack&&p())return f.info(\"Not sending `\"+e+\"` because Do Not Track is enabled\");if(!t||\"object\"!==ze(t))return f.error(\"A data object was expected in send() but was not provided\");var a,n,o=this.disableCookies?{}:(a=xe(),n=_.now(),a.session_start&&(a.sst=a.session_start,delete a.session_start),a.session_id&&(a.sid=a.session_id,delete a.session_id),a.session_expires&&(a.sex=a.session_expires,delete a.session_expires),(!a.sex||a.sex<n)&&(a.sid=i(),a.sst=n),a.sex=n+15e5,Se(a),{session_id:a.sid,session_start:a.sst,session_expires:a.sex}),s=Ke(Ke(Ke(Ke(Ke({},this.pageLevelData),t),o),this.viewerData),{},{event:e,env_key:this.envKey});s.user_id&&(s.viewer_user_id=s.user_id,delete s.user_id);var u=(null!==(r=s.mux_sample_number)&&void 0!==r?r:0)>=this.sampleRate,l=Ne(this._deduplicateBeaconData(e,s));if(this.lastEventTime=this.mux.utils.now(),u)return f.info(\"Not sending event due to sample rate restriction\",e,s,l);if(this.envKey||f.info(\"Missing environment key (envKey) - beacons will be dropped if the video source is not a valid mux video URL\",e,s,l),!this.rateLimited)if(f.info(\"Sending event\",e,s,l),this.rateLimited=!this.eventQueue.queueEvent(e,l),this.mux.WINDOW_UNLOADING&&\"viewend\"===e)this.eventQueue.destroy(!0);else if(this.mux.WINDOW_HIDDEN&&\"hb\"===e?this.eventQueue.flushEvents(!0):rt.indexOf(e)>=0&&this.eventQueue.flushEvents(),this.rateLimited)return s.event=\"eventrateexceeded\",l=Ne(s),this.eventQueue.queueEvent(s.event,l),f.error(\"Beaconing disabled due to rate limit.\")}}},{key:\"destroy\",value:function(){this.eventQueue.destroy(!1)}},{key:\"_deduplicateBeaconData\",value:function(e,t){var r=this,a={},n=t.view_id;if(\"-1\"===n||\"viewstart\"===e||\"viewend\"===e||!this.previousBeaconData||this.mux.utils.now()-this.lastEventTime>=6e5)a=Ke({},t),n&&(this.previousBeaconData=a),n&&\"viewend\"===e&&(this.previousBeaconData=null);else{var i=0===e.indexOf(\"request\");Object.entries(t).forEach((function(t){var n=Qe(t,2),o=n[0],s=n[1];r.previousBeaconData&&(s!==r.previousBeaconData[o]||Ze.indexOf(o)>-1||r.objectHasChanged(i,o,s,r.previousBeaconData[o])||r.eventRequiresKey(e,o))&&(a[o]=s,r.previousBeaconData[o]=s)}))}return a}},{key:\"objectHasChanged\",value:function(e,t,r,a){return!(!e||0!==t.indexOf(\"request_\")||\"request_response_headers\"!==t&&\"object\"===ze(r)&&\"object\"===ze(a)&&Object.keys(r||{}).length===Object.keys(a||{}).length)}},{key:\"eventRequiresKey\",value:function(e,t){return\"renditionchange\"===e&&0===t.indexOf(\"video_source_\")||!(!tt.includes(t)||!et.includes(e))}}])&&Xe(t.prototype,r),a&&Xe(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),e}();function nt(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function it(e,t,r){return t&&nt(e.prototype,t),r&&nt(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var ot=it((function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e);var r=0,a=0,n=0,i=0,o=0,s=0,u=0;t.on(\"requestcompleted\",(function(e,s){var u,l,d=s.request_start,c=s.request_response_start,f=s.request_response_end,p=s.request_bytes_loaded;if(i++,c?(u=c-(null!=d?d:0),l=(null!=f?f:0)-c):l=(null!=f?f:0)-(null!=d?d:0),l>0&&p&&p>0){var _=p/l*8e3;o++,a+=p,n+=l,t.data.view_min_request_throughput=Math.min(t.data.view_min_request_throughput||1/0,_),t.data.view_average_request_throughput=a/n*8e3,t.data.view_request_count=i,u>0&&(r+=u,t.data.view_max_request_latency=Math.max(t.data.view_max_request_latency||0,u),t.data.view_average_request_latency=r/o)}})),t.on(\"requestfailed\",(function(e,r){i++,s++,t.data.view_request_count=i,t.data.view_request_failed_count=s})),t.on(\"requestcanceled\",(function(e,r){i++,u++,t.data.view_request_count=i,t.data.view_request_canceled_count=u}))}));function st(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function ut(e,t,r){return t&&st(e.prototype,t),r&&st(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var lt=ut((function e(t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),t.on(\"before*\",(function(e,a){var n=a.viewer_time,i=_.now(),o=r._lastEventTime;if(r._lastEventTime=i,o&&i-o>36e5){var s=Object.keys(t.data).reduce((function(e,r){return 0===r.indexOf(\"video_\")?Object.assign(e,function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}({},r,t.data[r])):e}),{});t.mux.log.info(\"Received event after at least an hour inactivity, creating a new view\"),t.emit(\"viewinit\",Object.assign({viewer_time:n},s)),t.playbackHeartbeat._playheadShouldBeProgressing&&\"play\"!==e.type&&\"adbreakstart\"!==e.type&&(t.emit(\"play\",{viewer_time:n}),\"playing\"!==e.type&&t.emit(\"playing\",{viewer_time:n}))}}))}));function dt(e){return dt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},dt(e)}function ct(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,i=[],o=!0,s=!1;try{for(r=r.call(e);!(o=(a=r.next()).done)&&(i.push(a.value),!t||i.length!==t);o=!0);}catch(e){s=!0,n=e}finally{try{o||null==r.return||r.return()}finally{if(s)throw n}}return i}}(e,t)||function(e,t){if(e){if(\"string\"==typeof e)return ft(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?ft(e,t):void 0}}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function ft(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}function pt(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function _t(e,t){return _t=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},_t(e,t)}function ht(e){var t=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,a=yt(e);if(t){var n=yt(this).constructor;r=Reflect.construct(a,arguments,n)}else r=a.apply(this,arguments);return vt(this,r)}}function vt(e,t){if(t&&(\"object\"===dt(t)||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return mt(e)}function mt(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function yt(e){return yt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},yt(e)}var bt=[\"viewstart\",\"ended\",\"loadstart\",\"pause\",\"play\",\"playing\",\"ratechange\",\"waiting\",\"adplay\",\"adpause\",\"adended\",\"aderror\",\"adplaying\",\"adrequest\",\"adresponse\",\"adbreakstart\",\"adbreakend\",\"adfirstquartile\",\"admidpoint\",\"adthirdquartile\",\"rebufferstart\",\"rebufferend\",\"seeked\",\"error\",\"hb\",\"requestcompleted\",\"requestfailed\",\"requestcanceled\",\"renditionchange\"],gt=function(e){!function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&_t(e,t)}(o,e);var t,r,a,n=ht(o);function o(e,t,r){var a;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,o),(a=n.call(this)).DOM_CONTENT_LOADED_EVENT_END=m.domContentLoadedEventEnd(),a.NAVIGATION_START=m.navigationStart(),a.mux=e,a.id=t,(r=Object.assign({debug:!1,minimumRebufferDuration:250,sustainedRebufferThreshold:1e3,playbackHeartbeatTime:25,beaconDomain:\"litix.io\",sampleRate:1,disableCookies:!1,respectDoNotTrack:!1,disableRebufferTracking:!1,disablePlayheadRebufferTracking:!1,errorTranslator:function(e){return e}},r)).data=r.data||{},r.data.property_key&&(r.data.env_key=r.data.property_key,delete r.data.property_key),f.setLevel(r.debug?\"debug\":\"warn\"),a.getPlayheadTime=r.getPlayheadTime,a.getStateData=r.getStateData||function(){return{}},a.getAdData=r.getAdData||function(){},a.minimumRebufferDuration=r.minimumRebufferDuration,a.sustainedRebufferThreshold=r.sustainedRebufferThreshold,a.playbackHeartbeatTime=r.playbackHeartbeatTime,a.disableRebufferTracking=r.disableRebufferTracking,a.disableRebufferTracking&&a.mux.log.warn(\"Disabling rebuffer tracking. This should only be used in specific circumstances as a last resort when your player is known to unreliably track rebuffering.\"),a.disablePlayheadRebufferTracking=r.disablePlayheadRebufferTracking,a.errorTranslator=r.errorTranslator,a.playbackEventDispatcher=new at(e,r.data.env_key,r),a.data={player_instance_id:i(),mux_sample_rate:r.sampleRate,beacon_domain:r.beaconCollectionDomain?r.beaconCollectionDomain:r.beaconDomain},a.data.view_sequence_number=1,a.data.player_sequence_number=1,a.oldEmit=a.emit,a.emit=function(e,t){t=Object.assign({viewer_time:this.mux.utils.now()},t),this.oldEmit(e,t)};var s=function(){void 0===this.data.view_start&&(this.data.view_start=this.mux.utils.now(),this.emit(\"viewstart\"))}.bind(mt(a));a.on(\"viewinit\",(function(e,t){this._resetVideoData(),this._resetViewData(),this._resetErrorData(),this._updateStateData(),Object.assign(this.data,t),this._initializeViewData(),this.one(\"play\",s),this.one(\"adbreakstart\",s)}));var u=function(e){this.emit(\"viewend\"),this.send(\"viewend\"),this.emit(\"viewinit\",e)}.bind(mt(a));if(a.on(\"videochange\",(function(e,t){u(t)})),a.on(\"programchange\",(function(e,t){this.data.player_is_paused&&this.mux.log.warn(\"The `programchange` event is intended to be used when the content changes mid playback without the video source changing, however the video is not currently playing. If the video source is changing please use the videochange event otherwise you will lose startup time information.\"),u(Object.assign(t,{view_program_changed:!0})),s(),this.emit(\"play\"),this.emit(\"playing\")})),a.on(\"fragmentchange\",(function(e,t){this.currentFragmentPDT=t.currentFragmentPDT,this.currentFragmentStart=t.currentFragmentStart})),a.on(\"destroy\",a.destroy),\"undefined\"!=typeof window&&\"function\"==typeof window.addEventListener&&\"function\"==typeof window.removeEventListener){var l=function(){var e=void 0!==a.data.view_start;a.mux.WINDOW_HIDDEN=\"hidden\"===document.visibilityState,e&&a.mux.WINDOW_HIDDEN&&(a.data.player_is_paused||a.emit(\"hb\"))};window.addEventListener(\"visibilitychange\",l,!1);var d=function(e){e.persisted||a.destroy()};window.addEventListener(\"pagehide\",d,!1),a.on(\"destroy\",(function(){window.removeEventListener(\"visibilitychange\",l),window.removeEventListener(\"pagehide\",d)}))}return a.on(\"playerready\",(function(e,t){Object.assign(this.data,t)})),bt.forEach((function(e){a.on(e,(function(t,r){0!==e.indexOf(\"ad\")&&this._updateStateData(),Object.assign(this.data,r),this._sanitizeData()})),a.on(\"after\"+e,(function(){(\"error\"!==e||this.errorTracker.viewErrored)&&this.send(e)}))})),a.on(\"viewend\",(function(e,t){Object.assign(a.data,t)})),a.one(\"playerready\",(function(e){var t=this.mux.utils.now();this.data.player_init_time&&(this.data.player_startup_time=t-this.data.player_init_time),!this.mux.PLAYER_TRACKED&&this.NAVIGATION_START&&(this.mux.PLAYER_TRACKED=!0,(this.data.player_init_time||this.DOM_CONTENT_LOADED_EVENT_END)&&(this.data.page_load_time=Math.min(this.data.player_init_time||1/0,this.DOM_CONTENT_LOADED_EVENT_END||1/0)-this.NAVIGATION_START)),this.send(\"playerready\"),delete this.data.player_startup_time,delete this.data.page_load_time})),a.longResumeTracker=new lt(mt(a)),a.errorTracker=new G(mt(a)),new Te(mt(a)),a.seekingTracker=new de(mt(a)),a.playheadTime=new z(mt(a)),a.playbackHeartbeat=new B(mt(a)),new se(mt(a)),a.watchTimeTracker=new Q(mt(a)),new J(mt(a)),a.adTracker=new ve(mt(a)),new re(mt(a)),new Z(mt(a)),new ne(mt(a)),new be(mt(a)),new ot(mt(a)),r.hlsjs&&a.addHLSJS(r),r.dashjs&&a.addDashJS(r),a.emit(\"viewinit\",r.data),a}return t=o,r=[{key:\"destroy\",value:function(){this._destroyed||(this._destroyed=!0,void 0!==this.data.view_start&&(this.emit(\"viewend\"),this.send(\"viewend\")),this.playbackEventDispatcher.destroy(),this.removeHLSJS(),this.removeDashJS(),window.clearTimeout(this._heartBeatTimeout))}},{key:\"send\",value:function(e){if(this.data.view_id){var t=Object.assign({},this.data);if(void 0===t.video_source_is_live&&(t.player_source_duration===1/0||t.video_source_duration===1/0?t.video_source_is_live=!0:(t.player_source_duration>0||t.video_source_duration>0)&&(t.video_source_is_live=!1)),t.video_source_is_live||[\"player_program_time\",\"player_manifest_newest_program_time\",\"player_live_edge_program_time\",\"player_program_time\",\"video_holdback\",\"video_part_holdback\",\"video_target_duration\",\"video_part_target_duration\"].forEach((function(e){t[e]=void 0})),t.video_source_url=t.video_source_url||t.player_source_url,t.video_source_url){var r=ct(v(t.video_source_url),2),a=r[0],n=r[1];t.video_source_domain=n,t.video_source_hostname=a}delete t.ad_request_id,this.playbackEventDispatcher.send(e,t),this.data.view_sequence_number++,this.data.player_sequence_number++,this._restartHeartBeat(),\"viewend\"===e&&delete this.data.view_id}}},{key:\"_updateStateData\",value:function(){Object.assign(this.data,this.getStateData()),this.playheadTime._updatePlayheadTime(),this._sanitizeData()}},{key:\"_sanitizeData\",value:function(){var e=this;[\"player_width\",\"player_height\",\"video_source_width\",\"video_source_height\",\"player_playhead_time\",\"video_source_bitrate\"].forEach((function(t){var r=parseInt(e.data[t],10);e.data[t]=isNaN(r)?void 0:r})),[\"player_source_url\",\"video_source_url\"].forEach((function(t){if(e.data[t]){var r=e.data[t].toLowerCase();0!==r.indexOf(\"data:\")&&0!==r.indexOf(\"blob:\")||(e.data[t]=\"MSE style URL\")}}))}},{key:\"_resetVideoData\",value:function(e,t){var r=this;Object.keys(this.data).forEach((function(e){0===e.indexOf(\"video_\")&&delete r.data[e]}))}},{key:\"_resetViewData\",value:function(){var e=this;Object.keys(this.data).forEach((function(t){0===t.indexOf(\"view_\")&&delete e.data[t]})),this.data.view_sequence_number=1}},{key:\"_resetErrorData\",value:function(e,t){delete this.data.player_error_code,delete this.data.player_error_message}},{key:\"_initializeViewData\",value:function(){var e=this,t=this.data.view_id=i(),r=function(){t===e.data.view_id&&y(e.data,\"player_view_count\",1)};this.data.player_is_paused?this.one(\"play\",r):r()}},{key:\"_restartHeartBeat\",value:function(){var e=this;window.clearTimeout(this._heartBeatTimeout),this.errorTracker.viewErrored||(this._heartBeatTimeout=window.setTimeout((function(){e.data.player_is_paused||e.emit(\"hb\")}),1e4))}},{key:\"addHLSJS\",value:function(e){e.hlsjs?this.hlsjs?this.mux.log.warn(\"An instance of HLS.js is already being monitored for this player.\"):(this.hlsjs=e.hlsjs,function(e,t,r){var a=arguments.length>4?arguments[4]:void 0,n=e.log,i=e.utils.secondsToMs,o=function(e){var t,r=parseInt(a.version);return 1===r&&null!==e.programDateTime&&(t=e.programDateTime),0===r&&null!==e.pdt&&(t=e.pdt),t};if(m.exists()){var s=function(r,a){return e.emit(t,r,a)},u=function(e,t){var r=t.levels,a=t.audioTracks,n=t.url,i=t.stats,o=t.networkDetails,u=t.sessionData,l={},d={};r.forEach((function(e,t){l[t]={width:e.width,height:e.height,bitrate:e.bitrate,attrs:e.attrs}})),a.forEach((function(e,t){d[t]={name:e.name,language:e.lang,bitrate:e.bitrate}}));var c=x(i),f=c.bytesLoaded,p=c.requestStart,_=c.responseStart,v=c.responseEnd;s(\"requestcompleted\",O(O({},E(u)),{},{request_event_type:e,request_bytes_loaded:f,request_start:p,request_response_start:_,request_response_end:v,request_type:\"manifest\",request_hostname:h(n),request_response_headers:S(o),request_rendition_lists:{media:l,audio:d,video:{}}}))};r.on(a.Events.MANIFEST_LOADED,u);var l=function(e,t){var r=t.details,a=t.level,n=t.networkDetails,u=t.stats,l=x(u),d=l.bytesLoaded,c=l.requestStart,f=l.responseStart,p=l.responseEnd,_=r.fragments[r.fragments.length-1],v=o(_)+i(_.duration);s(\"requestcompleted\",{request_event_type:e,request_bytes_loaded:d,request_start:c,request_response_start:f,request_response_end:p,request_current_level:a,request_type:\"manifest\",request_hostname:h(r.url),request_response_headers:S(n),video_holdback:r.holdBack&&i(r.holdBack),video_part_holdback:r.partHoldBack&&i(r.partHoldBack),video_part_target_duration:r.partTarget&&i(r.partTarget),video_target_duration:r.targetduration&&i(r.targetduration),video_source_is_live:r.live,player_manifest_newest_program_time:isNaN(v)?void 0:v})};r.on(a.Events.LEVEL_LOADED,l);var d=function(e,t){var r=t.details,a=t.networkDetails,n=t.stats,i=x(n),o=i.bytesLoaded,u=i.requestStart,l=i.responseStart,d=i.responseEnd;s(\"requestcompleted\",{request_event_type:e,request_bytes_loaded:o,request_start:u,request_response_start:l,request_response_end:d,request_type:\"manifest\",request_hostname:h(r.url),request_response_headers:S(a)})};r.on(a.Events.AUDIO_TRACK_LOADED,d);var c=function(e,t){var a=t.stats,n=t.networkDetails,i=t.frag;a=a||i.stats;var o=x(a),u=o.bytesLoaded,l=o.requestStart,d=o.responseStart,c=o.responseEnd,f=n?S(n):void 0,p={request_event_type:e,request_bytes_loaded:u,request_start:l,request_response_start:d,request_response_end:c,request_hostname:n?h(n.responseURL):void 0,request_id:f?T(f):void 0,request_response_headers:f,request_media_duration:i.duration,request_url:null==n?void 0:n.responseURL};\"main\"===i.type?(p.request_type=\"media\",p.request_current_level=i.level,p.request_video_width=(r.levels[i.level]||{}).width,p.request_video_height=(r.levels[i.level]||{}).height,p.request_labeled_bitrate=(r.levels[i.level]||{}).bitrate):p.request_type=i.type,s(\"requestcompleted\",p)};r.on(a.Events.FRAG_LOADED,c);var f=function(e,t){var r=t.frag,a=r.start,n={currentFragmentPDT:o(r),currentFragmentStart:i(a)};s(\"fragmentchange\",n)};r.on(a.Events.FRAG_CHANGED,f);var p=function(e,t){var r=t.type,n=t.details,i=t.response,o=t.fatal,u=t.frag,l=t.networkDetails,d=(null==u?void 0:u.url)||t.url||\"\",c=l?S(l):void 0;if(n!==a.ErrorDetails.MANIFEST_LOAD_ERROR&&n!==a.ErrorDetails.MANIFEST_LOAD_TIMEOUT&&n!==a.ErrorDetails.FRAG_LOAD_ERROR&&n!==a.ErrorDetails.FRAG_LOAD_TIMEOUT&&n!==a.ErrorDetails.LEVEL_LOAD_ERROR&&n!==a.ErrorDetails.LEVEL_LOAD_TIMEOUT&&n!==a.ErrorDetails.AUDIO_TRACK_LOAD_ERROR&&n!==a.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT&&n!==a.ErrorDetails.SUBTITLE_LOAD_ERROR&&n!==a.ErrorDetails.SUBTITLE_LOAD_TIMEOUT&&n!==a.ErrorDetails.KEY_LOAD_ERROR&&n!==a.ErrorDetails.KEY_LOAD_TIMEOUT||s(\"requestfailed\",{request_error:n,request_url:d,request_hostname:h(d),request_id:c?T(c):void 0,request_type:n===a.ErrorDetails.FRAG_LOAD_ERROR||n===a.ErrorDetails.FRAG_LOAD_TIMEOUT?\"media\":n===a.ErrorDetails.AUDIO_TRACK_LOAD_ERROR||n===a.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT?\"audio\":n===a.ErrorDetails.SUBTITLE_LOAD_ERROR||n===a.ErrorDetails.SUBTITLE_LOAD_TIMEOUT?\"subtitle\":n===a.ErrorDetails.KEY_LOAD_ERROR||n===a.ErrorDetails.KEY_LOAD_TIMEOUT?\"encryption\":\"manifest\",request_error_code:null==i?void 0:i.code,request_error_text:null==i?void 0:i.text}),o){var f,p=\"\".concat(d?\"url: \".concat(d,\"\\n\"):\"\")+\"\".concat(i&&(i.code||i.text)?\"response: \".concat(i.code,\", \").concat(i.text,\"\\n\"):\"\")+\"\".concat(t.reason?\"failure reason: \".concat(t.reason,\"\\n\"):\"\")+\"\".concat(t.level?\"level: \".concat(t.level,\"\\n\"):\"\")+\"\".concat(t.parent?\"parent stream controller: \".concat(t.parent,\"\\n\"):\"\")+\"\".concat(t.buffer?\"buffer length: \".concat(t.buffer,\"\\n\"):\"\")+\"\".concat(t.error?\"error: \".concat(t.error,\"\\n\"):\"\")+\"\".concat(t.event?\"event: \".concat(t.event,\"\\n\"):\"\")+\"\".concat(t.err?\"error message: \".concat(null===(f=t.err)||void 0===f?void 0:f.message,\"\\n\"):\"\");s(\"error\",{player_error_code:r,player_error_message:n,player_error_context:p})}};r.on(a.Events.ERROR,p);var _=function(e,t){var r=t.frag,a=r&&r._url||\"\";s(\"requestcanceled\",{request_event_type:e,request_url:a,request_type:\"media\",request_hostname:h(a)})};r.on(a.Events.FRAG_LOAD_EMERGENCY_ABORTED,_);var v=function(e,t){var a=t.level,i=r.levels[a];if(i&&i.attrs&&i.attrs.BANDWIDTH){var o,u=i.attrs.BANDWIDTH,l=parseFloat(i.attrs[\"FRAME-RATE\"]);isNaN(l)||(o=l),u?s(\"renditionchange\",{video_source_fps:o,video_source_bitrate:u,video_source_width:i.width,video_source_height:i.height,video_source_rendition_name:i.name,video_source_codec:null==i?void 0:i.videoCodec}):n.warn(\"missing BANDWIDTH from HLS manifest parsed by HLS.js\")}};r.on(a.Events.LEVEL_SWITCHED,v),r._stopMuxMonitor=function(){r.off(a.Events.MANIFEST_LOADED,u),r.off(a.Events.LEVEL_LOADED,l),r.off(a.Events.AUDIO_TRACK_LOADED,d),r.off(a.Events.FRAG_LOADED,c),r.off(a.Events.FRAG_CHANGED,f),r.off(a.Events.ERROR,p),r.off(a.Events.FRAG_LOAD_EMERGENCY_ABORTED,_),r.off(a.Events.LEVEL_SWITCHED,v),r.off(a.Events.DESTROYING,r._stopMuxMonitor),delete r._stopMuxMonitor},r.on(a.Events.DESTROYING,r._stopMuxMonitor)}else n.warn(\"performance timing not supported. Not tracking HLS.js.\")}(this.mux,this.id,e.hlsjs,{},e.Hls||window.Hls)):this.mux.log.warn(\"You must pass a valid hlsjs instance in order to track it.\")}},{key:\"removeHLSJS\",value:function(){var e;this.hlsjs&&((e=this.hlsjs)&&\"function\"==typeof e._stopMuxMonitor&&e._stopMuxMonitor(),this.hlsjs=void 0)}},{key:\"addDashJS\",value:function(e){e.dashjs?this.dashjs?this.mux.log.warn(\"An instance of Dash.js is already being monitored for this player.\"):(this.dashjs=e.dashjs,function(e,t,r){var a=e.log;if(r&&r.on){var n=function(r,a){return e.emit(t,r,a)},i=function(e){var t=e.type,r=(e.data||{}).url;n(\"requestcompleted\",{request_event_type:t,request_start:0,request_response_start:0,request_response_end:0,request_bytes_loaded:-1,request_type:\"manifest\",request_hostname:h(r),request_url:r})};r.on(\"manifestLoaded\",i);var o={},s=function(e){var t=e.type,a=e.fragmentModel,i=(e.chunk||{}).mediaInfo||{},s=i.type,u=i.bitrateList,l={};(u=u||[]).forEach((function(e,t){l[t]={},l[t].width=e.width,l[t].height=e.height,l[t].bitrate=e.bandwidth,l[t].attrs={}})),\"video\"===s?o.video=l:\"audio\"===s?o.audio=l:o.media=l;var d=R(a,r),c=d.requestStart,f=d.requestResponseStart,p=d.requestResponseEnd,_=d.requestResponseHeaders,h=d.requestMediaDuration,v=d.requestHostname,m=d.requestUrl,y=d.requestId;n(\"requestcompleted\",{request_event_type:t,request_start:c,request_response_start:f,request_response_end:p,request_bytes_loaded:-1,request_type:s+\"_init\",request_response_headers:_,request_hostname:v,request_id:y,request_url:m,request_media_duration:h,request_rendition_lists:o})};r.on(\"initFragmentLoaded\",s);var u=function(e){var t=e.type,a=e.fragmentModel,i=e.chunk||{},o=i.mediaInfo,s=i.start,u=(o||{}).type,l=R(a,r),d=l.requestStart,c=l.requestResponseStart,f=l.requestResponseEnd,p=l.requestBytesLoaded,_=l.requestResponseHeaders,h=l.requestMediaDuration,v=l.requestHostname,m=l.requestUrl,y=l.requestId,b=I(u,r),g=b.currentLevel,w=b.renditionWidth,T=b.renditionHeight,E=b.renditionBitrate;n(\"requestcompleted\",{request_event_type:t,request_start:d,request_response_start:c,request_response_end:f,request_bytes_loaded:p,request_type:u,request_response_headers:_,request_hostname:v,request_id:y,request_url:m,request_media_start_time:s,request_media_duration:h,request_current_level:g,request_labeled_bitrate:E,request_video_width:w,request_video_height:T})};r.on(\"mediaFragmentLoaded\",u);var l={video:void 0,audio:void 0,totalBitrate:void 0},d=function(){if(l.video&&\"number\"==typeof l.video.bitrate){if(l.video.width&&l.video.height){var e=l.video.bitrate;return l.audio&&\"number\"==typeof l.audio.bitrate&&(e+=l.audio.bitrate),e!==l.totalBitrate?(l.totalBitrate=e,{video_source_bitrate:e,video_source_height:l.video.height,video_source_width:l.video.width,video_source_codec:j(l.video.codec)}):void 0}a.warn(\"have bitrate info for video but missing width/height\")}},c=function(e,t,i){if(\"number\"==typeof e.newQuality){var o=e.mediaType;if(\"audio\"===o||\"video\"===o){var s=r.getBitrateInfoListFor(o).find((function(t){return t.qualityIndex===e.newQuality}));if(s&&\"number\"==typeof s.bitrate){l[o]=P(P({},s),{},{codec:r.getCurrentTrackFor(o).codec});var u=d();u&&n(\"renditionchange\",u)}else a.warn(\"missing bitrate info for \".concat(o))}}else a.warn(\"missing evt.newQuality in qualityChangeRendered event\",e)};r.on(\"qualityChangeRendered\",c);var f=function(e){var t=e.request,r=e.mediaType;n(\"requestcanceled\",{request_event_type:(t=t||{}).type+\"_\"+t.action,request_url:t.url,request_type:r,request_hostname:h(t.url)})};r.on(\"fragmentLoadingAbandoned\",f);var p=function(e){var t,r,a=e.error,i=(null==a||null===(t=a.data)||void 0===t?void 0:t.request)||{},o=(null==a||null===(r=a.data)||void 0===r?void 0:r.response)||{};27===(null==a?void 0:a.code)&&n(\"requestfailed\",{request_error:i.type+\"_\"+i.action,request_url:i.url,request_hostname:h(i.url),request_type:i.mediaType,request_error_code:o.status,request_error_text:o.statusText});var s=\"\".concat(null!=i&&i.url?\"url: \".concat(i.url,\"\\n\"):\"\")+\"\".concat(null!=o&&o.status||null!=o&&o.statusText?\"response: \".concat(null==o?void 0:o.status,\", \").concat(null==o?void 0:o.statusText,\"\\n\"):\"\");n(\"error\",{player_error_code:null==a?void 0:a.code,player_error_message:null==a?void 0:a.message,player_error_context:s})};r.on(\"error\",p),r._stopMuxMonitor=function(){r.off(\"manifestLoaded\",i),r.off(\"initFragmentLoaded\",s),r.off(\"mediaFragmentLoaded\",u),r.off(\"qualityChangeRendered\",c),r.off(\"error\",p),r.off(\"fragmentLoadingAbandoned\",f),delete r._stopMuxMonitor}}else a.warn(\"Invalid dash.js player reference. Monitoring blocked.\")}(this.mux,this.id,e.dashjs)):this.mux.log.warn(\"You must pass a valid dashjs instance in order to track it.\")}},{key:\"removeDashJS\",value:function(){var e;this.dashjs&&((e=this.dashjs)&&\"function\"==typeof e._stopMuxMonitor&&e._stopMuxMonitor(),this.dashjs=void 0)}}],r&&pt(t.prototype,r),a&&pt(t,a),Object.defineProperty(t,\"prototype\",{writable:!1}),o}(H),wt=gt,Tt=r(153),Et=r.n(Tt);function kt(e){return kt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},kt(e)}function Ot(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,i=[],o=!0,s=!1;try{for(r=r.call(e);!(o=(a=r.next()).done)&&(i.push(a.value),!t||i.length!==t);o=!0);}catch(e){s=!0,n=e}finally{try{o||null==r.return||r.return()}finally{if(s)throw n}}return i}}(e,t)||function(e,t){if(e){if(\"string\"==typeof e)return Dt(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Dt(e,t):void 0}}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Dt(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}var xt,St=[\"loadstart\",\"pause\",\"play\",\"playing\",\"seeking\",\"seeked\",\"timeupdate\",\"ratechange\",\"stalled\",\"waiting\",\"error\",\"ended\"],qt={1:\"MEDIA_ERR_ABORTED\",2:\"MEDIA_ERR_NETWORK\",3:\"MEDIA_ERR_DECODE\",4:\"MEDIA_ERR_SRC_NOT_SUPPORTED\"};n()&&n().WeakMap&&(xt=new WeakMap);var Pt=\"#EXT-X-TARGETDURATION\",At=\"#EXT-X-PART-INF\",Rt=\"#EXT-X-SERVER-CONTROL\",It=\"#EXTINF\",jt=\"#EXT-X-PROGRAM-DATE-TIME\",Lt=\"#EXT-X-VERSION\",Ct=\"#EXT-X-SESSION-DATA\",Nt=function(e){return this.buffer=\"\",this.manifest={segments:[],serverControl:{},sessionData:{}},this.currentUri={},this.process(e),this.manifest};Nt.prototype.process=function(e){var t;for(this.buffer+=e,t=this.buffer.indexOf(\"\\n\");t>-1;t=this.buffer.indexOf(\"\\n\"))this.processLine(this.buffer.substring(0,t)),this.buffer=this.buffer.substring(t+1)},Nt.prototype.processLine=function(e){var t=e.indexOf(\":\"),r=Wt(e,t),a=r[0],n=2===r.length?Bt(r[1]):void 0;if(\"#\"!==a[0])this.currentUri.uri=a,this.manifest.segments.push(this.currentUri),this.manifest.targetDuration&&!(\"duration\"in this.currentUri)&&(this.currentUri.duration=this.manifest.targetDuration),this.currentUri={};else switch(a){case Pt:if(!isFinite(n)||n<0)return;this.manifest.targetDuration=n,this.setHoldBack();break;case At:Ht(this.manifest,r),this.manifest.partInf.partTarget&&(this.manifest.partTargetDuration=this.manifest.partInf.partTarget),this.setHoldBack();break;case Rt:Ht(this.manifest,r),this.setHoldBack();break;case It:0===n?this.currentUri.duration=.01:n>0&&(this.currentUri.duration=n);break;case jt:var i=n,o=new Date(i);this.manifest.dateTimeString||(this.manifest.dateTimeString=i,this.manifest.dateTimeObject=o),this.currentUri.dateTimeString=i,this.currentUri.dateTimeObject=o;break;case Lt:Ht(this.manifest,r);break;case Ct:var s=Qt(r[1]),u=E(s);Object.assign(this.manifest.sessionData,u)}},Nt.prototype.setHoldBack=function(){var e=this.manifest,t=e.serverControl,r=e.targetDuration,a=e.partTargetDuration;if(t){var n=\"holdBack\",i=\"partHoldBack\",o=r&&3*r,s=a&&2*a;r&&!t.hasOwnProperty(n)&&(t[n]=o),o&&t[n]<o&&(t[n]=o),a&&!t.hasOwnProperty(i)&&(t[i]=3*a),a&&t[i]<s&&(t[i]=s)}};var Ht=function(e,t){var r,a=Mt(t[0].replace(\"#EXT-X-\",\"\"));Gt(t[1])?(r={},r=Object.assign(Ft(t[1]),r)):r=Bt(t[1]),e[a]=r},Mt=function(e){return e.toLowerCase().replace(/-(\\w)/g,(function(e){return e[1].toUpperCase()}))},Bt=function(e){if(\"yes\"===e.toLowerCase()||\"no\"===e.toLowerCase())return\"yes\"===e.toLowerCase();var t=-1!==e.indexOf(\":\")?e:parseFloat(e);return isNaN(t)?e:t},Ut=function(e){var t={},r=e.split(\"=\");return r.length>1&&(t[Mt(r[0])]=Bt(r[1])),t},Ft=function(e){for(var t=e.split(\",\"),r={},a=0;t.length>a;a++){var n=t[a],i=Ut(n);r=Object.assign(i,r)}return r},Gt=function(e){return e.indexOf(\"=\")>-1},Wt=function(e,t){return-1===t?[e]:[e.substring(0,t),e.substring(t+1)]},Qt=function(e){var t={};if(e){var r=e.search(\",\");return[e.slice(0,r),e.slice(r+1)].forEach((function(e,r){for(var a=e.replace(/['\"]+/g,\"\").split(\"=\"),n=0;n<a.length;n++)\"DATA-ID\"===a[n]&&(t[\"DATA-ID\"]=a[1-n]),\"VALUE\"===a[n]&&(t.VALUE=a[1-n])})),{data:t}}},Vt=Nt,Jt={safeCall:function(e,t,r,a){var n=a;if(e&&\"function\"==typeof e[t])try{n=e[t].apply(e,r)}catch(e){f.info(\"safeCall error\",e)}return n},safeIncrement:y,getComputedStyle:function(e,t){var r;if(e&&t&&n()&&\"function\"==typeof n().getComputedStyle)return xt&&xt.has(e)&&(r=xt.get(e)),r||(r=n().getComputedStyle(e,null),xt&&xt.set(e,r)),r.getPropertyValue(t)},secondsToMs:function(e){return Math.floor(1e3*e)},assign:Object.assign,headersStringToObject:w,cdnHeadersToRequestId:T,extractHostnameAndDomain:v,extractHostname:h,manifestParser:Vt,generateShortID:o,generateUUID:i,now:_.now},Kt={PLAYER_READY:\"playerready\",VIEW_INIT:\"viewinit\",VIDEO_CHANGE:\"videochange\",PLAY:\"play\",PAUSE:\"pause\",PLAYING:\"playing\",TIME_UPDATE:\"timeupdate\",SEEKING:\"seeking\",SEEKED:\"seeked\",REBUFFER_START:\"rebufferstart\",REBUFFER_END:\"rebufferend\",ERROR:\"error\",ENDED:\"ended\",RENDITION_CHANGE:\"renditionchange\",ORIENTATION_CHANGE:\"orientationchange\",AD_REQUEST:\"adrequest\",AD_RESPONSE:\"adresponse\",AD_BREAK_START:\"adbreakstart\",AD_PLAY:\"adplay\",AD_PLAYING:\"adplaying\",AD_PAUSE:\"adpause\",AD_FIRST_QUARTILE:\"adfirstquartile\",AD_MID_POINT:\"admidpoint\",AD_THIRD_QUARTILE:\"adthirdquartile\",AD_ENDED:\"adended\",AD_BREAK_END:\"adbreakend\",AD_ERROR:\"aderror\",REQUEST_COMPLETED:\"requestcompleted\",REQUEST_FAILED:\"requestfailed\",REQUEST_CANCELLED:\"requestcanceled\"};function zt(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,i=[],o=!0,s=!1;try{for(r=r.call(e);!(o=(a=r.next()).done)&&(i.push(a.value),!t||i.length!==t);o=!0);}catch(e){s=!0,n=e}finally{try{o||null==r.return||r.return()}finally{if(s)throw n}}return i}}(e,t)||function(e,t){if(e){if(\"string\"==typeof e)return Yt(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Yt(e,t):void 0}}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Yt(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}var Xt={},$t=function e(t){var r=arguments;\"string\"==typeof t?e.hasOwnProperty(t)?n().setTimeout((function(){r=Array.prototype.splice.call(r,1),e[t].apply(null,r)}),0):f.warn(\"`\"+t+\"` is an unknown task\"):\"function\"==typeof t?n().setTimeout((function(){t(e)}),0):f.warn(\"`\"+t+\"` is invalid.\")},Zt={loaded:_.now(),NAME:\"mux-embed\",VERSION:\"4.26.0\",API_VERSION:\"2.1\",PLAYER_TRACKED:!1,monitor:function(e,t){return function(e,t,r){var a=Ot(u(t),3),n=a[0],i=a[1],o=a[2],s=e.log,l=e.utils.getComputedStyle,d=e.utils.secondsToMs;if(!n)return s.error(\"No element was found with the `\"+i+\"` query selector.\");if(\"video\"!==o&&\"audio\"!==o)return s.error(\"The element of `\"+i+\"` was not a media element.\");n.mux&&(n.mux.destroy(),delete n.mux,s.warn(\"Already monitoring this video element, replacing existing event listeners\")),(r=Object.assign({automaticErrorTracking:!0},r)).data=Object.assign({player_software:\"HTML5 Video Element\",player_mux_plugin_name:\"VideoElementMonitor\",player_mux_plugin_version:e.VERSION},r.data),r.getPlayheadTime=function(){return d(n.currentTime)},r.getStateData=function(){var e,t,a=this.hlsjs&&this.hlsjs.url,i=this.dashjs&&kt(\"function\"===this.dashjs.getSource)&&this.dashjs.getSource(),o={player_is_paused:n.paused,player_playhead_time:d(n.currentTime),player_width:parseInt(l(n,\"width\")),player_height:parseInt(l(n,\"height\")),player_autoplay_on:n.autoplay,player_preload_on:n.preload,player_language_code:n.lang,player_is_fullscreen:Et()&&!!(Et().fullscreenElement||Et().webkitFullscreenElement||Et().mozFullScreenElement||Et().msFullscreenElement),video_poster_url:n.poster,video_source_url:a||i||n.currentSrc,video_source_duration:d(n.duration),video_source_height:n.videoHeight,video_source_width:n.videoWidth,view_dropped_frame_count:null===(e=n)||void 0===e||null===(t=e.getVideoPlaybackQuality)||void 0===t?void 0:t.call(e).droppedVideoFrames},s=r.getPlayheadTime();if(n.getStartDate&&s>0){var u=n.getStartDate();if(u&&\"function\"==typeof u.getTime&&u.getTime()){var c=u.getTime();if(o.player_program_time=c+s,n.seekable.length>0){var f=c+n.seekable.end(n.seekable.length-1);o.player_live_edge_program_time=f}}}return o},n.mux=n.mux||{},n.mux.deleted=!1,n.mux.emit=function(t,r){e.emit(i,t,r)};var c=function(){s.error(\"The monitor for this video element has already been destroyed.\")};n.mux.destroy=function(){Object.keys(n.mux.listeners).forEach((function(e){n.removeEventListener(e,n.mux.listeners[e],!1)})),delete n.mux.listeners,n.mux.destroy=c,n.mux.swapElement=c,n.mux.emit=c,n.mux.addHLSJS=c,n.mux.addDashJS=c,n.mux.removeHLSJS=c,n.mux.removeDashJS=c,n.mux.deleted=!0,e.emit(i,\"destroy\")},n.mux.swapElement=function(t){var r=Ot(u(t),3),a=r[0],i=r[1],o=r[2];return a?\"video\"!==o&&\"audio\"!==o?e.log.error(\"The element of `\"+i+\"` was not a media element.\"):(a.muxId=n.muxId,delete n.muxId,a.mux=a.mux||{},a.mux.listeners=Object.assign({},n.mux.listeners),delete n.mux.listeners,Object.keys(a.mux.listeners).forEach((function(e){n.removeEventListener(e,a.mux.listeners[e],!1),a.addEventListener(e,a.mux.listeners[e],!1)})),a.mux.swapElement=n.mux.swapElement,a.mux.destroy=n.mux.destroy,delete n.mux,void(n=a)):e.log.error(\"No element was found with the `\"+i+\"` query selector.\")},n.mux.addHLSJS=function(t){e.addHLSJS(i,t)},n.mux.addDashJS=function(t){e.addDashJS(i,t)},n.mux.removeHLSJS=function(){e.removeHLSJS(i)},n.mux.removeDashJS=function(){e.removeDashJS(i)},e.init(i,r),e.emit(i,\"playerready\"),n.paused||(e.emit(i,\"play\"),n.readyState>2&&e.emit(i,\"playing\")),n.mux.listeners={},St.forEach((function(t){(\"error\"!==t||r.automaticErrorTracking)&&(n.mux.listeners[t]=function(){var r={};if(\"error\"===t){if(!n.error)return;if(1===n.error.code)return;r.player_error_code=n.error.code,r.player_error_message=qt[n.error.code]||n.error.message}e.emit(i,t,r)},n.addEventListener(t,n.mux.listeners[t],!1))}))}($t,e,t)},destroyMonitor:function(e){var t=zt(u(e),1)[0];t&&t.mux&&\"function\"==typeof t.mux.destroy?t.mux.destroy():f.error(\"A video element monitor for `\"+e+\"` has not been initialized via `mux.monitor`.\")},addHLSJS:function(e,t){var r=s(e);Xt[r]?Xt[r].addHLSJS(t):f.error(\"A monitor for `\"+r+\"` has not been initialized.\")},addDashJS:function(e,t){var r=s(e);Xt[r]?Xt[r].addDashJS(t):f.error(\"A monitor for `\"+r+\"` has not been initialized.\")},removeHLSJS:function(e){var t=s(e);Xt[t]?Xt[t].removeHLSJS():f.error(\"A monitor for `\"+t+\"` has not been initialized.\")},removeDashJS:function(e){var t=s(e);Xt[t]?Xt[t].removeDashJS():f.error(\"A monitor for `\"+t+\"` has not been initialized.\")},init:function(e,t){p()&&t&&t.respectDoNotTrack&&f.info(\"The browser's Do Not Track flag is enabled - Mux beaconing is disabled.\");var r=s(e);Xt[r]=new wt($t,r,t)},emit:function(e,t,r){var a=s(e);Xt[a]?(Xt[a].emit(t,r),\"destroy\"===t&&delete Xt[a]):f.error(\"A monitor for `\"+a+\"` has not been initialized.\")},checkDoNotTrack:p,log:f,utils:Jt,events:Kt,WINDOW_HIDDEN:!1,WINDOW_UNLOADING:!1};Object.assign($t,Zt),void 0!==n()&&\"function\"==typeof n().addEventListener&&n().addEventListener(\"pagehide\",(function(e){e.persisted||($t.WINDOW_UNLOADING=!0)}),!1);var er=$t},655:function(e,t,r){var a,n;function i(e){return i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},i(e)\n/*!\n * JavaScript Cookie v2.1.3\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */}!function(o){var s=!1;if(void 0===(n=\"function\"==typeof(a=o)?a.call(t,r,t,e):a)||(e.exports=n),s=!0,\"object\"===i(t)&&(e.exports=o(),s=!0),!s){var u=window.Cookies,l=window.Cookies=o();l.noConflict=function(){return window.Cookies=u,l}}}((function(){var e=function(){for(var e=0,t={};e<arguments.length;e++){var r=arguments[e];for(var a in r)t[a]=r[a]}return t};return function t(r){function a(t,n,i){var o;if(\"undefined\"!=typeof document){if(arguments.length>1){if(\"number\"==typeof(i=e({path:\"/\"},a.defaults,i)).expires){var s=new Date;s.setMilliseconds(s.getMilliseconds()+864e5*i.expires),i.expires=s}try{o=JSON.stringify(n),/^[\\{\\[]/.test(o)&&(n=o)}catch(e){}return n=r.write?r.write(n,t):encodeURIComponent(String(n)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent),t=(t=(t=encodeURIComponent(String(t))).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent)).replace(/[\\(\\)]/g,escape),document.cookie=[t,\"=\",n,i.expires?\"; expires=\"+i.expires.toUTCString():\"\",i.path?\"; path=\"+i.path:\"\",i.domain?\"; domain=\"+i.domain:\"\",i.secure?\"; secure\":\"\"].join(\"\")}t||(o={});for(var u=document.cookie?document.cookie.split(\"; \"):[],l=/(%[0-9A-Z]{2})+/g,d=0;d<u.length;d++){var c=u[d].split(\"=\"),f=c.slice(1).join(\"=\");'\"'===f.charAt(0)&&(f=f.slice(1,-1));try{var p=c[0].replace(l,decodeURIComponent);if(f=r.read?r.read(f,p):r(f,p)||f.replace(l,decodeURIComponent),this.json)try{f=JSON.parse(f)}catch(e){}if(t===p){o=f;break}t||(o[p]=f)}catch(e){}}return o}}return a.set=a,a.get=function(e){return a.call(a,e)},a.getJSON=function(){return a.apply({json:!0},[].slice.call(arguments))},a.defaults={},a.remove=function(t,r){a(t,\"\",e(r,{expires:-1}))},a.withConverter=t,a}((function(){}))}))},153:function(e,t,r){var a,n=void 0!==r.g?r.g:\"undefined\"!=typeof window?window:{},i=r(558);\"undefined\"!=typeof document?a=document:(a=n[\"__GLOBAL_DOCUMENT_CACHE@4\"])||(a=n[\"__GLOBAL_DOCUMENT_CACHE@4\"]=i),e.exports=a},48:function(e,t,r){var a;a=\"undefined\"!=typeof window?window:void 0!==r.g?r.g:\"undefined\"!=typeof self?self:{},e.exports=a},640:function(e,t,r){var a,n;!function(i,o){\"use strict\";a=function(){var e=function(){},t=\"undefined\",r=typeof window!==t&&typeof window.navigator!==t&&/Trident\\/|MSIE /.test(window.navigator.userAgent),a=[\"trace\",\"debug\",\"info\",\"warn\",\"error\"];function n(e,t){var r=e[t];if(\"function\"==typeof r.bind)return r.bind(e);try{return Function.prototype.bind.call(r,e)}catch(t){return function(){return Function.prototype.apply.apply(r,[e,arguments])}}}function i(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function o(a){return\"debug\"===a&&(a=\"log\"),typeof console!==t&&(\"trace\"===a&&r?i:void 0!==console[a]?n(console,a):void 0!==console.log?n(console,\"log\"):e)}function s(t,r){for(var n=0;n<a.length;n++){var i=a[n];this[i]=n<t?e:this.methodFactory(i,t,r)}this.log=this.debug}function u(e,r,a){return function(){typeof console!==t&&(s.call(this,r,a),this[e].apply(this,arguments))}}function l(e,t,r){return o(e)||u.apply(this,arguments)}function d(e,r,n){var i,o=this;r=null==r?\"WARN\":r;var u=\"loglevel\";function d(e){var r=(a[e]||\"silent\").toUpperCase();if(typeof window!==t&&u){try{return void(window.localStorage[u]=r)}catch(e){}try{window.document.cookie=encodeURIComponent(u)+\"=\"+r+\";\"}catch(e){}}}function c(){var e;if(typeof window!==t&&u){try{e=window.localStorage[u]}catch(e){}if(typeof e===t)try{var r=window.document.cookie,a=r.indexOf(encodeURIComponent(u)+\"=\");-1!==a&&(e=/^([^;]+)/.exec(r.slice(a))[1])}catch(e){}return void 0===o.levels[e]&&(e=void 0),e}}function f(){if(typeof window!==t&&u){try{return void window.localStorage.removeItem(u)}catch(e){}try{window.document.cookie=encodeURIComponent(u)+\"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\"}catch(e){}}}\"string\"==typeof e?u+=\":\"+e:\"symbol\"==typeof e&&(u=void 0),o.name=e,o.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},o.methodFactory=n||l,o.getLevel=function(){return i},o.setLevel=function(r,a){if(\"string\"==typeof r&&void 0!==o.levels[r.toUpperCase()]&&(r=o.levels[r.toUpperCase()]),!(\"number\"==typeof r&&r>=0&&r<=o.levels.SILENT))throw\"log.setLevel() called with invalid level: \"+r;if(i=r,!1!==a&&d(r),s.call(o,r,e),typeof console===t&&r<o.levels.SILENT)return\"No console available for logging\"},o.setDefaultLevel=function(e){r=e,c()||o.setLevel(e,!1)},o.resetLevel=function(){o.setLevel(r,!1),f()},o.enableAll=function(e){o.setLevel(o.levels.TRACE,e)},o.disableAll=function(e){o.setLevel(o.levels.SILENT,e)};var p=c();null==p&&(p=r),o.setLevel(p,!1)}var c=new d,f={};c.getLogger=function(e){if(\"symbol\"!=typeof e&&\"string\"!=typeof e||\"\"===e)throw new TypeError(\"You must supply a name when creating a logger.\");var t=f[e];return t||(t=f[e]=new d(e,c.getLevel(),c.methodFactory)),t};var p=typeof window!==t?window.log:void 0;return c.noConflict=function(){return typeof window!==t&&window.log===c&&(window.log=p),c},c.getLoggers=function(){return f},c.default=c,c},void 0===(n=\"function\"==typeof a?a.call(t,r,t,e):a)||(e.exports=n)}()},375:function(e,t){\"use strict\";var r=Object.prototype.hasOwnProperty;function a(e){try{return decodeURIComponent(e.replace(/\\+/g,\" \"))}catch(e){return null}}function n(e){try{return encodeURIComponent(e)}catch(e){return null}}t.stringify=function(e,t){t=t||\"\";var a,i,o=[];for(i in\"string\"!=typeof t&&(t=\"?\"),e)if(r.call(e,i)){if((a=e[i])||null!=a&&!isNaN(a)||(a=\"\"),i=n(i),a=n(a),null===i||null===a)continue;o.push(i+\"=\"+a)}return o.length?t+o.join(\"&\"):\"\"},t.parse=function(e){for(var t,r=/([^=?#&]+)=?([^&]*)/g,n={};t=r.exec(e);){var i=a(t[1]),o=a(t[2]);null===i||null===o||i in n||(n[i]=o)}return n}},558:function(){}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var i=t[a]={exports:{}};return e[a].call(i.exports,i,i.exports,r),i.exports}return r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,{a:t}),t},r.d=function(e,t){for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},r.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(e){if(\"object\"==typeof window)return window}}(),r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r(80)}()}, true?module.exports=t():0}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL211eC1lbWJlZC9kaXN0L211eC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLG9CQUFvQixrQkFBa0IsT0FBTyxtQkFBbUIseUJBQXlCLHFCQUFxQixhQUFhLE9BQU8sbUJBQW1CLFdBQVcsRUFBRSxrQ0FBa0MsMEVBQTBFLHlCQUF5QixxQ0FBcUMsR0FBRyxjQUFjLDBFQUEwRSxlQUFlLHVFQUF1RSxlQUFlLE1BQU0sNERBQTRELGdEQUFnRCxjQUFjLHVDQUF1QyxrQ0FBa0MsZUFBZSxrQkFBa0Isd0JBQXdCLG1CQUFtQix5QkFBeUIsbUJBQW1CLDhCQUE4QixVQUFVLGFBQWEsc0VBQXNFLE9BQU8sZUFBZSwrSEFBK0gsc0JBQXNCLGVBQWUsZUFBZSxlQUFlLGtEQUFrRCwwRkFBMEYsd0RBQXdELElBQUksa0JBQWtCLHNCQUFzQiw4QkFBOEIscUNBQXFDLG9DQUFvQyxxQ0FBcUMsNEJBQTRCLG9DQUFvQyw4QkFBOEIsa0JBQWtCLHNDQUFzQyx5R0FBeUcsY0FBYyxTQUFTLDZEQUE2RCxNQUFNLGdDQUFnQyxrR0FBa0csS0FBSyxjQUFjLE1BQU0sMEJBQTBCLHFCQUFxQixHQUFHLHNCQUFzQixrQkFBa0IsU0FBUyxnQkFBZ0IsV0FBVyxtR0FBbUcsVUFBVSxnQkFBZ0IscUJBQXFCLGlDQUFpQyxzQ0FBc0MsNEJBQTRCLHVEQUF1RCxzQkFBc0IsU0FBUyxjQUFjLFlBQVksbUJBQW1CLEtBQUsseUNBQXlDLHlDQUF5QyxZQUFZLHFJQUFxSSxnRUFBZ0UsR0FBRyxTQUFTLGtCQUFrQix5Q0FBeUMsa0RBQWtELFdBQVcsa0JBQWtCLGVBQWUsb0dBQW9HLE9BQU8sNEdBQTRHLGVBQWUsc0ZBQXNGLGdCQUFnQixxQkFBcUIsaUNBQWlDLHNDQUFzQyw0QkFBNEIsdURBQXVELHNCQUFzQixTQUFTLGNBQWMsWUFBWSxtQkFBbUIsS0FBSyx5Q0FBeUMseUNBQXlDLFlBQVkscUlBQXFJLGdFQUFnRSxHQUFHLFNBQVMsa0JBQWtCLHlDQUF5QyxrREFBa0QsV0FBVyxvQkFBb0IsaURBQWlELHFCQUFxQixpQkFBaUIsRUFBRSx5QkFBeUIsMlVBQTJVLDhEQUE4RCx3TEFBd0wsaUJBQWlCLCtEQUErRCxVQUFVLGlIQUFpSCxJQUFJLGVBQWUsTUFBTSx5RUFBeUUsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLHFCQUFxQixhQUFhLGVBQWUsOEVBQThFLFNBQVMsVUFBVSxlQUFlLCtCQUErQix1RkFBdUYsMEZBQTBGLEVBQUUsOEJBQThCLDBDQUEwQyw0QkFBNEIseURBQXlELElBQUksRUFBRSxnQ0FBZ0MsV0FBVyw2Q0FBNkMsbUJBQW1CLHVDQUF1QyxzREFBc0QsRUFBRSwrQkFBK0IsV0FBVyxvQkFBb0IsUUFBUSwrR0FBK0csbUNBQW1DLFVBQVUsT0FBTyxJQUFJLElBQUksdUJBQXVCLHFFQUFxRSxZQUFZLElBQUksT0FBTyxnQkFBZ0IsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csaUJBQWlCLGNBQWMsV0FBVyxlQUFlLDhFQUE4RSx3SEFBd0gsa0NBQWtDLGdtQ0FBZ21DLCtGQUErRixpQ0FBaUMsaUVBQWlFLHFDQUFxQyxxSEFBcUgsMEJBQTBCLHFDQUFxQyxHQUFHLFVBQVUsZ0JBQWdCLHVEQUF1RCxXQUFXLHVJQUF1SSwrQkFBK0IsbUNBQW1DLEVBQUUsc0RBQXNELDZNQUE2TSxvRUFBb0UsWUFBWSxJQUFJLEdBQUcsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLGtCQUFrQiwwRUFBMEUsWUFBWSxJQUFJLHVCQUF1QixXQUFXLGVBQWUsOEVBQThFLHFDQUFxQyxpQkFBaUIsK0JBQStCLElBQUkseUJBQXlCLDhIQUE4SCxFQUFFLHFWQUFxVixTQUFTLDhFQUE4RSxHQUFHLEdBQUcsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLGlCQUFpQixjQUFjLGVBQWUsOEVBQThFLDJMQUEyTCxVQUFVLGdCQUFnQiwyQ0FBMkMsb0JBQW9CLDJNQUEyTSxFQUFFLCtDQUErQyx1RUFBdUUsb0VBQW9FLFlBQVksSUFBSSxHQUFHLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyxpQkFBaUIsY0FBYyxXQUFXLGVBQWUsOEVBQThFLHdVQUF3VSxrQkFBa0IsOEJBQThCLGtCQUFrQiw4QkFBOEIsa0JBQWtCLG1DQUFtQyxrQkFBa0IsaUNBQWlDLGtCQUFrQiw2QkFBNkIsa0JBQWtCLEdBQUcsVUFBVSxnQkFBZ0IsMkNBQTJDLHVEQUF1RCwwVEFBMFQsRUFBRSwrQ0FBK0MsNkVBQTZFLG9FQUFvRSxZQUFZLElBQUksR0FBRyxnQkFBZ0IsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csaUJBQWlCLGNBQWMsZUFBZSw4RUFBOEUsbUJBQW1CLDBDQUEwQywyR0FBMkcsc0JBQXNCLEdBQUcsVUFBVSxnQkFBZ0Isa0RBQWtELGdOQUFnTixFQUFFLDhDQUE4Qyx3QkFBd0Isc0tBQXNLLDRIQUE0SCxpQ0FBaUMsZ0NBQWdDLDBGQUEwRixvRUFBb0UsWUFBWSxJQUFJLEdBQUcsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLGtCQUFrQiwwRUFBMEUsWUFBWSxJQUFJLDZCQUE2QixpQkFBaUIsOEVBQThFLHFDQUFxQyxzQkFBc0IsY0FBYyxlQUFlLE1BQU0sc0JBQXNCLHlSQUF5UixrT0FBa08sd0NBQXdDLFlBQVksdUNBQXVDLDhFQUE4RSwrQkFBK0IsZ0NBQWdDLElBQUksR0FBRyxpQkFBaUIsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csa0JBQWtCLGNBQWMsV0FBVyxlQUFlLDhFQUE4RSw4VUFBOFUsZ0NBQWdDLG9CQUFvQixFQUFFLElBQUksVUFBVSxlQUFlLDhDQUE4Qyw0SkFBNEosb0dBQW9HLHNEQUFzRCxvS0FBb0ssOENBQThDLHdDQUF3QywwQ0FBMEMsdURBQXVELEVBQUUsa0RBQWtELCtGQUErRixFQUFFLHFEQUFxRCxzSEFBc0gsRUFBRSxrREFBa0QsOERBQThELHNFQUFzRSwwQkFBMEIsRUFBRSxLQUFLLHVDQUF1QyxpSEFBaUgsc0pBQXNKLDhDQUE4Qyw4QkFBOEIsa0RBQWtELEdBQUcsc0ZBQXNGLHVFQUF1RSxZQUFZLElBQUksU0FBUyxpQkFBaUIsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csa0JBQWtCLGNBQWMsV0FBVyxlQUFlLDhFQUE4RSwrQ0FBK0MseUJBQXlCLDRCQUE0QixvQkFBb0Isb0JBQW9CLDJPQUEyTyxvRUFBb0Usd0NBQXdDLElBQUksR0FBRyxVQUFVLGdCQUFnQiwwQ0FBMEMsdUdBQXVHLEVBQUUsb0RBQW9ELDJFQUEyRSxjQUFjLHVSQUF1UixzRUFBc0UsWUFBWSxJQUFJLEdBQUcsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLG1CQUFtQiw0RUFBNEUsWUFBWSxJQUFJLHlCQUF5QixXQUFXLGVBQWUsOEVBQThFLHFDQUFxQywyQkFBMkIsd0ZBQXdGLG1CQUFtQiwySkFBMkosMERBQTBELCtDQUErQyxrSUFBa0kseVNBQXlTLDJCQUEyQixHQUFHLHlDQUF5QyxtQkFBbUIsZ09BQWdPLEdBQUcsR0FBRyxHQUFHLGlCQUFpQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyxtQkFBbUIsNEVBQTRFLFlBQVksSUFBSSx5QkFBeUIsV0FBVyxlQUFlLDhFQUE4RSx5REFBeUQsd0dBQXdHLDZCQUE2QixlQUFlLDhDQUE4QywrREFBK0QsbUNBQW1DLHdDQUF3Qyw4QkFBOEIsZUFBZSxHQUFHLEdBQUcsaUJBQWlCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLG1GQUFtRixZQUFZLHVCQUF1QixJQUFJLGdCQUFnQiwyREFBMkQsT0FBTyxTQUFTLFNBQVMsUUFBUSxJQUFJLDhCQUE4QixRQUFRLGNBQWMsVUFBVSxxQkFBcUIsTUFBTSxxQ0FBcUMsb0RBQW9ELGlMQUFpTCxrQkFBa0IsaUtBQWlLLEdBQUcsaUJBQWlCLG9DQUFvQywyQkFBMkIsSUFBSSxjQUFjLFNBQVMsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLHFCQUFxQixnQ0FBZ0MsbUNBQW1DLEdBQUcsNEhBQTRILGNBQWMsV0FBVyxlQUFlLDhFQUE4RSwrQ0FBK0MsOEtBQThLLDJCQUEyQix1Q0FBdUMsR0FBRyxpQkFBaUIsZ0JBQWdCLGdDQUFnQyxlQUFlLHNGQUFzRixpQkFBaUIsaUVBQWlFLDJLQUEySyxvQ0FBb0MsaUJBQWlCLGtFQUFrRSx5QkFBeUIsdUNBQXVDLDRFQUE0RSxnQ0FBZ0Msa2JBQWtiLG1DQUFtQyxvT0FBb08sOEJBQThCLHVCQUF1Qiw4QkFBOEIsdUJBQXVCLEdBQUcsVUFBVSxnQkFBZ0IseUNBQXlDLHVHQUF1RyxFQUFFLHNDQUFzQyxZQUFZLDBCQUEwQix5RUFBeUUsRUFBRSx3Q0FBd0MsNkJBQTZCLDZEQUE2RCwwQ0FBMEMsc0ZBQXNGLGlFQUFpRSw0Q0FBNEMsMkZBQTJGLGlSQUFpUixzRUFBc0UsWUFBWSxJQUFJLEdBQUcsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLG1CQUFtQiw0RUFBNEUsWUFBWSxJQUFJLHlCQUF5QixRQUFRLGVBQWUsOEVBQThFLFNBQVMsaUJBQWlCLCtHQUErRyxtQkFBbUIsVUFBVSwyQkFBMkIsa0hBQWtILE1BQU0sY0FBYyxvREFBb0QsU0FBUyw4QkFBOEIsU0FBUyxxQ0FBcUMsR0FBRyxpQkFBaUIsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csbUJBQW1CLDRFQUE0RSxZQUFZLElBQUkseUJBQXlCLFdBQVcsZUFBZSw4RUFBOEUsU0FBUyxpQkFBaUIsOENBQThDLGVBQWUsb0NBQW9DLHNEQUFzRCxjQUFjLHdCQUF3QixjQUFjLDZDQUE2QyxjQUFjLHdCQUF3QixjQUFjLHlCQUF5QixxRUFBcUUsZ0RBQWdELEdBQUcsNkRBQTZELE1BQU0sSUFBSSw2QkFBNkIsU0FBUyxLQUFLLFNBQVMsZ0JBQWdCLElBQUksNkJBQTZCLFlBQVksRUFBRSxXQUFXLGVBQWUsV0FBVyw4RUFBOEUsd0RBQXdELGlCQUFpQixnREFBZ0Qsd0JBQXdCLG9CQUFvQiw2RkFBNkYsa0JBQWtCLE1BQU0sYUFBYSw0QkFBNEIsTUFBTSx5QkFBeUIsTUFBTSxvQkFBb0IsTUFBTSxrQkFBa0Isa0JBQWtCLFNBQVMsZUFBZSw2RUFBNkUsa0JBQWtCLDJCQUEyQixpQkFBaUIsME1BQTBNLFNBQVMsNnhEQUE2eEQsRUFBRSxlQUFlLFNBQVMsZ0RBQWdELFNBQVMsZUFBZSxRQUFRLE1BQU0sMkNBQTJDLFNBQVMsdUNBQXVDLGtDQUFrQyxvR0FBb0cscUpBQXFKLDBCQUEwQixzQkFBc0IsUUFBUSxzRkFBc0YseUdBQXlHLGdFQUFnRSx3SUFBd0ksUUFBUSxzQ0FBc0Msc0JBQXNCLElBQUksdU5BQXVOLHFDQUFxQyw4REFBOEQsb0lBQW9JLGlDQUFpQyw4REFBOEQsb0dBQW9HLDJDQUEyQyw0SUFBNEkscUNBQXFDLHlDQUF5QyxHQUFHLDZCQUE2QixxQ0FBcUMsR0FBRywwQ0FBMEMsV0FBVyx3QkFBd0IsNERBQTRELDJGQUEyRix1Q0FBdUMsdUNBQXVDLGdLQUFnSyxJQUFJLDRDQUE0QyxtRUFBbUUsdUNBQXVDLGtFQUFrRSw2Q0FBNkMsV0FBVyxrR0FBa0csbUVBQW1FLDhCQUE4Qix5Q0FBeUMsb0JBQW9CLDRDQUE0QyxnRUFBZ0UsaUJBQWlCLGtCQUFrQix1QkFBdUIsa0JBQWtCLGNBQWMsdUNBQXVDLG9IQUFvSCwyQkFBMkIsd0dBQXdHLGdCQUFnQixXQUFXLGlFQUFpRSxXQUFXLG1CQUFtQix1QkFBdUIsc0JBQXNCLHFFQUFxRSwrQkFBK0IsOEJBQThCLDRCQUE0QixpQkFBaUIsb0JBQW9CLGlDQUFpQyxzQkFBc0IsaUJBQWlCLEdBQUcsS0FBSyx1QkFBdUIsOEJBQThCLHVDQUF1QyxpRUFBaUUsaUZBQWlGLEtBQUssT0FBTyxpQkFBaUIsbUJBQW1CLDZCQUE2QixtQkFBbUIsbUZBQW1GLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDJEQUEyRCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksOEJBQThCLFFBQVEsY0FBYyxVQUFVLHFCQUFxQixNQUFNLHFDQUFxQyxvREFBb0QsaUxBQWlMLGtCQUFrQixpS0FBaUssR0FBRyxpQkFBaUIsb0NBQW9DLDJCQUEyQixJQUFJLGNBQWMsU0FBUyxpQkFBaUIscUJBQXFCLGlDQUFpQyxzQ0FBc0MsNEJBQTRCLHVEQUF1RCxzQkFBc0IsU0FBUyxlQUFlLFlBQVksbUJBQW1CLEtBQUsseUNBQXlDLDBDQUEwQyxhQUFhLHNJQUFzSSxnRUFBZ0UsR0FBRyxTQUFTLGVBQWUsa0ZBQWtGLGdCQUFnQixhQUFhLG9HQUFvRyxPQUFPLGlCQUFpQiw4RUFBOEUsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLG1CQUFtQix5Q0FBeUMsa0RBQWtELFdBQVcsNlpBQTZaLGdCQUFnQiw4RkFBOEYsdWZBQXVmLDQrQkFBNCtCLHVDQUF1QyxNQUFNLFVBQVUsZ0JBQWdCLCtCQUErQixNQUFNLDBCQUEwQixvR0FBb0csb0dBQW9HLGdDQUFnQywyUUFBMlEsMkRBQTJELHFCQUFxQiw4Q0FBOEMsRUFBRSw0QkFBNEIsRUFBRSx5REFBeUQsK0dBQStHLHFIQUFxSCxzVEFBc1QsOFFBQThRLEVBQUUsK0JBQStCLDZCQUE2QixFQUFFLGlEQUFpRCxlQUFlLGFBQWEsMkhBQTJILG9GQUFvRixLQUFLLCtCQUErQix1Q0FBdUMsNEJBQTRCLHNMQUFzTCxHQUFHLFVBQVUsRUFBRSwrQ0FBK0MsNEhBQTRILDRCQUE0QixXQUFXLEVBQUUsMkNBQTJDLGtHQUFrRyxzRUFBc0UsWUFBWSxJQUFJLEdBQUcsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLG1CQUFtQiw0RUFBNEUsWUFBWSxJQUFJLHlCQUF5QixlQUFlLDhFQUE4RSxTQUFTLGdDQUFnQyx1Q0FBdUMsdUdBQXVHLDBGQUEwRixjQUFjLG9UQUFvVCx1Q0FBdUMsdUVBQXVFLHlDQUF5Qyx5RUFBeUUsR0FBRyxHQUFHLGlCQUFpQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyxtQkFBbUIsNEVBQTRFLFlBQVksSUFBSSx5QkFBeUIsV0FBVyxlQUFlLDhFQUE4RSx1Q0FBdUMsaURBQWlELG1DQUFtQyxnREFBZ0QsK0RBQStELHlDQUF5QyxrREFBa0QsV0FBVyxHQUFHLGlCQUFpQixJQUFJLEVBQUUseUhBQXlILGNBQWMsaUhBQWlILGNBQWMsd0NBQXdDLGNBQWMsSUFBSSxHQUFHLEdBQUcsZUFBZSxrRkFBa0YsZ0JBQWdCLGFBQWEsb0dBQW9HLE9BQU8saUJBQWlCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLG1GQUFtRixZQUFZLHVCQUF1QixJQUFJLGdCQUFnQiwyREFBMkQsT0FBTyxTQUFTLFNBQVMsUUFBUSxJQUFJLDhCQUE4QixRQUFRLGNBQWMsVUFBVSxxQkFBcUIsTUFBTSxxQ0FBcUMsb0RBQW9ELGlMQUFpTCxrQkFBa0IsaUtBQWlLLEdBQUcsaUJBQWlCLG9DQUFvQywyQkFBMkIsSUFBSSxjQUFjLFNBQVMsaUJBQWlCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLGlCQUFpQiwyRUFBMkUsdUJBQXVCLFNBQVMsZUFBZSxpQkFBaUIsNERBQTRELG1DQUFtQyxxQ0FBcUMsSUFBSSxnRkFBZ0YsT0FBTyxTQUFTLFVBQVUsR0FBRyxrQkFBa0IsY0FBYyxNQUFNLDJCQUEyQixtQ0FBbUMsK0JBQStCLG1CQUFtQixpQkFBaUIsd0RBQXdELDhGQUE4RixhQUFhLGVBQWUsb0dBQW9HLFNBQVMsZUFBZSx5RUFBeUUsNkNBQTZDLE9BQU8sNFhBQTRYLGVBQWUsNEdBQTRHLDBDQUEwQyxhQUFhLHFDQUFxQyx1Q0FBdUMsWUFBWSxhQUFhLE1BQU0sa0JBQWtCLGtCQUFrQixNQUFNLGVBQWUsOEVBQThFLDRKQUE0SixtUUFBbVEsVUFBVSxvQkFBb0IsdU1BQXVNLFNBQVMsc0NBQXNDLGlrQkFBaWtCLG1JQUFtSSxxR0FBcUcsaUJBQWlCLGlDQUFpQyx1QkFBdUIsaUJBQWlCLGtHQUFrRyxhQUFhLCtCQUErQixnTUFBZ00sR0FBRyxrQkFBa0Isa0VBQWtFLGFBQWEscUNBQXFDLEtBQUssdUNBQXVDLDZWQUE2Vix3QkFBd0IsOENBQThDLHdDQUF3Qyw4RkFBOEYsb0pBQW9KLGlCQUFpQixpQ0FBaUMseUhBQXlILGlEQUFpRCxrQkFBa0IsMEJBQTBCLG9FQUFvRSwwRkFBMEYsR0FBRyx5Q0FBeUMsMkJBQTJCLDJCQUEyQixzQkFBc0IsNkZBQTZGLDhCQUE4QiwyREFBMkQsR0FBRyxpQ0FBaUMsd0JBQXdCLG9DQUFvQywyQkFBMkIsd2NBQXdjLGlaQUFpWixlQUFlLCtCQUErQiw0T0FBNE8sRUFBRSw2QkFBNkIsc0JBQXNCLHNCQUFzQixZQUFZLGdkQUFnZCxZQUFZLGtGQUFrRixnREFBZ0Qsa0RBQWtELHFNQUFxTSxFQUFFLHdDQUF3QywyR0FBMkcsRUFBRSxxQ0FBcUMsV0FBVywrSUFBK0ksNkJBQTZCLDRCQUE0QixpRUFBaUUsY0FBYyw4QkFBOEIsNkVBQTZFLElBQUksRUFBRSwwQ0FBMEMsV0FBVyw0Q0FBNEMsMENBQTBDLElBQUksRUFBRSxzQ0FBc0MsV0FBVyw0Q0FBNEMseUNBQXlDLHFDQUFxQyxFQUFFLDBDQUEwQywwRUFBMEUsRUFBRSwyQ0FBMkMsZ0RBQWdELHFEQUFxRCxtREFBbUQsRUFBRSx5Q0FBeUMsV0FBVyxpSUFBaUksc0NBQXNDLFNBQVMsRUFBRSxpQ0FBaUMsOElBQThJLHlGQUF5Riw0QkFBNEIsZ0dBQWdHLGVBQWUsb0JBQW9CLHFCQUFxQixpQkFBaUIsd0ZBQXdGLE1BQU0seUJBQXlCLE1BQU0sK0RBQStELDRCQUE0QixNQUFNLCtDQUErQyxHQUFHLDhFQUE4RSwyQkFBMkIsU0FBUyxFQUFFLGlOQUFpTiwwQkFBMEIsSUFBSSxpQ0FBaUMsb0JBQW9CLDBMQUEwTCxzQkFBc0IsMGZBQTBmLEdBQUcsOEJBQThCLG9CQUFvQix1SEFBdUgsc0JBQXNCLDRMQUE0TCxHQUFHLG9DQUFvQyxvQkFBb0IsMENBQTBDLGFBQWEsaUdBQWlHLHVSQUF1UixvSEFBb0gscURBQXFELHlEQUF5RCwwREFBMEQsNkJBQTZCLG9CQUFvQiwwQkFBMEIsbURBQW1ELHVCQUF1Qiw4QkFBOEIsb0JBQW9CLGdJQUFnSSxnZkFBZ2YsdWhCQUF1aEIsS0FBSywra0JBQStrQixXQUFXLGtFQUFrRSxJQUFJLHVCQUF1QixvQkFBb0IsNkJBQTZCLHFCQUFxQiw4RUFBOEUsR0FBRyw2Q0FBNkMsb0JBQW9CLDRCQUE0QixrQ0FBa0MsOERBQThELHVDQUF1QyxvTEFBb0wsbUVBQW1FLDZEQUE2RCxnVkFBZ1YsNkNBQTZDLHNFQUFzRSw0QkFBNEIsc0dBQXNHLEVBQUUsbUNBQW1DLE1BQU0sMkdBQTJHLEVBQUUsa0NBQWtDLG1KQUFtSixZQUFZLFlBQVksb0JBQW9CLHFCQUFxQixlQUFlLDBCQUEwQixNQUFNLHNCQUFzQix5S0FBeUssR0FBRyx5QkFBeUIsUUFBUSxlQUFlLDZDQUE2QyxlQUFlLCtCQUErQixpQ0FBaUMsT0FBTyxnRkFBZ0YseURBQXlELG1MQUFtTCxzQkFBc0IsZ1FBQWdRLEdBQUcsNkJBQTZCLGtCQUFrQiw0Q0FBNEMsaUNBQWlDLG1TQUFtUyxzQkFBc0IsdVZBQXVWLEdBQUcsOEJBQThCLE9BQU8sOENBQThDLGNBQWMsOENBQThDLGtDQUFrQyxzQkFBc0IsNkdBQTZHLCtIQUErSCxTQUFTLGdFQUFnRSxtQkFBbUIsa0NBQWtDLGtCQUFrQiw2QkFBNkIsbURBQW1ELHFDQUFxQyxHQUFHLGtDQUFrQyxXQUFXLE1BQU0sRUFBRSxvQ0FBb0MsRUFBRSxVQUFVLDBCQUEwQixvREFBb0Qsd0VBQXdFLGdDQUFnQyxrQkFBa0IsOEJBQThCLHFCQUFxQiwyQkFBMkIsK0VBQStFLEdBQUcsbUNBQW1DLGtCQUFrQixpRkFBaUYsa0VBQWtFLGlEQUFpRCxtS0FBbUssRUFBRSxnTkFBZ04sV0FBVyw2R0FBNkcsR0FBRyw2Q0FBNkMsdU1BQXVNLHFFQUFxRSwrR0FBK0csRUFBRSxvQ0FBb0MsTUFBTSw4R0FBOEcsdUVBQXVFLFlBQVksSUFBSSwrQkFBK0IsZUFBZSxrRkFBa0YsZ0JBQWdCLGFBQWEsb0dBQW9HLE9BQU8saUJBQWlCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLG1GQUFtRixZQUFZLHVCQUF1QixJQUFJLGdCQUFnQiwyREFBMkQsT0FBTyxTQUFTLFNBQVMsUUFBUSxJQUFJLDhCQUE4QixRQUFRLGNBQWMsVUFBVSxxQkFBcUIsTUFBTSxxQ0FBcUMsb0RBQW9ELGlMQUFpTCxrQkFBa0IsaUtBQWlLLEdBQUcsaUJBQWlCLG9DQUFvQywyQkFBMkIsSUFBSSxjQUFjLFNBQVMsc0lBQXNJLGtHQUFrRyxtQ0FBbUMsc0xBQXNMLHFDQUFxQyw0QkFBNEIsZ0JBQWdCLG1CQUFtQixnQ0FBZ0MsaUNBQWlDLE1BQU0sK0NBQStDLEtBQUssZ0hBQWdILHNDQUFzQyxxRUFBcUUsMk5BQTJOLGVBQWUsb0NBQW9DLGtEQUFrRCxNQUFNLHFKQUFxSixNQUFNLCtDQUErQyxNQUFNLDZFQUE2RSxNQUFNLDhCQUE4QixnS0FBZ0ssTUFBTSw0QkFBNEIsTUFBTSw4QkFBOEIsNENBQTRDLHFDQUFxQyxnRkFBZ0YsTUFBTSxvREFBb0QsZ0hBQWdILHFCQUFxQix1Q0FBdUMsY0FBYyxnREFBZ0QsZ0JBQWdCLHFEQUFxRCwwQkFBMEIsR0FBRyxnQkFBZ0IsaUZBQWlGLDBDQUEwQyxvQkFBb0IsZ0JBQWdCLFFBQVEsZ0JBQWdCLDRDQUE0QyxnQkFBZ0IsMkJBQTJCLEtBQUssV0FBVyxLQUFLLG1CQUFtQixxQkFBcUIsU0FBUyxnQkFBZ0IseUJBQXlCLGtCQUFrQixxREFBcUQsZ0JBQWdCLFNBQVMsTUFBTSxvQkFBb0IseURBQXlELGdEQUFnRCxXQUFXLDZFQUE2RSxJQUFJLFNBQVMsV0FBVywyQkFBMkIsUUFBUSxrQ0FBa0Msa0JBQWtCLFNBQVMsMkJBQTJCLFNBQVMsZ0RBQWdELE1BQU0sb0tBQW9LLHlCQUF5Qix5QkFBeUIsZ0xBQWdMLEtBQUssc3VCQUFzdUIsaUJBQWlCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLG1GQUFtRixZQUFZLHVCQUF1QixJQUFJLGdCQUFnQiwyREFBMkQsT0FBTyxTQUFTLFNBQVMsUUFBUSxJQUFJLDhCQUE4QixRQUFRLGNBQWMsVUFBVSxxQkFBcUIsTUFBTSxxQ0FBcUMsb0RBQW9ELGlMQUFpTCxrQkFBa0IsaUtBQWlLLEdBQUcsaUJBQWlCLG9DQUFvQywyQkFBMkIsSUFBSSxjQUFjLFNBQVMsU0FBUyxrQkFBa0IsZ0JBQWdCLGtFQUFrRSxzREFBc0QsMEZBQTBGLEtBQUssbUNBQW1DLEtBQUssMkdBQTJHLHVCQUF1QiwrRkFBK0YsOEVBQThFLDhGQUE4Riw0SUFBNEksMEJBQTBCLHlCQUF5Qix1SEFBdUgsc0NBQXNDLHdCQUF3QiwyQkFBMkIsdUhBQXVILHFwQkFBcXBCLHVCQUF1Qix3QkFBd0IsdUJBQXVCLGlEQUFpRCxrQkFBa0Isa0RBQWtELDRDQUE0QyxvQ0FBb0MsU0FBUyxnQkFBZ0IsMkNBQTJDLGVBQWUsaUJBQWlCLDJFQUEyRSx5QkFBeUIsa0RBQWtELCtDQUErQyw0TEFBNEwsK0JBQStCLHNDQUFzQyxnSkFBZ0osaUNBQWlDLDJGQUEyRiwyRkFBMkYsZ0tBQWdLLDRCQUE0QixnQkFBZ0IsNkJBQTZCLGlCQUFpQiw4QkFBOEIsaUJBQWlCLCtCQUErQixrQkFBa0Isd0hBQXdILHlCQUF5Qix3RUFBd0UsU0FBUyxnQkFBZ0IsbUJBQW1CLDJCQUEyQiwwRkFBMEYsY0FBYyw4Q0FBOEMsR0FBRyxTQUFTLDRCQUE0QixvQkFBb0Isc0pBQXNKLHdCQUF3QixXQUFXLG1GQUFtRix5QkFBeUIsV0FBVyxvRkFBb0YseUJBQXlCLFdBQVcscUZBQXFGLDBCQUEwQixXQUFXLHNGQUFzRixvQkFBb0IsK0dBQStHLFdBQVcscUJBQXFCLHNCQUFzQixXQUFXLCtHQUErRyxrRkFBa0YseUhBQXlILHNDQUFzQyxNQUFNLFVBQVUscUJBQXFCLFFBQVEsY0FBYyxpRkFBaUYsZ0JBQWdCLGFBQWEsb0dBQW9HO0FBQzFzM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhLFNBQVMsd0hBQXdILDBDQUEwQyx3QkFBd0IsNEJBQTRCLGFBQWEsaUJBQWlCLGlCQUFpQixtQkFBbUIsS0FBSyxtQkFBbUIseUJBQXlCLFVBQVUscUJBQXFCLGtCQUFrQixNQUFNLGlDQUFpQyx1QkFBdUIseUJBQXlCLFNBQVMseUJBQXlCLGVBQWUsbUVBQW1FLElBQUkseUJBQXlCLG9CQUFvQixVQUFVLG1UQUFtVCwrQ0FBK0MsNkJBQTZCLGlDQUFpQyxxQkFBcUIsUUFBUSxFQUFFLG1EQUFtRCxvQkFBb0IsRUFBRSxTQUFTLFdBQVcsS0FBSyw2Q0FBNkMscUNBQXFDLElBQUkseUNBQXlDLDhFQUE4RSxnQkFBZ0IsVUFBVSxVQUFVLElBQUksTUFBTSxZQUFZLFdBQVcsVUFBVSxpQ0FBaUMsbUJBQW1CLHNCQUFzQixnQkFBZ0IsUUFBUSwyQkFBMkIsY0FBYyx3QkFBd0IsWUFBWSxXQUFXLEdBQUcscUJBQXFCLGNBQWMsR0FBRyxHQUFHLHFCQUFxQiw2REFBNkQsVUFBVSw2SEFBNkgsb0JBQW9CLE1BQU0scUZBQXFGLGFBQWEscUJBQXFCLFFBQVEsZUFBZSxhQUFhLGFBQWEsa0JBQWtCLDhKQUE4SixnQkFBZ0IsV0FBVyw4Q0FBOEMsSUFBSSx5Q0FBeUMsU0FBUyxrQkFBa0IseURBQXlELGFBQWEscUtBQXFLLGNBQWMsNklBQTZJLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLHdDQUF3QyxvQkFBb0Isa0JBQWtCLGtCQUFrQixzRUFBc0Usa0JBQWtCLHFDQUFxQyxrQkFBa0IsYUFBYSxtQkFBbUIsaUJBQWlCLGNBQWMscUNBQXFDLHlCQUF5QixJQUFJLHNDQUFzQyxVQUFVLElBQUkscURBQXFELEVBQUUsWUFBWSxhQUFhLE1BQU0seUJBQXlCLElBQUkseUJBQXlCLFVBQVUsb0JBQW9CLG9FQUFvRSxpQkFBaUIsMEJBQTBCLFVBQVUsMkNBQTJDLGFBQWEseUJBQXlCLElBQUksOENBQThDLFVBQVUsSUFBSSxpREFBaUQsdUNBQXVDLFlBQVksOEVBQThFLCtDQUErQyw0Q0FBNEMsU0FBUywwQkFBMEIsNkxBQTZMLGlIQUFpSCwrQkFBK0IsMEJBQTBCLHlCQUF5QixxQkFBcUIseUJBQXlCLDZCQUE2QiwwQkFBMEIsK0JBQStCLFVBQVUsZ0NBQWdDLGlCQUFpQix3QkFBd0Isd0hBQXdILFdBQVcsNERBQTRELDBDQUEwQywrQkFBK0IsMkRBQTJELHlCQUF5QixTQUFTLGVBQWUsb0VBQW9FLEdBQUcsbUJBQW1CLGFBQWEsc0NBQXNDLGNBQWMsSUFBSSxnREFBZ0QsU0FBUyxhQUFhLGNBQWMsSUFBSSw2QkFBNkIsU0FBUyxhQUFhLDBCQUEwQixRQUFRLGFBQWEsc0RBQXNELGtGQUFrRixnQkFBZ0IsaUNBQWlDLHFCQUFxQix3Q0FBd0MsWUFBWSxFQUFFLHdCQUF3QixxQ0FBcUMsVUFBVSxrQkFBa0IsTUFBTSxjQUFjLFdBQVcsK0JBQStCLFlBQVksWUFBWSxvREFBb0QsdUJBQXVCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLGNBQWMsSUFBSSxJQUFJLG1CQUFtQiwrREFBK0QsdUJBQXVCLEVBQUUsZ0JBQWdCLGlEQUFpRCxJQUFJLDJDQUEyQyxTQUFTLDBDQUEwQyxxQkFBcUIsaURBQWlELE9BQU8sR0FBRyxDQUFDLEtBQWlELG9CQUFvQixDQUFrRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXgtZW1iZWQvZGlzdC9tdXguanM/YzNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIG11eC1lbWJlZFxuICogQHZlcnNpb24gNC4yNi4wXG4gKiBAY29weXJpZ2h0IDIwMjMgTXV4LCBJbmNcbiAqL1xuIWZ1bmN0aW9uKCl7dmFyIGUsdDtlPXRoaXMsdD1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXs4MDpmdW5jdGlvbihlLHQscil7ZS5leHBvcnRzPXIoNzI4KS5kZWZhdWx0fSw3Mjg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3IuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIGVyfX0pO3ZhciBhPXIoNDgpLG49ci5uKGEpLGk9ZnVuY3Rpb24oKXtyZXR1cm5cInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywoZnVuY3Rpb24oZSl7dmFyIHQ9MTYqTWF0aC5yYW5kb20oKXwwO3JldHVybihcInhcIj09PWU/dDozJnR8OCkudG9TdHJpbmcoMTYpfSkpfSxvPWZ1bmN0aW9uKCl7cmV0dXJuKFwiMDAwMDAwXCIrKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMzYsNik8PDApLnRvU3RyaW5nKDM2KSkuc2xpY2UoLTYpfSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZ2b2lkIDAhPT1lLm5vZGVOYW1lPyhlLm11eElkfHwoZS5tdXhJZD1lLmlkfHxvKCkpLGUubXV4SWQpOmV9LHU9ZnVuY3Rpb24oZSl7dmFyIHQ7ZSYmdm9pZCAwIT09ZS5ub2RlTmFtZT9lPXModD1lKTp0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSk7dmFyIHI9dCYmdC5ub2RlTmFtZT90Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6XCJcIjtyZXR1cm5bdCxlLHJdfSxsPXIoNjQwKSxkPXIubihsKSxjPWQoKS5tZXRob2RGYWN0b3J5O2QoKS5tZXRob2RGYWN0b3J5PWZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1jKGUsdCxyKTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9W1wiW211eF1cIl0sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZS5wdXNoKGFyZ3VtZW50c1t0XSk7YS5hcHBseSh2b2lkIDAsZSl9fSxkKCkuc2V0TGV2ZWwoZCgpLmdldExldmVsKCkpO3ZhciBmPWQoKTtmdW5jdGlvbiBwKCl7cmV0dXJuXCIxXCI9PT0obigpLmRvTm90VHJhY2t8fG4oKS5uYXZpZ2F0b3ImJm4oKS5uYXZpZ2F0b3IuZG9Ob3RUcmFjayl9dmFyIF89e25vdzpmdW5jdGlvbigpe3ZhciBlPW4oKS5wZXJmb3JtYW5jZSx0PWUmJmUudGltaW5nLHI9dCYmdC5uYXZpZ2F0aW9uU3RhcnQsYT1cIm51bWJlclwiPT10eXBlb2YgciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5ub3c/citlLm5vdygpOkRhdGUubm93KCk7cmV0dXJuIE1hdGgucm91bmQoYSl9fSxoPWZ1bmN0aW9uKGUpe3JldHVybiB2KGUpWzBdfSx2PWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHxcIlwiPT09ZSlyZXR1cm5bXCJsb2NhbGhvc3RcIl07dmFyIHQscj0oZS5tYXRjaCgvXigoW146XFwvPyNdKyk6KT8oXFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/Lyl8fFtdKVs0XTtyZXR1cm4gciYmKHQ9KHIubWF0Y2goL1teXFwuXStcXC5bXlxcLl0rJC8pfHxbXSlbMF0pLFtyLHRdfSxtPXtleGlzdHM6ZnVuY3Rpb24oKXt2YXIgZT1uKCkucGVyZm9ybWFuY2U7cmV0dXJuIHZvaWQgMCE9PShlJiZlLnRpbWluZyl9LGRvbUNvbnRlbnRMb2FkZWRFdmVudEVuZDpmdW5jdGlvbigpe3ZhciBlPW4oKS5wZXJmb3JtYW5jZSx0PWUmJmUudGltaW5nO3JldHVybiB0JiZ0LmRvbUNvbnRlbnRMb2FkZWRFdmVudEVuZH0sbmF2aWdhdGlvblN0YXJ0OmZ1bmN0aW9uKCl7dmFyIGU9bigpLnBlcmZvcm1hbmNlLHQ9ZSYmZS50aW1pbmc7cmV0dXJuIHQmJnQubmF2aWdhdGlvblN0YXJ0fX07ZnVuY3Rpb24geShlLHQscil7cj12b2lkIDA9PT1yPzE6cixlW3RdPWVbdF18fDAsZVt0XSs9cn12YXIgYj1bXCJ4LXJlcXVlc3QtaWRcIixcImNmLXJheVwiLFwieC1hbXotY2YtaWRcIixcIngtYWthbWFpLXJlcXVlc3QtaWRcIl0sZz1bXCJ4LWNkblwiLFwiY29udGVudC10eXBlXCJdLmNvbmNhdChiKTtmdW5jdGlvbiB3KGUpe3ZhciB0PXt9O3JldHVybihlPWV8fFwiXCIpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoZSl7dmFyIHI9ZS5zcGxpdChcIjogXCIpLGE9ci5zaGlmdCgpO2EmJihnLmluZGV4T2YoYS50b0xvd2VyQ2FzZSgpKT49MHx8MD09PWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwieC1saXRpeC1cIikpJiYodFthXT1yLmpvaW4oXCI6IFwiKSl9fSkpLHR9ZnVuY3Rpb24gVChlKXtpZihlKXt2YXIgdD1iLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT1lW3RdfSkpO3JldHVybiB0P2VbdF06dm9pZCAwfX12YXIgRT1mdW5jdGlvbihlKXt2YXIgdD17fTtmb3IodmFyIHIgaW4gZSl7dmFyIGE9ZVtyXTstMSE9PWFbXCJEQVRBLUlEXCJdLnNlYXJjaChcImlvLmxpdGl4LmRhdGEuXCIpJiYodFthW1wiREFUQS1JRFwiXS5yZXBsYWNlKFwiaW8ubGl0aXguZGF0YS5cIixcIlwiKV09YS5WQUxVRSl9cmV0dXJuIHR9O2Z1bmN0aW9uIGsoZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihhPWEuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLGEpfXJldHVybiByfWZ1bmN0aW9uIE8oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/ayhPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe0QoZSx0LHJbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOmsoT2JqZWN0KHIpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocix0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gRChlLHQscil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1yLGV9dmFyIHg9ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJue307dmFyIHQ9bS5uYXZpZ2F0aW9uU3RhcnQoKSxyPWUubG9hZGluZyxhPXI/ci5zdGFydDplLnRyZXF1ZXN0LG49cj9yLmZpcnN0OmUudGZpcnN0LGk9cj9yLmVuZDplLnRsb2FkO3JldHVybntieXRlc0xvYWRlZDplLnRvdGFsLHJlcXVlc3RTdGFydDpNYXRoLnJvdW5kKHQrYSkscmVzcG9uc2VTdGFydDpNYXRoLnJvdW5kKHQrbikscmVzcG9uc2VFbmQ6TWF0aC5yb3VuZCh0K2kpfX0sUz1mdW5jdGlvbihlKXtpZihlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldEFsbFJlc3BvbnNlSGVhZGVycylyZXR1cm4gdyhlLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKX07ZnVuY3Rpb24gcShlLHQpe3ZhciByPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKGE9YS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksci5wdXNoLmFwcGx5KHIsYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gUChlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9xKE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7QShlLHQsclt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKSk6cShPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBBKGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX12YXIgUj1mdW5jdGlvbihlLHQpe2lmKCFlfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLmdldFJlcXVlc3RzKXJldHVybnt9O3ZhciByPWUuZ2V0UmVxdWVzdHMoe3N0YXRlOlwiZXhlY3V0ZWRcIn0pO2lmKDA9PT1yLmxlbmd0aClyZXR1cm57fTt2YXIgYSxuPXJbci5sZW5ndGgtMV0saT1oKG4udXJsKSxvPW4udXJsLHM9bi5ieXRlc0xvYWRlZCx1PW5ldyBEYXRlKG4ucmVxdWVzdFN0YXJ0RGF0ZSkuZ2V0VGltZSgpLGw9bmV3IERhdGUobi5maXJzdEJ5dGVEYXRlKS5nZXRUaW1lKCksZD1uZXcgRGF0ZShuLnJlcXVlc3RFbmREYXRlKS5nZXRUaW1lKCksYz1pc05hTihuLmR1cmF0aW9uKT8wOm4uZHVyYXRpb24sZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmdldE1ldHJpY3NGb3I/dC5nZXRNZXRyaWNzRm9yKG4ubWVkaWFUeXBlKS5IdHRwTGlzdDp0LmdldERhc2hNZXRyaWNzKCkuZ2V0SHR0cFJlcXVlc3RzKG4ubWVkaWFUeXBlKTtyZXR1cm4gZi5sZW5ndGg+MCYmKGE9dyhmW2YubGVuZ3RoLTFdLl9yZXNwb25zZUhlYWRlcnN8fFwiXCIpKSx7cmVxdWVzdFN0YXJ0OnUscmVxdWVzdFJlc3BvbnNlU3RhcnQ6bCxyZXF1ZXN0UmVzcG9uc2VFbmQ6ZCxyZXF1ZXN0Qnl0ZXNMb2FkZWQ6cyxyZXF1ZXN0UmVzcG9uc2VIZWFkZXJzOmEscmVxdWVzdE1lZGlhRHVyYXRpb246YyxyZXF1ZXN0SG9zdG5hbWU6aSxyZXF1ZXN0VXJsOm8scmVxdWVzdElkOmE/VChhKTp2b2lkIDB9fSxJPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5nZXRRdWFsaXR5Rm9yKGUpLGE9dC5nZXRDdXJyZW50VHJhY2tGb3IoZSkuYml0cmF0ZUxpc3Q7cmV0dXJuIGE/e2N1cnJlbnRMZXZlbDpyLHJlbmRpdGlvbldpZHRoOmFbcl0ud2lkdGh8fG51bGwscmVuZGl0aW9uSGVpZ2h0OmFbcl0uaGVpZ2h0fHxudWxsLHJlbmRpdGlvbkJpdHJhdGU6YVtyXS5iYW5kd2lkdGh9Ont9fSxqPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBudWxsPT09KHQ9ZS5tYXRjaCgvLipjb2RlY3NcXCo/PVwiKC4qKVwiLykpfHx2b2lkIDA9PT10P3ZvaWQgMDp0WzFdfTtmdW5jdGlvbiBMKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX12YXIgQz0wLE49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKX12YXIgdCxyLGE7cmV0dXJuIHQ9ZSxyPVt7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbihlLHQscil7cmV0dXJuIHQuX2V2ZW50RW1pdHRlckd1aWQ9dC5fZXZlbnRFbWl0dGVyR3VpZHx8KytDLHRoaXMuX2xpc3RlbmVycz10aGlzLl9saXN0ZW5lcnN8fHt9LHRoaXMuX2xpc3RlbmVyc1tlXT10aGlzLl9saXN0ZW5lcnNbZV18fFtdLHImJih0PXQuYmluZChyKSksdGhpcy5fbGlzdGVuZXJzW2VdLnB1c2godCksdH19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuX2xpc3RlbmVycyYmdGhpcy5fbGlzdGVuZXJzW2VdO3ImJnIuZm9yRWFjaCgoZnVuY3Rpb24oZSxhKXtlLl9ldmVudEVtaXR0ZXJHdWlkPT09dC5fZXZlbnRFbWl0dGVyR3VpZCYmci5zcGxpY2UoYSwxKX0pKX19LHtrZXk6XCJvbmVcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dmFyIGE9dGhpczt0Ll9ldmVudEVtaXR0ZXJHdWlkPXQuX2V2ZW50RW1pdHRlckd1aWR8fCsrQzt2YXIgbj1mdW5jdGlvbiBuKCl7YS5vZmYoZSxuKSx0LmFwcGx5KHJ8fHRoaXMsYXJndW1lbnRzKX07bi5fZXZlbnRFbWl0dGVyR3VpZD10Ll9ldmVudEVtaXR0ZXJHdWlkLHRoaXMub24oZSxuKX19LHtrZXk6XCJlbWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO2lmKHRoaXMuX2xpc3RlbmVycyl7dD10fHx7fTt2YXIgYT10aGlzLl9saXN0ZW5lcnNbXCJiZWZvcmUqXCJdfHxbXSxuPXRoaXMuX2xpc3RlbmVyc1tlXXx8W10saT10aGlzLl9saXN0ZW5lcnNbXCJhZnRlclwiK2VdfHxbXSxvPWZ1bmN0aW9uKHQsYSl7KHQ9dC5zbGljZSgpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmNhbGwocix7dHlwZTplfSxhKX0pKX07byhhLHQpLG8obix0KSxvKGksdCl9fX1dLHImJkwodC5wcm90b3R5cGUsciksYSYmTCh0LGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX0oKSxIPU47ZnVuY3Rpb24gTShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19dmFyIEI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciByPXRoaXM7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLnBtPXQsdGhpcy5fcGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbD1udWxsLHRoaXMuX3BsYXloZWFkU2hvdWxkQmVQcm9ncmVzc2luZz0hMSx0Lm9uKFwicGxheWluZ1wiLChmdW5jdGlvbigpe3IuX3BsYXloZWFkU2hvdWxkQmVQcm9ncmVzc2luZz0hMH0pKSx0Lm9uKFwicGxheVwiLHRoaXMuX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwicGxheWluZ1wiLHRoaXMuX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwiYWRicmVha3N0YXJ0XCIsdGhpcy5fc3RhcnRQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJhZHBsYXlcIix0aGlzLl9zdGFydFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwuYmluZCh0aGlzKSksdC5vbihcImFkcGxheWluZ1wiLHRoaXMuX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwic2Vla2luZ1wiLHRoaXMuX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwiZGV2aWNld2FrZVwiLHRoaXMuX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwidmlld3N0YXJ0XCIsdGhpcy5fc3RhcnRQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJyZWJ1ZmZlcnN0YXJ0XCIsdGhpcy5fc3RhcnRQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJwYXVzZVwiLHRoaXMuX3N0b3BQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJlbmRlZFwiLHRoaXMuX3N0b3BQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJ2aWV3ZW5kXCIsdGhpcy5fc3RvcFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwuYmluZCh0aGlzKSksdC5vbihcImVycm9yXCIsdGhpcy5fc3RvcFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwuYmluZCh0aGlzKSksdC5vbihcImFkZXJyb3JcIix0aGlzLl9zdG9wUGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwiYWRwYXVzZVwiLHRoaXMuX3N0b3BQbGF5YmFja0hlYXJ0YmVhdEludGVydmFsLmJpbmQodGhpcykpLHQub24oXCJhZGVuZGVkXCIsdGhpcy5fc3RvcFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwuYmluZCh0aGlzKSksdC5vbihcImFkYnJlYWtlbmRcIix0aGlzLl9zdG9wUGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHRoaXMpKSx0Lm9uKFwic2Vla2VkXCIsKGZ1bmN0aW9uKCl7dC5kYXRhLnBsYXllcl9pc19wYXVzZWQ/ci5fc3RvcFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwoKTpyLl9zdGFydFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwoKX0pKSx0Lm9uKFwidGltZXVwZGF0ZVwiLChmdW5jdGlvbigpe251bGwhPT1yLl9wbGF5YmFja0hlYXJ0YmVhdEludGVydmFsJiZ0LmVtaXQoXCJwbGF5YmFja2hlYXJ0YmVhdFwiKX0pKSx0Lm9uKFwiZGV2aWNlc2xlZXBcIiwoZnVuY3Rpb24oZSxhKXtudWxsIT09ci5fcGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbCYmKG4oKS5jbGVhckludGVydmFsKHIuX3BsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwpLHQuZW1pdChcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIse3ZpZXdlcl90aW1lOmEudmlld2VyX3RpbWV9KSxyLl9wbGF5YmFja0hlYXJ0YmVhdEludGVydmFsPW51bGwpfSkpfXZhciB0LHIsYTtyZXR1cm4gdD1lLChyPVt7a2V5OlwiX3N0YXJ0UGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztudWxsPT09dGhpcy5fcGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbCYmKHRoaXMucG0uZW1pdChcInBsYXliYWNraGVhcnRiZWF0XCIpLHRoaXMuX3BsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWw9bigpLnNldEludGVydmFsKChmdW5jdGlvbigpe2UucG0uZW1pdChcInBsYXliYWNraGVhcnRiZWF0XCIpfSksdGhpcy5wbS5wbGF5YmFja0hlYXJ0YmVhdFRpbWUpKX19LHtrZXk6XCJfc3RvcFBsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3BsYXloZWFkU2hvdWxkQmVQcm9ncmVzc2luZz0hMSxudWxsIT09dGhpcy5fcGxheWJhY2tIZWFydGJlYXRJbnRlcnZhbCYmKG4oKS5jbGVhckludGVydmFsKHRoaXMuX3BsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWwpLHRoaXMucG0uZW1pdChcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIpLHRoaXMuX3BsYXliYWNrSGVhcnRiZWF0SW50ZXJ2YWw9bnVsbCl9fV0pJiZNKHQucHJvdG90eXBlLHIpLGEmJk0odCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9KCk7ZnVuY3Rpb24gVShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19ZnVuY3Rpb24gRihlLHQscil7cmV0dXJuIHQmJlUoZS5wcm90b3R5cGUsdCksciYmVShlLHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX12YXIgRz1GKChmdW5jdGlvbiBlKHQpe3ZhciByPXRoaXM7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0Lm9uKFwidmlld2luaXRcIiwoZnVuY3Rpb24oKXtyLnZpZXdFcnJvcmVkPSExfSkpLHQub24oXCJlcnJvclwiLChmdW5jdGlvbihlLGEpe3RyeXt2YXIgbj10LmVycm9yVHJhbnNsYXRvcih7cGxheWVyX2Vycm9yX2NvZGU6YS5wbGF5ZXJfZXJyb3JfY29kZSxwbGF5ZXJfZXJyb3JfbWVzc2FnZTphLnBsYXllcl9lcnJvcl9tZXNzYWdlLHBsYXllcl9lcnJvcl9jb250ZXh0OmEucGxheWVyX2Vycm9yX2NvbnRleHR9KTtuPyh0LmRhdGEucGxheWVyX2Vycm9yX2NvZGU9bi5wbGF5ZXJfZXJyb3JfY29kZXx8YS5wbGF5ZXJfZXJyb3JfY29kZSx0LmRhdGEucGxheWVyX2Vycm9yX21lc3NhZ2U9bi5wbGF5ZXJfZXJyb3JfbWVzc2FnZXx8YS5wbGF5ZXJfZXJyb3JfbWVzc2FnZSx0LmRhdGEucGxheWVyX2Vycm9yX2NvbnRleHQ9bi5wbGF5ZXJfZXJyb3JfY29udGV4dHx8YS5wbGF5ZXJfZXJyb3JfY29udGV4dCxyLnZpZXdFcnJvcmVkPSEwKTooZGVsZXRlIHQuZGF0YS5wbGF5ZXJfZXJyb3JfY29kZSxkZWxldGUgdC5kYXRhLnBsYXllcl9lcnJvcl9tZXNzYWdlLGRlbGV0ZSB0LmRhdGEucGxheWVyX2Vycm9yX2NvbnRleHQpfWNhdGNoKGUpe3QubXV4LmxvZy53YXJuKFwiRXhjZXB0aW9uIGluIGVycm9yIHRyYW5zbGF0b3IgY2FsbGJhY2suXCIsZSksci52aWV3RXJyb3JlZD0hMH19KSl9KSk7ZnVuY3Rpb24gVyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19dmFyIFE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5wbT10LHRoaXMuX3dhdGNoVGltZVRyYWNrZXJMYXN0Q2hlY2tlZFRpbWU9bnVsbCx0Lm9uKFwicGxheWJhY2toZWFydGJlYXRcIix0aGlzLl91cGRhdGVXYXRjaFRpbWUuYmluZCh0aGlzKSksdC5vbihcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIsdGhpcy5fY2xlYXJXYXRjaFRpbWVTdGF0ZS5iaW5kKHRoaXMpKX12YXIgdCxyLGE7cmV0dXJuIHQ9ZSwocj1be2tleTpcIl91cGRhdGVXYXRjaFRpbWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXQudmlld2VyX3RpbWU7bnVsbD09PXRoaXMuX3dhdGNoVGltZVRyYWNrZXJMYXN0Q2hlY2tlZFRpbWUmJih0aGlzLl93YXRjaFRpbWVUcmFja2VyTGFzdENoZWNrZWRUaW1lPXIpLHkodGhpcy5wbS5kYXRhLFwidmlld193YXRjaF90aW1lXCIsci10aGlzLl93YXRjaFRpbWVUcmFja2VyTGFzdENoZWNrZWRUaW1lKSx0aGlzLl93YXRjaFRpbWVUcmFja2VyTGFzdENoZWNrZWRUaW1lPXJ9fSx7a2V5OlwiX2NsZWFyV2F0Y2hUaW1lU3RhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX3VwZGF0ZVdhdGNoVGltZShlLHQpLHRoaXMuX3dhdGNoVGltZVRyYWNrZXJMYXN0Q2hlY2tlZFRpbWU9bnVsbH19XSkmJlcodC5wcm90b3R5cGUsciksYSYmVyh0LGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX0oKTtmdW5jdGlvbiBWKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX12YXIgSj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIHI9dGhpczshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMucG09dCx0aGlzLl9wbGF5YmFja1RpbWVUcmFja2VyTGFzdFBsYXloZWFkUG9zaXRpb249LTEsdGhpcy5fbGFzdFRpbWU9Xy5ub3coKSx0aGlzLl9pc0FkUGxheWluZz0hMSx0Lm9uKFwicGxheWJhY2toZWFydGJlYXRcIix0aGlzLl91cGRhdGVQbGF5YmFja1RpbWUuYmluZCh0aGlzKSksdC5vbihcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIsdGhpcy5fY2xlYXJQbGF5YmFja1RpbWVTdGF0ZS5iaW5kKHRoaXMpKSx0Lm9uKFwic2Vla2luZ1wiLHRoaXMuX2NsZWFyUGxheWJhY2tUaW1lU3RhdGUuYmluZCh0aGlzKSksdC5vbihcImFkcGxheWluZ1wiLChmdW5jdGlvbigpe3IuX2lzQWRQbGF5aW5nPSEwfSkpLHQub24oXCJhZGVuZGVkXCIsKGZ1bmN0aW9uKCl7ci5faXNBZFBsYXlpbmc9ITF9KSksdC5vbihcImFkcGF1c2VcIiwoZnVuY3Rpb24oKXtyLl9pc0FkUGxheWluZz0hMX0pKSx0Lm9uKFwiYWRicmVha3N0YXJ0XCIsKGZ1bmN0aW9uKCl7ci5faXNBZFBsYXlpbmc9ITF9KSksdC5vbihcImFkYnJlYWtlbmRcIiwoZnVuY3Rpb24oKXtyLl9pc0FkUGxheWluZz0hMX0pKSx0Lm9uKFwiYWRwbGF5XCIsKGZ1bmN0aW9uKCl7ci5faXNBZFBsYXlpbmc9ITF9KSl9dmFyIHQscixhO3JldHVybiB0PWUsKHI9W3trZXk6XCJfdXBkYXRlUGxheWJhY2tUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnBtLmRhdGEucGxheWVyX3BsYXloZWFkX3RpbWUsdD1fLm5vdygpLHI9LTE7dGhpcy5fcGxheWJhY2tUaW1lVHJhY2tlckxhc3RQbGF5aGVhZFBvc2l0aW9uPj0wJiZlPnRoaXMuX3BsYXliYWNrVGltZVRyYWNrZXJMYXN0UGxheWhlYWRQb3NpdGlvbj9yPWUtdGhpcy5fcGxheWJhY2tUaW1lVHJhY2tlckxhc3RQbGF5aGVhZFBvc2l0aW9uOnRoaXMuX2lzQWRQbGF5aW5nJiYocj10LXRoaXMuX2xhc3RUaW1lKSxyPjAmJnI8PTFlMyYmeSh0aGlzLnBtLmRhdGEsXCJ2aWV3X2NvbnRlbnRfcGxheWJhY2tfdGltZVwiLHIpLHRoaXMuX3BsYXliYWNrVGltZVRyYWNrZXJMYXN0UGxheWhlYWRQb3NpdGlvbj1lLHRoaXMuX2xhc3RUaW1lPXR9fSx7a2V5OlwiX2NsZWFyUGxheWJhY2tUaW1lU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3VwZGF0ZVBsYXliYWNrVGltZSgpLHRoaXMuX3BsYXliYWNrVGltZVRyYWNrZXJMYXN0UGxheWhlYWRQb3NpdGlvbj0tMX19XSkmJlYodC5wcm90b3R5cGUsciksYSYmVih0LGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX0oKTtmdW5jdGlvbiBLKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX12YXIgej1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLnBtPXQ7dmFyIHI9dGhpcy5fdXBkYXRlUGxheWhlYWRUaW1lLmJpbmQodGhpcyk7dC5vbihcInBsYXliYWNraGVhcnRiZWF0XCIsciksdC5vbihcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIsciksdC5vbihcInRpbWV1cGRhdGVcIixyKSx0Lm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe3Qub2ZmKFwidGltZXVwZGF0ZVwiLHIpfSkpfXZhciB0LHIsYTtyZXR1cm4gdD1lLChyPVt7a2V5OlwiX3VwZGF0ZU1heFBsYXloZWFkUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucG0uZGF0YS52aWV3X21heF9wbGF5aGVhZF9wb3NpdGlvbj12b2lkIDA9PT10aGlzLnBtLmRhdGEudmlld19tYXhfcGxheWhlYWRfcG9zaXRpb24/dGhpcy5wbS5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lOk1hdGgubWF4KHRoaXMucG0uZGF0YS52aWV3X21heF9wbGF5aGVhZF9wb3NpdGlvbix0aGlzLnBtLmRhdGEucGxheWVyX3BsYXloZWFkX3RpbWUpfX0se2tleTpcIl91cGRhdGVQbGF5aGVhZFRpbWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMsYT1mdW5jdGlvbigpe3IucG0uY3VycmVudEZyYWdtZW50UERUJiZyLnBtLmN1cnJlbnRGcmFnbWVudFN0YXJ0JiYoci5wbS5kYXRhLnBsYXllcl9wcm9ncmFtX3RpbWU9ci5wbS5jdXJyZW50RnJhZ21lbnRQRFQrci5wbS5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lLXIucG0uY3VycmVudEZyYWdtZW50U3RhcnQpfTtpZih0JiZ0LnBsYXllcl9wbGF5aGVhZF90aW1lKXRoaXMucG0uZGF0YS5wbGF5ZXJfcGxheWhlYWRfdGltZT10LnBsYXllcl9wbGF5aGVhZF90aW1lLGEoKSx0aGlzLl91cGRhdGVNYXhQbGF5aGVhZFBvc2l0aW9uKCk7ZWxzZSBpZih0aGlzLnBtLmdldFBsYXloZWFkVGltZSl7dmFyIG49dGhpcy5wbS5nZXRQbGF5aGVhZFRpbWUoKTt2b2lkIDAhPT1uJiYodGhpcy5wbS5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lPW4sYSgpLHRoaXMuX3VwZGF0ZU1heFBsYXloZWFkUG9zaXRpb24oKSl9fX1dKSYmSyh0LnByb3RvdHlwZSxyKSxhJiZLKHQsYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfSgpO2Z1bmN0aW9uIFkoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fWZ1bmN0aW9uIFgoZSx0LHIpe3JldHVybiB0JiZZKGUucHJvdG90eXBlLHQpLHImJlkoZSxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9dmFyICQ9M2U1LFo9WCgoZnVuY3Rpb24gZSh0KXtpZihmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksIXQuZGlzYWJsZVJlYnVmZmVyVHJhY2tpbmcpe3ZhciByLGE9ZnVuY3Rpb24oZSx0KXtuKHQpLHI9dm9pZCAwfSxuPWZ1bmN0aW9uKGUpe2lmKHIpe3ZhciBhPWUudmlld2VyX3RpbWUtcjt5KHQuZGF0YSxcInZpZXdfcmVidWZmZXJfZHVyYXRpb25cIixhKSxyPWUudmlld2VyX3RpbWUsdC5kYXRhLnZpZXdfcmVidWZmZXJfZHVyYXRpb24+JCYmKHQuZW1pdChcInZpZXdlbmRcIiksdC5zZW5kKFwidmlld2VuZFwiKSx0Lm11eC5sb2cud2FybihcIkVuZGluZyB2aWV3IGFmdGVyIHJlYnVmZmVyaW5nIGZvciBsb25nZXIgdGhhbiBcIi5jb25jYXQoJCxcIm1zLCBmdXR1cmUgZXZlbnRzIHdpbGwgYmUgaWdub3JlZCB1bmxlc3MgYSBwcm9ncmFtY2hhbmdlIG9yIHZpZGVvY2hhbmdlIG9jY3Vycy5cIikpKX10LmRhdGEudmlld193YXRjaF90aW1lPj0wJiZ0LmRhdGEudmlld19yZWJ1ZmZlcl9jb3VudD4wJiYodC5kYXRhLnZpZXdfcmVidWZmZXJfZnJlcXVlbmN5PXQuZGF0YS52aWV3X3JlYnVmZmVyX2NvdW50L3QuZGF0YS52aWV3X3dhdGNoX3RpbWUsdC5kYXRhLnZpZXdfcmVidWZmZXJfcGVyY2VudGFnZT10LmRhdGEudmlld19yZWJ1ZmZlcl9kdXJhdGlvbi90LmRhdGEudmlld193YXRjaF90aW1lKX07dC5vbihcInBsYXliYWNraGVhcnRiZWF0XCIsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4odCl9KSksdC5vbihcInJlYnVmZmVyc3RhcnRcIiwoZnVuY3Rpb24oZSxuKXtyfHwoeSh0LmRhdGEsXCJ2aWV3X3JlYnVmZmVyX2NvdW50XCIsMSkscj1uLnZpZXdlcl90aW1lLHQub25lKFwicmVidWZmZXJlbmRcIixhKSl9KSksdC5vbihcInZpZXdpbml0XCIsKGZ1bmN0aW9uKCl7cj12b2lkIDAsdC5vZmYoXCJyZWJ1ZmZlcmVuZFwiLGEpfSkpfX0pKTtmdW5jdGlvbiBlZShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19dmFyIHRlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgcj10aGlzOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5wbT10LHQuZGlzYWJsZVJlYnVmZmVyVHJhY2tpbmd8fHQuZGlzYWJsZVBsYXloZWFkUmVidWZmZXJUcmFja2luZ3x8KHRoaXMuX2xhc3RDaGVja2VkVGltZT1udWxsLHRoaXMuX2xhc3RQbGF5aGVhZFRpbWU9bnVsbCx0aGlzLl9sYXN0UGxheWhlYWRUaW1lVXBkYXRlZFRpbWU9bnVsbCx0Lm9uKFwicGxheWJhY2toZWFydGJlYXRcIix0aGlzLl9jaGVja0lmUmVidWZmZXJpbmcuYmluZCh0aGlzKSksdC5vbihcInBsYXliYWNraGVhcnRiZWF0ZW5kXCIsdGhpcy5fY2xlYW51cFJlYnVmZmVyVHJhY2tlci5iaW5kKHRoaXMpKSx0Lm9uKFwic2Vla2luZ1wiLChmdW5jdGlvbigpe3IuX2NsZWFudXBSZWJ1ZmZlclRyYWNrZXIobnVsbCx7dmlld2VyX3RpbWU6Xy5ub3coKX0pfSkpKX12YXIgdCxyLGE7cmV0dXJuIHQ9ZSxyPVt7a2V5OlwiX2NoZWNrSWZSZWJ1ZmZlcmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5wbS5zZWVraW5nVHJhY2tlci5pc1NlZWtpbmd8fHRoaXMucG0uYWRUcmFja2VyLmlzQWRCcmVha3x8IXRoaXMucG0ucGxheWJhY2tIZWFydGJlYXQuX3BsYXloZWFkU2hvdWxkQmVQcm9ncmVzc2luZyl0aGlzLl9jbGVhbnVwUmVidWZmZXJUcmFja2VyKGUsdCk7ZWxzZSBpZihudWxsIT09dGhpcy5fbGFzdENoZWNrZWRUaW1lKWlmKHRoaXMuX2xhc3RQbGF5aGVhZFRpbWU9PT10aGlzLnBtLmRhdGEucGxheWVyX3BsYXloZWFkX3RpbWUpe3ZhciByPXQudmlld2VyX3RpbWUtdGhpcy5fbGFzdFBsYXloZWFkVGltZVVwZGF0ZWRUaW1lO1wibnVtYmVyXCI9PXR5cGVvZiB0aGlzLnBtLnN1c3RhaW5lZFJlYnVmZmVyVGhyZXNob2xkJiZyPj10aGlzLnBtLnN1c3RhaW5lZFJlYnVmZmVyVGhyZXNob2xkJiYodGhpcy5fcmVidWZmZXJpbmd8fCh0aGlzLl9yZWJ1ZmZlcmluZz0hMCx0aGlzLnBtLmVtaXQoXCJyZWJ1ZmZlcnN0YXJ0XCIse3ZpZXdlcl90aW1lOnRoaXMuX2xhc3RQbGF5aGVhZFRpbWVVcGRhdGVkVGltZX0pKSksdGhpcy5fbGFzdENoZWNrZWRUaW1lPXQudmlld2VyX3RpbWV9ZWxzZSB0aGlzLl9jbGVhbnVwUmVidWZmZXJUcmFja2VyKGUsdCwhMCk7ZWxzZSB0aGlzLl9wcmVwYXJlUmVidWZmZXJUcmFja2VyU3RhdGUodC52aWV3ZXJfdGltZSl9fSx7a2V5OlwiX2NsZWFyUmVidWZmZXJUcmFja2VyU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xhc3RDaGVja2VkVGltZT1udWxsLHRoaXMuX2xhc3RQbGF5aGVhZFRpbWU9bnVsbCx0aGlzLl9sYXN0UGxheWhlYWRUaW1lVXBkYXRlZFRpbWU9bnVsbH19LHtrZXk6XCJfcHJlcGFyZVJlYnVmZmVyVHJhY2tlclN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbGFzdENoZWNrZWRUaW1lPWUsdGhpcy5fbGFzdFBsYXloZWFkVGltZT10aGlzLnBtLmRhdGEucGxheWVyX3BsYXloZWFkX3RpbWUsdGhpcy5fbGFzdFBsYXloZWFkVGltZVVwZGF0ZWRUaW1lPWV9fSx7a2V5OlwiX2NsZWFudXBSZWJ1ZmZlclRyYWNrZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYodGhpcy5fcmVidWZmZXJpbmcpdGhpcy5fcmVidWZmZXJpbmc9ITEsdGhpcy5wbS5lbWl0KFwicmVidWZmZXJlbmRcIix7dmlld2VyX3RpbWU6dC52aWV3ZXJfdGltZX0pO2Vsc2V7aWYobnVsbD09PXRoaXMuX2xhc3RDaGVja2VkVGltZSlyZXR1cm47dmFyIGE9dGhpcy5wbS5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lLXRoaXMuX2xhc3RQbGF5aGVhZFRpbWUsbj10LnZpZXdlcl90aW1lLXRoaXMuX2xhc3RQbGF5aGVhZFRpbWVVcGRhdGVkVGltZTtcIm51bWJlclwiPT10eXBlb2YgdGhpcy5wbS5taW5pbXVtUmVidWZmZXJEdXJhdGlvbiYmYT4wJiZuLWE+dGhpcy5wbS5taW5pbXVtUmVidWZmZXJEdXJhdGlvbiYmKHRoaXMuX2xhc3RDaGVja2VkVGltZT1udWxsLHRoaXMucG0uZW1pdChcInJlYnVmZmVyc3RhcnRcIix7dmlld2VyX3RpbWU6dGhpcy5fbGFzdFBsYXloZWFkVGltZVVwZGF0ZWRUaW1lfSksdGhpcy5wbS5lbWl0KFwicmVidWZmZXJlbmRcIix7dmlld2VyX3RpbWU6dGhpcy5fbGFzdFBsYXloZWFkVGltZVVwZGF0ZWRUaW1lK24tYX0pKX1yP3RoaXMuX3ByZXBhcmVSZWJ1ZmZlclRyYWNrZXJTdGF0ZSh0LnZpZXdlcl90aW1lKTp0aGlzLl9jbGVhclJlYnVmZmVyVHJhY2tlclN0YXRlKCl9fV0sciYmZWUodC5wcm90b3R5cGUsciksYSYmZWUodCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9KCkscmU9dGU7ZnVuY3Rpb24gYWUoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fXZhciBuZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIHI9dGhpczshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMucG09dCx0Lm9uKFwidmlld2luaXRcIiwoZnVuY3Rpb24oKXt2YXIgZT10LmRhdGEsYT1lLnZpZXdfaWQ7aWYoIWUudmlld19wcm9ncmFtX2NoYW5nZWQpe3ZhciBuPWZ1bmN0aW9uKGUsbil7dmFyIGk9bi52aWV3ZXJfdGltZTtcInBsYXlpbmdcIj09PWUudHlwZSYmdm9pZCAwPT09dC5kYXRhLnZpZXdfdGltZV90b19maXJzdF9mcmFtZT9yLmNhbGN1bGF0ZVRpbWVUb0ZpcnN0RnJhbWUoaXx8Xy5ub3coKSxhKTpcImFkcGxheWluZ1wiIT09ZS50eXBlfHx2b2lkIDAhPT10LmRhdGEudmlld190aW1lX3RvX2ZpcnN0X2ZyYW1lJiYhci5faW5QcmVyb2xsUG9zaXRpb24oKXx8ci5jYWxjdWxhdGVUaW1lVG9GaXJzdEZyYW1lKGl8fF8ubm93KCksYSl9O3Qub25lKFwicGxheWluZ1wiLG4pLHQub25lKFwiYWRwbGF5aW5nXCIsbiksdC5vbmUoXCJ2aWV3ZW5kXCIsKGZ1bmN0aW9uKCl7dC5vZmYoXCJwbGF5aW5nXCIsbiksdC5vZmYoXCJhZHBsYXlpbmdcIixuKX0pKX19KSl9dmFyIHQscixhO3JldHVybiB0PWUsKHI9W3trZXk6XCJfaW5QcmVyb2xsUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLnBtLmRhdGEudmlld19jb250ZW50X3BsYXliYWNrX3RpbWV8fHRoaXMucG0uZGF0YS52aWV3X2NvbnRlbnRfcGxheWJhY2tfdGltZTw9MWUzfX0se2tleTpcImNhbGN1bGF0ZVRpbWVUb0ZpcnN0RnJhbWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3Q9PT10aGlzLnBtLmRhdGEudmlld19pZCYmKHRoaXMucG0ud2F0Y2hUaW1lVHJhY2tlci5fdXBkYXRlV2F0Y2hUaW1lKG51bGwse3ZpZXdlcl90aW1lOmV9KSx0aGlzLnBtLmRhdGEudmlld190aW1lX3RvX2ZpcnN0X2ZyYW1lPXRoaXMucG0uZGF0YS52aWV3X3dhdGNoX3RpbWUsKHRoaXMucG0uZGF0YS5wbGF5ZXJfYXV0b3BsYXlfb258fHRoaXMucG0uZGF0YS52aWRlb19pc19hdXRvcGxheSkmJnRoaXMuTkFWSUdBVElPTl9TVEFSVCYmKHRoaXMucG0uZGF0YS52aWV3X2FnZ3JlZ2F0ZV9zdGFydHVwX3RpbWU9dGhpcy5wbS5kYXRhLnZpZXdfc3RhcnQrdGhpcy5wbS5kYXRhLnZpZXdfd2F0Y2hfdGltZS10aGlzLk5BVklHQVRJT05fU1RBUlQpKX19XSkmJmFlKHQucHJvdG90eXBlLHIpLGEmJmFlKHQsYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfSgpO2Z1bmN0aW9uIGllKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX1mdW5jdGlvbiBvZShlLHQscil7cmV0dXJuIHQmJmllKGUucHJvdG90eXBlLHQpLHImJmllKGUsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfXZhciBzZT1vZSgoZnVuY3Rpb24gZSh0KXt2YXIgcj10aGlzOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdC5vbihcInZpZXdpbml0XCIsKGZ1bmN0aW9uKCl7ci5fbGFzdFBsYXloZWFkUG9zaXRpb249LTF9KSksW1wicGF1c2VcIixcInJlYnVmZmVyc3RhcnRcIixcInNlZWtpbmdcIixcImVycm9yXCIsXCJhZGJyZWFrc3RhcnRcIixcImhiXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Qub24oZSwoZnVuY3Rpb24oKXtpZihyLl9sYXN0UGxheWhlYWRQb3NpdGlvbj49MCYmdC5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lPj0wJiZyLl9sYXN0UGxheWVyV2lkdGg+PTAmJnIuX2xhc3RTb3VyY2VXaWR0aD4wJiZyLl9sYXN0UGxheWVySGVpZ2h0Pj0wJiZyLl9sYXN0U291cmNlSGVpZ2h0PjApe3ZhciBlPXQuZGF0YS5wbGF5ZXJfcGxheWhlYWRfdGltZS1yLl9sYXN0UGxheWhlYWRQb3NpdGlvbjtpZihlPDApcmV0dXJuIHZvaWQoci5fbGFzdFBsYXloZWFkUG9zaXRpb249LTEpO3ZhciBhPU1hdGgubWluKHIuX2xhc3RQbGF5ZXJXaWR0aC9yLl9sYXN0U291cmNlV2lkdGgsci5fbGFzdFBsYXllckhlaWdodC9yLl9sYXN0U291cmNlSGVpZ2h0KSxuPU1hdGgubWF4KDAsYS0xKSxpPU1hdGgubWF4KDAsMS1hKTt0LmRhdGEudmlld19tYXhfdXBzY2FsZV9wZXJjZW50YWdlPU1hdGgubWF4KHQuZGF0YS52aWV3X21heF91cHNjYWxlX3BlcmNlbnRhZ2V8fDAsbiksdC5kYXRhLnZpZXdfbWF4X2Rvd25zY2FsZV9wZXJjZW50YWdlPU1hdGgubWF4KHQuZGF0YS52aWV3X21heF9kb3duc2NhbGVfcGVyY2VudGFnZXx8MCxpKSx5KHQuZGF0YSxcInZpZXdfdG90YWxfY29udGVudF9wbGF5YmFja190aW1lXCIsZSkseSh0LmRhdGEsXCJ2aWV3X3RvdGFsX3Vwc2NhbGluZ1wiLG4qZSkseSh0LmRhdGEsXCJ2aWV3X3RvdGFsX2Rvd25zY2FsaW5nXCIsaSplKX1yLl9sYXN0UGxheWhlYWRQb3NpdGlvbj0tMX0pKX0pKSxbXCJwbGF5aW5nXCIsXCJoYlwiXS5mb3JFYWNoKChmdW5jdGlvbihlKXt0Lm9uKGUsKGZ1bmN0aW9uKCl7ci5fbGFzdFBsYXloZWFkUG9zaXRpb249dC5kYXRhLnBsYXllcl9wbGF5aGVhZF90aW1lLHIuX2xhc3RQbGF5ZXJXaWR0aD10LmRhdGEucGxheWVyX3dpZHRoLHIuX2xhc3RQbGF5ZXJIZWlnaHQ9dC5kYXRhLnBsYXllcl9oZWlnaHQsci5fbGFzdFNvdXJjZVdpZHRoPXQuZGF0YS52aWRlb19zb3VyY2Vfd2lkdGgsci5fbGFzdFNvdXJjZUhlaWdodD10LmRhdGEudmlkZW9fc291cmNlX2hlaWdodH0pKX0pKX0pKTtmdW5jdGlvbiB1ZShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19ZnVuY3Rpb24gbGUoZSx0LHIpe3JldHVybiB0JiZ1ZShlLnByb3RvdHlwZSx0KSxyJiZ1ZShlLHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX12YXIgZGU9bGUoKGZ1bmN0aW9uIGUodCl7dmFyIHI9dGhpczshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuaXNTZWVraW5nPSExLHQub24oXCJzZWVraW5nXCIsKGZ1bmN0aW9uKGUsYSl7T2JqZWN0LmFzc2lnbih0LmRhdGEsYSksci5fbGFzdFNlZWtpbmdUaW1lPV8ubm93KCksITE9PT1yLmlzU2Vla2luZyYmKHIuaXNTZWVraW5nPSEwLHQuc2VuZChcInNlZWtpbmdcIikpfSkpLHQub24oXCJzZWVrZWRcIiwoZnVuY3Rpb24oKXtyLmlzU2Vla2luZz0hMTt2YXIgZT1yLl9sYXN0U2Vla2luZ1RpbWV8fF8ubm93KCksYT1fLm5vdygpLWU7eSh0LmRhdGEsXCJ2aWV3X3NlZWtfY291bnRcIiwxKSx5KHQuZGF0YSxcInZpZXdfc2Vla19kdXJhdGlvblwiLGEpO3ZhciBuPXQuZGF0YS52aWV3X21heF9zZWVrX3RpbWV8fDA7dC5kYXRhLnZpZXdfbWF4X3NlZWtfdGltZT1NYXRoLm1heChuLGEpfSkpLHQub24oXCJ2aWV3ZW5kXCIsKGZ1bmN0aW9uKCl7ci5pc1NlZWtpbmc9ITF9KSl9KSk7ZnVuY3Rpb24gY2UoZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7dmFyIHI9bnVsbD09ZT9udWxsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9cil7dmFyIGEsbixpPVtdLG89ITAscz0hMTt0cnl7Zm9yKHI9ci5jYWxsKGUpOyEobz0oYT1yLm5leHQoKSkuZG9uZSkmJihpLnB1c2goYS52YWx1ZSksIXR8fGkubGVuZ3RoIT09dCk7bz0hMCk7fWNhdGNoKGUpe3M9ITAsbj1lfWZpbmFsbHl7dHJ5e298fG51bGw9PXIucmV0dXJufHxyLnJldHVybigpfWZpbmFsbHl7aWYocyl0aHJvdyBufX1yZXR1cm4gaX19KGUsdCl8fGZ1bmN0aW9uKGUsdCl7aWYoZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGZlKGUsdCk7dmFyIHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1yJiZlLmNvbnN0cnVjdG9yJiYocj1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1yfHxcIlNldFwiPT09cj9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1yfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChyKT9mZShlLHQpOnZvaWQgMH19KGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBmZShlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgcj0wLGE9bmV3IEFycmF5KHQpO3I8dDtyKyspYVtyXT1lW3JdO3JldHVybiBhfWZ1bmN0aW9uIHBlKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX12YXIgX2U9ZnVuY3Rpb24oZSx0KXtlLnB1c2godCksZS5zb3J0KChmdW5jdGlvbihlLHQpe3JldHVybiBlLnZpZXdlcl90aW1lLXQudmlld2VyX3RpbWV9KSl9LGhlPVtcImFkYnJlYWtzdGFydFwiLFwiYWRyZXF1ZXN0XCIsXCJhZHJlc3BvbnNlXCIsXCJhZHBsYXlcIixcImFkcGxheWluZ1wiLFwiYWRwYXVzZVwiLFwiYWRlbmRlZFwiLFwiYWRicmVha2VuZFwiLFwiYWRlcnJvclwiXSx2ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIHI9dGhpczshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMucG09dCx0Lm9uKFwidmlld2luaXRcIiwoZnVuY3Rpb24oKXtyLmlzQWRCcmVhaz0hMSxyLl9jdXJyZW50QWRSZXF1ZXN0TnVtYmVyPTAsci5fY3VycmVudEFkUmVzcG9uc2VOdW1iZXI9MCxyLl9hZFJlcXVlc3RzPVtdLHIuX2FkUmVzcG9uc2VzPVtdLHIuX2FkSGFzUGxheWVkPSExLHIuX3dvdWxkQmVOZXdBZFBsYXk9ITAsci5fcHJlcm9sbFBsYXlUaW1lPXZvaWQgMH0pKSxoZS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gdC5vbihlLHIuX3VwZGF0ZUFkRGF0YS5iaW5kKHIpKX0pKTt2YXIgYT1mdW5jdGlvbigpe3IuaXNBZEJyZWFrPSExfTt0Lm9uKFwiYWRicmVha3N0YXJ0XCIsKGZ1bmN0aW9uKCl7ci5pc0FkQnJlYWs9ITB9KSksdC5vbihcInBsYXlcIixhKSx0Lm9uKFwicGxheWluZ1wiLGEpLHQub24oXCJ2aWV3ZW5kXCIsYSksdC5vbihcImFkcmVxdWVzdFwiLChmdW5jdGlvbihlLGEpe2E9T2JqZWN0LmFzc2lnbih7YWRfcmVxdWVzdF9pZDpcImdlbmVyYXRlZEFkUmVxdWVzdElkXCIrci5fY3VycmVudEFkUmVxdWVzdE51bWJlcisrfSxhKSxfZShyLl9hZFJlcXVlc3RzLGEpLHkodC5kYXRhLFwidmlld19hZF9yZXF1ZXN0X2NvdW50XCIpLHIuaW5QcmVyb2xsUG9zaXRpb24oKSYmKHQuZGF0YS52aWV3X3ByZXJvbGxfcmVxdWVzdGVkPSEwLHIuX2FkSGFzUGxheWVkfHx5KHQuZGF0YSxcInZpZXdfcHJlcm9sbF9yZXF1ZXN0X2NvdW50XCIpKX0pKSx0Lm9uKFwiYWRyZXNwb25zZVwiLChmdW5jdGlvbihlLGEpe2E9T2JqZWN0LmFzc2lnbih7YWRfcmVxdWVzdF9pZDpcImdlbmVyYXRlZEFkUmVxdWVzdElkXCIrci5fY3VycmVudEFkUmVzcG9uc2VOdW1iZXIrK30sYSksX2Uoci5fYWRSZXNwb25zZXMsYSk7dmFyIG49ci5maW5kQWRSZXF1ZXN0KGEuYWRfcmVxdWVzdF9pZCk7biYmeSh0LmRhdGEsXCJ2aWV3X2FkX3JlcXVlc3RfdGltZVwiLE1hdGgubWF4KDAsYS52aWV3ZXJfdGltZS1uLnZpZXdlcl90aW1lKSl9KSksdC5vbihcImFkcGxheVwiLChmdW5jdGlvbihlLGEpe3IuX2FkSGFzUGxheWVkPSEwLHIuX3dvdWxkQmVOZXdBZFBsYXkmJihyLl93b3VsZEJlTmV3QWRQbGF5PSExLHkodC5kYXRhLFwidmlld19hZF9wbGF5ZWRfY291bnRcIikpLHIuaW5QcmVyb2xsUG9zaXRpb24oKSYmIXQuZGF0YS52aWV3X3ByZXJvbGxfcGxheWVkJiYodC5kYXRhLnZpZXdfcHJlcm9sbF9wbGF5ZWQ9ITAsci5fYWRSZXF1ZXN0cy5sZW5ndGg+MCYmKHQuZGF0YS52aWV3X3ByZXJvbGxfcmVxdWVzdF90aW1lPU1hdGgubWF4KDAsYS52aWV3ZXJfdGltZS1yLl9hZFJlcXVlc3RzWzBdLnZpZXdlcl90aW1lKSksdC5kYXRhLnZpZXdfc3RhcnQmJih0LmRhdGEudmlld19zdGFydHVwX3ByZXJvbGxfcmVxdWVzdF90aW1lPU1hdGgubWF4KDAsYS52aWV3ZXJfdGltZS10LmRhdGEudmlld19zdGFydCkpLHIuX3ByZXJvbGxQbGF5VGltZT1hLnZpZXdlcl90aW1lKX0pKSx0Lm9uKFwiYWRwbGF5aW5nXCIsKGZ1bmN0aW9uKGUsYSl7ci5pblByZXJvbGxQb3NpdGlvbigpJiZ2b2lkIDA9PT10LmRhdGEudmlld19wcmVyb2xsX2xvYWRfdGltZSYmdm9pZCAwIT09ci5fcHJlcm9sbFBsYXlUaW1lJiYodC5kYXRhLnZpZXdfcHJlcm9sbF9sb2FkX3RpbWU9YS52aWV3ZXJfdGltZS1yLl9wcmVyb2xsUGxheVRpbWUsdC5kYXRhLnZpZXdfc3RhcnR1cF9wcmVyb2xsX2xvYWRfdGltZT1hLnZpZXdlcl90aW1lLXIuX3ByZXJvbGxQbGF5VGltZSl9KSksdC5vbihcImFkZW5kZWRcIiwoZnVuY3Rpb24oKXtyLl93b3VsZEJlTmV3QWRQbGF5PSEwfSkpLHQub24oXCJhZGVycm9yXCIsKGZ1bmN0aW9uKCl7ci5fd291bGRCZU5ld0FkUGxheT0hMH0pKX12YXIgdCxyLGE7cmV0dXJuIHQ9ZSwocj1be2tleTpcImluUHJlcm9sbFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5wbS5kYXRhLnZpZXdfY29udGVudF9wbGF5YmFja190aW1lfHx0aGlzLnBtLmRhdGEudmlld19jb250ZW50X3BsYXliYWNrX3RpbWU8PTFlM319LHtrZXk6XCJmaW5kQWRSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDx0aGlzLl9hZFJlcXVlc3RzLmxlbmd0aDt0KyspaWYodGhpcy5fYWRSZXF1ZXN0c1t0XS5hZF9yZXF1ZXN0X2lkPT09ZSlyZXR1cm4gdGhpcy5fYWRSZXF1ZXN0c1t0XX19LHtrZXk6XCJfdXBkYXRlQWREYXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmluUHJlcm9sbFBvc2l0aW9uKCkpe2lmKCF0aGlzLnBtLmRhdGEudmlld19wcmVyb2xsX2FkX3RhZ19ob3N0bmFtZSYmdC5hZF90YWdfdXJsKXt2YXIgcj1jZSh2KHQuYWRfdGFnX3VybCksMiksYT1yWzBdLG49clsxXTt0aGlzLnBtLmRhdGEudmlld19wcmVyb2xsX2FkX3RhZ19kb21haW49bix0aGlzLnBtLmRhdGEudmlld19wcmVyb2xsX2FkX3RhZ19ob3N0bmFtZT1hfWlmKCF0aGlzLnBtLmRhdGEudmlld19wcmVyb2xsX2FkX2Fzc2V0X2hvc3RuYW1lJiZ0LmFkX2Fzc2V0X3VybCl7dmFyIGk9Y2Uodih0LmFkX2Fzc2V0X3VybCksMiksbz1pWzBdLHM9aVsxXTt0aGlzLnBtLmRhdGEudmlld19wcmVyb2xsX2FkX2Fzc2V0X2RvbWFpbj1zLHRoaXMucG0uZGF0YS52aWV3X3ByZXJvbGxfYWRfYXNzZXRfaG9zdG5hbWU9b319dGhpcy5wbS5kYXRhLmFkX2Fzc2V0X3VybD1udWxsPT10P3ZvaWQgMDp0LmFkX2Fzc2V0X3VybCx0aGlzLnBtLmRhdGEuYWRfdGFnX3VybD1udWxsPT10P3ZvaWQgMDp0LmFkX3RhZ191cmwsdGhpcy5wbS5kYXRhLmFkX2NyZWF0aXZlX2lkPW51bGw9PXQ/dm9pZCAwOnQuYWRfY3JlYXRpdmVfaWQsdGhpcy5wbS5kYXRhLmFkX2lkPW51bGw9PXQ/dm9pZCAwOnQuYWRfaWQsdGhpcy5wbS5kYXRhLmFkX3VuaXZlcnNhbF9pZD1udWxsPT10P3ZvaWQgMDp0LmFkX3VuaXZlcnNhbF9pZH19XSkmJnBlKHQucHJvdG90eXBlLHIpLGEmJnBlKHQsYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfSgpO2Z1bmN0aW9uIG1lKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX1mdW5jdGlvbiB5ZShlLHQscil7cmV0dXJuIHQmJm1lKGUucHJvdG90eXBlLHQpLHImJm1lKGUsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfXZhciBiZT15ZSgoZnVuY3Rpb24gZSh0KXt2YXIgcixhOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSk7dmFyIGk9ZnVuY3Rpb24oKXt0LmRpc2FibGVSZWJ1ZmZlclRyYWNraW5nfHxyJiYoeSh0LmRhdGEsXCJ2aWV3X3dhaXRpbmdfcmVidWZmZXJfZHVyYXRpb25cIixfLm5vdygpLXIpLHI9ITEsbigpLmNsZWFySW50ZXJ2YWwoYSkpfSxvPSExLHM9ZnVuY3Rpb24oKXtvPSExLGkoKX07dC5vbihcIndhaXRpbmdcIiwoZnVuY3Rpb24oKXtvJiYodC5kaXNhYmxlUmVidWZmZXJUcmFja2luZ3x8KHkodC5kYXRhLFwidmlld193YWl0aW5nX3JlYnVmZmVyX2NvdW50XCIsMSkscj1fLm5vdygpLGE9bigpLnNldEludGVydmFsKChmdW5jdGlvbigpe2lmKHIpe3ZhciBlPV8ubm93KCk7eSh0LmRhdGEsXCJ2aWV3X3dhaXRpbmdfcmVidWZmZXJfZHVyYXRpb25cIixlLXIpLHI9ZX19KSwyNTApKSl9KSksdC5vbihcInBsYXlpbmdcIiwoZnVuY3Rpb24oKXtpKCksbz0hMH0pKSx0Lm9uKFwicGF1c2VcIixzKSx0Lm9uKFwic2Vla2luZ1wiLHMpfSkpO2Z1bmN0aW9uIGdlKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBhPXRbcl07YS5lbnVtZXJhYmxlPWEuZW51bWVyYWJsZXx8ITEsYS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEua2V5LGEpfX1mdW5jdGlvbiB3ZShlLHQscil7cmV0dXJuIHQmJmdlKGUucHJvdG90eXBlLHQpLHImJmdlKGUsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfXZhciBUZT13ZSgoZnVuY3Rpb24gZSh0KXt2YXIgcj10aGlzOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSk7dmFyIGE9ZnVuY3Rpb24oKXtyLmxhc3RXYWxsQ2xvY2tUaW1lPV8ubm93KCksdC5vbihcImJlZm9yZSpcIixuKX0sbj1mdW5jdGlvbihlKXt2YXIgYT1fLm5vdygpLG49ci5sYXN0V2FsbENsb2NrVGltZTtyLmxhc3RXYWxsQ2xvY2tUaW1lPWEsYS1uPjNlNCYmKHQuZW1pdChcImRldmljZXNsZWVwXCIse3ZpZXdlcl90aW1lOm59KSxPYmplY3QuYXNzaWduKHQuZGF0YSx7dmlld2VyX3RpbWU6bn0pLHQuc2VuZChcImRldmljZXNsZWVwXCIpLHQuZW1pdChcImRldmljZXdha2VcIix7dmlld2VyX3RpbWU6YX0pLE9iamVjdC5hc3NpZ24odC5kYXRhLHt2aWV3ZXJfdGltZTphfSksdC5zZW5kKFwiZGV2aWNld2FrZVwiKSl9O3Qub25lKFwicGxheWJhY2toZWFydGJlYXRcIixhKSx0Lm9uKFwicGxheWJhY2toZWFydGJlYXRlbmRcIiwoZnVuY3Rpb24oKXt0Lm9mZihcImJlZm9yZSpcIixuKSx0Lm9uZShcInBsYXliYWNraGVhcnRiZWF0XCIsYSl9KSl9KSksRWU9cigzNzUpLGtlPXIoNjU1KSxPZT1yLm4oa2UpLERlPVwibXV4RGF0YVwiLHhlPWZ1bmN0aW9uKCl7dmFyIGU7dHJ5e2U9RWUucGFyc2UoT2UoKS5nZXQoRGUpfHxcIlwiKX1jYXRjaCh0KXtlPXt9fXJldHVybiBlfSxTZT1mdW5jdGlvbihlKXt0cnl7T2UoKS5zZXQoRGUsRWUuc3RyaW5naWZ5KGUpLHtleHBpcmVzOjM2NX0pfWNhdGNoKGUpe319LHFlPWZ1bmN0aW9uKCl7dmFyIGU9eGUoKTtyZXR1cm4gZS5tdXhfdmlld2VyX2lkPWUubXV4X3ZpZXdlcl9pZHx8aSgpLGUubXNuPWUubXNufHxNYXRoLnJhbmRvbSgpLFNlKGUpLHttdXhfdmlld2VyX2lkOmUubXV4X3ZpZXdlcl9pZCxtdXhfc2FtcGxlX251bWJlcjplLm1zbn19O2Z1bmN0aW9uIFBlKGUsdCl7dmFyIHI9dC5iZWFjb25Db2xsZWN0aW9uRG9tYWluLGE9dC5iZWFjb25Eb21haW47aWYocilyZXR1cm5cImh0dHBzOi8vXCIrcjt2YXIgbj1hfHxcImxpdGl4LmlvXCI7cmV0dXJuKGU9ZXx8XCJpbmZlcnJlZFwiKS5tYXRjaCgvXlthLXowLTldKyQvKT9cImh0dHBzOi8vXCIrZStcIi5cIituOlwiaHR0cHM6Ly9pbWcubGl0aXguaW8vYS5naWZcIn12YXIgQWU9ZnVuY3Rpb24oKXt2YXIgZTtzd2l0Y2goUmUoKSl7Y2FzZVwiY2VsbHVsYXJcIjplPVwiY2VsbHVsYXJcIjticmVhaztjYXNlXCJldGhlcm5ldFwiOmU9XCJ3aXJlZFwiO2JyZWFrO2Nhc2VcIndpZmlcIjplPVwid2lmaVwiO2JyZWFrO2Nhc2Ugdm9pZCAwOmJyZWFrO2RlZmF1bHQ6ZT1cIm90aGVyXCJ9cmV0dXJuIGV9LFJlPWZ1bmN0aW9uKCl7dmFyIGU9bigpLm5hdmlnYXRvcix0PWUmJihlLmNvbm5lY3Rpb258fGUubW96Q29ubmVjdGlvbnx8ZS53ZWJraXRDb25uZWN0aW9uKTtyZXR1cm4gdCYmdC50eXBlfTtBZS5nZXRDb25uZWN0aW9uRnJvbUFQST1SZTt2YXIgSWU9QWUsamU9Q2Uoe2E6XCJlbnZcIixiOlwiYmVhY29uXCIsYzpcImN1c3RvbVwiLGQ6XCJhZFwiLGU6XCJldmVudFwiLGY6XCJleHBlcmltZW50XCIsaTpcImludGVybmFsXCIsbTpcIm11eFwiLG46XCJyZXNwb25zZVwiLHA6XCJwbGF5ZXJcIixxOlwicmVxdWVzdFwiLHI6XCJyZXRyeVwiLHM6XCJzZXNzaW9uXCIsdDpcInRpbWVzdGFtcFwiLHU6XCJ2aWV3ZXJcIix2OlwidmlkZW9cIix3OlwicGFnZVwiLHg6XCJ2aWV3XCIseTpcInN1YlwifSksTGU9Q2Uoe2FkOlwiYWRcIixhZzpcImFnZ3JlZ2F0ZVwiLGFwOlwiYXBpXCIsYWw6XCJhcHBsaWNhdGlvblwiLGFyOlwiYXJjaGl0ZWN0dXJlXCIsYXM6XCJhc3NldFwiLGF1OlwiYXV0b3BsYXlcIixhdjpcImF2ZXJhZ2VcIixiaTpcImJpdHJhdGVcIixicjpcImJyZWFrXCIsYnc6XCJicm93c2VyXCIsYnk6XCJieXRlc1wiLGNhOlwiY2FjaGVkXCIsY2I6XCJjYW5jZWxcIixjYzpcImNvZGVjXCIsY2Q6XCJjb2RlXCIsY2c6XCJjYXRlZ29yeVwiLGNoOlwiY2hhbmdlZFwiLGNsOlwiY2FuY2VsZWRcIixjbjpcImNvbmZpZ1wiLGNvOlwiY291bnRcIixjZTpcImNvdW50ZXJcIixjcDpcImNvbXBsZXRlXCIsY3I6XCJjcmVhdGl2ZVwiLGN0OlwiY29udGVudFwiLGN1OlwiY3VycmVudFwiLGN4OlwiY29ubmVjdGlvblwiLGN6OlwiY29udGV4dFwiLGRnOlwiZG93bnNjYWxpbmdcIixkbTpcImRvbWFpblwiLGRuOlwiY2RuXCIsZG86XCJkb3duc2NhbGVcIixkcjpcImRybVwiLGRwOlwiZHJvcHBlZFwiLGR1OlwiZHVyYXRpb25cIixkdjpcImRldmljZVwiLGVjOlwiZW5jb2RpbmdcIixlZDpcImVkZ2VcIixlbjpcImVuZFwiLGVnOlwiZW5naW5lXCIsZW06XCJlbWJlZFwiLGVyOlwiZXJyb3JcIixlczpcImVycm9yY29kZVwiLGV0OlwiZXJyb3J0ZXh0XCIsZWU6XCJldmVudFwiLGV2OlwiZXZlbnRzXCIsZXg6XCJleHBpcmVzXCIsZXA6XCJleHBlcmltZW50c1wiLGZhOlwiZmFpbGVkXCIsZmk6XCJmaXJzdFwiLGZtOlwiZmFtaWx5XCIsZnQ6XCJmb3JtYXRcIixmcDpcImZwc1wiLGZxOlwiZnJlcXVlbmN5XCIsZnI6XCJmcmFtZVwiLGZzOlwiZnVsbHNjcmVlblwiLGhhOlwiaGFzXCIsaGI6XCJob2xkYmFja1wiLGhlOlwiaGVhZGVyc1wiLGhvOlwiaG9zdFwiLGhuOlwiaG9zdG5hbWVcIixodDpcImhlaWdodFwiLGlkOlwiaWRcIixpaTpcImluaXRcIixpbjpcImluc3RhbmNlXCIsaXA6XCJpcFwiLGlzOlwiaXNcIixrZTpcImtleVwiLGxhOlwibGFuZ3VhZ2VcIixsYjpcImxhYmVsZWRcIixsZTpcImxldmVsXCIsbGk6XCJsaXZlXCIsbGQ6XCJsb2FkZWRcIixsbzpcImxvYWRcIixsczpcImxpc3RzXCIsbHQ6XCJsYXRlbmN5XCIsbWE6XCJtYXhcIixtZDpcIm1lZGlhXCIsbWU6XCJtZXNzYWdlXCIsbWY6XCJtYW5pZmVzdFwiLG1pOlwibWltZVwiLG1sOlwibWlkcm9sbFwiLG1tOlwibWluXCIsbW46XCJtYW51ZmFjdHVyZXJcIixtbzpcIm1vZGVsXCIsbXg6XCJtdXhcIixuZTpcIm5ld2VzdFwiLG5tOlwibmFtZVwiLG5vOlwibnVtYmVyXCIsb246XCJvblwiLG9zOlwib3NcIixwYTpcInBhdXNlZFwiLHBiOlwicGxheWJhY2tcIixwZDpcInByb2R1Y2VyXCIscGU6XCJwZXJjZW50YWdlXCIscGY6XCJwbGF5ZWRcIixwZzpcInByb2dyYW1cIixwaDpcInBsYXloZWFkXCIscGk6XCJwbHVnaW5cIixwbDpcInByZXJvbGxcIixwbjpcInBsYXlpbmdcIixwbzpcInBvc3RlclwiLHByOlwicHJlbG9hZFwiLHBzOlwicG9zaXRpb25cIixwdDpcInBhcnRcIixweTpcInByb3BlcnR5XCIscmE6XCJyYXRlXCIscmQ6XCJyZXF1ZXN0ZWRcIixyZTpcInJlYnVmZmVyXCIscmY6XCJyZW5kaXRpb25cIixybTpcInJlbW90ZVwiLHJvOlwicmF0aW9cIixycDpcInJlc3BvbnNlXCIscnE6XCJyZXF1ZXN0XCIscnM6XCJyZXF1ZXN0c1wiLHNhOlwic2FtcGxlXCIsc2U6XCJzZXNzaW9uXCIsc2s6XCJzZWVrXCIsc206XCJzdHJlYW1cIixzbzpcInNvdXJjZVwiLHNxOlwic2VxdWVuY2VcIixzcjpcInNlcmllc1wiLHN0Olwic3RhcnRcIixzdTpcInN0YXJ0dXBcIixzdjpcInNlcnZlclwiLHN3Olwic29mdHdhcmVcIix0YTpcInRhZ1wiLHRjOlwidGVjaFwiLHRlOlwidGV4dFwiLHRnOlwidGFyZ2V0XCIsdGg6XCJ0aHJvdWdocHV0XCIsdGk6XCJ0aW1lXCIsdGw6XCJ0b3RhbFwiLHRvOlwidG9cIix0dDpcInRpdGxlXCIsdHk6XCJ0eXBlXCIsdWc6XCJ1cHNjYWxpbmdcIix1bjpcInVuaXZlcnNhbFwiLHVwOlwidXBzY2FsZVwiLHVyOlwidXJsXCIsdXM6XCJ1c2VyXCIsdmE6XCJ2YXJpYW50XCIsdmQ6XCJ2aWV3ZWRcIix2aTpcInZpZGVvXCIsdmU6XCJ2ZXJzaW9uXCIsdnc6XCJ2aWV3XCIsdnI6XCJ2aWV3ZXJcIix3ZDpcIndpZHRoXCIsd2E6XCJ3YXRjaFwiLHd0Olwid2FpdGluZ1wifSk7ZnVuY3Rpb24gQ2UoZSl7dmFyIHQ9e307Zm9yKHZhciByIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShyKSYmKHRbZVtyXV09cik7cmV0dXJuIHR9ZnVuY3Rpb24gTmUoZSl7dmFyIHQ9e30scj17fTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24oYSl7dmFyIG49ITE7aWYoZS5oYXNPd25Qcm9wZXJ0eShhKSYmdm9pZCAwIT09ZVthXSl7dmFyIGk9YS5zcGxpdChcIl9cIiksbz1pWzBdLHM9amVbb107c3x8KGYuaW5mbyhcIkRhdGEga2V5IHdvcmQgYFwiK2lbMF0rXCJgIG5vdCBleHBlY3RlZCBpbiBcIithKSxzPW8rXCJfXCIpLGkuc3BsaWNlKDEpLmZvckVhY2goKGZ1bmN0aW9uKGUpe1widXJsXCI9PT1lJiYobj0hMCksTGVbZV0/cys9TGVbZV06TnVtYmVyKGUpJiZNYXRoLmZsb29yKE51bWJlcihlKSk9PT1OdW1iZXIoZSk/cys9ZTooZi5pbmZvKFwiRGF0YSBrZXkgd29yZCBgXCIrZStcImAgbm90IGV4cGVjdGVkIGluIFwiK2EpLHMrPVwiX1wiK2UrXCJfXCIpfSkpLG4/cltzXT1lW2FdOnRbc109ZVthXX19KSksT2JqZWN0LmFzc2lnbih0LHIpfXZhciBIZT17bWF4QmVhY29uU2l6ZTozMDAsbWF4UXVldWVMZW5ndGg6MzYwMCxiYXNlVGltZUJldHdlZW5CZWFjb25zOjFlNCxtYXhQYXlsb2FkS0JTaXplOjUwMH0sTWU9W1wiaGJcIixcInJlcXVlc3Rjb21wbGV0ZWRcIixcInJlcXVlc3RmYWlsZWRcIixcInJlcXVlc3RjYW5jZWxlZFwiXSxCZT1cImh0dHBzOi8vaW1nLmxpdGl4LmlvXCIsVWU9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3RoaXMuX2JlYWNvblVybD1lfHxCZSx0aGlzLl9ldmVudFF1ZXVlPVtdLHRoaXMuX3Bvc3RJbkZsaWdodD0hMSx0aGlzLl9mYWlsdXJlQ291bnQ9MCx0aGlzLl9zZW5kVGltZW91dD0hMSx0aGlzLl9vcHRpb25zPU9iamVjdC5hc3NpZ24oe30sSGUsdCl9O1VlLnByb3RvdHlwZS5xdWV1ZUV2ZW50PWZ1bmN0aW9uKGUsdCl7dmFyIHI9T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4odGhpcy5fZXZlbnRRdWV1ZS5sZW5ndGg8PXRoaXMuX29wdGlvbnMubWF4UXVldWVMZW5ndGh8fFwiZXZlbnRyYXRlZXhjZWVkZWRcIj09PWUpJiYodGhpcy5fZXZlbnRRdWV1ZS5wdXNoKHIpLHRoaXMuX3NlbmRUaW1lb3V0fHx0aGlzLl9zdGFydEJlYWNvblNlbmRpbmcoKSx0aGlzLl9ldmVudFF1ZXVlLmxlbmd0aDw9dGhpcy5fb3B0aW9ucy5tYXhRdWV1ZUxlbmd0aCl9LFVlLnByb3RvdHlwZS5mbHVzaEV2ZW50cz1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07ZSYmMT09PXRoaXMuX2V2ZW50UXVldWUubGVuZ3RoP3RoaXMuX2V2ZW50UXVldWUucG9wKCk6KHRoaXMuX2V2ZW50UXVldWUubGVuZ3RoJiZ0aGlzLl9zZW5kQmVhY29uUXVldWUoKSx0aGlzLl9zdGFydEJlYWNvblNlbmRpbmcoKSl9LFVlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt0aGlzLmRlc3Ryb3llZD0hMCxlP3RoaXMuX2NsZWFyQmVhY29uUXVldWUoKTp0aGlzLmZsdXNoRXZlbnRzKCksbigpLmNsZWFyVGltZW91dCh0aGlzLl9zZW5kVGltZW91dCl9LFVlLnByb3RvdHlwZS5fY2xlYXJCZWFjb25RdWV1ZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2V2ZW50UXVldWUubGVuZ3RoPnRoaXMuX29wdGlvbnMubWF4QmVhY29uU2l6ZT90aGlzLl9ldmVudFF1ZXVlLmxlbmd0aC10aGlzLl9vcHRpb25zLm1heEJlYWNvblNpemU6MCx0PXRoaXMuX2V2ZW50UXVldWUuc2xpY2UoZSk7ZT4wJiZPYmplY3QuYXNzaWduKHRbdC5sZW5ndGgtMV0sTmUoe211eF92aWV3X21lc3NhZ2U6XCJldmVudCBxdWV1ZSB0cnVuY2F0ZWRcIn0pKTt2YXIgcj10aGlzLl9jcmVhdGVQYXlsb2FkKHQpO0dlKHRoaXMuX2JlYWNvblVybCxyLCEwLChmdW5jdGlvbigpe30pKX0sVWUucHJvdG90eXBlLl9zZW5kQmVhY29uUXVldWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKCF0aGlzLl9wb3N0SW5GbGlnaHQpe3ZhciB0PXRoaXMuX2V2ZW50UXVldWUuc2xpY2UoMCx0aGlzLl9vcHRpb25zLm1heEJlYWNvblNpemUpO3RoaXMuX2V2ZW50UXVldWU9dGhpcy5fZXZlbnRRdWV1ZS5zbGljZSh0aGlzLl9vcHRpb25zLm1heEJlYWNvblNpemUpLHRoaXMuX3Bvc3RJbkZsaWdodD0hMDt2YXIgcj10aGlzLl9jcmVhdGVQYXlsb2FkKHQpLGE9Xy5ub3coKTtHZSh0aGlzLl9iZWFjb25VcmwsciwhMSwoZnVuY3Rpb24ocixuKXtuPyhlLl9ldmVudFF1ZXVlPXQuY29uY2F0KGUuX2V2ZW50UXVldWUpLGUuX2ZhaWx1cmVDb3VudCs9MSxmLmluZm8oXCJFcnJvciBzZW5kaW5nIGJlYWNvbjogXCIrbikpOmUuX2ZhaWx1cmVDb3VudD0wLGUuX3JvdW5kVHJpcFRpbWU9Xy5ub3coKS1hLGUuX3Bvc3RJbkZsaWdodD0hMX0pKX19LFVlLnByb3RvdHlwZS5fZ2V0TmV4dEJlYWNvblRpbWU9ZnVuY3Rpb24oKXtpZighdGhpcy5fZmFpbHVyZUNvdW50KXJldHVybiB0aGlzLl9vcHRpb25zLmJhc2VUaW1lQmV0d2VlbkJlYWNvbnM7dmFyIGU9TWF0aC5wb3coMix0aGlzLl9mYWlsdXJlQ291bnQtMSk7cmV0dXJuKDErKGUqPU1hdGgucmFuZG9tKCkpKSp0aGlzLl9vcHRpb25zLmJhc2VUaW1lQmV0d2VlbkJlYWNvbnN9LFVlLnByb3RvdHlwZS5fc3RhcnRCZWFjb25TZW5kaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztuKCkuY2xlYXJUaW1lb3V0KHRoaXMuX3NlbmRUaW1lb3V0KSx0aGlzLmRlc3Ryb3llZHx8KHRoaXMuX3NlbmRUaW1lb3V0PW4oKS5zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UuX2V2ZW50UXVldWUubGVuZ3RoJiZlLl9zZW5kQmVhY29uUXVldWUoKSxlLl9zdGFydEJlYWNvblNlbmRpbmcoKX0pLHRoaXMuX2dldE5leHRCZWFjb25UaW1lKCkpKX0sVWUucHJvdG90eXBlLl9jcmVhdGVQYXlsb2FkPWZ1bmN0aW9uKGUpe3ZhciB0LHIsYSxuPXRoaXMsaT17dHJhbnNtaXNzaW9uX3RpbWVzdGFtcDpNYXRoLnJvdW5kKF8ubm93KCkpfTt0aGlzLl9yb3VuZFRyaXBUaW1lJiYoaS5ydHRfbXM9TWF0aC5yb3VuZCh0aGlzLl9yb3VuZFRyaXBUaW1lKSk7dmFyIG89ZnVuY3Rpb24oKXt0PUpTT04uc3RyaW5naWZ5KHttZXRhZGF0YTppLGV2ZW50czpyfHxlfSksYT10Lmxlbmd0aC8xMDI0fSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGE8PW4uX29wdGlvbnMubWF4UGF5bG9hZEtCU2l6ZX07cmV0dXJuIG8oKSxzKCl8fChmLmluZm8oXCJQYXlsb2FkIHNpemUgaXMgdG9vIGJpZyAoXCIrYStcIiBrYikuIFJlbW92aW5nIHVubmVjZXNzYXJ5IGV2ZW50cy5cIikscj1lLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT1NZS5pbmRleE9mKGUuZSl9KSksbygpKSxzKCl8fChmLmluZm8oXCJQYXlsb2FkIHNpemUgc3RpbGwgdG9vIGJpZyAoXCIrYStcIiBrYikuIENyb3BwaW5nIGZpZWxkcy4uXCIpLHIuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIGUpe3ZhciByPWVbdF07XCJzdHJpbmdcIj09dHlwZW9mIHImJnIubGVuZ3RoPjUxMjAwJiYoZVt0XT1yLnN1YnN0cmluZygwLDUxMjAwKSl9fSkpLG8oKSksdH07dmFyIEZlPWZ1bmN0aW9uKGUpe3JldHVybiBlLmxlbmd0aDw9NTczNDR9LEdlPWZ1bmN0aW9uKGUsdCxyLGEpe2lmKHImJm5hdmlnYXRvciYmbmF2aWdhdG9yLnNlbmRCZWFjb24mJm5hdmlnYXRvci5zZW5kQmVhY29uKGUsdCkpYSgpO2Vsc2UgaWYobigpLmZldGNoKW4oKS5mZXRjaChlLHttZXRob2Q6XCJQT1NUXCIsYm9keTp0LGhlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6XCJ0ZXh0L3BsYWluXCJ9LGtlZXBhbGl2ZTpGZSh0KX0pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBhKG51bGwsZS5vaz9udWxsOlwiRXJyb3JcIil9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3JldHVybiBhKG51bGwsZSl9KSk7ZWxzZXtpZihuKCkuWE1MSHR0cFJlcXVlc3Qpe3ZhciBpPW5ldyhuKCkuWE1MSHR0cFJlcXVlc3QpO3JldHVybiBpLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQ9PT1pLnJlYWR5U3RhdGUpcmV0dXJuIGEobnVsbCwyMDAhPT1pLnN0YXR1cz9cImVycm9yXCI6dm9pZCAwKX0saS5vcGVuKFwiUE9TVFwiLGUpLGkuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLFwidGV4dC9wbGFpblwiKSx2b2lkIGkuc2VuZCh0KX1hKCl9fSxXZT1VZTtmdW5jdGlvbiBRZShlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXt2YXIgcj1udWxsPT1lP251bGw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZihudWxsIT1yKXt2YXIgYSxuLGk9W10sbz0hMCxzPSExO3RyeXtmb3Iocj1yLmNhbGwoZSk7IShvPShhPXIubmV4dCgpKS5kb25lKSYmKGkucHVzaChhLnZhbHVlKSwhdHx8aS5sZW5ndGghPT10KTtvPSEwKTt9Y2F0Y2goZSl7cz0hMCxuPWV9ZmluYWxseXt0cnl7b3x8bnVsbD09ci5yZXR1cm58fHIucmV0dXJuKCl9ZmluYWxseXtpZihzKXRocm93IG59fXJldHVybiBpfX0oZSx0KXx8ZnVuY3Rpb24oZSx0KXtpZihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gVmUoZSx0KTt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PXImJmUuY29uc3RydWN0b3ImJihyPWUuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PXJ8fFwiU2V0XCI9PT1yP0FycmF5LmZyb20oZSk6XCJBcmd1bWVudHNcIj09PXJ8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHIpP1ZlKGUsdCk6dm9pZCAwfX0oZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIFZlKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciByPTAsYT1uZXcgQXJyYXkodCk7cjx0O3IrKylhW3JdPWVbcl07cmV0dXJuIGF9ZnVuY3Rpb24gSmUoZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihhPWEuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLGEpfXJldHVybiByfWZ1bmN0aW9uIEtlKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP0plKE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7JGUoZSx0LHJbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOkplKE9iamVjdChyKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsdCkpfSkpfXJldHVybiBlfWZ1bmN0aW9uIHplKGUpe3JldHVybiB6ZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSx6ZShlKX1mdW5jdGlvbiBZZShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gWGUoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fWZ1bmN0aW9uICRlKGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX12YXIgWmU9W1wiZW52X2tleVwiLFwidmlld19pZFwiLFwidmlld19zZXF1ZW5jZV9udW1iZXJcIixcInBsYXllcl9zZXF1ZW5jZV9udW1iZXJcIixcImJlYWNvbl9kb21haW5cIixcInBsYXllcl9wbGF5aGVhZF90aW1lXCIsXCJ2aWV3ZXJfdGltZVwiLFwibXV4X2FwaV92ZXJzaW9uXCIsXCJldmVudFwiLFwidmlkZW9faWRcIixcInBsYXllcl9pbnN0YW5jZV9pZFwiXSxldD1bXCJhZHBsYXlcIixcImFkcGxheWluZ1wiLFwiYWRwYXVzZVwiLFwiYWRmaXJzdHF1YXJ0aWxlXCIsXCJhZG1pZHBvaW50XCIsXCJhZHRoaXJkcXVhcnRpbGVcIixcImFkZW5kZWRcIixcImFkcmVzcG9uc2VcIixcImFkcmVxdWVzdFwiXSx0dD1bXCJhZF9pZFwiLFwiYWRfY3JlYXRpdmVfaWRcIixcImFkX3VuaXZlcnNhbF9pZFwiXSxydD1bXCJ2aWV3c3RhcnRcIixcImVycm9yXCIsXCJlbmRlZFwiLFwidmlld2VuZFwiXSxhdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxyKXt2YXIgYSxpLG8scyx1LGwsZCxjLGYscCxfLGgsdixtLHksYj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e307WWUodGhpcyxlKSwkZSh0aGlzLFwicHJldmlvdXNCZWFjb25EYXRhXCIsbnVsbCksJGUodGhpcyxcImxhc3RFdmVudFRpbWVcIiwwKSwkZSh0aGlzLFwicmF0ZUxpbWl0ZWRcIiwhMSksdGhpcy5tdXg9dCx0aGlzLmVudktleT1yLHRoaXMub3B0aW9ucz1iLHRoaXMuZXZlbnRRdWV1ZT1uZXcgV2UoUGUodGhpcy5lbnZLZXksdGhpcy5vcHRpb25zKSksdGhpcy5zYW1wbGVSYXRlPW51bGwhPT0oYT10aGlzLm9wdGlvbnMuc2FtcGxlUmF0ZSkmJnZvaWQgMCE9PWE/YToxLHRoaXMuZGlzYWJsZUNvb2tpZXM9bnVsbCE9PShpPXRoaXMub3B0aW9ucy5kaXNhYmxlQ29va2llcykmJnZvaWQgMCE9PWkmJmksdGhpcy5yZXNwZWN0RG9Ob3RUcmFjaz1udWxsIT09KG89dGhpcy5vcHRpb25zLnJlc3BlY3REb05vdFRyYWNrKSYmdm9pZCAwIT09byYmbyx0aGlzLnByZXZpb3VzQmVhY29uRGF0YT1udWxsLHRoaXMubGFzdEV2ZW50VGltZT0wLHRoaXMucmF0ZUxpbWl0ZWQ9ITEsdGhpcy5wYWdlTGV2ZWxEYXRhPXttdXhfYXBpX3ZlcnNpb246dGhpcy5tdXguQVBJX1ZFUlNJT04sbXV4X2VtYmVkOnRoaXMubXV4Lk5BTUUsbXV4X2VtYmVkX3ZlcnNpb246dGhpcy5tdXguVkVSU0lPTix2aWV3ZXJfYXBwbGljYXRpb25fbmFtZTpudWxsPT09KHM9dGhpcy5vcHRpb25zLnBsYXRmb3JtKXx8dm9pZCAwPT09cz92b2lkIDA6cy5uYW1lLHZpZXdlcl9hcHBsaWNhdGlvbl92ZXJzaW9uOm51bGw9PT0odT10aGlzLm9wdGlvbnMucGxhdGZvcm0pfHx2b2lkIDA9PT11P3ZvaWQgMDp1LnZlcnNpb24sdmlld2VyX2FwcGxpY2F0aW9uX2VuZ2luZTpudWxsPT09KGw9dGhpcy5vcHRpb25zLnBsYXRmb3JtKXx8dm9pZCAwPT09bD92b2lkIDA6bC5sYXlvdXQsdmlld2VyX2RldmljZV9uYW1lOm51bGw9PT0oZD10aGlzLm9wdGlvbnMucGxhdGZvcm0pfHx2b2lkIDA9PT1kP3ZvaWQgMDpkLnByb2R1Y3Qsdmlld2VyX2RldmljZV9jYXRlZ29yeTpcIlwiLHZpZXdlcl9kZXZpY2VfbWFudWZhY3R1cmVyOm51bGw9PT0oYz10aGlzLm9wdGlvbnMucGxhdGZvcm0pfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLm1hbnVmYWN0dXJlcix2aWV3ZXJfb3NfZmFtaWx5Om51bGw9PT0oZj10aGlzLm9wdGlvbnMucGxhdGZvcm0pfHx2b2lkIDA9PT1mfHxudWxsPT09KHA9Zi5vcyl8fHZvaWQgMD09PXA/dm9pZCAwOnAuZmFtaWx5LHZpZXdlcl9vc19hcmNoaXRlY3R1cmU6bnVsbD09PShfPXRoaXMub3B0aW9ucy5wbGF0Zm9ybSl8fHZvaWQgMD09PV98fG51bGw9PT0oaD1fLm9zKXx8dm9pZCAwPT09aD92b2lkIDA6aC5hcmNoaXRlY3R1cmUsdmlld2VyX29zX3ZlcnNpb246bnVsbD09PSh2PXRoaXMub3B0aW9ucy5wbGF0Zm9ybSl8fHZvaWQgMD09PXZ8fG51bGw9PT0obT12Lm9zKXx8dm9pZCAwPT09bT92b2lkIDA6bS52ZXJzaW9uLHZpZXdlcl9jb25uZWN0aW9uX3R5cGU6SWUoKSxwYWdlX3VybDpudWxsPT09bigpfHx2b2lkIDA9PT1uKCl8fG51bGw9PT0oeT1uKCkubG9jYXRpb24pfHx2b2lkIDA9PT15P3ZvaWQgMDp5LmhyZWZ9LHRoaXMudmlld2VyRGF0YT10aGlzLmRpc2FibGVDb29raWVzP3t9OnFlKCl9dmFyIHQscixhO3JldHVybiB0PWUsKHI9W3trZXk6XCJzZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcjtpZihlJiZudWxsIT10JiZ0LnZpZXdfaWQpe2lmKHRoaXMucmVzcGVjdERvTm90VHJhY2smJnAoKSlyZXR1cm4gZi5pbmZvKFwiTm90IHNlbmRpbmcgYFwiK2UrXCJgIGJlY2F1c2UgRG8gTm90IFRyYWNrIGlzIGVuYWJsZWRcIik7aWYoIXR8fFwib2JqZWN0XCIhPT16ZSh0KSlyZXR1cm4gZi5lcnJvcihcIkEgZGF0YSBvYmplY3Qgd2FzIGV4cGVjdGVkIGluIHNlbmQoKSBidXQgd2FzIG5vdCBwcm92aWRlZFwiKTt2YXIgYSxuLG89dGhpcy5kaXNhYmxlQ29va2llcz97fTooYT14ZSgpLG49Xy5ub3coKSxhLnNlc3Npb25fc3RhcnQmJihhLnNzdD1hLnNlc3Npb25fc3RhcnQsZGVsZXRlIGEuc2Vzc2lvbl9zdGFydCksYS5zZXNzaW9uX2lkJiYoYS5zaWQ9YS5zZXNzaW9uX2lkLGRlbGV0ZSBhLnNlc3Npb25faWQpLGEuc2Vzc2lvbl9leHBpcmVzJiYoYS5zZXg9YS5zZXNzaW9uX2V4cGlyZXMsZGVsZXRlIGEuc2Vzc2lvbl9leHBpcmVzKSwoIWEuc2V4fHxhLnNleDxuKSYmKGEuc2lkPWkoKSxhLnNzdD1uKSxhLnNleD1uKzE1ZTUsU2UoYSkse3Nlc3Npb25faWQ6YS5zaWQsc2Vzc2lvbl9zdGFydDphLnNzdCxzZXNzaW9uX2V4cGlyZXM6YS5zZXh9KSxzPUtlKEtlKEtlKEtlKEtlKHt9LHRoaXMucGFnZUxldmVsRGF0YSksdCksbyksdGhpcy52aWV3ZXJEYXRhKSx7fSx7ZXZlbnQ6ZSxlbnZfa2V5OnRoaXMuZW52S2V5fSk7cy51c2VyX2lkJiYocy52aWV3ZXJfdXNlcl9pZD1zLnVzZXJfaWQsZGVsZXRlIHMudXNlcl9pZCk7dmFyIHU9KG51bGwhPT0ocj1zLm11eF9zYW1wbGVfbnVtYmVyKSYmdm9pZCAwIT09cj9yOjApPj10aGlzLnNhbXBsZVJhdGUsbD1OZSh0aGlzLl9kZWR1cGxpY2F0ZUJlYWNvbkRhdGEoZSxzKSk7aWYodGhpcy5sYXN0RXZlbnRUaW1lPXRoaXMubXV4LnV0aWxzLm5vdygpLHUpcmV0dXJuIGYuaW5mbyhcIk5vdCBzZW5kaW5nIGV2ZW50IGR1ZSB0byBzYW1wbGUgcmF0ZSByZXN0cmljdGlvblwiLGUscyxsKTtpZih0aGlzLmVudktleXx8Zi5pbmZvKFwiTWlzc2luZyBlbnZpcm9ubWVudCBrZXkgKGVudktleSkgLSBiZWFjb25zIHdpbGwgYmUgZHJvcHBlZCBpZiB0aGUgdmlkZW8gc291cmNlIGlzIG5vdCBhIHZhbGlkIG11eCB2aWRlbyBVUkxcIixlLHMsbCksIXRoaXMucmF0ZUxpbWl0ZWQpaWYoZi5pbmZvKFwiU2VuZGluZyBldmVudFwiLGUscyxsKSx0aGlzLnJhdGVMaW1pdGVkPSF0aGlzLmV2ZW50UXVldWUucXVldWVFdmVudChlLGwpLHRoaXMubXV4LldJTkRPV19VTkxPQURJTkcmJlwidmlld2VuZFwiPT09ZSl0aGlzLmV2ZW50UXVldWUuZGVzdHJveSghMCk7ZWxzZSBpZih0aGlzLm11eC5XSU5ET1dfSElEREVOJiZcImhiXCI9PT1lP3RoaXMuZXZlbnRRdWV1ZS5mbHVzaEV2ZW50cyghMCk6cnQuaW5kZXhPZihlKT49MCYmdGhpcy5ldmVudFF1ZXVlLmZsdXNoRXZlbnRzKCksdGhpcy5yYXRlTGltaXRlZClyZXR1cm4gcy5ldmVudD1cImV2ZW50cmF0ZWV4Y2VlZGVkXCIsbD1OZShzKSx0aGlzLmV2ZW50UXVldWUucXVldWVFdmVudChzLmV2ZW50LGwpLGYuZXJyb3IoXCJCZWFjb25pbmcgZGlzYWJsZWQgZHVlIHRvIHJhdGUgbGltaXQuXCIpfX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmV2ZW50UXVldWUuZGVzdHJveSghMSl9fSx7a2V5OlwiX2RlZHVwbGljYXRlQmVhY29uRGF0YVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcyxhPXt9LG49dC52aWV3X2lkO2lmKFwiLTFcIj09PW58fFwidmlld3N0YXJ0XCI9PT1lfHxcInZpZXdlbmRcIj09PWV8fCF0aGlzLnByZXZpb3VzQmVhY29uRGF0YXx8dGhpcy5tdXgudXRpbHMubm93KCktdGhpcy5sYXN0RXZlbnRUaW1lPj02ZTUpYT1LZSh7fSx0KSxuJiYodGhpcy5wcmV2aW91c0JlYWNvbkRhdGE9YSksbiYmXCJ2aWV3ZW5kXCI9PT1lJiYodGhpcy5wcmV2aW91c0JlYWNvbkRhdGE9bnVsbCk7ZWxzZXt2YXIgaT0wPT09ZS5pbmRleE9mKFwicmVxdWVzdFwiKTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1RZSh0LDIpLG89blswXSxzPW5bMV07ci5wcmV2aW91c0JlYWNvbkRhdGEmJihzIT09ci5wcmV2aW91c0JlYWNvbkRhdGFbb118fFplLmluZGV4T2Yobyk+LTF8fHIub2JqZWN0SGFzQ2hhbmdlZChpLG8scyxyLnByZXZpb3VzQmVhY29uRGF0YVtvXSl8fHIuZXZlbnRSZXF1aXJlc0tleShlLG8pKSYmKGFbb109cyxyLnByZXZpb3VzQmVhY29uRGF0YVtvXT1zKX0pKX1yZXR1cm4gYX19LHtrZXk6XCJvYmplY3RIYXNDaGFuZ2VkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsYSl7cmV0dXJuISghZXx8MCE9PXQuaW5kZXhPZihcInJlcXVlc3RfXCIpfHxcInJlcXVlc3RfcmVzcG9uc2VfaGVhZGVyc1wiIT09dCYmXCJvYmplY3RcIj09PXplKHIpJiZcIm9iamVjdFwiPT09emUoYSkmJk9iamVjdC5rZXlzKHJ8fHt9KS5sZW5ndGg9PT1PYmplY3Qua2V5cyhhfHx7fSkubGVuZ3RoKX19LHtrZXk6XCJldmVudFJlcXVpcmVzS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInJlbmRpdGlvbmNoYW5nZVwiPT09ZSYmMD09PXQuaW5kZXhPZihcInZpZGVvX3NvdXJjZV9cIil8fCEoIXR0LmluY2x1ZGVzKHQpfHwhZXQuaW5jbHVkZXMoZSkpfX1dKSYmWGUodC5wcm90b3R5cGUsciksYSYmWGUodCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9KCk7ZnVuY3Rpb24gbnQoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fWZ1bmN0aW9uIGl0KGUsdCxyKXtyZXR1cm4gdCYmbnQoZS5wcm90b3R5cGUsdCksciYmbnQoZSxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9dmFyIG90PWl0KChmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSk7dmFyIHI9MCxhPTAsbj0wLGk9MCxvPTAscz0wLHU9MDt0Lm9uKFwicmVxdWVzdGNvbXBsZXRlZFwiLChmdW5jdGlvbihlLHMpe3ZhciB1LGwsZD1zLnJlcXVlc3Rfc3RhcnQsYz1zLnJlcXVlc3RfcmVzcG9uc2Vfc3RhcnQsZj1zLnJlcXVlc3RfcmVzcG9uc2VfZW5kLHA9cy5yZXF1ZXN0X2J5dGVzX2xvYWRlZDtpZihpKyssYz8odT1jLShudWxsIT1kP2Q6MCksbD0obnVsbCE9Zj9mOjApLWMpOmw9KG51bGwhPWY/ZjowKS0obnVsbCE9ZD9kOjApLGw+MCYmcCYmcD4wKXt2YXIgXz1wL2wqOGUzO28rKyxhKz1wLG4rPWwsdC5kYXRhLnZpZXdfbWluX3JlcXVlc3RfdGhyb3VnaHB1dD1NYXRoLm1pbih0LmRhdGEudmlld19taW5fcmVxdWVzdF90aHJvdWdocHV0fHwxLzAsXyksdC5kYXRhLnZpZXdfYXZlcmFnZV9yZXF1ZXN0X3Rocm91Z2hwdXQ9YS9uKjhlMyx0LmRhdGEudmlld19yZXF1ZXN0X2NvdW50PWksdT4wJiYocis9dSx0LmRhdGEudmlld19tYXhfcmVxdWVzdF9sYXRlbmN5PU1hdGgubWF4KHQuZGF0YS52aWV3X21heF9yZXF1ZXN0X2xhdGVuY3l8fDAsdSksdC5kYXRhLnZpZXdfYXZlcmFnZV9yZXF1ZXN0X2xhdGVuY3k9ci9vKX19KSksdC5vbihcInJlcXVlc3RmYWlsZWRcIiwoZnVuY3Rpb24oZSxyKXtpKysscysrLHQuZGF0YS52aWV3X3JlcXVlc3RfY291bnQ9aSx0LmRhdGEudmlld19yZXF1ZXN0X2ZhaWxlZF9jb3VudD1zfSkpLHQub24oXCJyZXF1ZXN0Y2FuY2VsZWRcIiwoZnVuY3Rpb24oZSxyKXtpKyssdSsrLHQuZGF0YS52aWV3X3JlcXVlc3RfY291bnQ9aSx0LmRhdGEudmlld19yZXF1ZXN0X2NhbmNlbGVkX2NvdW50PXV9KSl9KSk7ZnVuY3Rpb24gc3QoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYS5rZXksYSl9fWZ1bmN0aW9uIHV0KGUsdCxyKXtyZXR1cm4gdCYmc3QoZS5wcm90b3R5cGUsdCksciYmc3QoZSxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGV9dmFyIGx0PXV0KChmdW5jdGlvbiBlKHQpe3ZhciByPXRoaXM7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0Lm9uKFwiYmVmb3JlKlwiLChmdW5jdGlvbihlLGEpe3ZhciBuPWEudmlld2VyX3RpbWUsaT1fLm5vdygpLG89ci5fbGFzdEV2ZW50VGltZTtpZihyLl9sYXN0RXZlbnRUaW1lPWksbyYmaS1vPjM2ZTUpe3ZhciBzPU9iamVjdC5rZXlzKHQuZGF0YSkucmVkdWNlKChmdW5jdGlvbihlLHIpe3JldHVybiAwPT09ci5pbmRleE9mKFwidmlkZW9fXCIpP09iamVjdC5hc3NpZ24oZSxmdW5jdGlvbihlLHQscil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1yLGV9KHt9LHIsdC5kYXRhW3JdKSk6ZX0pLHt9KTt0Lm11eC5sb2cuaW5mbyhcIlJlY2VpdmVkIGV2ZW50IGFmdGVyIGF0IGxlYXN0IGFuIGhvdXIgaW5hY3Rpdml0eSwgY3JlYXRpbmcgYSBuZXcgdmlld1wiKSx0LmVtaXQoXCJ2aWV3aW5pdFwiLE9iamVjdC5hc3NpZ24oe3ZpZXdlcl90aW1lOm59LHMpKSx0LnBsYXliYWNrSGVhcnRiZWF0Ll9wbGF5aGVhZFNob3VsZEJlUHJvZ3Jlc3NpbmcmJlwicGxheVwiIT09ZS50eXBlJiZcImFkYnJlYWtzdGFydFwiIT09ZS50eXBlJiYodC5lbWl0KFwicGxheVwiLHt2aWV3ZXJfdGltZTpufSksXCJwbGF5aW5nXCIhPT1lLnR5cGUmJnQuZW1pdChcInBsYXlpbmdcIix7dmlld2VyX3RpbWU6bn0pKX19KSl9KSk7ZnVuY3Rpb24gZHQoZSl7cmV0dXJuIGR0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LGR0KGUpfWZ1bmN0aW9uIGN0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe3ZhciByPW51bGw9PWU/bnVsbDpcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZlW1N5bWJvbC5pdGVyYXRvcl18fGVbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGwhPXIpe3ZhciBhLG4saT1bXSxvPSEwLHM9ITE7dHJ5e2ZvcihyPXIuY2FsbChlKTshKG89KGE9ci5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKGEudmFsdWUpLCF0fHxpLmxlbmd0aCE9PXQpO289ITApO31jYXRjaChlKXtzPSEwLG49ZX1maW5hbGx5e3RyeXtvfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHMpdGhyb3cgbn19cmV0dXJuIGl9fShlLHQpfHxmdW5jdGlvbihlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBmdChlLHQpO3ZhciByPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09ciYmZS5jb25zdHJ1Y3RvciYmKHI9ZS5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09cnx8XCJTZXRcIj09PXI/QXJyYXkuZnJvbShlKTpcIkFyZ3VtZW50c1wiPT09cnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qocik/ZnQoZSx0KTp2b2lkIDB9fShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gZnQoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIHI9MCxhPW5ldyBBcnJheSh0KTtyPHQ7cisrKWFbcl09ZVtyXTtyZXR1cm4gYX1mdW5jdGlvbiBwdChlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgYT10W3JdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLmtleSxhKX19ZnVuY3Rpb24gX3QoZSx0KXtyZXR1cm4gX3Q9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSxfdChlLHQpfWZ1bmN0aW9uIGh0KGUpe3ZhciB0PWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsYT15dChlKTtpZih0KXt2YXIgbj15dCh0aGlzKS5jb25zdHJ1Y3RvcjtyPVJlZmxlY3QuY29uc3RydWN0KGEsYXJndW1lbnRzLG4pfWVsc2Ugcj1hLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gdnQodGhpcyxyKX19ZnVuY3Rpb24gdnQoZSx0KXtpZih0JiYoXCJvYmplY3RcIj09PWR0KHQpfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KSlyZXR1cm4gdDtpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtyZXR1cm4gbXQoZSl9ZnVuY3Rpb24gbXQoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24geXQoZSl7cmV0dXJuIHl0PU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSx5dChlKX12YXIgYnQ9W1widmlld3N0YXJ0XCIsXCJlbmRlZFwiLFwibG9hZHN0YXJ0XCIsXCJwYXVzZVwiLFwicGxheVwiLFwicGxheWluZ1wiLFwicmF0ZWNoYW5nZVwiLFwid2FpdGluZ1wiLFwiYWRwbGF5XCIsXCJhZHBhdXNlXCIsXCJhZGVuZGVkXCIsXCJhZGVycm9yXCIsXCJhZHBsYXlpbmdcIixcImFkcmVxdWVzdFwiLFwiYWRyZXNwb25zZVwiLFwiYWRicmVha3N0YXJ0XCIsXCJhZGJyZWFrZW5kXCIsXCJhZGZpcnN0cXVhcnRpbGVcIixcImFkbWlkcG9pbnRcIixcImFkdGhpcmRxdWFydGlsZVwiLFwicmVidWZmZXJzdGFydFwiLFwicmVidWZmZXJlbmRcIixcInNlZWtlZFwiLFwiZXJyb3JcIixcImhiXCIsXCJyZXF1ZXN0Y29tcGxldGVkXCIsXCJyZXF1ZXN0ZmFpbGVkXCIsXCJyZXF1ZXN0Y2FuY2VsZWRcIixcInJlbmRpdGlvbmNoYW5nZVwiXSxndD1mdW5jdGlvbihlKXshZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksdCYmX3QoZSx0KX0obyxlKTt2YXIgdCxyLGEsbj1odChvKTtmdW5jdGlvbiBvKGUsdCxyKXt2YXIgYTshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLG8pLChhPW4uY2FsbCh0aGlzKSkuRE9NX0NPTlRFTlRfTE9BREVEX0VWRU5UX0VORD1tLmRvbUNvbnRlbnRMb2FkZWRFdmVudEVuZCgpLGEuTkFWSUdBVElPTl9TVEFSVD1tLm5hdmlnYXRpb25TdGFydCgpLGEubXV4PWUsYS5pZD10LChyPU9iamVjdC5hc3NpZ24oe2RlYnVnOiExLG1pbmltdW1SZWJ1ZmZlckR1cmF0aW9uOjI1MCxzdXN0YWluZWRSZWJ1ZmZlclRocmVzaG9sZDoxZTMscGxheWJhY2tIZWFydGJlYXRUaW1lOjI1LGJlYWNvbkRvbWFpbjpcImxpdGl4LmlvXCIsc2FtcGxlUmF0ZToxLGRpc2FibGVDb29raWVzOiExLHJlc3BlY3REb05vdFRyYWNrOiExLGRpc2FibGVSZWJ1ZmZlclRyYWNraW5nOiExLGRpc2FibGVQbGF5aGVhZFJlYnVmZmVyVHJhY2tpbmc6ITEsZXJyb3JUcmFuc2xhdG9yOmZ1bmN0aW9uKGUpe3JldHVybiBlfX0scikpLmRhdGE9ci5kYXRhfHx7fSxyLmRhdGEucHJvcGVydHlfa2V5JiYoci5kYXRhLmVudl9rZXk9ci5kYXRhLnByb3BlcnR5X2tleSxkZWxldGUgci5kYXRhLnByb3BlcnR5X2tleSksZi5zZXRMZXZlbChyLmRlYnVnP1wiZGVidWdcIjpcIndhcm5cIiksYS5nZXRQbGF5aGVhZFRpbWU9ci5nZXRQbGF5aGVhZFRpbWUsYS5nZXRTdGF0ZURhdGE9ci5nZXRTdGF0ZURhdGF8fGZ1bmN0aW9uKCl7cmV0dXJue319LGEuZ2V0QWREYXRhPXIuZ2V0QWREYXRhfHxmdW5jdGlvbigpe30sYS5taW5pbXVtUmVidWZmZXJEdXJhdGlvbj1yLm1pbmltdW1SZWJ1ZmZlckR1cmF0aW9uLGEuc3VzdGFpbmVkUmVidWZmZXJUaHJlc2hvbGQ9ci5zdXN0YWluZWRSZWJ1ZmZlclRocmVzaG9sZCxhLnBsYXliYWNrSGVhcnRiZWF0VGltZT1yLnBsYXliYWNrSGVhcnRiZWF0VGltZSxhLmRpc2FibGVSZWJ1ZmZlclRyYWNraW5nPXIuZGlzYWJsZVJlYnVmZmVyVHJhY2tpbmcsYS5kaXNhYmxlUmVidWZmZXJUcmFja2luZyYmYS5tdXgubG9nLndhcm4oXCJEaXNhYmxpbmcgcmVidWZmZXIgdHJhY2tpbmcuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBzcGVjaWZpYyBjaXJjdW1zdGFuY2VzIGFzIGEgbGFzdCByZXNvcnQgd2hlbiB5b3VyIHBsYXllciBpcyBrbm93biB0byB1bnJlbGlhYmx5IHRyYWNrIHJlYnVmZmVyaW5nLlwiKSxhLmRpc2FibGVQbGF5aGVhZFJlYnVmZmVyVHJhY2tpbmc9ci5kaXNhYmxlUGxheWhlYWRSZWJ1ZmZlclRyYWNraW5nLGEuZXJyb3JUcmFuc2xhdG9yPXIuZXJyb3JUcmFuc2xhdG9yLGEucGxheWJhY2tFdmVudERpc3BhdGNoZXI9bmV3IGF0KGUsci5kYXRhLmVudl9rZXksciksYS5kYXRhPXtwbGF5ZXJfaW5zdGFuY2VfaWQ6aSgpLG11eF9zYW1wbGVfcmF0ZTpyLnNhbXBsZVJhdGUsYmVhY29uX2RvbWFpbjpyLmJlYWNvbkNvbGxlY3Rpb25Eb21haW4/ci5iZWFjb25Db2xsZWN0aW9uRG9tYWluOnIuYmVhY29uRG9tYWlufSxhLmRhdGEudmlld19zZXF1ZW5jZV9udW1iZXI9MSxhLmRhdGEucGxheWVyX3NlcXVlbmNlX251bWJlcj0xLGEub2xkRW1pdD1hLmVtaXQsYS5lbWl0PWZ1bmN0aW9uKGUsdCl7dD1PYmplY3QuYXNzaWduKHt2aWV3ZXJfdGltZTp0aGlzLm11eC51dGlscy5ub3coKX0sdCksdGhpcy5vbGRFbWl0KGUsdCl9O3ZhciBzPWZ1bmN0aW9uKCl7dm9pZCAwPT09dGhpcy5kYXRhLnZpZXdfc3RhcnQmJih0aGlzLmRhdGEudmlld19zdGFydD10aGlzLm11eC51dGlscy5ub3coKSx0aGlzLmVtaXQoXCJ2aWV3c3RhcnRcIikpfS5iaW5kKG10KGEpKTthLm9uKFwidmlld2luaXRcIiwoZnVuY3Rpb24oZSx0KXt0aGlzLl9yZXNldFZpZGVvRGF0YSgpLHRoaXMuX3Jlc2V0Vmlld0RhdGEoKSx0aGlzLl9yZXNldEVycm9yRGF0YSgpLHRoaXMuX3VwZGF0ZVN0YXRlRGF0YSgpLE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLHQpLHRoaXMuX2luaXRpYWxpemVWaWV3RGF0YSgpLHRoaXMub25lKFwicGxheVwiLHMpLHRoaXMub25lKFwiYWRicmVha3N0YXJ0XCIscyl9KSk7dmFyIHU9ZnVuY3Rpb24oZSl7dGhpcy5lbWl0KFwidmlld2VuZFwiKSx0aGlzLnNlbmQoXCJ2aWV3ZW5kXCIpLHRoaXMuZW1pdChcInZpZXdpbml0XCIsZSl9LmJpbmQobXQoYSkpO2lmKGEub24oXCJ2aWRlb2NoYW5nZVwiLChmdW5jdGlvbihlLHQpe3UodCl9KSksYS5vbihcInByb2dyYW1jaGFuZ2VcIiwoZnVuY3Rpb24oZSx0KXt0aGlzLmRhdGEucGxheWVyX2lzX3BhdXNlZCYmdGhpcy5tdXgubG9nLndhcm4oXCJUaGUgYHByb2dyYW1jaGFuZ2VgIGV2ZW50IGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2hlbiB0aGUgY29udGVudCBjaGFuZ2VzIG1pZCBwbGF5YmFjayB3aXRob3V0IHRoZSB2aWRlbyBzb3VyY2UgY2hhbmdpbmcsIGhvd2V2ZXIgdGhlIHZpZGVvIGlzIG5vdCBjdXJyZW50bHkgcGxheWluZy4gSWYgdGhlIHZpZGVvIHNvdXJjZSBpcyBjaGFuZ2luZyBwbGVhc2UgdXNlIHRoZSB2aWRlb2NoYW5nZSBldmVudCBvdGhlcndpc2UgeW91IHdpbGwgbG9zZSBzdGFydHVwIHRpbWUgaW5mb3JtYXRpb24uXCIpLHUoT2JqZWN0LmFzc2lnbih0LHt2aWV3X3Byb2dyYW1fY2hhbmdlZDohMH0pKSxzKCksdGhpcy5lbWl0KFwicGxheVwiKSx0aGlzLmVtaXQoXCJwbGF5aW5nXCIpfSkpLGEub24oXCJmcmFnbWVudGNoYW5nZVwiLChmdW5jdGlvbihlLHQpe3RoaXMuY3VycmVudEZyYWdtZW50UERUPXQuY3VycmVudEZyYWdtZW50UERULHRoaXMuY3VycmVudEZyYWdtZW50U3RhcnQ9dC5jdXJyZW50RnJhZ21lbnRTdGFydH0pKSxhLm9uKFwiZGVzdHJveVwiLGEuZGVzdHJveSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKXt2YXIgbD1mdW5jdGlvbigpe3ZhciBlPXZvaWQgMCE9PWEuZGF0YS52aWV3X3N0YXJ0O2EubXV4LldJTkRPV19ISURERU49XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSxlJiZhLm11eC5XSU5ET1dfSElEREVOJiYoYS5kYXRhLnBsYXllcl9pc19wYXVzZWR8fGEuZW1pdChcImhiXCIpKX07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsbCwhMSk7dmFyIGQ9ZnVuY3Rpb24oZSl7ZS5wZXJzaXN0ZWR8fGEuZGVzdHJveSgpfTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsZCwhMSksYS5vbihcImRlc3Ryb3lcIiwoZnVuY3Rpb24oKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixsKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsZCl9KSl9cmV0dXJuIGEub24oXCJwbGF5ZXJyZWFkeVwiLChmdW5jdGlvbihlLHQpe09iamVjdC5hc3NpZ24odGhpcy5kYXRhLHQpfSkpLGJ0LmZvckVhY2goKGZ1bmN0aW9uKGUpe2Eub24oZSwoZnVuY3Rpb24odCxyKXswIT09ZS5pbmRleE9mKFwiYWRcIikmJnRoaXMuX3VwZGF0ZVN0YXRlRGF0YSgpLE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLHIpLHRoaXMuX3Nhbml0aXplRGF0YSgpfSkpLGEub24oXCJhZnRlclwiK2UsKGZ1bmN0aW9uKCl7KFwiZXJyb3JcIiE9PWV8fHRoaXMuZXJyb3JUcmFja2VyLnZpZXdFcnJvcmVkKSYmdGhpcy5zZW5kKGUpfSkpfSkpLGEub24oXCJ2aWV3ZW5kXCIsKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmFzc2lnbihhLmRhdGEsdCl9KSksYS5vbmUoXCJwbGF5ZXJyZWFkeVwiLChmdW5jdGlvbihlKXt2YXIgdD10aGlzLm11eC51dGlscy5ub3coKTt0aGlzLmRhdGEucGxheWVyX2luaXRfdGltZSYmKHRoaXMuZGF0YS5wbGF5ZXJfc3RhcnR1cF90aW1lPXQtdGhpcy5kYXRhLnBsYXllcl9pbml0X3RpbWUpLCF0aGlzLm11eC5QTEFZRVJfVFJBQ0tFRCYmdGhpcy5OQVZJR0FUSU9OX1NUQVJUJiYodGhpcy5tdXguUExBWUVSX1RSQUNLRUQ9ITAsKHRoaXMuZGF0YS5wbGF5ZXJfaW5pdF90aW1lfHx0aGlzLkRPTV9DT05URU5UX0xPQURFRF9FVkVOVF9FTkQpJiYodGhpcy5kYXRhLnBhZ2VfbG9hZF90aW1lPU1hdGgubWluKHRoaXMuZGF0YS5wbGF5ZXJfaW5pdF90aW1lfHwxLzAsdGhpcy5ET01fQ09OVEVOVF9MT0FERURfRVZFTlRfRU5EfHwxLzApLXRoaXMuTkFWSUdBVElPTl9TVEFSVCkpLHRoaXMuc2VuZChcInBsYXllcnJlYWR5XCIpLGRlbGV0ZSB0aGlzLmRhdGEucGxheWVyX3N0YXJ0dXBfdGltZSxkZWxldGUgdGhpcy5kYXRhLnBhZ2VfbG9hZF90aW1lfSkpLGEubG9uZ1Jlc3VtZVRyYWNrZXI9bmV3IGx0KG10KGEpKSxhLmVycm9yVHJhY2tlcj1uZXcgRyhtdChhKSksbmV3IFRlKG10KGEpKSxhLnNlZWtpbmdUcmFja2VyPW5ldyBkZShtdChhKSksYS5wbGF5aGVhZFRpbWU9bmV3IHoobXQoYSkpLGEucGxheWJhY2tIZWFydGJlYXQ9bmV3IEIobXQoYSkpLG5ldyBzZShtdChhKSksYS53YXRjaFRpbWVUcmFja2VyPW5ldyBRKG10KGEpKSxuZXcgSihtdChhKSksYS5hZFRyYWNrZXI9bmV3IHZlKG10KGEpKSxuZXcgcmUobXQoYSkpLG5ldyBaKG10KGEpKSxuZXcgbmUobXQoYSkpLG5ldyBiZShtdChhKSksbmV3IG90KG10KGEpKSxyLmhsc2pzJiZhLmFkZEhMU0pTKHIpLHIuZGFzaGpzJiZhLmFkZERhc2hKUyhyKSxhLmVtaXQoXCJ2aWV3aW5pdFwiLHIuZGF0YSksYX1yZXR1cm4gdD1vLHI9W3trZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9kZXN0cm95ZWR8fCh0aGlzLl9kZXN0cm95ZWQ9ITAsdm9pZCAwIT09dGhpcy5kYXRhLnZpZXdfc3RhcnQmJih0aGlzLmVtaXQoXCJ2aWV3ZW5kXCIpLHRoaXMuc2VuZChcInZpZXdlbmRcIikpLHRoaXMucGxheWJhY2tFdmVudERpc3BhdGNoZXIuZGVzdHJveSgpLHRoaXMucmVtb3ZlSExTSlMoKSx0aGlzLnJlbW92ZURhc2hKUygpLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5faGVhcnRCZWF0VGltZW91dCkpfX0se2tleTpcInNlbmRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLmRhdGEudmlld19pZCl7dmFyIHQ9T2JqZWN0LmFzc2lnbih7fSx0aGlzLmRhdGEpO2lmKHZvaWQgMD09PXQudmlkZW9fc291cmNlX2lzX2xpdmUmJih0LnBsYXllcl9zb3VyY2VfZHVyYXRpb249PT0xLzB8fHQudmlkZW9fc291cmNlX2R1cmF0aW9uPT09MS8wP3QudmlkZW9fc291cmNlX2lzX2xpdmU9ITA6KHQucGxheWVyX3NvdXJjZV9kdXJhdGlvbj4wfHx0LnZpZGVvX3NvdXJjZV9kdXJhdGlvbj4wKSYmKHQudmlkZW9fc291cmNlX2lzX2xpdmU9ITEpKSx0LnZpZGVvX3NvdXJjZV9pc19saXZlfHxbXCJwbGF5ZXJfcHJvZ3JhbV90aW1lXCIsXCJwbGF5ZXJfbWFuaWZlc3RfbmV3ZXN0X3Byb2dyYW1fdGltZVwiLFwicGxheWVyX2xpdmVfZWRnZV9wcm9ncmFtX3RpbWVcIixcInBsYXllcl9wcm9ncmFtX3RpbWVcIixcInZpZGVvX2hvbGRiYWNrXCIsXCJ2aWRlb19wYXJ0X2hvbGRiYWNrXCIsXCJ2aWRlb190YXJnZXRfZHVyYXRpb25cIixcInZpZGVvX3BhcnRfdGFyZ2V0X2R1cmF0aW9uXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV09dm9pZCAwfSkpLHQudmlkZW9fc291cmNlX3VybD10LnZpZGVvX3NvdXJjZV91cmx8fHQucGxheWVyX3NvdXJjZV91cmwsdC52aWRlb19zb3VyY2VfdXJsKXt2YXIgcj1jdCh2KHQudmlkZW9fc291cmNlX3VybCksMiksYT1yWzBdLG49clsxXTt0LnZpZGVvX3NvdXJjZV9kb21haW49bix0LnZpZGVvX3NvdXJjZV9ob3N0bmFtZT1hfWRlbGV0ZSB0LmFkX3JlcXVlc3RfaWQsdGhpcy5wbGF5YmFja0V2ZW50RGlzcGF0Y2hlci5zZW5kKGUsdCksdGhpcy5kYXRhLnZpZXdfc2VxdWVuY2VfbnVtYmVyKyssdGhpcy5kYXRhLnBsYXllcl9zZXF1ZW5jZV9udW1iZXIrKyx0aGlzLl9yZXN0YXJ0SGVhcnRCZWF0KCksXCJ2aWV3ZW5kXCI9PT1lJiZkZWxldGUgdGhpcy5kYXRhLnZpZXdfaWR9fX0se2tleTpcIl91cGRhdGVTdGF0ZURhdGFcIix2YWx1ZTpmdW5jdGlvbigpe09iamVjdC5hc3NpZ24odGhpcy5kYXRhLHRoaXMuZ2V0U3RhdGVEYXRhKCkpLHRoaXMucGxheWhlYWRUaW1lLl91cGRhdGVQbGF5aGVhZFRpbWUoKSx0aGlzLl9zYW5pdGl6ZURhdGEoKX19LHtrZXk6XCJfc2FuaXRpemVEYXRhXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO1tcInBsYXllcl93aWR0aFwiLFwicGxheWVyX2hlaWdodFwiLFwidmlkZW9fc291cmNlX3dpZHRoXCIsXCJ2aWRlb19zb3VyY2VfaGVpZ2h0XCIsXCJwbGF5ZXJfcGxheWhlYWRfdGltZVwiLFwidmlkZW9fc291cmNlX2JpdHJhdGVcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9cGFyc2VJbnQoZS5kYXRhW3RdLDEwKTtlLmRhdGFbdF09aXNOYU4ocik/dm9pZCAwOnJ9KSksW1wicGxheWVyX3NvdXJjZV91cmxcIixcInZpZGVvX3NvdXJjZV91cmxcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoZS5kYXRhW3RdKXt2YXIgcj1lLmRhdGFbdF0udG9Mb3dlckNhc2UoKTswIT09ci5pbmRleE9mKFwiZGF0YTpcIikmJjAhPT1yLmluZGV4T2YoXCJibG9iOlwiKXx8KGUuZGF0YVt0XT1cIk1TRSBzdHlsZSBVUkxcIil9fSkpfX0se2tleTpcIl9yZXNldFZpZGVvRGF0YVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goKGZ1bmN0aW9uKGUpezA9PT1lLmluZGV4T2YoXCJ2aWRlb19cIikmJmRlbGV0ZSByLmRhdGFbZV19KSl9fSx7a2V5OlwiX3Jlc2V0Vmlld0RhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7T2JqZWN0LmtleXModGhpcy5kYXRhKS5mb3JFYWNoKChmdW5jdGlvbih0KXswPT09dC5pbmRleE9mKFwidmlld19cIikmJmRlbGV0ZSBlLmRhdGFbdF19KSksdGhpcy5kYXRhLnZpZXdfc2VxdWVuY2VfbnVtYmVyPTF9fSx7a2V5OlwiX3Jlc2V0RXJyb3JEYXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtkZWxldGUgdGhpcy5kYXRhLnBsYXllcl9lcnJvcl9jb2RlLGRlbGV0ZSB0aGlzLmRhdGEucGxheWVyX2Vycm9yX21lc3NhZ2V9fSx7a2V5OlwiX2luaXRpYWxpemVWaWV3RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuZGF0YS52aWV3X2lkPWkoKSxyPWZ1bmN0aW9uKCl7dD09PWUuZGF0YS52aWV3X2lkJiZ5KGUuZGF0YSxcInBsYXllcl92aWV3X2NvdW50XCIsMSl9O3RoaXMuZGF0YS5wbGF5ZXJfaXNfcGF1c2VkP3RoaXMub25lKFwicGxheVwiLHIpOnIoKX19LHtrZXk6XCJfcmVzdGFydEhlYXJ0QmVhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2hlYXJ0QmVhdFRpbWVvdXQpLHRoaXMuZXJyb3JUcmFja2VyLnZpZXdFcnJvcmVkfHwodGhpcy5faGVhcnRCZWF0VGltZW91dD13aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLmRhdGEucGxheWVyX2lzX3BhdXNlZHx8ZS5lbWl0KFwiaGJcIil9KSwxZTQpKX19LHtrZXk6XCJhZGRITFNKU1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UuaGxzanM/dGhpcy5obHNqcz90aGlzLm11eC5sb2cud2FybihcIkFuIGluc3RhbmNlIG9mIEhMUy5qcyBpcyBhbHJlYWR5IGJlaW5nIG1vbml0b3JlZCBmb3IgdGhpcyBwbGF5ZXIuXCIpOih0aGlzLmhsc2pzPWUuaGxzanMsZnVuY3Rpb24oZSx0LHIpe3ZhciBhPWFyZ3VtZW50cy5sZW5ndGg+ND9hcmd1bWVudHNbNF06dm9pZCAwLG49ZS5sb2csaT1lLnV0aWxzLnNlY29uZHNUb01zLG89ZnVuY3Rpb24oZSl7dmFyIHQscj1wYXJzZUludChhLnZlcnNpb24pO3JldHVybiAxPT09ciYmbnVsbCE9PWUucHJvZ3JhbURhdGVUaW1lJiYodD1lLnByb2dyYW1EYXRlVGltZSksMD09PXImJm51bGwhPT1lLnBkdCYmKHQ9ZS5wZHQpLHR9O2lmKG0uZXhpc3RzKCkpe3ZhciBzPWZ1bmN0aW9uKHIsYSl7cmV0dXJuIGUuZW1pdCh0LHIsYSl9LHU9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LmxldmVscyxhPXQuYXVkaW9UcmFja3Msbj10LnVybCxpPXQuc3RhdHMsbz10Lm5ldHdvcmtEZXRhaWxzLHU9dC5zZXNzaW9uRGF0YSxsPXt9LGQ9e307ci5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2xbdF09e3dpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0LGJpdHJhdGU6ZS5iaXRyYXRlLGF0dHJzOmUuYXR0cnN9fSkpLGEuZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXtkW3RdPXtuYW1lOmUubmFtZSxsYW5ndWFnZTplLmxhbmcsYml0cmF0ZTplLmJpdHJhdGV9fSkpO3ZhciBjPXgoaSksZj1jLmJ5dGVzTG9hZGVkLHA9Yy5yZXF1ZXN0U3RhcnQsXz1jLnJlc3BvbnNlU3RhcnQsdj1jLnJlc3BvbnNlRW5kO3MoXCJyZXF1ZXN0Y29tcGxldGVkXCIsTyhPKHt9LEUodSkpLHt9LHtyZXF1ZXN0X2V2ZW50X3R5cGU6ZSxyZXF1ZXN0X2J5dGVzX2xvYWRlZDpmLHJlcXVlc3Rfc3RhcnQ6cCxyZXF1ZXN0X3Jlc3BvbnNlX3N0YXJ0Ol8scmVxdWVzdF9yZXNwb25zZV9lbmQ6dixyZXF1ZXN0X3R5cGU6XCJtYW5pZmVzdFwiLHJlcXVlc3RfaG9zdG5hbWU6aChuKSxyZXF1ZXN0X3Jlc3BvbnNlX2hlYWRlcnM6UyhvKSxyZXF1ZXN0X3JlbmRpdGlvbl9saXN0czp7bWVkaWE6bCxhdWRpbzpkLHZpZGVvOnt9fX0pKX07ci5vbihhLkV2ZW50cy5NQU5JRkVTVF9MT0FERUQsdSk7dmFyIGw9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LmRldGFpbHMsYT10LmxldmVsLG49dC5uZXR3b3JrRGV0YWlscyx1PXQuc3RhdHMsbD14KHUpLGQ9bC5ieXRlc0xvYWRlZCxjPWwucmVxdWVzdFN0YXJ0LGY9bC5yZXNwb25zZVN0YXJ0LHA9bC5yZXNwb25zZUVuZCxfPXIuZnJhZ21lbnRzW3IuZnJhZ21lbnRzLmxlbmd0aC0xXSx2PW8oXykraShfLmR1cmF0aW9uKTtzKFwicmVxdWVzdGNvbXBsZXRlZFwiLHtyZXF1ZXN0X2V2ZW50X3R5cGU6ZSxyZXF1ZXN0X2J5dGVzX2xvYWRlZDpkLHJlcXVlc3Rfc3RhcnQ6YyxyZXF1ZXN0X3Jlc3BvbnNlX3N0YXJ0OmYscmVxdWVzdF9yZXNwb25zZV9lbmQ6cCxyZXF1ZXN0X2N1cnJlbnRfbGV2ZWw6YSxyZXF1ZXN0X3R5cGU6XCJtYW5pZmVzdFwiLHJlcXVlc3RfaG9zdG5hbWU6aChyLnVybCkscmVxdWVzdF9yZXNwb25zZV9oZWFkZXJzOlMobiksdmlkZW9faG9sZGJhY2s6ci5ob2xkQmFjayYmaShyLmhvbGRCYWNrKSx2aWRlb19wYXJ0X2hvbGRiYWNrOnIucGFydEhvbGRCYWNrJiZpKHIucGFydEhvbGRCYWNrKSx2aWRlb19wYXJ0X3RhcmdldF9kdXJhdGlvbjpyLnBhcnRUYXJnZXQmJmkoci5wYXJ0VGFyZ2V0KSx2aWRlb190YXJnZXRfZHVyYXRpb246ci50YXJnZXRkdXJhdGlvbiYmaShyLnRhcmdldGR1cmF0aW9uKSx2aWRlb19zb3VyY2VfaXNfbGl2ZTpyLmxpdmUscGxheWVyX21hbmlmZXN0X25ld2VzdF9wcm9ncmFtX3RpbWU6aXNOYU4odik/dm9pZCAwOnZ9KX07ci5vbihhLkV2ZW50cy5MRVZFTF9MT0FERUQsbCk7dmFyIGQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LmRldGFpbHMsYT10Lm5ldHdvcmtEZXRhaWxzLG49dC5zdGF0cyxpPXgobiksbz1pLmJ5dGVzTG9hZGVkLHU9aS5yZXF1ZXN0U3RhcnQsbD1pLnJlc3BvbnNlU3RhcnQsZD1pLnJlc3BvbnNlRW5kO3MoXCJyZXF1ZXN0Y29tcGxldGVkXCIse3JlcXVlc3RfZXZlbnRfdHlwZTplLHJlcXVlc3RfYnl0ZXNfbG9hZGVkOm8scmVxdWVzdF9zdGFydDp1LHJlcXVlc3RfcmVzcG9uc2Vfc3RhcnQ6bCxyZXF1ZXN0X3Jlc3BvbnNlX2VuZDpkLHJlcXVlc3RfdHlwZTpcIm1hbmlmZXN0XCIscmVxdWVzdF9ob3N0bmFtZTpoKHIudXJsKSxyZXF1ZXN0X3Jlc3BvbnNlX2hlYWRlcnM6UyhhKX0pfTtyLm9uKGEuRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCxkKTt2YXIgYz1mdW5jdGlvbihlLHQpe3ZhciBhPXQuc3RhdHMsbj10Lm5ldHdvcmtEZXRhaWxzLGk9dC5mcmFnO2E9YXx8aS5zdGF0czt2YXIgbz14KGEpLHU9by5ieXRlc0xvYWRlZCxsPW8ucmVxdWVzdFN0YXJ0LGQ9by5yZXNwb25zZVN0YXJ0LGM9by5yZXNwb25zZUVuZCxmPW4/UyhuKTp2b2lkIDAscD17cmVxdWVzdF9ldmVudF90eXBlOmUscmVxdWVzdF9ieXRlc19sb2FkZWQ6dSxyZXF1ZXN0X3N0YXJ0OmwscmVxdWVzdF9yZXNwb25zZV9zdGFydDpkLHJlcXVlc3RfcmVzcG9uc2VfZW5kOmMscmVxdWVzdF9ob3N0bmFtZTpuP2gobi5yZXNwb25zZVVSTCk6dm9pZCAwLHJlcXVlc3RfaWQ6Zj9UKGYpOnZvaWQgMCxyZXF1ZXN0X3Jlc3BvbnNlX2hlYWRlcnM6ZixyZXF1ZXN0X21lZGlhX2R1cmF0aW9uOmkuZHVyYXRpb24scmVxdWVzdF91cmw6bnVsbD09bj92b2lkIDA6bi5yZXNwb25zZVVSTH07XCJtYWluXCI9PT1pLnR5cGU/KHAucmVxdWVzdF90eXBlPVwibWVkaWFcIixwLnJlcXVlc3RfY3VycmVudF9sZXZlbD1pLmxldmVsLHAucmVxdWVzdF92aWRlb193aWR0aD0oci5sZXZlbHNbaS5sZXZlbF18fHt9KS53aWR0aCxwLnJlcXVlc3RfdmlkZW9faGVpZ2h0PShyLmxldmVsc1tpLmxldmVsXXx8e30pLmhlaWdodCxwLnJlcXVlc3RfbGFiZWxlZF9iaXRyYXRlPShyLmxldmVsc1tpLmxldmVsXXx8e30pLmJpdHJhdGUpOnAucmVxdWVzdF90eXBlPWkudHlwZSxzKFwicmVxdWVzdGNvbXBsZXRlZFwiLHApfTtyLm9uKGEuRXZlbnRzLkZSQUdfTE9BREVELGMpO3ZhciBmPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5mcmFnLGE9ci5zdGFydCxuPXtjdXJyZW50RnJhZ21lbnRQRFQ6byhyKSxjdXJyZW50RnJhZ21lbnRTdGFydDppKGEpfTtzKFwiZnJhZ21lbnRjaGFuZ2VcIixuKX07ci5vbihhLkV2ZW50cy5GUkFHX0NIQU5HRUQsZik7dmFyIHA9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LnR5cGUsbj10LmRldGFpbHMsaT10LnJlc3BvbnNlLG89dC5mYXRhbCx1PXQuZnJhZyxsPXQubmV0d29ya0RldGFpbHMsZD0obnVsbD09dT92b2lkIDA6dS51cmwpfHx0LnVybHx8XCJcIixjPWw/UyhsKTp2b2lkIDA7aWYobiE9PWEuRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1ImJm4hPT1hLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQmJm4hPT1hLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1ImJm4hPT1hLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCYmbiE9PWEuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1ImJm4hPT1hLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQmJm4hPT1hLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SJiZuIT09YS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUJiZuIT09YS5FcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUiYmbiE9PWEuRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfVElNRU9VVCYmbiE9PWEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SJiZuIT09YS5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVHx8cyhcInJlcXVlc3RmYWlsZWRcIix7cmVxdWVzdF9lcnJvcjpuLHJlcXVlc3RfdXJsOmQscmVxdWVzdF9ob3N0bmFtZTpoKGQpLHJlcXVlc3RfaWQ6Yz9UKGMpOnZvaWQgMCxyZXF1ZXN0X3R5cGU6bj09PWEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUnx8bj09PWEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUP1wibWVkaWFcIjpuPT09YS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUnx8bj09PWEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVD9cImF1ZGlvXCI6bj09PWEuRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1J8fG49PT1hLkVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX1RJTUVPVVQ/XCJzdWJ0aXRsZVwiOm49PT1hLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUnx8bj09PWEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ/XCJlbmNyeXB0aW9uXCI6XCJtYW5pZmVzdFwiLHJlcXVlc3RfZXJyb3JfY29kZTpudWxsPT1pP3ZvaWQgMDppLmNvZGUscmVxdWVzdF9lcnJvcl90ZXh0Om51bGw9PWk/dm9pZCAwOmkudGV4dH0pLG8pe3ZhciBmLHA9XCJcIi5jb25jYXQoZD9cInVybDogXCIuY29uY2F0KGQsXCJcXG5cIik6XCJcIikrXCJcIi5jb25jYXQoaSYmKGkuY29kZXx8aS50ZXh0KT9cInJlc3BvbnNlOiBcIi5jb25jYXQoaS5jb2RlLFwiLCBcIikuY29uY2F0KGkudGV4dCxcIlxcblwiKTpcIlwiKStcIlwiLmNvbmNhdCh0LnJlYXNvbj9cImZhaWx1cmUgcmVhc29uOiBcIi5jb25jYXQodC5yZWFzb24sXCJcXG5cIik6XCJcIikrXCJcIi5jb25jYXQodC5sZXZlbD9cImxldmVsOiBcIi5jb25jYXQodC5sZXZlbCxcIlxcblwiKTpcIlwiKStcIlwiLmNvbmNhdCh0LnBhcmVudD9cInBhcmVudCBzdHJlYW0gY29udHJvbGxlcjogXCIuY29uY2F0KHQucGFyZW50LFwiXFxuXCIpOlwiXCIpK1wiXCIuY29uY2F0KHQuYnVmZmVyP1wiYnVmZmVyIGxlbmd0aDogXCIuY29uY2F0KHQuYnVmZmVyLFwiXFxuXCIpOlwiXCIpK1wiXCIuY29uY2F0KHQuZXJyb3I/XCJlcnJvcjogXCIuY29uY2F0KHQuZXJyb3IsXCJcXG5cIik6XCJcIikrXCJcIi5jb25jYXQodC5ldmVudD9cImV2ZW50OiBcIi5jb25jYXQodC5ldmVudCxcIlxcblwiKTpcIlwiKStcIlwiLmNvbmNhdCh0LmVycj9cImVycm9yIG1lc3NhZ2U6IFwiLmNvbmNhdChudWxsPT09KGY9dC5lcnIpfHx2b2lkIDA9PT1mP3ZvaWQgMDpmLm1lc3NhZ2UsXCJcXG5cIik6XCJcIik7cyhcImVycm9yXCIse3BsYXllcl9lcnJvcl9jb2RlOnIscGxheWVyX2Vycm9yX21lc3NhZ2U6bixwbGF5ZXJfZXJyb3JfY29udGV4dDpwfSl9fTtyLm9uKGEuRXZlbnRzLkVSUk9SLHApO3ZhciBfPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5mcmFnLGE9ciYmci5fdXJsfHxcIlwiO3MoXCJyZXF1ZXN0Y2FuY2VsZWRcIix7cmVxdWVzdF9ldmVudF90eXBlOmUscmVxdWVzdF91cmw6YSxyZXF1ZXN0X3R5cGU6XCJtZWRpYVwiLHJlcXVlc3RfaG9zdG5hbWU6aChhKX0pfTtyLm9uKGEuRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxfKTt2YXIgdj1mdW5jdGlvbihlLHQpe3ZhciBhPXQubGV2ZWwsaT1yLmxldmVsc1thXTtpZihpJiZpLmF0dHJzJiZpLmF0dHJzLkJBTkRXSURUSCl7dmFyIG8sdT1pLmF0dHJzLkJBTkRXSURUSCxsPXBhcnNlRmxvYXQoaS5hdHRyc1tcIkZSQU1FLVJBVEVcIl0pO2lzTmFOKGwpfHwobz1sKSx1P3MoXCJyZW5kaXRpb25jaGFuZ2VcIix7dmlkZW9fc291cmNlX2ZwczpvLHZpZGVvX3NvdXJjZV9iaXRyYXRlOnUsdmlkZW9fc291cmNlX3dpZHRoOmkud2lkdGgsdmlkZW9fc291cmNlX2hlaWdodDppLmhlaWdodCx2aWRlb19zb3VyY2VfcmVuZGl0aW9uX25hbWU6aS5uYW1lLHZpZGVvX3NvdXJjZV9jb2RlYzpudWxsPT1pP3ZvaWQgMDppLnZpZGVvQ29kZWN9KTpuLndhcm4oXCJtaXNzaW5nIEJBTkRXSURUSCBmcm9tIEhMUyBtYW5pZmVzdCBwYXJzZWQgYnkgSExTLmpzXCIpfX07ci5vbihhLkV2ZW50cy5MRVZFTF9TV0lUQ0hFRCx2KSxyLl9zdG9wTXV4TW9uaXRvcj1mdW5jdGlvbigpe3Iub2ZmKGEuRXZlbnRzLk1BTklGRVNUX0xPQURFRCx1KSxyLm9mZihhLkV2ZW50cy5MRVZFTF9MT0FERUQsbCksci5vZmYoYS5FdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELGQpLHIub2ZmKGEuRXZlbnRzLkZSQUdfTE9BREVELGMpLHIub2ZmKGEuRXZlbnRzLkZSQUdfQ0hBTkdFRCxmKSxyLm9mZihhLkV2ZW50cy5FUlJPUixwKSxyLm9mZihhLkV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXyksci5vZmYoYS5FdmVudHMuTEVWRUxfU1dJVENIRUQsdiksci5vZmYoYS5FdmVudHMuREVTVFJPWUlORyxyLl9zdG9wTXV4TW9uaXRvciksZGVsZXRlIHIuX3N0b3BNdXhNb25pdG9yfSxyLm9uKGEuRXZlbnRzLkRFU1RST1lJTkcsci5fc3RvcE11eE1vbml0b3IpfWVsc2Ugbi53YXJuKFwicGVyZm9ybWFuY2UgdGltaW5nIG5vdCBzdXBwb3J0ZWQuIE5vdCB0cmFja2luZyBITFMuanMuXCIpfSh0aGlzLm11eCx0aGlzLmlkLGUuaGxzanMse30sZS5IbHN8fHdpbmRvdy5IbHMpKTp0aGlzLm11eC5sb2cud2FybihcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBobHNqcyBpbnN0YW5jZSBpbiBvcmRlciB0byB0cmFjayBpdC5cIil9fSx7a2V5OlwicmVtb3ZlSExTSlNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3RoaXMuaGxzanMmJigoZT10aGlzLmhsc2pzKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5fc3RvcE11eE1vbml0b3ImJmUuX3N0b3BNdXhNb25pdG9yKCksdGhpcy5obHNqcz12b2lkIDApfX0se2tleTpcImFkZERhc2hKU1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UuZGFzaGpzP3RoaXMuZGFzaGpzP3RoaXMubXV4LmxvZy53YXJuKFwiQW4gaW5zdGFuY2Ugb2YgRGFzaC5qcyBpcyBhbHJlYWR5IGJlaW5nIG1vbml0b3JlZCBmb3IgdGhpcyBwbGF5ZXIuXCIpOih0aGlzLmRhc2hqcz1lLmRhc2hqcyxmdW5jdGlvbihlLHQscil7dmFyIGE9ZS5sb2c7aWYociYmci5vbil7dmFyIG49ZnVuY3Rpb24ocixhKXtyZXR1cm4gZS5lbWl0KHQscixhKX0saT1mdW5jdGlvbihlKXt2YXIgdD1lLnR5cGUscj0oZS5kYXRhfHx7fSkudXJsO24oXCJyZXF1ZXN0Y29tcGxldGVkXCIse3JlcXVlc3RfZXZlbnRfdHlwZTp0LHJlcXVlc3Rfc3RhcnQ6MCxyZXF1ZXN0X3Jlc3BvbnNlX3N0YXJ0OjAscmVxdWVzdF9yZXNwb25zZV9lbmQ6MCxyZXF1ZXN0X2J5dGVzX2xvYWRlZDotMSxyZXF1ZXN0X3R5cGU6XCJtYW5pZmVzdFwiLHJlcXVlc3RfaG9zdG5hbWU6aChyKSxyZXF1ZXN0X3VybDpyfSl9O3Iub24oXCJtYW5pZmVzdExvYWRlZFwiLGkpO3ZhciBvPXt9LHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50eXBlLGE9ZS5mcmFnbWVudE1vZGVsLGk9KGUuY2h1bmt8fHt9KS5tZWRpYUluZm98fHt9LHM9aS50eXBlLHU9aS5iaXRyYXRlTGlzdCxsPXt9Oyh1PXV8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2xbdF09e30sbFt0XS53aWR0aD1lLndpZHRoLGxbdF0uaGVpZ2h0PWUuaGVpZ2h0LGxbdF0uYml0cmF0ZT1lLmJhbmR3aWR0aCxsW3RdLmF0dHJzPXt9fSkpLFwidmlkZW9cIj09PXM/by52aWRlbz1sOlwiYXVkaW9cIj09PXM/by5hdWRpbz1sOm8ubWVkaWE9bDt2YXIgZD1SKGEsciksYz1kLnJlcXVlc3RTdGFydCxmPWQucmVxdWVzdFJlc3BvbnNlU3RhcnQscD1kLnJlcXVlc3RSZXNwb25zZUVuZCxfPWQucmVxdWVzdFJlc3BvbnNlSGVhZGVycyxoPWQucmVxdWVzdE1lZGlhRHVyYXRpb24sdj1kLnJlcXVlc3RIb3N0bmFtZSxtPWQucmVxdWVzdFVybCx5PWQucmVxdWVzdElkO24oXCJyZXF1ZXN0Y29tcGxldGVkXCIse3JlcXVlc3RfZXZlbnRfdHlwZTp0LHJlcXVlc3Rfc3RhcnQ6YyxyZXF1ZXN0X3Jlc3BvbnNlX3N0YXJ0OmYscmVxdWVzdF9yZXNwb25zZV9lbmQ6cCxyZXF1ZXN0X2J5dGVzX2xvYWRlZDotMSxyZXF1ZXN0X3R5cGU6cytcIl9pbml0XCIscmVxdWVzdF9yZXNwb25zZV9oZWFkZXJzOl8scmVxdWVzdF9ob3N0bmFtZTp2LHJlcXVlc3RfaWQ6eSxyZXF1ZXN0X3VybDptLHJlcXVlc3RfbWVkaWFfZHVyYXRpb246aCxyZXF1ZXN0X3JlbmRpdGlvbl9saXN0czpvfSl9O3Iub24oXCJpbml0RnJhZ21lbnRMb2FkZWRcIixzKTt2YXIgdT1mdW5jdGlvbihlKXt2YXIgdD1lLnR5cGUsYT1lLmZyYWdtZW50TW9kZWwsaT1lLmNodW5rfHx7fSxvPWkubWVkaWFJbmZvLHM9aS5zdGFydCx1PShvfHx7fSkudHlwZSxsPVIoYSxyKSxkPWwucmVxdWVzdFN0YXJ0LGM9bC5yZXF1ZXN0UmVzcG9uc2VTdGFydCxmPWwucmVxdWVzdFJlc3BvbnNlRW5kLHA9bC5yZXF1ZXN0Qnl0ZXNMb2FkZWQsXz1sLnJlcXVlc3RSZXNwb25zZUhlYWRlcnMsaD1sLnJlcXVlc3RNZWRpYUR1cmF0aW9uLHY9bC5yZXF1ZXN0SG9zdG5hbWUsbT1sLnJlcXVlc3RVcmwseT1sLnJlcXVlc3RJZCxiPUkodSxyKSxnPWIuY3VycmVudExldmVsLHc9Yi5yZW5kaXRpb25XaWR0aCxUPWIucmVuZGl0aW9uSGVpZ2h0LEU9Yi5yZW5kaXRpb25CaXRyYXRlO24oXCJyZXF1ZXN0Y29tcGxldGVkXCIse3JlcXVlc3RfZXZlbnRfdHlwZTp0LHJlcXVlc3Rfc3RhcnQ6ZCxyZXF1ZXN0X3Jlc3BvbnNlX3N0YXJ0OmMscmVxdWVzdF9yZXNwb25zZV9lbmQ6ZixyZXF1ZXN0X2J5dGVzX2xvYWRlZDpwLHJlcXVlc3RfdHlwZTp1LHJlcXVlc3RfcmVzcG9uc2VfaGVhZGVyczpfLHJlcXVlc3RfaG9zdG5hbWU6dixyZXF1ZXN0X2lkOnkscmVxdWVzdF91cmw6bSxyZXF1ZXN0X21lZGlhX3N0YXJ0X3RpbWU6cyxyZXF1ZXN0X21lZGlhX2R1cmF0aW9uOmgscmVxdWVzdF9jdXJyZW50X2xldmVsOmcscmVxdWVzdF9sYWJlbGVkX2JpdHJhdGU6RSxyZXF1ZXN0X3ZpZGVvX3dpZHRoOncscmVxdWVzdF92aWRlb19oZWlnaHQ6VH0pfTtyLm9uKFwibWVkaWFGcmFnbWVudExvYWRlZFwiLHUpO3ZhciBsPXt2aWRlbzp2b2lkIDAsYXVkaW86dm9pZCAwLHRvdGFsQml0cmF0ZTp2b2lkIDB9LGQ9ZnVuY3Rpb24oKXtpZihsLnZpZGVvJiZcIm51bWJlclwiPT10eXBlb2YgbC52aWRlby5iaXRyYXRlKXtpZihsLnZpZGVvLndpZHRoJiZsLnZpZGVvLmhlaWdodCl7dmFyIGU9bC52aWRlby5iaXRyYXRlO3JldHVybiBsLmF1ZGlvJiZcIm51bWJlclwiPT10eXBlb2YgbC5hdWRpby5iaXRyYXRlJiYoZSs9bC5hdWRpby5iaXRyYXRlKSxlIT09bC50b3RhbEJpdHJhdGU/KGwudG90YWxCaXRyYXRlPWUse3ZpZGVvX3NvdXJjZV9iaXRyYXRlOmUsdmlkZW9fc291cmNlX2hlaWdodDpsLnZpZGVvLmhlaWdodCx2aWRlb19zb3VyY2Vfd2lkdGg6bC52aWRlby53aWR0aCx2aWRlb19zb3VyY2VfY29kZWM6aihsLnZpZGVvLmNvZGVjKX0pOnZvaWQgMH1hLndhcm4oXCJoYXZlIGJpdHJhdGUgaW5mbyBmb3IgdmlkZW8gYnV0IG1pc3Npbmcgd2lkdGgvaGVpZ2h0XCIpfX0sYz1mdW5jdGlvbihlLHQsaSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUubmV3UXVhbGl0eSl7dmFyIG89ZS5tZWRpYVR5cGU7aWYoXCJhdWRpb1wiPT09b3x8XCJ2aWRlb1wiPT09byl7dmFyIHM9ci5nZXRCaXRyYXRlSW5mb0xpc3RGb3IobykuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucXVhbGl0eUluZGV4PT09ZS5uZXdRdWFsaXR5fSkpO2lmKHMmJlwibnVtYmVyXCI9PXR5cGVvZiBzLmJpdHJhdGUpe2xbb109UChQKHt9LHMpLHt9LHtjb2RlYzpyLmdldEN1cnJlbnRUcmFja0ZvcihvKS5jb2RlY30pO3ZhciB1PWQoKTt1JiZuKFwicmVuZGl0aW9uY2hhbmdlXCIsdSl9ZWxzZSBhLndhcm4oXCJtaXNzaW5nIGJpdHJhdGUgaW5mbyBmb3IgXCIuY29uY2F0KG8pKX19ZWxzZSBhLndhcm4oXCJtaXNzaW5nIGV2dC5uZXdRdWFsaXR5IGluIHF1YWxpdHlDaGFuZ2VSZW5kZXJlZCBldmVudFwiLGUpfTtyLm9uKFwicXVhbGl0eUNoYW5nZVJlbmRlcmVkXCIsYyk7dmFyIGY9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXF1ZXN0LHI9ZS5tZWRpYVR5cGU7bihcInJlcXVlc3RjYW5jZWxlZFwiLHtyZXF1ZXN0X2V2ZW50X3R5cGU6KHQ9dHx8e30pLnR5cGUrXCJfXCIrdC5hY3Rpb24scmVxdWVzdF91cmw6dC51cmwscmVxdWVzdF90eXBlOnIscmVxdWVzdF9ob3N0bmFtZTpoKHQudXJsKX0pfTtyLm9uKFwiZnJhZ21lbnRMb2FkaW5nQWJhbmRvbmVkXCIsZik7dmFyIHA9ZnVuY3Rpb24oZSl7dmFyIHQscixhPWUuZXJyb3IsaT0obnVsbD09YXx8bnVsbD09PSh0PWEuZGF0YSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQucmVxdWVzdCl8fHt9LG89KG51bGw9PWF8fG51bGw9PT0ocj1hLmRhdGEpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLnJlc3BvbnNlKXx8e307Mjc9PT0obnVsbD09YT92b2lkIDA6YS5jb2RlKSYmbihcInJlcXVlc3RmYWlsZWRcIix7cmVxdWVzdF9lcnJvcjppLnR5cGUrXCJfXCIraS5hY3Rpb24scmVxdWVzdF91cmw6aS51cmwscmVxdWVzdF9ob3N0bmFtZTpoKGkudXJsKSxyZXF1ZXN0X3R5cGU6aS5tZWRpYVR5cGUscmVxdWVzdF9lcnJvcl9jb2RlOm8uc3RhdHVzLHJlcXVlc3RfZXJyb3JfdGV4dDpvLnN0YXR1c1RleHR9KTt2YXIgcz1cIlwiLmNvbmNhdChudWxsIT1pJiZpLnVybD9cInVybDogXCIuY29uY2F0KGkudXJsLFwiXFxuXCIpOlwiXCIpK1wiXCIuY29uY2F0KG51bGwhPW8mJm8uc3RhdHVzfHxudWxsIT1vJiZvLnN0YXR1c1RleHQ/XCJyZXNwb25zZTogXCIuY29uY2F0KG51bGw9PW8/dm9pZCAwOm8uc3RhdHVzLFwiLCBcIikuY29uY2F0KG51bGw9PW8/dm9pZCAwOm8uc3RhdHVzVGV4dCxcIlxcblwiKTpcIlwiKTtuKFwiZXJyb3JcIix7cGxheWVyX2Vycm9yX2NvZGU6bnVsbD09YT92b2lkIDA6YS5jb2RlLHBsYXllcl9lcnJvcl9tZXNzYWdlOm51bGw9PWE/dm9pZCAwOmEubWVzc2FnZSxwbGF5ZXJfZXJyb3JfY29udGV4dDpzfSl9O3Iub24oXCJlcnJvclwiLHApLHIuX3N0b3BNdXhNb25pdG9yPWZ1bmN0aW9uKCl7ci5vZmYoXCJtYW5pZmVzdExvYWRlZFwiLGkpLHIub2ZmKFwiaW5pdEZyYWdtZW50TG9hZGVkXCIscyksci5vZmYoXCJtZWRpYUZyYWdtZW50TG9hZGVkXCIsdSksci5vZmYoXCJxdWFsaXR5Q2hhbmdlUmVuZGVyZWRcIixjKSxyLm9mZihcImVycm9yXCIscCksci5vZmYoXCJmcmFnbWVudExvYWRpbmdBYmFuZG9uZWRcIixmKSxkZWxldGUgci5fc3RvcE11eE1vbml0b3J9fWVsc2UgYS53YXJuKFwiSW52YWxpZCBkYXNoLmpzIHBsYXllciByZWZlcmVuY2UuIE1vbml0b3JpbmcgYmxvY2tlZC5cIil9KHRoaXMubXV4LHRoaXMuaWQsZS5kYXNoanMpKTp0aGlzLm11eC5sb2cud2FybihcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBkYXNoanMgaW5zdGFuY2UgaW4gb3JkZXIgdG8gdHJhY2sgaXQuXCIpfX0se2tleTpcInJlbW92ZURhc2hKU1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7dGhpcy5kYXNoanMmJigoZT10aGlzLmRhc2hqcykmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuX3N0b3BNdXhNb25pdG9yJiZlLl9zdG9wTXV4TW9uaXRvcigpLHRoaXMuZGFzaGpzPXZvaWQgMCl9fV0sciYmcHQodC5wcm90b3R5cGUsciksYSYmcHQodCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLG99KEgpLHd0PWd0LFR0PXIoMTUzKSxFdD1yLm4oVHQpO2Z1bmN0aW9uIGt0KGUpe3JldHVybiBrdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSxrdChlKX1mdW5jdGlvbiBPdChlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXt2YXIgcj1udWxsPT1lP251bGw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZihudWxsIT1yKXt2YXIgYSxuLGk9W10sbz0hMCxzPSExO3RyeXtmb3Iocj1yLmNhbGwoZSk7IShvPShhPXIubmV4dCgpKS5kb25lKSYmKGkucHVzaChhLnZhbHVlKSwhdHx8aS5sZW5ndGghPT10KTtvPSEwKTt9Y2F0Y2goZSl7cz0hMCxuPWV9ZmluYWxseXt0cnl7b3x8bnVsbD09ci5yZXR1cm58fHIucmV0dXJuKCl9ZmluYWxseXtpZihzKXRocm93IG59fXJldHVybiBpfX0oZSx0KXx8ZnVuY3Rpb24oZSx0KXtpZihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gRHQoZSx0KTt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PXImJmUuY29uc3RydWN0b3ImJihyPWUuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PXJ8fFwiU2V0XCI9PT1yP0FycmF5LmZyb20oZSk6XCJBcmd1bWVudHNcIj09PXJ8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHIpP0R0KGUsdCk6dm9pZCAwfX0oZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIER0KGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciByPTAsYT1uZXcgQXJyYXkodCk7cjx0O3IrKylhW3JdPWVbcl07cmV0dXJuIGF9dmFyIHh0LFN0PVtcImxvYWRzdGFydFwiLFwicGF1c2VcIixcInBsYXlcIixcInBsYXlpbmdcIixcInNlZWtpbmdcIixcInNlZWtlZFwiLFwidGltZXVwZGF0ZVwiLFwicmF0ZWNoYW5nZVwiLFwic3RhbGxlZFwiLFwid2FpdGluZ1wiLFwiZXJyb3JcIixcImVuZGVkXCJdLHF0PXsxOlwiTUVESUFfRVJSX0FCT1JURURcIiwyOlwiTUVESUFfRVJSX05FVFdPUktcIiwzOlwiTUVESUFfRVJSX0RFQ09ERVwiLDQ6XCJNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcIn07bigpJiZuKCkuV2Vha01hcCYmKHh0PW5ldyBXZWFrTWFwKTt2YXIgUHQ9XCIjRVhULVgtVEFSR0VURFVSQVRJT05cIixBdD1cIiNFWFQtWC1QQVJULUlORlwiLFJ0PVwiI0VYVC1YLVNFUlZFUi1DT05UUk9MXCIsSXQ9XCIjRVhUSU5GXCIsanQ9XCIjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUVcIixMdD1cIiNFWFQtWC1WRVJTSU9OXCIsQ3Q9XCIjRVhULVgtU0VTU0lPTi1EQVRBXCIsTnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnVmZmVyPVwiXCIsdGhpcy5tYW5pZmVzdD17c2VnbWVudHM6W10sc2VydmVyQ29udHJvbDp7fSxzZXNzaW9uRGF0YTp7fX0sdGhpcy5jdXJyZW50VXJpPXt9LHRoaXMucHJvY2VzcyhlKSx0aGlzLm1hbmlmZXN0fTtOdC5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihlKXt2YXIgdDtmb3IodGhpcy5idWZmZXIrPWUsdD10aGlzLmJ1ZmZlci5pbmRleE9mKFwiXFxuXCIpO3Q+LTE7dD10aGlzLmJ1ZmZlci5pbmRleE9mKFwiXFxuXCIpKXRoaXMucHJvY2Vzc0xpbmUodGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsdCkpLHRoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLnN1YnN0cmluZyh0KzEpfSxOdC5wcm90b3R5cGUucHJvY2Vzc0xpbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5pbmRleE9mKFwiOlwiKSxyPVd0KGUsdCksYT1yWzBdLG49Mj09PXIubGVuZ3RoP0J0KHJbMV0pOnZvaWQgMDtpZihcIiNcIiE9PWFbMF0pdGhpcy5jdXJyZW50VXJpLnVyaT1hLHRoaXMubWFuaWZlc3Quc2VnbWVudHMucHVzaCh0aGlzLmN1cnJlbnRVcmkpLHRoaXMubWFuaWZlc3QudGFyZ2V0RHVyYXRpb24mJiEoXCJkdXJhdGlvblwiaW4gdGhpcy5jdXJyZW50VXJpKSYmKHRoaXMuY3VycmVudFVyaS5kdXJhdGlvbj10aGlzLm1hbmlmZXN0LnRhcmdldER1cmF0aW9uKSx0aGlzLmN1cnJlbnRVcmk9e307ZWxzZSBzd2l0Y2goYSl7Y2FzZSBQdDppZighaXNGaW5pdGUobil8fG48MClyZXR1cm47dGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbj1uLHRoaXMuc2V0SG9sZEJhY2soKTticmVhaztjYXNlIEF0Okh0KHRoaXMubWFuaWZlc3QsciksdGhpcy5tYW5pZmVzdC5wYXJ0SW5mLnBhcnRUYXJnZXQmJih0aGlzLm1hbmlmZXN0LnBhcnRUYXJnZXREdXJhdGlvbj10aGlzLm1hbmlmZXN0LnBhcnRJbmYucGFydFRhcmdldCksdGhpcy5zZXRIb2xkQmFjaygpO2JyZWFrO2Nhc2UgUnQ6SHQodGhpcy5tYW5pZmVzdCxyKSx0aGlzLnNldEhvbGRCYWNrKCk7YnJlYWs7Y2FzZSBJdDowPT09bj90aGlzLmN1cnJlbnRVcmkuZHVyYXRpb249LjAxOm4+MCYmKHRoaXMuY3VycmVudFVyaS5kdXJhdGlvbj1uKTticmVhaztjYXNlIGp0OnZhciBpPW4sbz1uZXcgRGF0ZShpKTt0aGlzLm1hbmlmZXN0LmRhdGVUaW1lU3RyaW5nfHwodGhpcy5tYW5pZmVzdC5kYXRlVGltZVN0cmluZz1pLHRoaXMubWFuaWZlc3QuZGF0ZVRpbWVPYmplY3Q9byksdGhpcy5jdXJyZW50VXJpLmRhdGVUaW1lU3RyaW5nPWksdGhpcy5jdXJyZW50VXJpLmRhdGVUaW1lT2JqZWN0PW87YnJlYWs7Y2FzZSBMdDpIdCh0aGlzLm1hbmlmZXN0LHIpO2JyZWFrO2Nhc2UgQ3Q6dmFyIHM9UXQoclsxXSksdT1FKHMpO09iamVjdC5hc3NpZ24odGhpcy5tYW5pZmVzdC5zZXNzaW9uRGF0YSx1KX19LE50LnByb3RvdHlwZS5zZXRIb2xkQmFjaz1mdW5jdGlvbigpe3ZhciBlPXRoaXMubWFuaWZlc3QsdD1lLnNlcnZlckNvbnRyb2wscj1lLnRhcmdldER1cmF0aW9uLGE9ZS5wYXJ0VGFyZ2V0RHVyYXRpb247aWYodCl7dmFyIG49XCJob2xkQmFja1wiLGk9XCJwYXJ0SG9sZEJhY2tcIixvPXImJjMqcixzPWEmJjIqYTtyJiYhdC5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09byksbyYmdFtuXTxvJiYodFtuXT1vKSxhJiYhdC5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09MyphKSxhJiZ0W2ldPHMmJih0W2ldPXMpfX07dmFyIEh0PWZ1bmN0aW9uKGUsdCl7dmFyIHIsYT1NdCh0WzBdLnJlcGxhY2UoXCIjRVhULVgtXCIsXCJcIikpO0d0KHRbMV0pPyhyPXt9LHI9T2JqZWN0LmFzc2lnbihGdCh0WzFdKSxyKSk6cj1CdCh0WzFdKSxlW2FdPXJ9LE10PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csKGZ1bmN0aW9uKGUpe3JldHVybiBlWzFdLnRvVXBwZXJDYXNlKCl9KSl9LEJ0PWZ1bmN0aW9uKGUpe2lmKFwieWVzXCI9PT1lLnRvTG93ZXJDYXNlKCl8fFwibm9cIj09PWUudG9Mb3dlckNhc2UoKSlyZXR1cm5cInllc1wiPT09ZS50b0xvd2VyQ2FzZSgpO3ZhciB0PS0xIT09ZS5pbmRleE9mKFwiOlwiKT9lOnBhcnNlRmxvYXQoZSk7cmV0dXJuIGlzTmFOKHQpP2U6dH0sVXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9e30scj1lLnNwbGl0KFwiPVwiKTtyZXR1cm4gci5sZW5ndGg+MSYmKHRbTXQoclswXSldPUJ0KHJbMV0pKSx0fSxGdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5zcGxpdChcIixcIikscj17fSxhPTA7dC5sZW5ndGg+YTthKyspe3ZhciBuPXRbYV0saT1VdChuKTtyPU9iamVjdC5hc3NpZ24oaSxyKX1yZXR1cm4gcn0sR3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5kZXhPZihcIj1cIik+LTF9LFd0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT10P1tlXTpbZS5zdWJzdHJpbmcoMCx0KSxlLnN1YnN0cmluZyh0KzEpXX0sUXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9e307aWYoZSl7dmFyIHI9ZS5zZWFyY2goXCIsXCIpO3JldHVybltlLnNsaWNlKDAsciksZS5zbGljZShyKzEpXS5mb3JFYWNoKChmdW5jdGlvbihlLHIpe2Zvcih2YXIgYT1lLnJlcGxhY2UoL1snXCJdKy9nLFwiXCIpLnNwbGl0KFwiPVwiKSxuPTA7bjxhLmxlbmd0aDtuKyspXCJEQVRBLUlEXCI9PT1hW25dJiYodFtcIkRBVEEtSURcIl09YVsxLW5dKSxcIlZBTFVFXCI9PT1hW25dJiYodC5WQUxVRT1hWzEtbl0pfSkpLHtkYXRhOnR9fX0sVnQ9TnQsSnQ9e3NhZmVDYWxsOmZ1bmN0aW9uKGUsdCxyLGEpe3ZhciBuPWE7aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZVt0XSl0cnl7bj1lW3RdLmFwcGx5KGUscil9Y2F0Y2goZSl7Zi5pbmZvKFwic2FmZUNhbGwgZXJyb3JcIixlKX1yZXR1cm4gbn0sc2FmZUluY3JlbWVudDp5LGdldENvbXB1dGVkU3R5bGU6ZnVuY3Rpb24oZSx0KXt2YXIgcjtpZihlJiZ0JiZuKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIG4oKS5nZXRDb21wdXRlZFN0eWxlKXJldHVybiB4dCYmeHQuaGFzKGUpJiYocj14dC5nZXQoZSkpLHJ8fChyPW4oKS5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkseHQmJnh0LnNldChlLHIpKSxyLmdldFByb3BlcnR5VmFsdWUodCl9LHNlY29uZHNUb01zOmZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLmZsb29yKDFlMyplKX0sYXNzaWduOk9iamVjdC5hc3NpZ24saGVhZGVyc1N0cmluZ1RvT2JqZWN0OncsY2RuSGVhZGVyc1RvUmVxdWVzdElkOlQsZXh0cmFjdEhvc3RuYW1lQW5kRG9tYWluOnYsZXh0cmFjdEhvc3RuYW1lOmgsbWFuaWZlc3RQYXJzZXI6VnQsZ2VuZXJhdGVTaG9ydElEOm8sZ2VuZXJhdGVVVUlEOmksbm93Ol8ubm93fSxLdD17UExBWUVSX1JFQURZOlwicGxheWVycmVhZHlcIixWSUVXX0lOSVQ6XCJ2aWV3aW5pdFwiLFZJREVPX0NIQU5HRTpcInZpZGVvY2hhbmdlXCIsUExBWTpcInBsYXlcIixQQVVTRTpcInBhdXNlXCIsUExBWUlORzpcInBsYXlpbmdcIixUSU1FX1VQREFURTpcInRpbWV1cGRhdGVcIixTRUVLSU5HOlwic2Vla2luZ1wiLFNFRUtFRDpcInNlZWtlZFwiLFJFQlVGRkVSX1NUQVJUOlwicmVidWZmZXJzdGFydFwiLFJFQlVGRkVSX0VORDpcInJlYnVmZmVyZW5kXCIsRVJST1I6XCJlcnJvclwiLEVOREVEOlwiZW5kZWRcIixSRU5ESVRJT05fQ0hBTkdFOlwicmVuZGl0aW9uY2hhbmdlXCIsT1JJRU5UQVRJT05fQ0hBTkdFOlwib3JpZW50YXRpb25jaGFuZ2VcIixBRF9SRVFVRVNUOlwiYWRyZXF1ZXN0XCIsQURfUkVTUE9OU0U6XCJhZHJlc3BvbnNlXCIsQURfQlJFQUtfU1RBUlQ6XCJhZGJyZWFrc3RhcnRcIixBRF9QTEFZOlwiYWRwbGF5XCIsQURfUExBWUlORzpcImFkcGxheWluZ1wiLEFEX1BBVVNFOlwiYWRwYXVzZVwiLEFEX0ZJUlNUX1FVQVJUSUxFOlwiYWRmaXJzdHF1YXJ0aWxlXCIsQURfTUlEX1BPSU5UOlwiYWRtaWRwb2ludFwiLEFEX1RISVJEX1FVQVJUSUxFOlwiYWR0aGlyZHF1YXJ0aWxlXCIsQURfRU5ERUQ6XCJhZGVuZGVkXCIsQURfQlJFQUtfRU5EOlwiYWRicmVha2VuZFwiLEFEX0VSUk9SOlwiYWRlcnJvclwiLFJFUVVFU1RfQ09NUExFVEVEOlwicmVxdWVzdGNvbXBsZXRlZFwiLFJFUVVFU1RfRkFJTEVEOlwicmVxdWVzdGZhaWxlZFwiLFJFUVVFU1RfQ0FOQ0VMTEVEOlwicmVxdWVzdGNhbmNlbGVkXCJ9O2Z1bmN0aW9uIHp0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe3ZhciByPW51bGw9PWU/bnVsbDpcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZlW1N5bWJvbC5pdGVyYXRvcl18fGVbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGwhPXIpe3ZhciBhLG4saT1bXSxvPSEwLHM9ITE7dHJ5e2ZvcihyPXIuY2FsbChlKTshKG89KGE9ci5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKGEudmFsdWUpLCF0fHxpLmxlbmd0aCE9PXQpO289ITApO31jYXRjaChlKXtzPSEwLG49ZX1maW5hbGx5e3RyeXtvfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHMpdGhyb3cgbn19cmV0dXJuIGl9fShlLHQpfHxmdW5jdGlvbihlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBZdChlLHQpO3ZhciByPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09ciYmZS5jb25zdHJ1Y3RvciYmKHI9ZS5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09cnx8XCJTZXRcIj09PXI/QXJyYXkuZnJvbShlKTpcIkFyZ3VtZW50c1wiPT09cnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qocik/WXQoZSx0KTp2b2lkIDB9fShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gWXQoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIHI9MCxhPW5ldyBBcnJheSh0KTtyPHQ7cisrKWFbcl09ZVtyXTtyZXR1cm4gYX12YXIgWHQ9e30sJHQ9ZnVuY3Rpb24gZSh0KXt2YXIgcj1hcmd1bWVudHM7XCJzdHJpbmdcIj09dHlwZW9mIHQ/ZS5oYXNPd25Qcm9wZXJ0eSh0KT9uKCkuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyPUFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChyLDEpLGVbdF0uYXBwbHkobnVsbCxyKX0pLDApOmYud2FybihcImBcIit0K1wiYCBpcyBhbiB1bmtub3duIHRhc2tcIik6XCJmdW5jdGlvblwiPT10eXBlb2YgdD9uKCkuc2V0VGltZW91dCgoZnVuY3Rpb24oKXt0KGUpfSksMCk6Zi53YXJuKFwiYFwiK3QrXCJgIGlzIGludmFsaWQuXCIpfSxadD17bG9hZGVkOl8ubm93KCksTkFNRTpcIm11eC1lbWJlZFwiLFZFUlNJT046XCI0LjI2LjBcIixBUElfVkVSU0lPTjpcIjIuMVwiLFBMQVlFUl9UUkFDS0VEOiExLG1vbml0b3I6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3ZhciBhPU90KHUodCksMyksbj1hWzBdLGk9YVsxXSxvPWFbMl0scz1lLmxvZyxsPWUudXRpbHMuZ2V0Q29tcHV0ZWRTdHlsZSxkPWUudXRpbHMuc2Vjb25kc1RvTXM7aWYoIW4pcmV0dXJuIHMuZXJyb3IoXCJObyBlbGVtZW50IHdhcyBmb3VuZCB3aXRoIHRoZSBgXCIraStcImAgcXVlcnkgc2VsZWN0b3IuXCIpO2lmKFwidmlkZW9cIiE9PW8mJlwiYXVkaW9cIiE9PW8pcmV0dXJuIHMuZXJyb3IoXCJUaGUgZWxlbWVudCBvZiBgXCIraStcImAgd2FzIG5vdCBhIG1lZGlhIGVsZW1lbnQuXCIpO24ubXV4JiYobi5tdXguZGVzdHJveSgpLGRlbGV0ZSBuLm11eCxzLndhcm4oXCJBbHJlYWR5IG1vbml0b3JpbmcgdGhpcyB2aWRlbyBlbGVtZW50LCByZXBsYWNpbmcgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzXCIpKSwocj1PYmplY3QuYXNzaWduKHthdXRvbWF0aWNFcnJvclRyYWNraW5nOiEwfSxyKSkuZGF0YT1PYmplY3QuYXNzaWduKHtwbGF5ZXJfc29mdHdhcmU6XCJIVE1MNSBWaWRlbyBFbGVtZW50XCIscGxheWVyX211eF9wbHVnaW5fbmFtZTpcIlZpZGVvRWxlbWVudE1vbml0b3JcIixwbGF5ZXJfbXV4X3BsdWdpbl92ZXJzaW9uOmUuVkVSU0lPTn0sci5kYXRhKSxyLmdldFBsYXloZWFkVGltZT1mdW5jdGlvbigpe3JldHVybiBkKG4uY3VycmVudFRpbWUpfSxyLmdldFN0YXRlRGF0YT1mdW5jdGlvbigpe3ZhciBlLHQsYT10aGlzLmhsc2pzJiZ0aGlzLmhsc2pzLnVybCxpPXRoaXMuZGFzaGpzJiZrdChcImZ1bmN0aW9uXCI9PT10aGlzLmRhc2hqcy5nZXRTb3VyY2UpJiZ0aGlzLmRhc2hqcy5nZXRTb3VyY2UoKSxvPXtwbGF5ZXJfaXNfcGF1c2VkOm4ucGF1c2VkLHBsYXllcl9wbGF5aGVhZF90aW1lOmQobi5jdXJyZW50VGltZSkscGxheWVyX3dpZHRoOnBhcnNlSW50KGwobixcIndpZHRoXCIpKSxwbGF5ZXJfaGVpZ2h0OnBhcnNlSW50KGwobixcImhlaWdodFwiKSkscGxheWVyX2F1dG9wbGF5X29uOm4uYXV0b3BsYXkscGxheWVyX3ByZWxvYWRfb246bi5wcmVsb2FkLHBsYXllcl9sYW5ndWFnZV9jb2RlOm4ubGFuZyxwbGF5ZXJfaXNfZnVsbHNjcmVlbjpFdCgpJiYhIShFdCgpLmZ1bGxzY3JlZW5FbGVtZW50fHxFdCgpLndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50fHxFdCgpLm1vekZ1bGxTY3JlZW5FbGVtZW50fHxFdCgpLm1zRnVsbHNjcmVlbkVsZW1lbnQpLHZpZGVvX3Bvc3Rlcl91cmw6bi5wb3N0ZXIsdmlkZW9fc291cmNlX3VybDphfHxpfHxuLmN1cnJlbnRTcmMsdmlkZW9fc291cmNlX2R1cmF0aW9uOmQobi5kdXJhdGlvbiksdmlkZW9fc291cmNlX2hlaWdodDpuLnZpZGVvSGVpZ2h0LHZpZGVvX3NvdXJjZV93aWR0aDpuLnZpZGVvV2lkdGgsdmlld19kcm9wcGVkX2ZyYW1lX2NvdW50Om51bGw9PT0oZT1uKXx8dm9pZCAwPT09ZXx8bnVsbD09PSh0PWUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmNhbGwoZSkuZHJvcHBlZFZpZGVvRnJhbWVzfSxzPXIuZ2V0UGxheWhlYWRUaW1lKCk7aWYobi5nZXRTdGFydERhdGUmJnM+MCl7dmFyIHU9bi5nZXRTdGFydERhdGUoKTtpZih1JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmdldFRpbWUmJnUuZ2V0VGltZSgpKXt2YXIgYz11LmdldFRpbWUoKTtpZihvLnBsYXllcl9wcm9ncmFtX3RpbWU9YytzLG4uc2Vla2FibGUubGVuZ3RoPjApe3ZhciBmPWMrbi5zZWVrYWJsZS5lbmQobi5zZWVrYWJsZS5sZW5ndGgtMSk7by5wbGF5ZXJfbGl2ZV9lZGdlX3Byb2dyYW1fdGltZT1mfX19cmV0dXJuIG99LG4ubXV4PW4ubXV4fHx7fSxuLm11eC5kZWxldGVkPSExLG4ubXV4LmVtaXQ9ZnVuY3Rpb24odCxyKXtlLmVtaXQoaSx0LHIpfTt2YXIgYz1mdW5jdGlvbigpe3MuZXJyb3IoXCJUaGUgbW9uaXRvciBmb3IgdGhpcyB2aWRlbyBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKX07bi5tdXguZGVzdHJveT1mdW5jdGlvbigpe09iamVjdC5rZXlzKG4ubXV4Lmxpc3RlbmVycykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bi5yZW1vdmVFdmVudExpc3RlbmVyKGUsbi5tdXgubGlzdGVuZXJzW2VdLCExKX0pKSxkZWxldGUgbi5tdXgubGlzdGVuZXJzLG4ubXV4LmRlc3Ryb3k9YyxuLm11eC5zd2FwRWxlbWVudD1jLG4ubXV4LmVtaXQ9YyxuLm11eC5hZGRITFNKUz1jLG4ubXV4LmFkZERhc2hKUz1jLG4ubXV4LnJlbW92ZUhMU0pTPWMsbi5tdXgucmVtb3ZlRGFzaEpTPWMsbi5tdXguZGVsZXRlZD0hMCxlLmVtaXQoaSxcImRlc3Ryb3lcIil9LG4ubXV4LnN3YXBFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciByPU90KHUodCksMyksYT1yWzBdLGk9clsxXSxvPXJbMl07cmV0dXJuIGE/XCJ2aWRlb1wiIT09byYmXCJhdWRpb1wiIT09bz9lLmxvZy5lcnJvcihcIlRoZSBlbGVtZW50IG9mIGBcIitpK1wiYCB3YXMgbm90IGEgbWVkaWEgZWxlbWVudC5cIik6KGEubXV4SWQ9bi5tdXhJZCxkZWxldGUgbi5tdXhJZCxhLm11eD1hLm11eHx8e30sYS5tdXgubGlzdGVuZXJzPU9iamVjdC5hc3NpZ24oe30sbi5tdXgubGlzdGVuZXJzKSxkZWxldGUgbi5tdXgubGlzdGVuZXJzLE9iamVjdC5rZXlzKGEubXV4Lmxpc3RlbmVycykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bi5yZW1vdmVFdmVudExpc3RlbmVyKGUsYS5tdXgubGlzdGVuZXJzW2VdLCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoZSxhLm11eC5saXN0ZW5lcnNbZV0sITEpfSkpLGEubXV4LnN3YXBFbGVtZW50PW4ubXV4LnN3YXBFbGVtZW50LGEubXV4LmRlc3Ryb3k9bi5tdXguZGVzdHJveSxkZWxldGUgbi5tdXgsdm9pZChuPWEpKTplLmxvZy5lcnJvcihcIk5vIGVsZW1lbnQgd2FzIGZvdW5kIHdpdGggdGhlIGBcIitpK1wiYCBxdWVyeSBzZWxlY3Rvci5cIil9LG4ubXV4LmFkZEhMU0pTPWZ1bmN0aW9uKHQpe2UuYWRkSExTSlMoaSx0KX0sbi5tdXguYWRkRGFzaEpTPWZ1bmN0aW9uKHQpe2UuYWRkRGFzaEpTKGksdCl9LG4ubXV4LnJlbW92ZUhMU0pTPWZ1bmN0aW9uKCl7ZS5yZW1vdmVITFNKUyhpKX0sbi5tdXgucmVtb3ZlRGFzaEpTPWZ1bmN0aW9uKCl7ZS5yZW1vdmVEYXNoSlMoaSl9LGUuaW5pdChpLHIpLGUuZW1pdChpLFwicGxheWVycmVhZHlcIiksbi5wYXVzZWR8fChlLmVtaXQoaSxcInBsYXlcIiksbi5yZWFkeVN0YXRlPjImJmUuZW1pdChpLFwicGxheWluZ1wiKSksbi5tdXgubGlzdGVuZXJzPXt9LFN0LmZvckVhY2goKGZ1bmN0aW9uKHQpeyhcImVycm9yXCIhPT10fHxyLmF1dG9tYXRpY0Vycm9yVHJhY2tpbmcpJiYobi5tdXgubGlzdGVuZXJzW3RdPWZ1bmN0aW9uKCl7dmFyIHI9e307aWYoXCJlcnJvclwiPT09dCl7aWYoIW4uZXJyb3IpcmV0dXJuO2lmKDE9PT1uLmVycm9yLmNvZGUpcmV0dXJuO3IucGxheWVyX2Vycm9yX2NvZGU9bi5lcnJvci5jb2RlLHIucGxheWVyX2Vycm9yX21lc3NhZ2U9cXRbbi5lcnJvci5jb2RlXXx8bi5lcnJvci5tZXNzYWdlfWUuZW1pdChpLHQscil9LG4uYWRkRXZlbnRMaXN0ZW5lcih0LG4ubXV4Lmxpc3RlbmVyc1t0XSwhMSkpfSkpfSgkdCxlLHQpfSxkZXN0cm95TW9uaXRvcjpmdW5jdGlvbihlKXt2YXIgdD16dCh1KGUpLDEpWzBdO3QmJnQubXV4JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm11eC5kZXN0cm95P3QubXV4LmRlc3Ryb3koKTpmLmVycm9yKFwiQSB2aWRlbyBlbGVtZW50IG1vbml0b3IgZm9yIGBcIitlK1wiYCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgdmlhIGBtdXgubW9uaXRvcmAuXCIpfSxhZGRITFNKUzpmdW5jdGlvbihlLHQpe3ZhciByPXMoZSk7WHRbcl0/WHRbcl0uYWRkSExTSlModCk6Zi5lcnJvcihcIkEgbW9uaXRvciBmb3IgYFwiK3IrXCJgIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC5cIil9LGFkZERhc2hKUzpmdW5jdGlvbihlLHQpe3ZhciByPXMoZSk7WHRbcl0/WHRbcl0uYWRkRGFzaEpTKHQpOmYuZXJyb3IoXCJBIG1vbml0b3IgZm9yIGBcIityK1wiYCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuXCIpfSxyZW1vdmVITFNKUzpmdW5jdGlvbihlKXt2YXIgdD1zKGUpO1h0W3RdP1h0W3RdLnJlbW92ZUhMU0pTKCk6Zi5lcnJvcihcIkEgbW9uaXRvciBmb3IgYFwiK3QrXCJgIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC5cIil9LHJlbW92ZURhc2hKUzpmdW5jdGlvbihlKXt2YXIgdD1zKGUpO1h0W3RdP1h0W3RdLnJlbW92ZURhc2hKUygpOmYuZXJyb3IoXCJBIG1vbml0b3IgZm9yIGBcIit0K1wiYCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuXCIpfSxpbml0OmZ1bmN0aW9uKGUsdCl7cCgpJiZ0JiZ0LnJlc3BlY3REb05vdFRyYWNrJiZmLmluZm8oXCJUaGUgYnJvd3NlcidzIERvIE5vdCBUcmFjayBmbGFnIGlzIGVuYWJsZWQgLSBNdXggYmVhY29uaW5nIGlzIGRpc2FibGVkLlwiKTt2YXIgcj1zKGUpO1h0W3JdPW5ldyB3dCgkdCxyLHQpfSxlbWl0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1zKGUpO1h0W2FdPyhYdFthXS5lbWl0KHQsciksXCJkZXN0cm95XCI9PT10JiZkZWxldGUgWHRbYV0pOmYuZXJyb3IoXCJBIG1vbml0b3IgZm9yIGBcIithK1wiYCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuXCIpfSxjaGVja0RvTm90VHJhY2s6cCxsb2c6Zix1dGlsczpKdCxldmVudHM6S3QsV0lORE9XX0hJRERFTjohMSxXSU5ET1dfVU5MT0FESU5HOiExfTtPYmplY3QuYXNzaWduKCR0LFp0KSx2b2lkIDAhPT1uKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIG4oKS5hZGRFdmVudExpc3RlbmVyJiZuKCkuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsKGZ1bmN0aW9uKGUpe2UucGVyc2lzdGVkfHwoJHQuV0lORE9XX1VOTE9BRElORz0hMCl9KSwhMSk7dmFyIGVyPSR0fSw2NTU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhLG47ZnVuY3Rpb24gaShlKXtyZXR1cm4gaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSxpKGUpXG4vKiFcbiAqIEphdmFTY3JpcHQgQ29va2llIHYyLjEuM1xuICogaHR0cHM6Ly9naXRodWIuY29tL2pzLWNvb2tpZS9qcy1jb29raWVcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiwgMjAxNSBLbGF1cyBIYXJ0bCAmIEZhZ25lciBCcmFja1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi99IWZ1bmN0aW9uKG8pe3ZhciBzPSExO2lmKHZvaWQgMD09PShuPVwiZnVuY3Rpb25cIj09dHlwZW9mKGE9byk/YS5jYWxsKHQscix0LGUpOmEpfHwoZS5leHBvcnRzPW4pLHM9ITAsXCJvYmplY3RcIj09PWkodCkmJihlLmV4cG9ydHM9bygpLHM9ITApLCFzKXt2YXIgdT13aW5kb3cuQ29va2llcyxsPXdpbmRvdy5Db29raWVzPW8oKTtsLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LkNvb2tpZXM9dSxsfX19KChmdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTAsdD17fTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1hcmd1bWVudHNbZV07Zm9yKHZhciBhIGluIHIpdFthXT1yW2FdfXJldHVybiB0fTtyZXR1cm4gZnVuY3Rpb24gdChyKXtmdW5jdGlvbiBhKHQsbixpKXt2YXIgbztpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7aWYoXCJudW1iZXJcIj09dHlwZW9mKGk9ZSh7cGF0aDpcIi9cIn0sYS5kZWZhdWx0cyxpKSkuZXhwaXJlcyl7dmFyIHM9bmV3IERhdGU7cy5zZXRNaWxsaXNlY29uZHMocy5nZXRNaWxsaXNlY29uZHMoKSs4NjRlNSppLmV4cGlyZXMpLGkuZXhwaXJlcz1zfXRyeXtvPUpTT04uc3RyaW5naWZ5KG4pLC9eW1xce1xcW10vLnRlc3QobykmJihuPW8pfWNhdGNoKGUpe31yZXR1cm4gbj1yLndyaXRlP3Iud3JpdGUobix0KTplbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG4pKS5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDNBfDNDfDNFfDNEfDJGfDNGfDQwfDVCfDVEfDVFfDYwfDdCfDdEfDdDKS9nLGRlY29kZVVSSUNvbXBvbmVudCksdD0odD0odD1lbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHQpKSkucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnw1RXw2MHw3QykvZyxkZWNvZGVVUklDb21wb25lbnQpKS5yZXBsYWNlKC9bXFwoXFwpXS9nLGVzY2FwZSksZG9jdW1lbnQuY29va2llPVt0LFwiPVwiLG4saS5leHBpcmVzP1wiOyBleHBpcmVzPVwiK2kuZXhwaXJlcy50b1VUQ1N0cmluZygpOlwiXCIsaS5wYXRoP1wiOyBwYXRoPVwiK2kucGF0aDpcIlwiLGkuZG9tYWluP1wiOyBkb21haW49XCIraS5kb21haW46XCJcIixpLnNlY3VyZT9cIjsgc2VjdXJlXCI6XCJcIl0uam9pbihcIlwiKX10fHwobz17fSk7Zm9yKHZhciB1PWRvY3VtZW50LmNvb2tpZT9kb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKTpbXSxsPS8oJVswLTlBLVpdezJ9KSsvZyxkPTA7ZDx1Lmxlbmd0aDtkKyspe3ZhciBjPXVbZF0uc3BsaXQoXCI9XCIpLGY9Yy5zbGljZSgxKS5qb2luKFwiPVwiKTsnXCInPT09Zi5jaGFyQXQoMCkmJihmPWYuc2xpY2UoMSwtMSkpO3RyeXt2YXIgcD1jWzBdLnJlcGxhY2UobCxkZWNvZGVVUklDb21wb25lbnQpO2lmKGY9ci5yZWFkP3IucmVhZChmLHApOnIoZixwKXx8Zi5yZXBsYWNlKGwsZGVjb2RlVVJJQ29tcG9uZW50KSx0aGlzLmpzb24pdHJ5e2Y9SlNPTi5wYXJzZShmKX1jYXRjaChlKXt9aWYodD09PXApe289ZjticmVha310fHwob1twXT1mKX1jYXRjaChlKXt9fXJldHVybiBvfX1yZXR1cm4gYS5zZXQ9YSxhLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gYS5jYWxsKGEsZSl9LGEuZ2V0SlNPTj1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KHtqc29uOiEwfSxbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfSxhLmRlZmF1bHRzPXt9LGEucmVtb3ZlPWZ1bmN0aW9uKHQscil7YSh0LFwiXCIsZShyLHtleHBpcmVzOi0xfSkpfSxhLndpdGhDb252ZXJ0ZXI9dCxhfSgoZnVuY3Rpb24oKXt9KSl9KSl9LDE1MzpmdW5jdGlvbihlLHQscil7dmFyIGEsbj12b2lkIDAhPT1yLmc/ci5nOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9LGk9cig1NTgpO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudD9hPWRvY3VtZW50OihhPW5bXCJfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0XCJdKXx8KGE9bltcIl9fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDRcIl09aSksZS5leHBvcnRzPWF9LDQ4OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYTthPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnZvaWQgMCE9PXIuZz9yLmc6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp7fSxlLmV4cG9ydHM9YX0sNjQwOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYSxuOyFmdW5jdGlvbihpLG8pe1widXNlIHN0cmljdFwiO2E9ZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbigpe30sdD1cInVuZGVmaW5lZFwiLHI9dHlwZW9mIHdpbmRvdyE9PXQmJnR5cGVvZiB3aW5kb3cubmF2aWdhdG9yIT09dCYmL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLGE9W1widHJhY2VcIixcImRlYnVnXCIsXCJpbmZvXCIsXCJ3YXJuXCIsXCJlcnJvclwiXTtmdW5jdGlvbiBuKGUsdCl7dmFyIHI9ZVt0XTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmJpbmQpcmV0dXJuIHIuYmluZChlKTt0cnl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwocixlKX1jYXRjaCh0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHIsW2UsYXJndW1lbnRzXSl9fX1mdW5jdGlvbiBpKCl7Y29uc29sZS5sb2cmJihjb25zb2xlLmxvZy5hcHBseT9jb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cyk6RnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLFtjb25zb2xlLGFyZ3VtZW50c10pKSxjb25zb2xlLnRyYWNlJiZjb25zb2xlLnRyYWNlKCl9ZnVuY3Rpb24gbyhhKXtyZXR1cm5cImRlYnVnXCI9PT1hJiYoYT1cImxvZ1wiKSx0eXBlb2YgY29uc29sZSE9PXQmJihcInRyYWNlXCI9PT1hJiZyP2k6dm9pZCAwIT09Y29uc29sZVthXT9uKGNvbnNvbGUsYSk6dm9pZCAwIT09Y29uc29sZS5sb2c/bihjb25zb2xlLFwibG9nXCIpOmUpfWZ1bmN0aW9uIHModCxyKXtmb3IodmFyIG49MDtuPGEubGVuZ3RoO24rKyl7dmFyIGk9YVtuXTt0aGlzW2ldPW48dD9lOnRoaXMubWV0aG9kRmFjdG9yeShpLHQscil9dGhpcy5sb2c9dGhpcy5kZWJ1Z31mdW5jdGlvbiB1KGUscixhKXtyZXR1cm4gZnVuY3Rpb24oKXt0eXBlb2YgY29uc29sZSE9PXQmJihzLmNhbGwodGhpcyxyLGEpLHRoaXNbZV0uYXBwbHkodGhpcyxhcmd1bWVudHMpKX19ZnVuY3Rpb24gbChlLHQscil7cmV0dXJuIG8oZSl8fHUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGQoZSxyLG4pe3ZhciBpLG89dGhpcztyPW51bGw9PXI/XCJXQVJOXCI6cjt2YXIgdT1cImxvZ2xldmVsXCI7ZnVuY3Rpb24gZChlKXt2YXIgcj0oYVtlXXx8XCJzaWxlbnRcIikudG9VcHBlckNhc2UoKTtpZih0eXBlb2Ygd2luZG93IT09dCYmdSl7dHJ5e3JldHVybiB2b2lkKHdpbmRvdy5sb2NhbFN0b3JhZ2VbdV09cil9Y2F0Y2goZSl7fXRyeXt3aW5kb3cuZG9jdW1lbnQuY29va2llPWVuY29kZVVSSUNvbXBvbmVudCh1KStcIj1cIityK1wiO1wifWNhdGNoKGUpe319fWZ1bmN0aW9uIGMoKXt2YXIgZTtpZih0eXBlb2Ygd2luZG93IT09dCYmdSl7dHJ5e2U9d2luZG93LmxvY2FsU3RvcmFnZVt1XX1jYXRjaChlKXt9aWYodHlwZW9mIGU9PT10KXRyeXt2YXIgcj13aW5kb3cuZG9jdW1lbnQuY29va2llLGE9ci5pbmRleE9mKGVuY29kZVVSSUNvbXBvbmVudCh1KStcIj1cIik7LTEhPT1hJiYoZT0vXihbXjtdKykvLmV4ZWMoci5zbGljZShhKSlbMV0pfWNhdGNoKGUpe31yZXR1cm4gdm9pZCAwPT09by5sZXZlbHNbZV0mJihlPXZvaWQgMCksZX19ZnVuY3Rpb24gZigpe2lmKHR5cGVvZiB3aW5kb3chPT10JiZ1KXt0cnl7cmV0dXJuIHZvaWQgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHUpfWNhdGNoKGUpe310cnl7d2luZG93LmRvY3VtZW50LmNvb2tpZT1lbmNvZGVVUklDb21wb25lbnQodSkrXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCJ9Y2F0Y2goZSl7fX19XCJzdHJpbmdcIj09dHlwZW9mIGU/dSs9XCI6XCIrZTpcInN5bWJvbFwiPT10eXBlb2YgZSYmKHU9dm9pZCAwKSxvLm5hbWU9ZSxvLmxldmVscz17VFJBQ0U6MCxERUJVRzoxLElORk86MixXQVJOOjMsRVJST1I6NCxTSUxFTlQ6NX0sby5tZXRob2RGYWN0b3J5PW58fGwsby5nZXRMZXZlbD1mdW5jdGlvbigpe3JldHVybiBpfSxvLnNldExldmVsPWZ1bmN0aW9uKHIsYSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJnZvaWQgMCE9PW8ubGV2ZWxzW3IudG9VcHBlckNhc2UoKV0mJihyPW8ubGV2ZWxzW3IudG9VcHBlckNhc2UoKV0pLCEoXCJudW1iZXJcIj09dHlwZW9mIHImJnI+PTAmJnI8PW8ubGV2ZWxzLlNJTEVOVCkpdGhyb3dcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiK3I7aWYoaT1yLCExIT09YSYmZChyKSxzLmNhbGwobyxyLGUpLHR5cGVvZiBjb25zb2xlPT09dCYmcjxvLmxldmVscy5TSUxFTlQpcmV0dXJuXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wifSxvLnNldERlZmF1bHRMZXZlbD1mdW5jdGlvbihlKXtyPWUsYygpfHxvLnNldExldmVsKGUsITEpfSxvLnJlc2V0TGV2ZWw9ZnVuY3Rpb24oKXtvLnNldExldmVsKHIsITEpLGYoKX0sby5lbmFibGVBbGw9ZnVuY3Rpb24oZSl7by5zZXRMZXZlbChvLmxldmVscy5UUkFDRSxlKX0sby5kaXNhYmxlQWxsPWZ1bmN0aW9uKGUpe28uc2V0TGV2ZWwoby5sZXZlbHMuU0lMRU5ULGUpfTt2YXIgcD1jKCk7bnVsbD09cCYmKHA9ciksby5zZXRMZXZlbChwLCExKX12YXIgYz1uZXcgZCxmPXt9O2MuZ2V0TG9nZ2VyPWZ1bmN0aW9uKGUpe2lmKFwic3ltYm9sXCIhPXR5cGVvZiBlJiZcInN0cmluZ1wiIT10eXBlb2YgZXx8XCJcIj09PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7dmFyIHQ9ZltlXTtyZXR1cm4gdHx8KHQ9ZltlXT1uZXcgZChlLGMuZ2V0TGV2ZWwoKSxjLm1ldGhvZEZhY3RvcnkpKSx0fTt2YXIgcD10eXBlb2Ygd2luZG93IT09dD93aW5kb3cubG9nOnZvaWQgMDtyZXR1cm4gYy5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHR5cGVvZiB3aW5kb3chPT10JiZ3aW5kb3cubG9nPT09YyYmKHdpbmRvdy5sb2c9cCksY30sYy5nZXRMb2dnZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGZ9LGMuZGVmYXVsdD1jLGN9LHZvaWQgMD09PShuPVwiZnVuY3Rpb25cIj09dHlwZW9mIGE/YS5jYWxsKHQscix0LGUpOmEpfHwoZS5leHBvcnRzPW4pfSgpfSwzNzU6ZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgcj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGEoZSl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZS5yZXBsYWNlKC9cXCsvZyxcIiBcIikpfWNhdGNoKGUpe3JldHVybiBudWxsfX1mdW5jdGlvbiBuKGUpe3RyeXtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGUpfWNhdGNoKGUpe3JldHVybiBudWxsfX10LnN0cmluZ2lmeT1mdW5jdGlvbihlLHQpe3Q9dHx8XCJcIjt2YXIgYSxpLG89W107Zm9yKGkgaW5cInN0cmluZ1wiIT10eXBlb2YgdCYmKHQ9XCI/XCIpLGUpaWYoci5jYWxsKGUsaSkpe2lmKChhPWVbaV0pfHxudWxsIT1hJiYhaXNOYU4oYSl8fChhPVwiXCIpLGk9bihpKSxhPW4oYSksbnVsbD09PWl8fG51bGw9PT1hKWNvbnRpbnVlO28ucHVzaChpK1wiPVwiK2EpfXJldHVybiBvLmxlbmd0aD90K28uam9pbihcIiZcIik6XCJcIn0sdC5wYXJzZT1mdW5jdGlvbihlKXtmb3IodmFyIHQscj0vKFtePT8jJl0rKT0/KFteJl0qKS9nLG49e307dD1yLmV4ZWMoZSk7KXt2YXIgaT1hKHRbMV0pLG89YSh0WzJdKTtudWxsPT09aXx8bnVsbD09PW98fGkgaW4gbnx8KG5baV09byl9cmV0dXJuIG59fSw1NTg6ZnVuY3Rpb24oKXt9fSx0PXt9O2Z1bmN0aW9uIHIoYSl7dmFyIG49dFthXTtpZih2b2lkIDAhPT1uKXJldHVybiBuLmV4cG9ydHM7dmFyIGk9dFthXT17ZXhwb3J0czp7fX07cmV0dXJuIGVbYV0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5leHBvcnRzfXJldHVybiByLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHIuZCh0LHthOnR9KSx0fSxyLmQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGEgaW4gdClyLm8odCxhKSYmIXIubyhlLGEpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLHtlbnVtZXJhYmxlOiEwLGdldDp0W2FdfSl9LHIuZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChlKXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLHIubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0scig4MCl9KCl9LFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLm11eD10KCk6ZS5tdXg9dCgpfSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/mux-embed/dist/mux.js\n"));

/***/ }),

/***/ "(app-client)/./src/app/(bettor)/gameView/page.tsx":
/*!********************************************!*\
  !*** ./src/app/(bettor)/gameView/page.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameView; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mui/material */ \"(app-client)/./node_modules/@mui/material/Grid/Grid.js\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mui/material */ \"(app-client)/./node_modules/@mui/material/Typography/Typography.js\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @mui/material */ \"(app-client)/./node_modules/@mui/material/Button/Button.js\");\n/* harmony import */ var _mui_icons_material_Circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mui/icons-material/Circle */ \"(app-client)/./node_modules/@mui/icons-material/Circle.js\");\n/* harmony import */ var _publicComponents_customStyles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/publicComponents/customStyles */ \"(app-client)/./src/publicComponents/customStyles.tsx\");\n/* harmony import */ var _mui_icons_material_East__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @mui/icons-material/East */ \"(app-client)/./node_modules/@mui/icons-material/East.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _publicComponents_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/publicComponents/header */ \"(app-client)/./src/publicComponents/header.tsx\");\n/* harmony import */ var _mux_mux_player_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mux/mux-player-react */ \"(app-client)/./node_modules/@mux/mux-player-react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\nconst rounds = [\n    {\n        fightNo: \"1\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"2\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"3\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"4\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"5\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"6\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"7\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"8\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"9\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"10\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"11\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"12\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"13\",\n        winner: \"meron\"\n    },\n    {\n        fightNo: \"14\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"15\",\n        winner: \"wala\"\n    },\n    {\n        fightNo: \"16\",\n        winner: \"wala\"\n    }\n];\nconst GameHeader = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                columns: 12,\n                container: true,\n                flexDirection: \"row\",\n                justifyContent: \"space-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        item: true,\n                        md: true,\n                        sm: true,\n                        xs: true,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            sx: {\n                                color: \"white\"\n                            },\n                            variant: \"h6\",\n                            children: \"Fight #1\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 39,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        item: true,\n                        md: true,\n                        sm: true,\n                        xs: true,\n                        textAlign: \"right\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            sx: {\n                                color: \"white\",\n                                display: \"flex\",\n                                justifyContent: \"flex-end\",\n                                alignItems: \"center\"\n                            },\n                            variant: \"body2\",\n                            children: [\n                                \"Last Call \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_icons_material_Circle__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                    style: {\n                                        color: \"white\",\n                                        paddingLeft: \"10px\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                    lineNumber: 44,\n                                    columnNumber: 47\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 43,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 42,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 38,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                variant: \"body2\",\n                sx: {\n                    color: \"white\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        variant: \"caption\",\n                        sx: {\n                            backgroundColor: \"red\",\n                            padding: \"5px\",\n                            borderRadius: \"3px\",\n                            color: \"white\"\n                        },\n                        children: \"MIRROR\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 48,\n                        columnNumber: 17\n                    }, undefined),\n                    \"Private Sabong\",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        variant: \"caption\",\n                        sx: {\n                            color: \"white\"\n                        },\n                        children: \"(300 exp. fights)\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 50,\n                        columnNumber: 17\n                    }, undefined),\n                    \"(300 exp. fights)\"\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 47,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n        lineNumber: 37,\n        columnNumber: 9\n    }, undefined);\n};\n_c = GameHeader;\nconst BetButtons = ()=>{\n    const handleBet = (side)=>{\n        const submitBet = async ()=>{\n        // const apiResponse = await bet_api(\"\")\n        };\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n            columns: 12,\n            container: true,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                    item: true,\n                    sm: true,\n                    md: true,\n                    xs: true,\n                    lg: true,\n                    xl: true,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                backgroundColor: \"maroon\",\n                                color: \"white\",\n                                minWidth: \"100%\",\n                                textAlign: \"center\"\n                            },\n                            children: \"MERON\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 65,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                backgroundColor: \"red\",\n                                minWidth: \"100%\",\n                                textAlign: \"center\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                    sx: {\n                                        color: \"white\",\n                                        padding: \"1rem\"\n                                    },\n                                    variant: \"h6\",\n                                    children: \"0.00\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                    lineNumber: 69,\n                                    columnNumber: 25\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                    style: {\n                                        backgroundColor: _publicComponents_customStyles__WEBPACK_IMPORTED_MODULE_1__.colors.gold,\n                                        color: \"black\",\n                                        padding: \"1em 1em\",\n                                        marginBottom: \"2rem\"\n                                    },\n                                    onClick: ()=>handleBet(\"meron\"),\n                                    children: \"CHOOSE MERON\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                    lineNumber: 73,\n                                    columnNumber: 25\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 68,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                    lineNumber: 64,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                    item: true,\n                    sm: true,\n                    md: true,\n                    xs: true,\n                    lg: true,\n                    xl: true,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                backgroundColor: \"#0404b1\",\n                                color: \"white\",\n                                textAlign: \"center\"\n                            },\n                            children: \"WALA\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 84,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                backgroundColor: \"blue\",\n                                textAlign: \"center\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                    sx: {\n                                        color: \"white\",\n                                        padding: \"1rem\"\n                                    },\n                                    variant: \"h6\",\n                                    children: \"0.00\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                    lineNumber: 88,\n                                    columnNumber: 25\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                    style: {\n                                        backgroundColor: _publicComponents_customStyles__WEBPACK_IMPORTED_MODULE_1__.colors.gold,\n                                        color: \"black\",\n                                        padding: \"1em 1em\",\n                                        marginBottom: \"2rem\"\n                                    },\n                                    onClick: ()=>handleBet(\"wala\"),\n                                    children: \"CHOOSE WALA\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 25\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                            lineNumber: 87,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                    lineNumber: 83,\n                    columnNumber: 17\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n            lineNumber: 63,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n        lineNumber: 62,\n        columnNumber: 9\n    }, undefined);\n};\n_c1 = BetButtons;\nconst Trends = (param)=>{\n    let { isMeron, textValue } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            border: \"1px solid gray\",\n            maxWidth: \"25px\",\n            maxHeight: \"25px\",\n            minWidth: \"25px\",\n            minHeight: \"25px\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                backgroundColor: isMeron ? \"red\" : \"blue\",\n                borderRadius: \"50%\",\n                color: \"white\"\n            },\n            children: textValue\n        }, void 0, false, {\n            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n            lineNumber: 114,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n        lineNumber: 107,\n        columnNumber: 9\n    }, undefined);\n};\n_c2 = Trends;\nfunction GameView() {\n    const LiveStreamComponent = ()=>{\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                minWidth: \"100%\"\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mux_mux_player_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                streamType: \"ll-live\",\n                playbackId: \"MRLwgB4HRQkeUmbPXZS2aDbdqOz100yvX1BG17JJv68M\",\n                autoPlay: true,\n                metadata: {\n                    video_id: \"video-id-54321\",\n                    video_title: \"Test video title\",\n                    viewer_user_id: \"user-id-007\"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 124,\n                columnNumber: 13\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n            lineNumber: 121,\n            columnNumber: 11\n        }, this);\n    };\n    let counter = 0;\n    const trendCountList = [];\n    rounds.forEach((val, index)=>{\n        const isMeron = val.winner === \"meron\";\n        if (index === 0 || rounds[index].winner !== rounds[index - 1].winner) {\n            counter = 1;\n        } else {\n            counter++;\n        }\n        if (index === rounds.length - 1 || rounds[index].winner !== rounds[index + 1].winner) {\n            trendCountList.push({\n                count: counter,\n                isMeron: val.winner === \"meron\"\n            });\n        }\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_publicComponents_header__WEBPACK_IMPORTED_MODULE_3__.LoggedHeader, {}, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 159,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LiveStreamComponent, {}, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 160,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GameHeader, {}, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 161,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BetButtons, {}, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 162,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 163,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        variant: \"h6\",\n                        sx: {\n                            color: \"white\"\n                        },\n                        children: [\n                            \"Trends \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_icons_material_East__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                lineNumber: 165,\n                                columnNumber: 71\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 165,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            maxWidth: \"100vw\",\n                            minHeight: \"20vh\",\n                            padding: \"2em 0em\",\n                            overflowX: \"auto\"\n                        },\n                        children: trendCountList.map((val, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    flexDirection: \"column\"\n                                },\n                                children: Array.from({\n                                    length: val.count\n                                }).map((_, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Trends, {\n                                        isMeron: val.isMeron,\n                                        textValue: \"\".concat(index)\n                                    }, i + index, false, {\n                                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                        lineNumber: 171,\n                                        columnNumber: 33\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                                lineNumber: 169,\n                                columnNumber: 29\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                        lineNumber: 166,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n                lineNumber: 164,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\eSabong\\\\frontend\\\\src\\\\app\\\\(bettor)\\\\gameView\\\\page.tsx\",\n        lineNumber: 158,\n        columnNumber: 9\n    }, this);\n}\n_c3 = GameView;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"GameHeader\");\n$RefreshReg$(_c1, \"BetButtons\");\n$RefreshReg$(_c2, \"Trends\");\n$RefreshReg$(_c3, \"GameView\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2FwcC8oYmV0dG9yKS9nYW1lVmlldy9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ3dEO0FBQ0o7QUFDSztBQUNUO0FBQ3RCO0FBRStCO0FBQ1g7QUFROUMsTUFBTVMsU0FBa0I7SUFDcEI7UUFBQ0MsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU07SUFDN0I7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU87SUFDOUI7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU07SUFDN0I7UUFBQ0QsU0FBUztRQUFLQyxRQUFRO0lBQU07SUFDN0I7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU07SUFDOUI7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU87SUFDL0I7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU07SUFDOUI7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU87SUFDL0I7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU07SUFDOUI7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU07SUFDOUI7UUFBQ0QsU0FBUztRQUFNQyxRQUFRO0lBQU07Q0FDakM7QUFDRCxNQUFNQyxhQUFhO0lBQ2YscUJBQ0ksOERBQUNDOzswQkFDRyw4REFBQ1oscURBQUlBO2dCQUFDYSxTQUFTO2dCQUFJQyxTQUFTO2dCQUFDQyxlQUFlO2dCQUFPQyxnQkFBZ0I7O2tDQUMvRCw4REFBQ2hCLHFEQUFJQTt3QkFBQ2lCLElBQUk7d0JBQUNDLEVBQUU7d0JBQUNDLEVBQUU7d0JBQUNDLEVBQUU7a0NBQ2YsNEVBQUNuQixxREFBVUE7NEJBQUNvQixJQUFJO2dDQUFDQyxPQUFPOzRCQUFPOzRCQUFHQyxTQUFRO3NDQUFLOzs7Ozs7Ozs7OztrQ0FFbkQsOERBQUN2QixxREFBSUE7d0JBQUNpQixJQUFJO3dCQUFDQyxFQUFFO3dCQUFDQyxFQUFFO3dCQUFDQyxFQUFFO3dCQUFDSSxXQUFXO2tDQUMzQiw0RUFBQ3ZCLHFEQUFVQTs0QkFBQ29CLElBQUk7Z0NBQUNDLE9BQU87Z0NBQVNHLFNBQVM7Z0NBQVFULGdCQUFnQjtnQ0FBWVUsWUFBVzs0QkFBUTs0QkFDakdILFNBQVE7O2dDQUFROzhDQUFVLDhEQUFDckIsa0VBQVVBO29DQUFDeUIsT0FBTzt3Q0FBQ0wsT0FBTzt3Q0FBU00sYUFBYTtvQ0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBR3pGLDhEQUFDM0IscURBQVVBO2dCQUFDc0IsU0FBUTtnQkFBUUYsSUFBSTtvQkFBQ0MsT0FBTztnQkFBTzs7a0NBQzNDLDhEQUFDckIscURBQVVBO3dCQUFDc0IsU0FBUTt3QkFBVUYsSUFBSTs0QkFBQ1EsaUJBQWdCOzRCQUFPQyxTQUFTOzRCQUFPQyxjQUFjOzRCQUFPVCxPQUFPO3dCQUFPO2tDQUFHOzs7Ozs7b0JBQW1CO2tDQUVuSSw4REFBQ3JCLHFEQUFVQTt3QkFBQ3NCLFNBQVE7d0JBQVVGLElBQUk7NEJBQUNDLE9BQU87d0JBQU87a0NBQUc7Ozs7OztvQkFBOEI7Ozs7Ozs7Ozs7Ozs7QUFJbEc7S0FuQk1YO0FBb0JOLE1BQU1xQixhQUFhO0lBQ2YsTUFBTUMsWUFBWSxDQUFDQztRQUNmLE1BQU1DLFlBQVk7UUFDZCx3Q0FBd0M7UUFDNUM7SUFDSjtJQUNBLHFCQUNJLDhEQUFDdkI7a0JBQ0csNEVBQUNaLHFEQUFJQTtZQUFDYSxTQUFTO1lBQUlDLFNBQVM7OzhCQUN4Qiw4REFBQ2QscURBQUlBO29CQUFDaUIsSUFBSTtvQkFBQ0UsRUFBRTtvQkFBQ0QsRUFBRTtvQkFBQ0UsRUFBRTtvQkFBQ2dCLEVBQUU7b0JBQUNDLEVBQUU7O3NDQUNyQiw4REFBQ3pCOzRCQUFJZSxPQUFPO2dDQUFDRSxpQkFBaUI7Z0NBQVVQLE9BQU87Z0NBQVNnQixVQUFVO2dDQUFRZCxXQUFVOzRCQUFRO3NDQUFHOzs7Ozs7c0NBRy9GLDhEQUFDWjs0QkFBSWUsT0FBTztnQ0FBQ0UsaUJBQWlCO2dDQUFPUyxVQUFVO2dDQUFRZCxXQUFVOzRCQUFROzs4Q0FDckUsOERBQUN2QixxREFBVUE7b0NBQUNvQixJQUFJO3dDQUFDQyxPQUFPO3dDQUFTUSxTQUFTO29DQUFNO29DQUFHUCxTQUFROzhDQUM0Qjs7Ozs7OzhDQUd2Riw4REFBQ3hCLHFEQUFNQTtvQ0FBQzRCLE9BQU87d0NBQ1hFLGlCQUFpQjFCLGtFQUFNQSxDQUFDb0MsSUFBSTt3Q0FDNUJqQixPQUFPO3dDQUNQUSxTQUFTO3dDQUNUVSxjQUFjO29DQUNsQjtvQ0FDQUMsU0FBUyxJQUFNUixVQUFVOzhDQUN4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUdULDhEQUFDakMscURBQUlBO29CQUFDaUIsSUFBSTtvQkFBQ0UsRUFBRTtvQkFBQ0QsRUFBRTtvQkFBQ0UsRUFBRTtvQkFBQ2dCLEVBQUU7b0JBQUNDLEVBQUU7O3NDQUNyQiw4REFBQ3pCOzRCQUFJZSxPQUFPO2dDQUFDRSxpQkFBaUI7Z0NBQVdQLE9BQU87Z0NBQVNFLFdBQVU7NEJBQVE7c0NBQUc7Ozs7OztzQ0FHOUUsOERBQUNaOzRCQUFJZSxPQUFPO2dDQUFDRSxpQkFBaUI7Z0NBQVFMLFdBQVU7NEJBQVE7OzhDQUNwRCw4REFBQ3ZCLHFEQUFVQTtvQ0FBQ29CLElBQUk7d0NBQUNDLE9BQU87d0NBQVNRLFNBQVM7b0NBQU07b0NBQUdQLFNBQVE7OENBQUs7Ozs7Ozs4Q0FHaEUsOERBQUN4QixxREFBTUE7b0NBQUM0QixPQUFPO3dDQUNYRSxpQkFBaUIxQixrRUFBTUEsQ0FBQ29DLElBQUk7d0NBQzVCakIsT0FBTzt3Q0FDUFEsU0FBUzt3Q0FDVFUsY0FBYztvQ0FDbEI7b0NBQ0FDLFNBQVMsSUFBTVIsVUFBVTs4Q0FDeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXpCO01BakRNRDtBQWtETixNQUFNVSxTQUFTO1FBQUMsRUFBQ0MsT0FBTyxFQUFFQyxTQUFTLEVBQXVDO0lBQ3RFLHFCQUNJLDhEQUFDaEM7UUFBSWUsT0FBTztZQUNSa0IsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWFQsVUFBVTtZQUNWVSxXQUFXO1FBQ2Y7a0JBQ0ksNEVBQUNwQztZQUFJZSxPQUFPO2dCQUFDRSxpQkFBaUJjLFVBQVUsUUFBTztnQkFBUVosY0FBYztnQkFBT1QsT0FBTztZQUFPO3NCQUFJc0I7Ozs7Ozs7Ozs7O0FBRzFHO01BWk1GO0FBYVMsU0FBU087SUFDcEIsTUFBTUMsc0JBQXNCO1FBQ3hCLHFCQUNFLDhEQUFDdEM7WUFBSWUsT0FBTztnQkFDVlcsVUFBVTtZQUNaO3NCQUNFLDRFQUFDL0IsNkRBQVNBO2dCQUNONEMsWUFBVztnQkFDWEMsWUFBVztnQkFDWEMsVUFBVTtnQkFDVkMsVUFBVTtvQkFDTkMsVUFBVTtvQkFDVkMsYUFBYTtvQkFDYkMsZ0JBQWdCO2dCQUNwQjs7Ozs7Ozs7Ozs7SUFJVjtJQUNGLElBQUlDLFVBQVU7SUFLZCxNQUFNQyxpQkFBK0IsRUFBRTtJQUV2Q25ELE9BQU9vRCxPQUFPLENBQUMsQ0FBQ0MsS0FBS0M7UUFDakIsTUFBTW5CLFVBQW1Ca0IsSUFBSW5ELE1BQU0sS0FBSztRQUV4QyxJQUFJb0QsVUFBVSxLQUFLdEQsTUFBTSxDQUFDc0QsTUFBTSxDQUFDcEQsTUFBTSxLQUFLRixNQUFNLENBQUNzRCxRQUFRLEVBQUUsQ0FBQ3BELE1BQU0sRUFBRTtZQUNsRWdELFVBQVU7UUFDZCxPQUFPO1lBQ0hBO1FBQ0o7UUFFQSxJQUFJSSxVQUFVdEQsT0FBT3VELE1BQU0sR0FBRyxLQUFLdkQsTUFBTSxDQUFDc0QsTUFBTSxDQUFDcEQsTUFBTSxLQUFLRixNQUFNLENBQUNzRCxRQUFRLEVBQUUsQ0FBQ3BELE1BQU0sRUFBRTtZQUNsRmlELGVBQWVLLElBQUksQ0FBQztnQkFBQ0MsT0FBT1A7Z0JBQVNmLFNBQVNrQixJQUFJbkQsTUFBTSxLQUFLO1lBQU87UUFDeEU7SUFDSjtJQUNBLHFCQUNJLDhEQUFDRTs7MEJBQ0csOERBQUNOLGtFQUFZQTs7Ozs7MEJBQ2IsOERBQUM0Qzs7Ozs7MEJBQ0QsOERBQUN2Qzs7Ozs7MEJBQ0QsOERBQUNxQjs7Ozs7MEJBQ0QsOERBQUNrQzs7Ozs7MEJBQ0QsOERBQUN0RDs7a0NBQ0csOERBQUNYLHFEQUFVQTt3QkFBQ3NCLFNBQVE7d0JBQUtGLElBQUk7NEJBQUNDLE9BQU87d0JBQU87OzRCQUFHOzBDQUFPLDhEQUFDbEIsZ0VBQVFBOzs7Ozs7Ozs7OztrQ0FDL0QsOERBQUNRO3dCQUFJZSxPQUFPOzRCQUFFRixTQUFTOzRCQUFRcUIsVUFBVTs0QkFBU0UsV0FBVzs0QkFBUWxCLFNBQVM7NEJBQVdxQyxXQUFXO3dCQUFPO2tDQUVuR1IsZUFBZVMsR0FBRyxDQUFDLENBQUNQLEtBQUtRLGtCQUNyQiw4REFBQ3pEO2dDQUFJZSxPQUFPO29DQUFFRixTQUFTO29DQUFRVixlQUFlO2dDQUFTOzBDQUN0RHVELE1BQU1DLElBQUksQ0FBQztvQ0FBRVIsUUFBUUYsSUFBSUksS0FBSztnQ0FBQyxHQUFHRyxHQUFHLENBQUMsQ0FBQ0ksR0FBR1Ysc0JBQ3ZDLDhEQUFDcEI7d0NBQXVCQyxTQUFTa0IsSUFBSWxCLE9BQU87d0NBQUVDLFdBQVcsR0FBUyxPQUFOa0I7dUNBQS9DTyxJQUFJUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBY2pEO01BbkV3QmIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC8oYmV0dG9yKS9nYW1lVmlldy9wYWdlLnRzeD9mNTU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5pbXBvcnQgeyBCdXR0b24sIEdyaWQsIFR5cG9ncmFwaHkgfSBmcm9tIFwiQG11aS9tYXRlcmlhbFwiXHJcbmltcG9ydCBDaXJjbGVJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvQ2lyY2xlJztcclxuaW1wb3J0IHsgY29sb3JzIH0gZnJvbSBcIkAvcHVibGljQ29tcG9uZW50cy9jdXN0b21TdHlsZXNcIjtcclxuaW1wb3J0IEVhc3RJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvRWFzdCc7XHJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgaXNKc3hFbGVtZW50IH0gZnJvbSBcInR5cGVzY3JpcHRcIjtcclxuaW1wb3J0IHsgTG9nZ2VkSGVhZGVyIH0gZnJvbSBcIkAvcHVibGljQ29tcG9uZW50cy9oZWFkZXJcIjtcclxuaW1wb3J0IE11eFBsYXllciBmcm9tIFwiQG11eC9tdXgtcGxheWVyLXJlYWN0XCI7IFxyXG5pbXBvcnQgeyBiZXRfYXBpIH0gZnJvbSBcIkAvYXBpL2JldHRvci9iZXRcIjtcclxuXHJcbnR5cGUgUm91bmQgPSB7XHJcbiAgICB3aW5uZXI6ICdtZXJvbicgfCAnd2FsYSc7XHJcbiAgICBmaWdodE5vOiBzdHJpbmc7XHJcbn07XHJcbiAgXHJcbmNvbnN0IHJvdW5kczogUm91bmRbXSA9IFtcclxuICAgIHtmaWdodE5vOiAnMScsIHdpbm5lcjogJ21lcm9uJ30sXHJcbiAgICB7ZmlnaHRObzogJzInLCB3aW5uZXI6ICdtZXJvbid9LFxyXG4gICAge2ZpZ2h0Tm86ICczJywgd2lubmVyOiAnbWVyb24nfSxcclxuICAgIHtmaWdodE5vOiAnNCcsIHdpbm5lcjogJ21lcm9uJ30sXHJcbiAgICB7ZmlnaHRObzogJzUnLCB3aW5uZXI6ICd3YWxhJ30sXHJcbiAgICB7ZmlnaHRObzogJzYnLCB3aW5uZXI6ICdtZXJvbid9LFxyXG4gICAge2ZpZ2h0Tm86ICc3Jywgd2lubmVyOiAnbWVyb24nfSxcclxuICAgIHtmaWdodE5vOiAnOCcsIHdpbm5lcjogJ3dhbGEnfSxcclxuICAgIHtmaWdodE5vOiAnOScsIHdpbm5lcjogJ3dhbGEnfSxcclxuICAgIHtmaWdodE5vOiAnMTAnLCB3aW5uZXI6ICd3YWxhJ30sXHJcbiAgICB7ZmlnaHRObzogJzExJywgd2lubmVyOiAnbWVyb24nfSxcclxuICAgIHtmaWdodE5vOiAnMTInLCB3aW5uZXI6ICd3YWxhJ30sXHJcbiAgICB7ZmlnaHRObzogJzEzJywgd2lubmVyOiAnbWVyb24nfSxcclxuICAgIHtmaWdodE5vOiAnMTQnLCB3aW5uZXI6ICd3YWxhJ30sXHJcbiAgICB7ZmlnaHRObzogJzE1Jywgd2lubmVyOiAnd2FsYSd9LFxyXG4gICAge2ZpZ2h0Tm86ICcxNicsIHdpbm5lcjogJ3dhbGEnfSxcclxuXVxyXG5jb25zdCBHYW1lSGVhZGVyID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8R3JpZCBjb2x1bW5zPXsxMn0gY29udGFpbmVyIGZsZXhEaXJlY3Rpb249e1wicm93XCJ9IGp1c3RpZnlDb250ZW50PXsnc3BhY2UtYmV0d2Vlbid9PlxyXG4gICAgICAgICAgICAgICAgPEdyaWQgaXRlbSBtZCBzbSB4cz5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBzeD17e2NvbG9yOiAnd2hpdGUnfX0gdmFyaWFudD1cImg2XCI+RmlnaHQgIzE8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8R3JpZCBpdGVtIG1kIHNtIHhzIHRleHRBbGlnbj17J3JpZ2h0J30+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgc3g9e3tjb2xvcjogJ3doaXRlJywgZGlzcGxheTogJ2ZsZXgnLCBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJywgYWxpZ25JdGVtczonY2VudGVyJ319XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudD1cImJvZHkyXCI+TGFzdCBDYWxsIDxDaXJjbGVJY29uIHN0eWxlPXt7Y29sb3I6ICd3aGl0ZScsIHBhZGRpbmdMZWZ0OiAnMTBweCd9fSAvPjwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgPC9HcmlkPlxyXG4gICAgICAgICAgICA8VHlwb2dyYXBoeSB2YXJpYW50PVwiYm9keTJcIiBzeD17e2NvbG9yOiAnd2hpdGUnfX0+XHJcbiAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB2YXJpYW50PVwiY2FwdGlvblwiIHN4PXt7YmFja2dyb3VuZENvbG9yOidyZWQnLCBwYWRkaW5nOiAnNXB4JywgYm9yZGVyUmFkaXVzOiAnM3B4JywgY29sb3I6ICd3aGl0ZSd9fT5NSVJST1I8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICBQcml2YXRlIFNhYm9uZ1xyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdmFyaWFudD1cImNhcHRpb25cIiBzeD17e2NvbG9yOiAnd2hpdGUnfX0+KDMwMCBleHAuIGZpZ2h0cyk8L1R5cG9ncmFwaHk+KDMwMCBleHAuIGZpZ2h0cylcclxuICAgICAgICAgICAgPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcbmNvbnN0IEJldEJ1dHRvbnMgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVCZXQgPSAoc2lkZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3VibWl0QmV0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IGJldF9hcGkoXCJcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxHcmlkIGNvbHVtbnM9ezEyfSBjb250YWluZXI+XHJcbiAgICAgICAgICAgICAgICA8R3JpZCBpdGVtIHNtIG1kIHhzIGxnIHhsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3I6ICdtYXJvb24nLCBjb2xvcjogJ3doaXRlJywgbWluV2lkdGg6ICcxMDAlJywgdGV4dEFsaWduOidjZW50ZXInfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1FUk9OXHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e2JhY2tncm91bmRDb2xvcjogJ3JlZCcsIG1pbldpZHRoOiAnMTAwJScsIHRleHRBbGlnbjonY2VudGVyJ319PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBzeD17e2NvbG9yOiAnd2hpdGUnLCBwYWRkaW5nOiAnMXJlbSd9fSB2YXJpYW50PVwiaDZcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiA0MDAsMDAwLjxUeXBvZ3JhcGh5IHN4PXt7Y29sb3I6ICd3aGl0ZSd9fSB2YXJpYW50PVwiY2FwdGlvblwiPjAwPC9UeXBvZ3JhcGh5PiAqL31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5nb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMWVtIDFlbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcycmVtJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVCZXQoJ21lcm9uJyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5DSE9PU0UgTUVST048L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgICAgIDxHcmlkIGl0ZW0gc20gbWQgeHMgbGcgeGw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e2JhY2tncm91bmRDb2xvcjogJyMwNDA0YjEnLCBjb2xvcjogJ3doaXRlJywgdGV4dEFsaWduOidjZW50ZXInfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdBTEFcclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yOiAnYmx1ZScsIHRleHRBbGlnbjonY2VudGVyJ319PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBzeD17e2NvbG9yOiAnd2hpdGUnLCBwYWRkaW5nOiAnMXJlbSd9fSB2YXJpYW50PVwiaDZcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5nb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMWVtIDFlbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcycmVtJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVCZXQoJ3dhbGEnKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPkNIT09TRSBXQUxBPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5jb25zdCBUcmVuZHMgPSAoe2lzTWVyb24sIHRleHRWYWx1ZX06e2lzTWVyb246IGJvb2xlYW4sIHRleHRWYWx1ZTogc3RyaW5nfSkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHN0eWxlPXt7XHJcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBncmF5JyxcclxuICAgICAgICAgICAgbWF4V2lkdGg6ICcyNXB4JyxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiAnMjVweCcsXHJcbiAgICAgICAgICAgIG1pbldpZHRoOiAnMjVweCcsXHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzI1cHgnLFxyXG4gICAgICAgIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yOiBpc01lcm9uID8gJ3JlZCc6ICdibHVlJywgYm9yZGVyUmFkaXVzOiAnNTAlJywgY29sb3I6ICd3aGl0ZSd9fT57dGV4dFZhbHVlfTwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbWVWaWV3KCkge1xyXG4gICAgY29uc3QgTGl2ZVN0cmVhbUNvbXBvbmVudCA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPGRpdiBzdHlsZT17e1xyXG4gICAgICAgICAgICBtaW5XaWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgfX0+XHJcbiAgICAgICAgICAgIDxNdXhQbGF5ZXJcclxuICAgICAgICAgICAgICAgIHN0cmVhbVR5cGU9XCJsbC1saXZlXCJcclxuICAgICAgICAgICAgICAgIHBsYXliYWNrSWQ9XCJNUkx3Z0I0SFJRa2VVbWJQWFpTMmFEYmRxT3oxMDB5dlgxQkcxN0pKdjY4TVwiXHJcbiAgICAgICAgICAgICAgICBhdXRvUGxheT17dHJ1ZX1cclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9faWQ6IFwidmlkZW8taWQtNTQzMjFcIixcclxuICAgICAgICAgICAgICAgICAgICB2aWRlb190aXRsZTogXCJUZXN0IHZpZGVvIHRpdGxlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyX3VzZXJfaWQ6IFwidXNlci1pZC0wMDdcIixcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgICB9O1xyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgdHlwZSB0cmVuZENvdW50ID0ge1xyXG4gICAgICAgIGNvdW50OiBudW1iZXIsXHJcbiAgICAgICAgaXNNZXJvbjogYm9vbGVhbixcclxuICAgIH1cclxuICAgIGNvbnN0IHRyZW5kQ291bnRMaXN0OiB0cmVuZENvdW50W10gPSBbXTtcclxuXHJcbiAgICByb3VuZHMuZm9yRWFjaCgodmFsLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzTWVyb246IGJvb2xlYW4gPSB2YWwud2lubmVyID09PSAnbWVyb24nO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPT09IDAgfHwgcm91bmRzW2luZGV4XS53aW5uZXIgIT09IHJvdW5kc1tpbmRleCAtIDFdLndpbm5lcikge1xyXG4gICAgICAgICAgICBjb3VudGVyID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5kZXggPT09IHJvdW5kcy5sZW5ndGggLSAxIHx8IHJvdW5kc1tpbmRleF0ud2lubmVyICE9PSByb3VuZHNbaW5kZXggKyAxXS53aW5uZXIpIHtcclxuICAgICAgICAgICAgdHJlbmRDb3VudExpc3QucHVzaCh7Y291bnQ6IGNvdW50ZXIsIGlzTWVyb246IHZhbC53aW5uZXIgPT09ICdtZXJvbid9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPExvZ2dlZEhlYWRlciAvPlxyXG4gICAgICAgICAgICA8TGl2ZVN0cmVhbUNvbXBvbmVudCAvPlxyXG4gICAgICAgICAgICA8R2FtZUhlYWRlciAvPlxyXG4gICAgICAgICAgICA8QmV0QnV0dG9ucyAvPlxyXG4gICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJoNlwiIHN4PXt7Y29sb3I6IFwid2hpdGVcIn19PlRyZW5kcyA8RWFzdEljb24gLz48L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgbWF4V2lkdGg6ICcxMDB2dycsIG1pbkhlaWdodDogJzIwdmgnLCBwYWRkaW5nOiAnMmVtIDBlbScsIG92ZXJmbG93WDogJ2F1dG8nIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlbmRDb3VudExpc3QubWFwKCh2YWwsIGkpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWwuY291bnQgfSkubWFwKChfLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUcmVuZHMga2V5PXtpICsgaW5kZXh9IGlzTWVyb249e3ZhbC5pc01lcm9ufSB0ZXh0VmFsdWU9e2Ake2luZGV4fWB9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHsvKiB7dHJlbmRDb2x1bW5zLm1hcCgoY29sdW1uLCBjb2x1bW5JbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtjb2x1bW5JbmRleH0gc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJywgYWxpZ25JdGVtczogJ2NlbnRlcicgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvbHVtbn1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICkpfSAqL31cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufSJdLCJuYW1lcyI6WyJCdXR0b24iLCJHcmlkIiwiVHlwb2dyYXBoeSIsIkNpcmNsZUljb24iLCJjb2xvcnMiLCJFYXN0SWNvbiIsIlJlYWN0IiwiTG9nZ2VkSGVhZGVyIiwiTXV4UGxheWVyIiwicm91bmRzIiwiZmlnaHRObyIsIndpbm5lciIsIkdhbWVIZWFkZXIiLCJkaXYiLCJjb2x1bW5zIiwiY29udGFpbmVyIiwiZmxleERpcmVjdGlvbiIsImp1c3RpZnlDb250ZW50IiwiaXRlbSIsIm1kIiwic20iLCJ4cyIsInN4IiwiY29sb3IiLCJ2YXJpYW50IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJzdHlsZSIsInBhZGRpbmdMZWZ0IiwiYmFja2dyb3VuZENvbG9yIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsIkJldEJ1dHRvbnMiLCJoYW5kbGVCZXQiLCJzaWRlIiwic3VibWl0QmV0IiwibGciLCJ4bCIsIm1pbldpZHRoIiwiZ29sZCIsIm1hcmdpbkJvdHRvbSIsIm9uQ2xpY2siLCJUcmVuZHMiLCJpc01lcm9uIiwidGV4dFZhbHVlIiwiYm9yZGVyIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJtaW5IZWlnaHQiLCJHYW1lVmlldyIsIkxpdmVTdHJlYW1Db21wb25lbnQiLCJzdHJlYW1UeXBlIiwicGxheWJhY2tJZCIsImF1dG9QbGF5IiwibWV0YWRhdGEiLCJ2aWRlb19pZCIsInZpZGVvX3RpdGxlIiwidmlld2VyX3VzZXJfaWQiLCJjb3VudGVyIiwidHJlbmRDb3VudExpc3QiLCJmb3JFYWNoIiwidmFsIiwiaW5kZXgiLCJsZW5ndGgiLCJwdXNoIiwiY291bnQiLCJiciIsIm92ZXJmbG93WCIsIm1hcCIsImkiLCJBcnJheSIsImZyb20iLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./src/app/(bettor)/gameView/page.tsx\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@mux/mux-player-react/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@mux/mux-player-react/dist/index.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaError: function() { return /* reexport safe */ _mux_mux_player__WEBPACK_IMPORTED_MODULE_1__.MediaError; },\n/* harmony export */   \"default\": function() { return /* binding */ Ce; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _mux_mux_player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mux/mux-player */ \"(app-client)/./node_modules/@mux/mux-player/dist/index.mjs\");\nvar d={className:\"class\",classname:\"class\",htmlFor:\"for\",crossOrigin:\"crossorigin\",viewBox:\"viewBox\",playsInline:\"playsinline\",autoPlay:\"autoplay\",playbackRate:\"playbackrate\"},_=e=>e==null,q=(e,n)=>_(n)?!1:e in n,J=e=>e.replace(/[A-Z]/g,n=>`-${n.toLowerCase()}`),Y=(e,n)=>{if(!(typeof n==\"boolean\"&&!n)){if(q(e,d))return d[e];if(typeof n!=null)return/[A-Z]/.test(e)?J(e):e}};var $=(e,n)=>typeof e==\"boolean\"?\"\":e,c=(e={})=>Object.entries(e).reduce((n,[t,o])=>{let a=Y(t,o);if(!a)return n;let i=$(o,t);return n[a]=i,n},{});var m=(...e)=>{let n=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{e.forEach(t=>{!t||(typeof t==\"function\"?t(n.current):t.current=n.current)})},[e]),n};var ee=Object.prototype.hasOwnProperty,ne=(e,n)=>{if(Object.is(e,n))return!0;if(typeof e!=\"object\"||e===null||typeof n!=\"object\"||n===null)return!1;if(Array.isArray(e))return!Array.isArray(n)||e.length!==n.length?!1:e.some((a,i)=>n[i]===a);let t=Object.keys(e),o=Object.keys(n);if(t.length!==o.length)return!1;for(let a=0;a<t.length;a++)if(!ee.call(n,t[a])||!Object.is(e[t[a]],n[t[a]]))return!1;return!0},p=(e,n,t)=>!ne(n,e[t]),te=(e,n,t)=>{e[t]=n},re=(e,n,t,o=te,a=p)=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let i=t==null?void 0:t.current;!i||!a(i,n,e)||o(i,n,e)},[t==null?void 0:t.current,n]),l=re;var ae=()=>{try{return\"1.11.4\"}catch{}return\"UNKNOWN\"},oe=ae(),E=()=>oe;var le=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({children:e,...n},t)=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"mux-player\",c({...n,ref:t}),e)),r=(e,n,t)=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let o=n==null?void 0:n.current;if(!(!o||!t))return o.addEventListener(e,t),()=>{o.removeEventListener(e,t)}},[n==null?void 0:n.current,t]),ue=(e,n)=>{let{onAbort:t,onCanPlay:o,onCanPlayThrough:a,onEmptied:i,onLoadStart:g,onLoadedData:f,onLoadedMetadata:M,onProgress:P,onDurationChange:v,onVolumeChange:b,onRateChange:x,onResize:T,onWaiting:h,onPlay:R,onPlaying:k,onTimeUpdate:C,onPause:L,onSeeking:O,onSeeked:S,onStalled:G,onSuspend:w,onEnded:V,onError:A,onCuePointChange:N,onCuePointsChange:I,metadata:K,tokens:D,paused:U,playbackId:H,playbackRates:j,currentTime:z,themeProps:F,...W}=n;return l(\"playbackRates\",j,e),l(\"metadata\",K,e),l(\"themeProps\",F,e),l(\"tokens\",D,e),l(\"playbackId\",H,e),l(\"paused\",U,e,(s,u)=>{u!=null&&(u?s.pause():s.play())},(s,u,Z)=>s.hasAttribute(\"autoplay\")&&!s.hasPlayed?!1:p(s,u,Z)),l(\"currentTime\",z,e,(s,u)=>{u!=null&&(s.currentTime=u)}),r(\"abort\",e,t),r(\"canplay\",e,o),r(\"canplaythrough\",e,a),r(\"emptied\",e,i),r(\"loadstart\",e,g),r(\"loadeddata\",e,f),r(\"loadedmetadata\",e,M),r(\"progress\",e,P),r(\"durationchange\",e,v),r(\"volumechange\",e,b),r(\"ratechange\",e,x),r(\"resize\",e,T),r(\"waiting\",e,h),r(\"play\",e,R),r(\"playing\",e,k),r(\"timeupdate\",e,C),r(\"pause\",e,L),r(\"seeking\",e,O),r(\"seeked\",e,S),r(\"stalled\",e,G),r(\"suspend\",e,w),r(\"ended\",e,V),r(\"error\",e,A),r(\"cuepointchange\",e,N),r(\"cuepointschange\",e,I),[W]},ye=E(),pe=\"mux-player-react\",de=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((e,n)=>{let t=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),o=m(t,n),[a]=ue(t,e);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(le,{ref:o,playerSoftwareName:pe,playerSoftwareVersion:ye,...a})}),Ce=de;\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BtdXgvbXV4LXBsYXllci1yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9GLE9BQU8sd0tBQXdLLHFFQUFxRSxnQkFBZ0IsYUFBYSwrQkFBK0Isc0JBQXNCLGlEQUFpRCw2Q0FBNkMsd0NBQXdDLGFBQWEsZUFBZSxhQUFhLGdCQUFnQixHQUFHLEVBQWdGLGVBQWUsTUFBTSw2Q0FBQyxPQUFPLE9BQU8sZ0RBQUMsTUFBTSxjQUFjLDREQUE0RCxFQUFFLFNBQTJDLGtEQUFrRCwyQkFBMkIsdUVBQXVFLDRGQUE0RixzQ0FBc0MsZ0NBQWdDLFlBQVksV0FBVyw4REFBOEQsU0FBUyxxQ0FBcUMsT0FBTyxzQkFBc0IsZ0RBQUMsTUFBTSwrQkFBK0Isd0JBQXdCLG9DQUFvQyxZQUFZLElBQUksZUFBZSxPQUFPLGdCQUFnQixrQkFBa0IsT0FBTyw2Q0FBWSxHQUFHLGdCQUFnQixLQUFLLGdEQUFlLGlCQUFpQixXQUFXLGlCQUFpQixnREFBRSxNQUFNLCtCQUErQixpREFBaUQsNEJBQTRCLDBDQUEwQyxJQUFJLDhhQUE4YSxHQUFHLCtIQUErSCxnQ0FBZ0MsNEZBQTRGLDJCQUEyQix1ZEFBdWQsaUNBQWlDLDZDQUFZLFNBQVMsTUFBTSw2Q0FBRSw0QkFBNEIsT0FBTyxnREFBZSxLQUFLLDBEQUEwRCxFQUFFLFFBQStDO0FBQ3JsRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG11eC9tdXgtcGxheWVyLXJlYWN0L2Rpc3QvaW5kZXgubWpzP2ZkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHkse3VzZUVmZmVjdCBhcyBpZX1mcm9tXCJyZWFjdFwiO2ltcG9ydHtNZWRpYUVycm9yIGFzIGJlfWZyb21cIkBtdXgvbXV4LXBsYXllclwiO3ZhciBkPXtjbGFzc05hbWU6XCJjbGFzc1wiLGNsYXNzbmFtZTpcImNsYXNzXCIsaHRtbEZvcjpcImZvclwiLGNyb3NzT3JpZ2luOlwiY3Jvc3NvcmlnaW5cIix2aWV3Qm94Olwidmlld0JveFwiLHBsYXlzSW5saW5lOlwicGxheXNpbmxpbmVcIixhdXRvUGxheTpcImF1dG9wbGF5XCIscGxheWJhY2tSYXRlOlwicGxheWJhY2tyYXRlXCJ9LF89ZT0+ZT09bnVsbCxxPShlLG4pPT5fKG4pPyExOmUgaW4gbixKPWU9PmUucmVwbGFjZSgvW0EtWl0vZyxuPT5gLSR7bi50b0xvd2VyQ2FzZSgpfWApLFk9KGUsbik9PntpZighKHR5cGVvZiBuPT1cImJvb2xlYW5cIiYmIW4pKXtpZihxKGUsZCkpcmV0dXJuIGRbZV07aWYodHlwZW9mIG4hPW51bGwpcmV0dXJuL1tBLVpdLy50ZXN0KGUpP0ooZSk6ZX19O3ZhciAkPShlLG4pPT50eXBlb2YgZT09XCJib29sZWFuXCI/XCJcIjplLGM9KGU9e30pPT5PYmplY3QuZW50cmllcyhlKS5yZWR1Y2UoKG4sW3Qsb10pPT57bGV0IGE9WSh0LG8pO2lmKCFhKXJldHVybiBuO2xldCBpPSQobyx0KTtyZXR1cm4gblthXT1pLG59LHt9KTtpbXBvcnR7dXNlUmVmIGFzIHNlfWZyb21cInJlYWN0XCI7aW1wb3J0e3VzZUVmZmVjdCBhcyBRLHVzZVJlZiBhcyBYfWZyb21cInJlYWN0XCI7dmFyIG09KC4uLmUpPT57bGV0IG49WChudWxsKTtyZXR1cm4gUSgoKT0+e2UuZm9yRWFjaCh0PT57IXR8fCh0eXBlb2YgdD09XCJmdW5jdGlvblwiP3Qobi5jdXJyZW50KTp0LmN1cnJlbnQ9bi5jdXJyZW50KX0pfSxbZV0pLG59O2ltcG9ydHt1c2VFZmZlY3QgYXMgQn1mcm9tXCJyZWFjdFwiO3ZhciBlZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG5lPShlLG4pPT57aWYoT2JqZWN0LmlzKGUsbikpcmV0dXJuITA7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsfHx0eXBlb2YgbiE9XCJvYmplY3RcInx8bj09PW51bGwpcmV0dXJuITE7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hQXJyYXkuaXNBcnJheShuKXx8ZS5sZW5ndGghPT1uLmxlbmd0aD8hMTplLnNvbWUoKGEsaSk9Pm5baV09PT1hKTtsZXQgdD1PYmplY3Qua2V5cyhlKSxvPU9iamVjdC5rZXlzKG4pO2lmKHQubGVuZ3RoIT09by5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspaWYoIWVlLmNhbGwobix0W2FdKXx8IU9iamVjdC5pcyhlW3RbYV1dLG5bdFthXV0pKXJldHVybiExO3JldHVybiEwfSxwPShlLG4sdCk9PiFuZShuLGVbdF0pLHRlPShlLG4sdCk9PntlW3RdPW59LHJlPShlLG4sdCxvPXRlLGE9cCk9PkIoKCk9PntsZXQgaT10PT1udWxsP3ZvaWQgMDp0LmN1cnJlbnQ7IWl8fCFhKGksbixlKXx8byhpLG4sZSl9LFt0PT1udWxsP3ZvaWQgMDp0LmN1cnJlbnQsbl0pLGw9cmU7dmFyIGFlPSgpPT57dHJ5e3JldHVyblwiMS4xMS40XCJ9Y2F0Y2h7fXJldHVyblwiVU5LTk9XTlwifSxvZT1hZSgpLEU9KCk9Pm9lO3ZhciBsZT15LmZvcndhcmRSZWYoKHtjaGlsZHJlbjplLC4uLm59LHQpPT55LmNyZWF0ZUVsZW1lbnQoXCJtdXgtcGxheWVyXCIsYyh7Li4ubixyZWY6dH0pLGUpKSxyPShlLG4sdCk9PmllKCgpPT57bGV0IG89bj09bnVsbD92b2lkIDA6bi5jdXJyZW50O2lmKCEoIW98fCF0KSlyZXR1cm4gby5hZGRFdmVudExpc3RlbmVyKGUsdCksKCk9PntvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSx0KX19LFtuPT1udWxsP3ZvaWQgMDpuLmN1cnJlbnQsdF0pLHVlPShlLG4pPT57bGV0e29uQWJvcnQ6dCxvbkNhblBsYXk6byxvbkNhblBsYXlUaHJvdWdoOmEsb25FbXB0aWVkOmksb25Mb2FkU3RhcnQ6ZyxvbkxvYWRlZERhdGE6ZixvbkxvYWRlZE1ldGFkYXRhOk0sb25Qcm9ncmVzczpQLG9uRHVyYXRpb25DaGFuZ2U6dixvblZvbHVtZUNoYW5nZTpiLG9uUmF0ZUNoYW5nZTp4LG9uUmVzaXplOlQsb25XYWl0aW5nOmgsb25QbGF5OlIsb25QbGF5aW5nOmssb25UaW1lVXBkYXRlOkMsb25QYXVzZTpMLG9uU2Vla2luZzpPLG9uU2Vla2VkOlMsb25TdGFsbGVkOkcsb25TdXNwZW5kOncsb25FbmRlZDpWLG9uRXJyb3I6QSxvbkN1ZVBvaW50Q2hhbmdlOk4sb25DdWVQb2ludHNDaGFuZ2U6SSxtZXRhZGF0YTpLLHRva2VuczpELHBhdXNlZDpVLHBsYXliYWNrSWQ6SCxwbGF5YmFja1JhdGVzOmosY3VycmVudFRpbWU6eix0aGVtZVByb3BzOkYsLi4uV309bjtyZXR1cm4gbChcInBsYXliYWNrUmF0ZXNcIixqLGUpLGwoXCJtZXRhZGF0YVwiLEssZSksbChcInRoZW1lUHJvcHNcIixGLGUpLGwoXCJ0b2tlbnNcIixELGUpLGwoXCJwbGF5YmFja0lkXCIsSCxlKSxsKFwicGF1c2VkXCIsVSxlLChzLHUpPT57dSE9bnVsbCYmKHU/cy5wYXVzZSgpOnMucGxheSgpKX0sKHMsdSxaKT0+cy5oYXNBdHRyaWJ1dGUoXCJhdXRvcGxheVwiKSYmIXMuaGFzUGxheWVkPyExOnAocyx1LFopKSxsKFwiY3VycmVudFRpbWVcIix6LGUsKHMsdSk9Pnt1IT1udWxsJiYocy5jdXJyZW50VGltZT11KX0pLHIoXCJhYm9ydFwiLGUsdCkscihcImNhbnBsYXlcIixlLG8pLHIoXCJjYW5wbGF5dGhyb3VnaFwiLGUsYSkscihcImVtcHRpZWRcIixlLGkpLHIoXCJsb2Fkc3RhcnRcIixlLGcpLHIoXCJsb2FkZWRkYXRhXCIsZSxmKSxyKFwibG9hZGVkbWV0YWRhdGFcIixlLE0pLHIoXCJwcm9ncmVzc1wiLGUsUCkscihcImR1cmF0aW9uY2hhbmdlXCIsZSx2KSxyKFwidm9sdW1lY2hhbmdlXCIsZSxiKSxyKFwicmF0ZWNoYW5nZVwiLGUseCkscihcInJlc2l6ZVwiLGUsVCkscihcIndhaXRpbmdcIixlLGgpLHIoXCJwbGF5XCIsZSxSKSxyKFwicGxheWluZ1wiLGUsaykscihcInRpbWV1cGRhdGVcIixlLEMpLHIoXCJwYXVzZVwiLGUsTCkscihcInNlZWtpbmdcIixlLE8pLHIoXCJzZWVrZWRcIixlLFMpLHIoXCJzdGFsbGVkXCIsZSxHKSxyKFwic3VzcGVuZFwiLGUsdykscihcImVuZGVkXCIsZSxWKSxyKFwiZXJyb3JcIixlLEEpLHIoXCJjdWVwb2ludGNoYW5nZVwiLGUsTikscihcImN1ZXBvaW50c2NoYW5nZVwiLGUsSSksW1ddfSx5ZT1FKCkscGU9XCJtdXgtcGxheWVyLXJlYWN0XCIsZGU9eS5mb3J3YXJkUmVmKChlLG4pPT57bGV0IHQ9c2UobnVsbCksbz1tKHQsbiksW2FdPXVlKHQsZSk7cmV0dXJuIHkuY3JlYXRlRWxlbWVudChsZSx7cmVmOm8scGxheWVyU29mdHdhcmVOYW1lOnBlLHBsYXllclNvZnR3YXJlVmVyc2lvbjp5ZSwuLi5hfSl9KSxDZT1kZTtleHBvcnR7YmUgYXMgTWVkaWFFcnJvcixDZSBhcyBkZWZhdWx0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@mux/mux-player-react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@mux/mux-player/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@mux/mux-player/dist/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaError: function() { return /* reexport safe */ _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError; },\n/* harmony export */   \"default\": function() { return /* binding */ ki; },\n/* harmony export */   getVideoAttribute: function() { return /* binding */ Z; }\n/* harmony export */ });\n/* harmony import */ var media_chrome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! media-chrome */ \"(app-client)/./node_modules/media-chrome/dist/index.js\");\n/* harmony import */ var media_chrome_dist_experimental_media_captions_selectmenu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! media-chrome/dist/experimental/media-captions-selectmenu.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-selectmenu.js\");\n/* harmony import */ var _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mux/mux-video */ \"(app-client)/./node_modules/@mux/mux-video/dist/index.mjs\");\n/* harmony import */ var _mux_playback_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mux/playback-core */ \"(app-client)/./node_modules/@mux/playback-core/dist/index.mjs\");\n/* harmony import */ var media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! media-chrome/dist/media-theme-element.js */ \"(app-client)/./node_modules/media-chrome/dist/media-theme-element.js\");\nvar Oe=(t,a,e)=>{if(!a.has(t))throw TypeError(\"Cannot \"+e)};var m=(t,a,e)=>(Oe(t,a,\"read from private field\"),e?e.call(t):a.get(t)),p=(t,a,e)=>{if(a.has(t))throw TypeError(\"Cannot add the same private member more than once\");a instanceof WeakSet?a.add(t):a.set(t,e)},x=(t,a,e,r)=>(Oe(t,a,\"write to private field\"),r?r.call(t,e):a.set(t,e),e);var f=(t,a,e)=>(Oe(t,a,\"access private method\"),e);var W=class{addEventListener(){}removeEventListener(){}dispatchEvent(a){return!0}};if(typeof DocumentFragment==\"undefined\"){class t extends W{}globalThis.DocumentFragment=t}var z=class extends W{},Le=class extends W{},Nt={get(t){},define(t,a,e){},upgrade(t){},whenDefined(t){return Promise.resolve(z)}},J,Re=class{constructor(a,e={}){p(this,J,void 0);x(this,J,e==null?void 0:e.detail)}get detail(){return m(this,J)}initCustomEvent(){}};J=new WeakMap;function Bt(t,a){return new z}var rt={document:{createElement:Bt},DocumentFragment,customElements:Nt,CustomEvent:Re,EventTarget:W,HTMLElement:z,HTMLVideoElement:Le},ot=typeof window==\"undefined\"||typeof globalThis.customElements==\"undefined\",h=ot?rt:globalThis,T=ot?rt.document:globalThis.document;var It=\"en\",H={code:It};var nt=\"en\";function d(t,a=!0){var i,o;let e=a&&(o=(i=H)==null?void 0:i[t])!=null?o:t,r=a?H.code:nt;return new Se(e,r)}var Se=class{constructor(a,e=(r=>(r=H.code)!=null?r:nt)()){this.message=a,this.locale=e}format(a){return this.message.replace(/\\{(\\w+)\\}/g,(e,r)=>{var i;return(i=a[r])!=null?i:\"\"})}toString(){return this.message}};function st(t){let a=\"\";return Object.entries(t).forEach(([e,r])=>{r!=null&&(a+=`${de(e)}: ${r}; `)}),a?a.trim():void 0}function de(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase()}function ue(t){return t.replace(/[-_]([a-z])/g,(a,e)=>e.toUpperCase())}function R(t){if(t==null)return;let a=+t;return Number.isNaN(a)?void 0:a}function me(t){let a=Dt(t).toString();return a?\"?\"+a:\"\"}function Dt(t){let a={};for(let e in t)t[e]!=null&&(a[e]=t[e]);return new URLSearchParams(a)}function N(t){let a=(t!=null?t:\"\").split(\".\")[1];if(!a)return{};let e=a.replace(/-/g,\"+\").replace(/_/g,\"/\"),r=decodeURIComponent(atob(e).split(\"\").map(function(i){return\"%\"+(\"00\"+i.charCodeAt(0).toString(16)).slice(-2)}).join(\"\"));return JSON.parse(r)}var Me=(t,a)=>!t||!a?!1:t.contains(a)?!0:Me(t,a.getRootNode().host);var Pe=\"mux.com\",Vt=()=>{try{return\"1.11.4\"}catch{}return\"UNKNOWN\"},Ht=Vt(),pe=()=>Ht,_e=(t,{maxResolution:a,token:e,domain:r=Pe}={})=>{let n=!!e?{token:e}:{redundant_streams:!0,...a?{max_resolution:a}:{}};return`https://stream.${r}/${t}.m3u8${me(n)}`},lt=(t,{token:a,thumbnailTime:e,domain:r=Pe}={})=>{let i=a==null?e:void 0,{aud:o}=N(a);if(!(a&&o!==\"t\"))return`https://image.${r}/${t}/thumbnail.webp${me({token:a,time:i})}`},dt=(t,{token:a,domain:e=Pe}={})=>{let{aud:r}=N(a);if(!(a&&r!==\"s\"))return`https://image.${e}/${t}/storyboard.vtt${me({token:a,format:\"webp\"})}`},X=t=>{if(!!t){if([_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.ON_DEMAND].includes(t))return t;if(t!=null&&t.includes(\"live\"))return _mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE}};var $t={crossorigin:\"crossOrigin\",playsinline:\"playsInline\"};function ut(t){var a;return(a=$t[t])!=null?a:ue(t)}var $,K,E,ce=class{constructor(a,e){p(this,$,void 0);p(this,K,void 0);p(this,E,[]);x(this,$,a),x(this,K,e)}[Symbol.iterator](){return m(this,E).values()}get length(){return m(this,E).length}get value(){var a;return(a=m(this,E).join(\" \"))!=null?a:\"\"}set value(a){var e;a!==this.value&&(x(this,E,[]),this.add(...(e=a==null?void 0:a.split(\" \"))!=null?e:[]))}toString(){return this.value}item(a){return m(this,E)[a]}values(){return m(this,E).values()}keys(){return m(this,E).keys()}forEach(a){m(this,E).forEach(a)}add(...a){var e,r;a.forEach(i=>{this.contains(i)||m(this,E).push(i)}),!(this.value===\"\"&&!((e=m(this,$))!=null&&e.hasAttribute(`${m(this,K)}`)))&&((r=m(this,$))==null||r.setAttribute(`${m(this,K)}`,`${this.value}`))}remove(...a){var e;a.forEach(r=>{m(this,E).splice(m(this,E).indexOf(r),1)}),(e=m(this,$))==null||e.setAttribute(`${m(this,K)}`,`${this.value}`)}contains(a){return m(this,E).includes(a)}toggle(a,e){return typeof e!=\"undefined\"?e?(this.add(a),!0):(this.remove(a),!1):this.contains(a)?(this.remove(a),!1):(this.add(a),!0)}replace(a,e){this.remove(a),this.add(e)}};$=new WeakMap,K=new WeakMap,E=new WeakMap;var mt=`[mux-player ${pe()}]`;function B(...t){console.warn(mt,...t)}function O(...t){console.error(mt,...t)}function Ne(t){var e;let a=(e=t.message)!=null?e:\"\";if(t.context&&(a+=` ${t.context}`),t.file){let r=\"https://github.com/muxinc/elements/blob/main/errors/\";a+=` ${d(\"Read more: \")}\n${r}${t.file}`}B(a)}var y={AUTOPLAY:\"autoplay\",CROSSORIGIN:\"crossorigin\",LOOP:\"loop\",MUTED:\"muted\",PLAYSINLINE:\"playsinline\",PRELOAD:\"preload\"},F={VOLUME:\"volume\",PLAYBACKRATE:\"playbackrate\",MUTED:\"muted\"},pt=Object.freeze({length:0,start(t){let a=t>>>0;if(a>=this.length)throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${a}) is greater than or equal to the maximum bound (${this.length}).`);return 0},end(t){let a=t>>>0;if(a>=this.length)throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${a}) is greater than or equal to the maximum bound (${this.length}).`);return 0}}),Ft=_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.VideoEvents.filter(t=>t!==\"error\"),Ut=Object.values(y).filter(t=>![y.PLAYSINLINE].includes(t)),Yt=Object.values(F);function bt(t){t.querySelectorAll(\":scope > track\").forEach(a=>{var e;(e=t.media)==null||e.append(a.cloneNode())}),Ft.forEach(a=>{var e;(e=t.media)==null||e.addEventListener(a,r=>{t.dispatchEvent(new Event(r.type))})})}var Be=class extends h.HTMLElement{static get observedAttributes(){return[...Ut,...Yt]}constructor(){super(),this.querySelectorAll(\":scope > track\").forEach(r=>{var i;(i=this.media)==null||i.append(r.cloneNode())});let a=r=>{for(let i of r)i.type===\"childList\"&&(i.removedNodes.forEach(o=>{var u,b;let n=(u=this.media)==null?void 0:u.querySelector(`track[src=\"${o.src}\"]`);n&&((b=this.media)==null||b.removeChild(n))}),i.addedNodes.forEach(o=>{var n;(n=this.media)==null||n.append(o.cloneNode())}))};new MutationObserver(a).observe(this,{childList:!0,subtree:!0})}attributeChangedCallback(a,e,r){var i,o;switch(a){case F.MUTED:{this.media&&(this.media.muted=r!=null,this.media.defaultMuted=r!=null);return}case F.VOLUME:{let n=(i=R(r))!=null?i:1;this.media&&(this.media.volume=n);return}case F.PLAYBACKRATE:{let n=(o=R(r))!=null?o:1;this.media&&(this.media.playbackRate=n,this.media.defaultPlaybackRate=n);return}}}play(){var a,e;return(e=(a=this.media)==null?void 0:a.play())!=null?e:Promise.reject()}pause(){var a;(a=this.media)==null||a.pause()}requestCast(a){var e;return(e=this.media)==null?void 0:e.requestCast(a)}get media(){var a;return(a=this.shadowRoot)==null?void 0:a.querySelector(\"mux-video\")}get paused(){var a,e;return(e=(a=this.media)==null?void 0:a.paused)!=null?e:!0}get duration(){var a,e;return(e=(a=this.media)==null?void 0:a.duration)!=null?e:NaN}get ended(){var a,e;return(e=(a=this.media)==null?void 0:a.ended)!=null?e:!1}get buffered(){var a,e;return(e=(a=this.media)==null?void 0:a.buffered)!=null?e:pt}get seekable(){var a,e;return(e=(a=this.media)==null?void 0:a.seekable)!=null?e:pt}get readyState(){var a,e;return(e=(a=this.media)==null?void 0:a.readyState)!=null?e:0}get videoWidth(){var a,e;return(e=(a=this.media)==null?void 0:a.videoWidth)!=null?e:0}get videoHeight(){var a,e;return(e=(a=this.media)==null?void 0:a.videoHeight)!=null?e:0}get currentTime(){var a,e;return(e=(a=this.media)==null?void 0:a.currentTime)!=null?e:0}set currentTime(a){this.media&&(this.media.currentTime=Number(a))}get volume(){var a,e;return(e=(a=this.media)==null?void 0:a.volume)!=null?e:1}set volume(a){this.media&&(this.media.volume=Number(a))}get playbackRate(){var a,e;return(e=(a=this.media)==null?void 0:a.playbackRate)!=null?e:1}set playbackRate(a){this.media&&(this.media.playbackRate=Number(a))}get defaultPlaybackRate(){var a;return(a=R(this.getAttribute(F.PLAYBACKRATE)))!=null?a:1}set defaultPlaybackRate(a){a!=null?this.setAttribute(F.PLAYBACKRATE,`${a}`):this.removeAttribute(F.PLAYBACKRATE)}get crossOrigin(){return Q(this,y.CROSSORIGIN)}set crossOrigin(a){this.setAttribute(y.CROSSORIGIN,`${a}`)}get autoplay(){return Q(this,y.AUTOPLAY)!=null}set autoplay(a){a?this.setAttribute(y.AUTOPLAY,typeof a==\"string\"?a:\"\"):this.removeAttribute(y.AUTOPLAY)}get loop(){return Q(this,y.LOOP)!=null}set loop(a){a?this.setAttribute(y.LOOP,\"\"):this.removeAttribute(y.LOOP)}get muted(){var a,e;return(e=(a=this.media)==null?void 0:a.muted)!=null?e:!1}set muted(a){this.media&&(this.media.muted=Boolean(a))}get defaultMuted(){return Q(this,y.MUTED)!=null}set defaultMuted(a){a?this.setAttribute(y.MUTED,\"\"):this.removeAttribute(y.MUTED)}get playsInline(){return Q(this,y.PLAYSINLINE)!=null}set playsInline(a){O(\"playsInline is set to true by default and is not currently supported as a setter.\")}get preload(){return this.media?this.media.preload:this.getAttribute(\"preload\")}set preload(a){[\"\",\"none\",\"metadata\",\"auto\"].includes(a)?this.setAttribute(y.PRELOAD,a):this.removeAttribute(y.PRELOAD)}};function Q(t,a){return t.media?t.media.getAttribute(a):t.getAttribute(a)}var Ie=Be;var ht=`:host {\n  --media-control-display: var(--controls);\n  --media-loading-indicator-display: var(--loading-indicator);\n  --media-dialog-display: var(--dialog);\n  --media-play-button-display: var(--play-button);\n  --media-live-button-display: var(--live-button);\n  --media-seek-backward-button-display: var(--seek-backward-button);\n  --media-seek-forward-button-display: var(--seek-forward-button);\n  --media-mute-button-display: var(--mute-button);\n  --media-captions-button-display: var(--captions-button);\n  --media-captions-selectmenu-display: var(--captions-selectmenu, var(--media-captions-button-display));\n  --media-airplay-button-display: var(--airplay-button);\n  --media-pip-button-display: var(--pip-button);\n  --media-fullscreen-button-display: var(--fullscreen-button);\n  --media-cast-button-display: var(--cast-button);\n  --media-playback-rate-button-display: var(--playback-rate-button);\n  --media-volume-range-display: var(--volume-range);\n  --media-time-range-display: var(--time-range);\n  --media-time-display-display: var(--time-display);\n  --media-duration-display-display: var(--duration-display);\n  --media-title-display-display: var(--title-display);\n\n  display: inline-block;\n  width: 100%;\n}\n\n/* Hide custom elements that are not defined yet */\n:not(:defined) {\n  display: none;\n}\n\na {\n  color: #fff;\n  font-size: 0.9em;\n  text-decoration: underline;\n}\n\nmedia-theme {\n  width: 100%;\n  height: 100%;\n  direction: ltr;\n}\n\n::part(top),\n[part~='top'] {\n  --media-control-display: var(--controls, var(--top-controls));\n  --media-play-button-display: var(--play-button, var(--top-play-button));\n  --media-live-button-display: var(--live-button, var(--top-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--top-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--top-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--top-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--top-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--top-captions-selectmenu))\n  );\n  --media-airplay-button-display: var(--airplay-button, var(--top-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--top-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--top-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--top-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--top-playback-rate-button));\n  --media-volume-range-display: var(--volume-range, var(--top-volume-range));\n  --media-time-range-display: var(--time-range, var(--top-time-range));\n  --media-time-display-display: var(--time-display, var(--top-time-display));\n  --media-duration-display-display: var(--duration-display, var(--top-duration-display));\n  --media-title-display-display: var(--title-display, var(--top-title-display));\n}\n\n::part(center),\n[part~='center'] {\n  --media-control-display: var(--controls, var(--center-controls));\n  --media-play-button-display: var(--play-button, var(--center-play-button));\n  --media-live-button-display: var(--live-button, var(--center-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--center-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--center-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--center-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--center-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--center-captions-selectmenu))\n  );\n  --media-airplay-button-display: var(--airplay-button, var(--center-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--center-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--center-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--center-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--center-playback-rate-button));\n  --media-volume-range-display: var(--volume-range, var(--center-volume-range));\n  --media-time-range-display: var(--time-range, var(--center-time-range));\n  --media-time-display-display: var(--time-display, var(--center-time-display));\n  --media-duration-display-display: var(--duration-display, var(--center-duration-display));\n}\n\n::part(bottom),\n[part~='bottom'] {\n  --media-control-display: var(--controls, var(--bottom-controls));\n  --media-play-button-display: var(--play-button, var(--bottom-play-button));\n  --media-live-button-display: var(--live-button, var(--bottom-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--bottom-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--bottom-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--bottom-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--bottom-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--bottom-captions-selectmenu))\n  );\n  --media-airplay-button-display: var(--airplay-button, var(--bottom-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--bottom-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--bottom-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--bottom-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--bottom-playback-rate-button));\n  --media-volume-range-display: var(--volume-range, var(--bottom-volume-range));\n  --media-time-range-display: var(--time-range, var(--bottom-time-range));\n  --media-time-display-display: var(--time-display, var(--bottom-time-display));\n  --media-duration-display-display: var(--duration-display, var(--bottom-duration-display));\n  --media-title-display-display: var(--title-display, var(--bottom-title-display));\n}\n`;var gt=`<!-- prettier-ignore -->\n<template id=\"media-theme-mux\">\n  <style>\n    :host {\n      --_primary-color: var(--media-primary-color, white);\n      --_secondary-color: var(--media-secondary-color, rgb(0 0 0 / .75));\n\n      --media-icon-color: var(--_primary-color);\n      --media-range-thumb-background: var(--_primary-color);\n      --media-range-bar-color: var(--_primary-color);\n      --media-control-background: var(--_secondary-color);\n      --media-control-hover-background: var(--_secondary-color);\n      --media-time-range-buffered-color: rgba(255, 255, 255, 0.4);\n      --media-range-track-background:\n        linear-gradient(rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)),\n        linear-gradient(rgba(20, 20, 30, 0.7), rgba(20, 20, 30, 0.7));\n      --media-preview-thumbnail-border: 0;\n      --media-preview-thumbnail-border-radius: 2px 2px 0 0;\n      --media-preview-time-border-radius: 0 0 2px 2px;\n      --media-preview-time-margin: 0 0 8px;\n      --media-preview-time-text-shadow: none;\n\n      color: var(--_primary-color);\n      display: inline-block;\n      width: 100%;\n      height: 100%;\n    }\n\n    :host([audio]) {\n      --media-preview-time-border-radius: 3px;\n      --media-preview-time-margin: 0 0 5px;\n      --media-preview-time-text-shadow: none;\n    }\n\n    :host([audio]) ::slotted([slot='media']) {\n      height: 0px;\n    }\n\n    :host([audio]) media-loading-indicator,\n    :host([audio]) ::slotted([slot=poster]) {\n      display: none;\n    }\n\n    :host([audio]) media-controller {\n      background: transparent;\n    }\n\n    :host([audio]) media-controller::part(vertical-layer) {\n      background: transparent;\n    }\n\n    :host([audio]) media-control-bar {\n      width: 100%;\n    }\n\n    [disabled]:not(media-live-button),\n    [aria-disabled='true']:not(media-live-button) {\n      opacity: 60%;\n      cursor: not-allowed;\n    }\n\n    :host(:not([audio])) media-captions-selectmenu::part(listbox) {\n      z-index: 10;\n    }\n\n    media-controller:not([mediasubtitleslist]) media-captions-selectmenu {\n      --captions-selectmenu: none;\n    }\n\n\n    /* 0.433s is the transition duration for VTT Regions.\n     * Borrowed here, so the captions don't move too fast. */\n    media-controller ::slotted([slot='media']) {\n      --media-webkit-text-track-transition: transform 0.433s ease-out 0.3s;\n    }\n    media-controller:is([mediapaused],:not([userinactive])) ::slotted([slot='media']) {\n      /* 42px is the height of the control bar and progress bar\n       * with an additional 5px as a buffer, to get 47px */\n      --media-webkit-text-track-transform: translateY(-47px);\n      --media-webkit-text-track-transition: transform 0.15s ease;\n    }\n\n    media-captions-selectmenu {\n      --media-listbox-background: var(--_secondary-color);\n      --media-listbox-selected-background: rgba(255, 255, 255, 0.28);\n      --media-listbox-hover-background: none;\n      --media-listbox-hover-outline: white solid 1px;\n      --media-text-color: white;\n    }\n\n    media-volume-range[mediavolumeunavailable] {\n      --volume-range: none;\n    }\n\n    media-airplay-button[mediaairplayunavailable] {\n      --airplay-button: none;\n    }\n\n    media-fullscreen-button[mediafullscreenunavailable] {\n      --fullscreen-button: none;\n    }\n\n    media-cast-button[mediacastunavailable] {\n      --cast-button: none;\n    }\n\n    media-pip-button[mediapipunavailable] {\n      --pip-button: none;\n    }\n\n    :host media-time-range {\n      color: var(--_primary-color);\n      --media-range-thumb-opacity: 0;\n    }\n\n    :host(:not([audio])) media-time-range {\n      --media-range-padding: 0;\n      background: transparent;\n      z-index: 10;\n      height: 10px;\n      bottom: -3px;\n      width: 100%;\n    }\n\n    media-control-bar {\n      --media-control-padding: 4px 3px;\n    }\n\n    [breakpointsm] media-control-bar {\n      --media-control-padding: 9px 5px;\n    }\n\n    [breakpointmd] media-control-bar {\n      --media-control-padding: 9px 7px;\n    }\n\n    media-control-bar :is([role='button'], [role='switch'], button) {\n      line-height: 0;\n    }\n\n    media-control-bar :is(media-text-display, media-time-display):first-child {\n      --media-control-padding: 9px 5px 9px 10px;\n    }\n\n    .spacer {\n      flex-grow: 1;\n      background-color: var(--media-control-background, rgba(20, 20, 30, 0.7));\n    }\n\n    /* Add a small space on the right to have the play button and\n     * fullscreen button aligned in relation to the progress bar. */\n    media-control-bar:not([slot])::after {\n      content: '';\n      width: 2px;\n      height: 100%;\n      background-color: var(--media-control-background, rgba(20, 20, 30, 0.7));\n    }\n\n    media-control-bar[slot='top-chrome'] {\n      min-height: 42px;\n      pointer-events: none;\n    }\n\n    :host([title]) media-control-bar[slot='top-chrome']::before {\n      content: '';\n      position: absolute;\n      width: 100%;\n      padding-bottom: min(160px, 25%);\n      background: linear-gradient(rgb(0 0 0 / 0.4), transparent);\n    }\n\n    media-control-bar[slot='top-chrome'] > * {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      position: relative;\n    }\n\n    media-controller::part(vertical-layer) {\n      transition: background-color 1s;\n    }\n\n    media-controller:is([mediapaused], :not([userinactive]))::part(vertical-layer) {\n      background-color: var(--controls-backdrop-color, var(--controls, transparent));\n      transition: background-color 0.25s;\n    }\n\n    .center-controls {\n      --media-button-icon-width: 100%;\n      --media-button-icon-height: auto;\n      pointer-events: none;\n      width: 100%;\n      display: flex;\n      flex-flow: row;\n      align-items: center;\n      justify-content: center;\n      filter: drop-shadow(0 0 2px rgb(0 0 0 / 0.25)) drop-shadow(0 0 6px rgb(0 0 0 / 0.25));\n      paint-order: stroke;\n      stroke: rgba(102, 102, 102, 1);\n      stroke-width: 0.3px;\n      text-shadow: 0 0 2px rgb(0 0 0 / 0.25), 0 0 6px rgb(0 0 0 / 0.25);\n    }\n\n    .center-controls media-play-button {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      padding: 0;\n      width: max(43px, min(10%, 55px));\n    }\n\n    .center-controls media-seek-backward-button,\n    .center-controls media-seek-forward-button {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      padding: 0;\n      margin: 0 2%;\n      width: max(33px, min(8%, 40px));\n    }\n\n    media-control-bar:not([slot]) media-seek-backward-button {\n      padding-right: 5px;\n    }\n\n    media-control-bar:not([slot]) media-seek-forward-button {\n      padding-left: 5px;\n    }\n\n    media-loading-indicator {\n      --media-loading-icon-width: 100%;\n      --media-button-icon-height: auto;\n      display: var(--media-control-display, var(--media-loading-indicator-display, flex));\n      pointer-events: none;\n      position: absolute;\n      width: min(15%, 150px);\n      flex-flow: row;\n      align-items: center;\n      justify-content: center;\n    }\n\n    /* Intentionally don't target the div for transition but the children\n     of the div. Prevents messing with media-chrome's autohide feature. */\n    media-loading-indicator + div * {\n      transition: opacity 0.15s;\n      opacity: 1;\n    }\n\n    media-loading-indicator[medialoading]:not([mediapaused]) ~ div > * {\n      opacity: 0;\n      transition-delay: 400ms;\n    }\n\n    media-volume-range {\n      width: min(100%, 100px);\n    }\n\n    media-time-display {\n      white-space: nowrap;\n    }\n\n    :is(media-time-display, media-text-display, media-playback-rate-button[role='button']) {\n      color: inherit;\n      line-height: 24px;\n    }\n\n    :is(.title-display, media-live-button) {\n      color: inherit;\n      font-size: 16px;\n      text-shadow: 0 0 2px rgb(0 0 0 / 0.6);\n    }\n\n    :host([audio]) .title-display {\n      flex-grow: 1;\n      font-size: 21px;\n    }\n  </style>\n\n  <template partial=\"TitleDisplay\">\n    <template if=\"title\">\n      <media-text-display part=\"top title display\" class=\"title-display\">\n        {{title}}\n      </media-text-display>\n    </template>\n  </template>\n\n  <template partial=\"PlayButton\">\n    <media-play-button\n      part=\"{{section ?? 'bottom'}} play button\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"play\">\n        <path d=\"m6.73 20.93 14.05-8.54a.46.46 0 0 0 0-.78L6.73 3.07a.48.48 0 0 0-.73.39v17.07a.48.48 0 0 0 .73.4Z\" />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"pause\">\n        <path\n          d=\"M6 19.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-15a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v15ZM14.5 4a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-15a.5.5 0 0 0-.5-.5h-3Z\"\n        />\n      </svg>\n    </media-play-button>\n  </template>\n\n  <template partial=\"SeekBackwardButton\">\n    <media-seek-backward-button\n      seekoffset=\"{{backwardseekoffset}}\"\n      part=\"{{section ?? 'bottom'}} seek-backward button\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 22 24\" slot=\"backward\">\n        <path d=\"M11 6V3L5.37 7 11 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 11 6Z\" />\n        <text class=\"value\" transform=\"translate(2.5 21)\" style=\"font-size: 8px; font-family: 'ArialMT', 'Arial'\">\n          {{backwardseekoffset}}\n        </text>\n      </svg>\n    </media-seek-backward-button>\n  </template>\n\n  <template partial=\"SeekForwardButton\">\n    <media-seek-forward-button\n      seekoffset=\"{{forwardseekoffset}}\"\n      part=\"{{section ?? 'bottom'}} seek-forward button\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 22 24\" slot=\"forward\">\n        <path d=\"M11 6V3l5.61 4L11 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 11 6Z\" />\n        <text class=\"value\" transform=\"translate(10 21)\" style=\"font-size: 8px; font-family: 'ArialMT', 'Arial'\">\n          {{forwardseekoffset}}\n        </text>\n      </svg>\n    </media-seek-forward-button>\n  </template>\n\n  <template partial=\"MuteButton\">\n    <media-mute-button part=\"bottom mute button\" disabled=\"{{disabled}}\" aria-disabled=\"{{disabled}}\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"high\">\n        <path\n          d=\"m11.14 4.86-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.21a.5.5 0 0 0-.86-.35Zm2.74-1.56v1.52A7.52 7.52 0 0 1 19.47 12a7.52 7.52 0 0 1-5.59 7.18v1.52A9 9 0 0 0 21 12a9 9 0 0 0-7.12-8.7Zm3.56 8.7a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"low\">\n        <path\n          d=\"m11.14 4.853-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.203a.5.5 0 0 0-.86-.35Zm6.3 7.14a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"medium\">\n        <path\n          d=\"m11.14 4.853-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.203a.5.5 0 0 0-.86-.35Zm6.3 7.14a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"off\">\n        <path\n          d=\"m3 4.05 4.48 4.47-.33.33a.49.49 0 0 1-.36.15H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.48.48 0 0 0 .36.15.5.5 0 0 0 .5-.5v-5.75l4.67 4.66a7.71 7.71 0 0 1-2.79 1.47v1.52a9.32 9.32 0 0 0 3.87-1.91L20 21l1-1L4.06 3 3 4.05Zm5.36 5.36 2.39 2.39V17L8 14.26a1.74 1.74 0 0 0-1.24-.51H4.25v-3.5h2.54A1.74 1.74 0 0 0 8 9.74l.36-.33ZM19.47 12a7.19 7.19 0 0 1-.89 3.47l1.11 1.1A8.64 8.64 0 0 0 21 12a9 9 0 0 0-7.12-8.7v1.52A7.52 7.52 0 0 1 19.47 12ZM12 8.88V5.21a.5.5 0 0 0-.5-.5.48.48 0 0 0-.36.15L9.56 6.44 12 8.88ZM15.91 12a4.284 4.284 0 0 1-.07.72l1.22 1.22a5.2 5.2 0 0 0 .38-1.94 5.49 5.49 0 0 0-3.56-5.1v1.66A4 4 0 0 1 15.91 12Z\"\n        />\n      </svg>\n    </media-mute-button>\n  </template>\n\n  <template partial=\"PipButton\">\n    <media-pip-button part=\"bottom pip button\" disabled=\"{{disabled}}\" aria-disabled=\"{{disabled}}\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"enter\">\n        <path\n          d=\"M22 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h6.75v-1.25h-6.5V4.25h17.5v6.5H23V4a1 1 0 0 0-1-1Zm0 10h-8a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1Zm-.5 6.5h-7v-5h7v5Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"exit\">\n        <path\n          d=\"M22 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h6.75v-1.25h-6.5V4.25h17.5v6.5H23V4a1 1 0 0 0-1-1Zm0 10h-8a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1Zm-.5 6.5h-7v-5h7v5Z\"\n        />\n      </svg>\n    </media-pip-button>\n  </template>\n\n  <template partial=\"CaptionsMenuButton\">\n    <media-captions-selectmenu\n      part=\"bottom captions selectmenu\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"on\">\n        <path\n          d=\"M22.832 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.41 10.1a3.63 3.63 0 0 1-1.51.32 4.76 4.76 0 0 1-1.63-.27 4 4 0 0 1-1.28-.83 3.67 3.67 0 0 1-.84-1.26 4.23 4.23 0 0 1-.3-1.63 4.28 4.28 0 0 1 .3-1.64 3.53 3.53 0 0 1 .84-1.21 3.89 3.89 0 0 1 1.29-.8 4.76 4.76 0 0 1 1.63-.27 4.06 4.06 0 0 1 1.35.24c.225.091.44.205.64.34a2.7 2.7 0 0 1 .55.52l-1.27 1a1.79 1.79 0 0 0-.6-.46 2 2 0 0 0-.83-.16 2 2 0 0 0-1.56.69 2.35 2.35 0 0 0-.46.77 2.78 2.78 0 0 0-.16 1c-.009.34.046.68.16 1 .104.283.26.545.46.77.188.21.415.38.67.5a2 2 0 0 0 .84.18 1.87 1.87 0 0 0 .9-.21 1.78 1.78 0 0 0 .65-.6l1.38 1a2.88 2.88 0 0 1-1.22 1.01Zm7.52 0a3.63 3.63 0 0 1-1.51.32 4.76 4.76 0 0 1-1.63-.27 3.89 3.89 0 0 1-1.28-.83 3.55 3.55 0 0 1-.85-1.26 4.23 4.23 0 0 1-.3-1.63 4.28 4.28 0 0 1 .3-1.64 3.43 3.43 0 0 1 .85-1.25 3.75 3.75 0 0 1 1.28-.8 4.76 4.76 0 0 1 1.63-.27 4 4 0 0 1 1.35.24c.225.091.44.205.64.34.21.144.395.32.55.52l-1.27 1a1.79 1.79 0 0 0-.6-.46 2 2 0 0 0-.83-.16 2 2 0 0 0-1.56.69 2.352 2.352 0 0 0-.46.77 3.01 3.01 0 0 0-.16 1c-.003.34.05.678.16 1 .108.282.263.542.46.77.188.21.416.38.67.5a2 2 0 0 0 .84.18 1.87 1.87 0 0 0 .9-.21 1.78 1.78 0 0 0 .65-.6l1.38 1a2.82 2.82 0 0 1-1.21 1.05Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"off\">\n        <path\n          d=\"M22.832 5.68a2.58 2.58 0 0 0-2.3-2.5c-1.81-.12-4.67-.18-7.53-.18-2.86 0-5.72.06-7.53.18a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c1.81.12 4.67.18 7.53.18 2.86 0 5.72-.06 7.53-.18a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.137-.21-8.283 0-12.42a1.11 1.11 0 0 1 .91-1.11c1.67-.11 4.43-.18 7.43-.18s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.137.21 8.283 0 12.42ZM10.843 14a1.55 1.55 0 0 1-.76.18 1.57 1.57 0 0 1-.71-.18 1.69 1.69 0 0 1-.57-.42 2.099 2.099 0 0 1-.38-.58 2.47 2.47 0 0 1 0-1.64 2 2 0 0 1 .39-.66 1.73 1.73 0 0 1 .58-.42c.23-.103.479-.158.73-.16.241-.004.48.044.7.14.199.088.373.222.51.39l1.08-.89a2.179 2.179 0 0 0-.47-.44 2.81 2.81 0 0 0-.54-.32 2.91 2.91 0 0 0-.58-.15 2.71 2.71 0 0 0-.56 0 4.08 4.08 0 0 0-1.38.15 3.27 3.27 0 0 0-1.09.67 3.14 3.14 0 0 0-.71 1.06 3.62 3.62 0 0 0-.26 1.39 3.57 3.57 0 0 0 .26 1.38 3 3 0 0 0 .71 1.06c.316.293.687.52 1.09.67.443.16.91.238 1.38.23a3.2 3.2 0 0 0 1.28-.27c.401-.183.747-.47 1-.83l-1.17-.88a1.42 1.42 0 0 1-.53.52Zm6.62 0a1.58 1.58 0 0 1-.76.18 1.54 1.54 0 0 1-.7-.18 1.69 1.69 0 0 1-.57-.42 2.12 2.12 0 0 1-.43-.58 2.29 2.29 0 0 1 .39-2.3 1.84 1.84 0 0 1 1.32-.58c.241-.003.48.045.7.14.199.088.373.222.51.39l1.08-.92a2.43 2.43 0 0 0-.47-.44 3.22 3.22 0 0 0-.53-.29 2.999 2.999 0 0 0-.57-.15 2.87 2.87 0 0 0-.57 0 4.06 4.06 0 0 0-1.36.15 3.17 3.17 0 0 0-1.09.67 3 3 0 0 0-.72 1.06 3.62 3.62 0 0 0-.25 1.39 3.57 3.57 0 0 0 .25 1.38c.16.402.405.764.72 1.06a3.17 3.17 0 0 0 1.09.67c.44.16.904.237 1.37.23.441 0 .877-.092 1.28-.27a2.45 2.45 0 0 0 1-.83l-1.15-.85a1.49 1.49 0 0 1-.54.49Z\"\n        />\n      </svg>\n    </media-captions-selectmenu>\n  </template>\n\n  <template partial=\"AirplayButton\">\n    <media-airplay-button part=\"bottom airplay button\" disabled=\"{{disabled}}\" aria-disabled=\"{{disabled}}\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"airplay\">\n        <path\n          d=\"M13.19 14.22a.25.25 0 0 0-.38 0l-5.46 6.37a.25.25 0 0 0 .19.41h10.92a.25.25 0 0 0 .19-.41l-5.46-6.37Z\"\n        />\n        <path\n          d=\"M22 3H4a1 1 0 0 0-1 1v13a1 1 0 0 0 1 1h2.94L8 16.75H4.25V4.25h17.5v12.5H18L19.06 18H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z\"\n        />\n      </svg>\n    </media-airplay-button>\n  </template>\n\n  <template partial=\"FullscreenButton\">\n    <media-fullscreen-button part=\"bottom fullscreen button\" disabled=\"{{disabled}}\" aria-disabled=\"{{disabled}}\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"enter\">\n        <path\n          d=\"M20.25 14.5a.76.76 0 0 0-.75.75v4.25h-4.25a.75.75 0 1 0 0 1.5h5a.76.76 0 0 0 .75-.75v-5a.76.76 0 0 0-.75-.75Zm0-11.5h-5a.76.76 0 0 0-.75.75.76.76 0 0 0 .75.75h4.25v4.25a.75.75 0 1 0 1.5 0v-5a.76.76 0 0 0-.75-.75ZM8.75 19.5H4.5v-4.25a.76.76 0 0 0-.75-.75.76.76 0 0 0-.75.75v5a.76.76 0 0 0 .75.75h5a.75.75 0 1 0 0-1.5Zm0-16.5h-5a.76.76 0 0 0-.75.75v5a.76.76 0 0 0 .75.75.76.76 0 0 0 .75-.75V4.5h4.25a.76.76 0 0 0 .75-.75.76.76 0 0 0-.75-.75Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" slot=\"exit\">\n        <path\n          d=\"M20.25 14.5h-5a.76.76 0 0 0-.75.75v5a.75.75 0 1 0 1.5 0V16h4.25a.75.75 0 1 0 0-1.5Zm-5-5h5a.75.75 0 1 0 0-1.5H16V3.75a.75.75 0 1 0-1.5 0v5a.76.76 0 0 0 .75.75Zm-6.5 5h-5a.75.75 0 1 0 0 1.5H8v4.25a.75.75 0 1 0 1.5 0v-5a.76.76 0 0 0-.75-.75Zm0-11.5a.76.76 0 0 0-.75.75V8H3.75a.75.75 0 0 0 0 1.5h5a.76.76 0 0 0 .75-.75v-5A.76.76 0 0 0 8.75 3Z\"\n        />\n      </svg>\n    </media-fullscreen-button>\n  </template>\n\n  <template partial=\"CastButton\">\n    <media-cast-button part=\"bottom cast button\" disabled=\"{{disabled}}\" aria-disabled=\"{{disabled}}\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"enter\">\n        <path d=\"M3 15.5V17c2.206 0 4 1.794 4 4h1.5A5.5 5.5 0 0 0 3 15.5Zm0 3V21h2.5A2.5 2.5 0 0 0 3 18.5Z\" />\n        <path d=\"M3 12.5V14c3.86 0 7 3.14 7 7h1.5A8.5 8.5 0 0 0 3 12.5Z\" />\n        <path\n          d=\"M22 3H4a1 1 0 0 0-1 1v6.984c.424 0 .84.035 1.25.086V4.25h17.5v15.5h-8.82c.051.41.086.826.086 1.25H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z\"\n        />\n      </svg>\n      <svg aria-hidden=\"true\" viewBox=\"0 0 26 24\" slot=\"exit\">\n        <path d=\"M3 15.5V17c2.206 0 4 1.794 4 4h1.5A5.5 5.5 0 0 0 3 15.5Zm0 3V21h2.5A2.5 2.5 0 0 0 3 18.5Z\" />\n        <path d=\"M3 12.5V14c3.86 0 7 3.14 7 7h1.5A8.5 8.5 0 0 0 3 12.5Z\" />\n        <path\n          d=\"M22 3H4a1 1 0 0 0-1 1v6.984c.424 0 .84.035 1.25.086V4.25h17.5v15.5h-8.82c.051.41.086.826.086 1.25H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z\"\n        />\n        <path d=\"M20.5 5.5h-15v5.811c3.52.906 6.283 3.67 7.189 7.19H20.5V5.5Z\" />\n      </svg>\n    </media-cast-button>\n  </template>\n\n  <template partial=\"LiveButton\">\n    <media-live-button\n      part=\"{{section ?? 'top'}} live button\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    ></media-live-button>\n  </template>\n\n  <template partial=\"PlaybackRateButton\">\n    <media-playback-rate-button\n      rates=\"{{playbackrates}}\"\n      part=\"bottom playback-rate button\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    ></media-playback-rate-button>\n  </template>\n\n  <template partial=\"VolumeRange\">\n    <media-volume-range\n      part=\"bottom volume range\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    ></media-volume-range>\n  </template>\n\n  <template partial=\"TimeDisplay\">\n    <media-time-display\n      remaining=\"{{defaultshowremainingtime}}\"\n      showduration=\"{{!hideduration}}\"\n      part=\"bottom time display\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    ></media-time-display>\n  </template>\n\n  <template partial=\"TimeRange\">\n    <media-time-range\n      part=\"bottom time range\"\n      disabled=\"{{disabled}}\"\n      aria-disabled=\"{{disabled}}\"\n    ></media-time-range>\n  </template>\n\n  <media-controller\n    defaultstreamtype=\"{{defaultstreamtype ?? 'on-demand'}}\"\n    breakpoints=\"sm:300 md:700\"\n    gesturesdisabled=\"{{disabled}}\"\n    hotkeys=\"{{hotkeys}}\"\n    nohotkeys=\"{{nohotkeys}}\"\n    novolumepref=\"{{novolumepref}}\"\n    audio=\"{{audio}}\"\n    noautoseektolive=\"{{noautoseektolive}}\"\n    defaultsubtitles=\"{{defaultsubtitles}}\"\n    exportparts=\"layer, media-layer, poster-layer, vertical-layer, centered-layer, gesture-layer\"\n  >\n    <slot name=\"media\" slot=\"media\"></slot>\n    <slot name=\"poster\" slot=\"poster\"></slot>\n    <media-loading-indicator slot=\"centered-chrome\" noautohide></media-loading-indicator>\n\n    <template if=\"audio\">\n\n      <template if=\"streamtype == 'on-demand'\">\n        <template if=\"title\">\n          <media-control-bar>{{>TitleDisplay}}</media-control-bar>\n        </template>\n        <media-control-bar>\n          {{>PlayButton}}\n          {{>SeekBackwardButton}}\n          {{>SeekForwardButton}}\n          {{>TimeDisplay}}\n          {{>TimeRange}}\n          {{>MuteButton}}\n          {{>VolumeRange}}\n          {{>PlaybackRateButton}}\n          {{>AirplayButton}}\n          {{>CastButton}}\n        </media-control-bar>\n      </template>\n\n      <template if=\"streamtype == 'live'\">\n\n        <template if=\"targetlivewindow > 0\">\n          <template if=\"title\">\n            <media-control-bar>{{>TitleDisplay}}</media-control-bar>\n          </template>\n          <media-control-bar>\n            {{>PlayButton}}\n            {{>LiveButton section=\"bottom\"}}\n            {{>SeekBackwardButton}}\n            {{>SeekForwardButton}}\n            {{>TimeDisplay}}\n            {{>TimeRange}}\n            {{>MuteButton}}\n            {{>VolumeRange}}\n            {{>PlaybackRateButton}}\n            {{>AirplayButton}}\n            {{>CastButton}}\n          </media-control-bar>\n        </template>\n\n        <template if=\"!targetlivewindow\">\n          <template if=\"title\">\n            <media-control-bar>{{>TitleDisplay}}</media-control-bar>\n          </template>\n          <media-control-bar>\n            {{>PlayButton}}\n            {{>LiveButton section=\"bottom\"}}\n            {{>MuteButton}}\n            {{>VolumeRange}}\n            <div class=\"spacer\"></div>\n            {{>AirplayButton}}\n            {{>CastButton}}\n          </media-control-bar>\n        </template>\n\n      </template>\n    </template>\n\n    <template if=\"!audio\">\n\n      <template if=\"streamtype == 'on-demand'\">\n\n        <template if=\"!breakpointsm\">\n          {{>TimeRange}}\n          <media-control-bar>\n            {{>PlayButton}}\n            {{>MuteButton}}\n            <div class=\"spacer\"></div>\n            {{>CaptionsMenuButton}}\n            {{>FullscreenButton}}\n          </media-control-bar>\n        </template>\n\n        <template if=\"breakpointsm\">\n          <template if=\"!breakpointmd\">\n            <media-control-bar slot=\"top-chrome\">\n              {{>TitleDisplay}}\n            </media-control-bar>\n            <div slot=\"centered-chrome\" class=\"center-controls\">\n              {{>SeekBackwardButton section=\"center\"}}\n              {{>PlayButton section=\"center\"}}\n              {{>SeekForwardButton section=\"center\"}}\n            </div>\n            {{>TimeRange}}\n            <media-control-bar>\n              {{>PlayButton}}\n              {{>TimeDisplay}}\n              {{>MuteButton}}\n              {{>VolumeRange}}\n              <div class=\"spacer\"></div>\n              {{>PlaybackRateButton}}\n              {{>CaptionsMenuButton}}\n              {{>AirplayButton}}\n              {{>CastButton}}\n              {{>PipButton}}\n              {{>FullscreenButton}}\n            </media-control-bar>\n          </template>\n        </template>\n\n        <template if=\"breakpointmd\">\n          <media-control-bar slot=\"top-chrome\">\n            {{>TitleDisplay}}\n          </media-control-bar>\n          <div slot=\"centered-chrome\" class=\"center-controls\">\n            {{>PlayButton section=\"center\"}}\n          </div>\n          {{>TimeRange}}\n          <media-control-bar>\n            {{>PlayButton}}\n            {{>SeekBackwardButton}}\n            {{>SeekForwardButton}}\n            {{>TimeDisplay}}\n            {{>MuteButton}}\n            {{>VolumeRange}}\n            <div class=\"spacer\"></div>\n            {{>PlaybackRateButton}}\n            {{>CaptionsMenuButton}}\n            {{>AirplayButton}}\n            {{>CastButton}}\n            {{>PipButton}}\n            {{>FullscreenButton}}\n          </media-control-bar>\n        </template>\n\n      </template>\n\n      <template if=\"streamtype == 'live'\">\n\n        <template if=\"!targetlivewindow\">\n\n          <template if=\"!breakpointsm\">\n            <media-control-bar slot=\"top-chrome\">\n              {{>LiveButton}}\n            </media-control-bar>\n            <media-control-bar>\n              {{>PlayButton}}\n              {{>MuteButton}}\n              <div class=\"spacer\"></div>\n              {{>CaptionsMenuButton}}\n              {{>FullscreenButton}}\n            </media-control-bar>\n          </template>\n\n          <template if=\"breakpointsm\">\n            <template if=\"!breakpointmd\">\n              <media-control-bar slot=\"top-chrome\">\n                {{>LiveButton}}\n                {{>TitleDisplay}}\n              </media-control-bar>\n              <div slot=\"centered-chrome\" class=\"center-controls\">\n                {{>PlayButton section=\"center\"}}\n              </div>\n              <media-control-bar>\n                {{>PlayButton}}\n                {{>MuteButton}}\n                {{>VolumeRange}}\n                <div class=\"spacer\"></div>\n                {{>CaptionsMenuButton}}\n                {{>AirplayButton}}\n                {{>CastButton}}\n                {{>PipButton}}\n                {{>FullscreenButton}}\n              </media-control-bar>\n            </template>\n          </template>\n\n          <template if=\"breakpointmd\">\n            <media-control-bar slot=\"top-chrome\">\n              {{>LiveButton}}\n              {{>TitleDisplay}}\n            </media-control-bar>\n            <div slot=\"centered-chrome\" class=\"center-controls\">\n              {{>PlayButton section=\"center\"}}\n            </div>\n            <media-control-bar>\n              {{>PlayButton}}\n              {{>MuteButton}}\n              {{>VolumeRange}}\n              <div class=\"spacer\"></div>\n              {{>CaptionsMenuButton}}\n              {{>AirplayButton}}\n              {{>CastButton}}\n              {{>PipButton}}\n              {{>FullscreenButton}}\n            </media-control-bar>\n          </template>\n        </template>\n\n        <template if=\"targetlivewindow > 0\">\n\n          <template if=\"!breakpointsm\">\n            <media-control-bar slot=\"top-chrome\">\n              {{>LiveButton}}\n            </media-control-bar>\n            {{>TimeRange}}\n            <media-control-bar>\n              {{>PlayButton}}\n              {{>MuteButton}}\n              <div class=\"spacer\"></div>\n              {{>CaptionsMenuButton}}\n              {{>FullscreenButton}}\n            </media-control-bar>\n          </template>\n\n          <template if=\"breakpointsm\">\n            <template if=\"!breakpointmd\">\n              <media-control-bar slot=\"top-chrome\">\n                {{>LiveButton}}\n                {{>TitleDisplay}}\n              </media-control-bar>\n              <div slot=\"centered-chrome\" class=\"center-controls\">\n                {{>SeekBackwardButton section=\"center\"}}\n                {{>PlayButton section=\"center\"}}\n                {{>SeekForwardButton section=\"center\"}}\n              </div>\n              {{>TimeRange}}\n              <media-control-bar>\n                {{>PlayButton}}\n                {{>MuteButton}}\n                {{>VolumeRange}}\n                <div class=\"spacer\"></div>\n                {{>CaptionsMenuButton}}\n                {{>AirplayButton}}\n                {{>CastButton}}\n                {{>PipButton}}\n                {{>FullscreenButton}}\n              </media-control-bar>\n            </template>\n          </template>\n\n          <template if=\"breakpointmd\">\n            <media-control-bar slot=\"top-chrome\">\n              {{>LiveButton}}\n              {{>TitleDisplay}}\n            </media-control-bar>\n            <div slot=\"centered-chrome\" class=\"center-controls\">\n              {{>PlayButton section=\"center\"}}\n            </div>\n            {{>TimeRange}}\n            <media-control-bar>\n              {{>PlayButton}}\n              {{>SeekBackwardButton}}\n              {{>SeekForwardButton}}\n              {{>MuteButton}}\n              {{>VolumeRange}}\n              <div class=\"spacer\"></div>\n              {{>CaptionsMenuButton}}\n              {{>AirplayButton}}\n              {{>CastButton}}\n              {{>PipButton}}\n              {{>FullscreenButton}}\n            </media-control-bar>\n          </template>\n\n        </template>\n\n      </template>\n\n    </template>\n\n    <slot></slot>\n\n  </media-controller>\n</template>\n`;var yt=`\n  :host {\n    z-index: 100;\n    display: var(--media-dialog-display, flex);\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    box-sizing: border-box;\n    color: #fff;\n    line-height: 18px;\n    font-family: Arial, sans-serif;\n    padding: var(--media-dialog-backdrop-padding, 0);\n    background: var(--media-dialog-backdrop-background,\n      linear-gradient(to bottom, rgba(20, 20, 30, 0.7) 50%, rgba(20, 20, 30, 0.9))\n    );\n    /* Needs to use !important to prevent overwrite of media-chrome */\n    transition: var(--media-dialog-transition-open, visibility .2s, opacity .2s) !important;\n    transform: var(--media-dialog-transform-open, none) !important;\n    visibility: visible !important;\n    opacity: 1 !important;\n    pointer-events: auto !important;\n  }\n\n  :host(:not([open])) {\n    /* Needs to use !important to prevent overwrite of media-chrome */\n    transition: var(--media-dialog-transition-close, visibility .1s, opacity .1s) !important;\n    transform: var(--media-dialog-transform-close, none) !important;\n    visibility: hidden !important;\n    opacity: 0 !important;\n    pointer-events: none !important;\n  }\n\n  :focus-visible {\n    box-shadow: 0 0 0 2px rgba(27, 127, 204, 0.9);\n  }\n\n  .dialog {\n    position: relative;\n    box-sizing: border-box;\n    background: var(--media-dialog-background, none);\n    padding: var(--media-dialog-padding, 10px);\n    width: min(320px, 100%);\n    word-wrap: break-word;\n    max-height: 100%;\n    overflow: auto;\n    text-align: center;\n    line-height: 1.4;\n  }\n`,vt=T.createElement(\"template\");vt.innerHTML=`\n  <style>\n    ${yt}\n  </style>\n\n  <div class=\"dialog\">\n    <slot></slot>\n  </div>\n`;var I=class extends h.HTMLElement{constructor(){var e;super();this.attachShadow({mode:\"open\"}),(e=this.shadowRoot)==null||e.appendChild(this.constructor.template.content.cloneNode(!0))}show(){this.setAttribute(\"open\",\"\"),this.dispatchEvent(new CustomEvent(\"open\",{composed:!0,bubbles:!0})),ft(this)}close(){!this.hasAttribute(\"open\")||(this.removeAttribute(\"open\"),this.dispatchEvent(new CustomEvent(\"close\",{composed:!0,bubbles:!0})),jt(this))}attributeChangedCallback(e,r,i){e===\"open\"&&r!==i&&(i!=null?this.show():this.close())}connectedCallback(){this.hasAttribute(\"role\")||this.setAttribute(\"role\",\"dialog\"),this.hasAttribute(\"open\")&&ft(this)}};I.styles=yt,I.template=vt,I.observedAttributes=[\"open\"];function ft(t){let a=new CustomEvent(\"initfocus\",{composed:!0,bubbles:!0,cancelable:!0});if(t.dispatchEvent(a),a.defaultPrevented)return;let e=t.querySelector(\"[autofocus]:not([disabled])\");!e&&t.tabIndex>=0&&(e=t),e||(e=Et(t.shadowRoot)),t._previouslyFocusedElement=T.activeElement,T.activeElement instanceof HTMLElement&&T.activeElement.blur(),t.addEventListener(\"transitionend\",()=>{e instanceof HTMLElement&&e.focus({preventScroll:!0})},{once:!0})}function Et(t){let e=[\"button\",\"input\",\"keygen\",\"select\",\"textarea\"].map(function(i){return i+\":not([disabled])\"});e.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');let r=t==null?void 0:t.querySelector(e.join(\", \"));if(!r&&\"attachShadow\"in Element.prototype){let i=(t==null?void 0:t.querySelectorAll(\"*\"))||[];for(let o=0;o<i.length&&!(i[o].tagName&&i[o].shadowRoot&&(r=Et(i[o].shadowRoot),r));o++);}return r}function jt(t){t._previouslyFocusedElement instanceof HTMLElement&&t._previouslyFocusedElement.focus()}h.customElements.get(\"media-dialog\")||(h.customElements.define(\"media-dialog\",I),h.MediaDialog=I);var De=I;var kt=T.createElement(\"template\");kt.innerHTML=`\n  <style>\n    ${De.styles}\n\n    .close {\n      background: none;\n      color: inherit;\n      border: none;\n      padding: 0;\n      font: inherit;\n      cursor: pointer;\n      outline: inherit;\n      width: 28px;\n      height: 28px;\n      position: absolute;\n      top: 1rem;\n      right: 1rem;\n    }\n  </style>\n\n  <div class=\"dialog\">\n    <slot></slot>\n  </div>\n\n  <slot name=\"close\">\n    <button class=\"close\" tabindex=\"0\">\n      <svg fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6 18L18 6M6 6l12 12\" />\n      </svg>\n    </button>\n  </slot>\n`;var ee=class extends De{constructor(){var a,e;super(),(e=(a=this.shadowRoot)==null?void 0:a.querySelector(\".close\"))==null||e.addEventListener(\"click\",()=>{this.close()})}};ee.template=kt;h.customElements.get(\"mxp-dialog\")||(h.customElements.define(\"mxp-dialog\",ee),h.MxpDialog=ee);var te=new WeakMap,ae=class{constructor(a,e){this.element=a;this.type=e;this.element.addEventListener(this.type,this);let r=te.get(this.element);r&&r.set(this.type,this)}set(a){if(typeof a==\"function\")this.handleEvent=a.bind(this.element);else if(typeof a==\"object\"&&typeof a.handleEvent==\"function\")this.handleEvent=a.handleEvent.bind(a);else{this.element.removeEventListener(this.type,this);let e=te.get(this.element);e&&e.delete(this.type)}}static for(a){te.has(a.element)||te.set(a.element,new Map);let e=a.attributeName.slice(2),r=te.get(a.element);return r&&r.has(e)?r.get(e):new ae(a.element,e)}};function Gt(t,a){return t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.AttrPart&&t.attributeName.startsWith(\"on\")?(ae.for(t).set(a),t.element.removeAttributeNS(t.attributeNamespace,t.attributeName),!0):!1}function zt(t,a){return a instanceof be&&t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.ChildNodePart?(a.renderInto(t),!0):!1}function Jt(t,a){return a instanceof DocumentFragment&&t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.ChildNodePart?(a.childNodes.length&&t.replace(...a.childNodes),!0):!1}function Xt(t,a){if(t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.AttrPart){let e=t.attributeNamespace,r=t.element.getAttributeNS(e,t.attributeName);return String(a)!==r&&(t.value=String(a)),!0}return t.value=String(a),!0}function Qt(t,a){if(t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.AttrPart&&a instanceof Element){let e=t.element;return e[t.attributeName]!==a&&(t.element.removeAttributeNS(t.attributeNamespace,t.attributeName),e[t.attributeName]=a),!0}return!1}function ea(t,a){if(typeof a==\"boolean\"&&t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.AttrPart){let e=t.attributeNamespace,r=t.element.hasAttributeNS(e,t.attributeName);return a!==r&&(t.booleanValue=a),!0}return!1}function ta(t,a){return a===!1&&t instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.ChildNodePart?(t.replace(\"\"),!0):!1}function aa(t,a){Qt(t,a)||ea(t,a)||Gt(t,a)||ta(t,a)||zt(t,a)||Jt(t,a)||Xt(t,a)}var Ve=new Map,Tt=new WeakMap,At=new WeakMap,be=class{constructor(a,e,r){this.strings=a;this.values=e;this.processor=r;this.stringsKey=this.strings.join(\"\u0001\")}get template(){if(Ve.has(this.stringsKey))return Ve.get(this.stringsKey);{let a=T.createElement(\"template\"),e=this.strings.length-1;return a.innerHTML=this.strings.reduce((r,i,o)=>r+i+(o<e?`{{ ${o} }}`:\"\"),\"\"),Ve.set(this.stringsKey,a),a}}renderInto(a){var i;let e=this.template;if(Tt.get(a)!==e){Tt.set(a,e);let o=new media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.TemplateInstance(e,this.values,this.processor);At.set(a,o),a instanceof media_chrome_dist_media_theme_element_js__WEBPACK_IMPORTED_MODULE_4__.ChildNodePart?a.replace(...o.children):a.appendChild(o);return}let r=At.get(a);(i=r==null?void 0:r.update)==null||i.call(r,this.values)}},ia={processCallback(t,a,e){var r;if(!!e){for(let[i,o]of a)if(i in e){let n=(r=e[i])!=null?r:\"\";aa(o,n)}}}};function S(t,...a){return new be(t,a,ia)}function xt(t,a){t.renderInto(a)}var He=T.createElement(\"template\");\"innerHTML\"in He&&(He.innerHTML=gt);var wt=t=>S`\n  <style>\n    ${ht}\n  </style>\n  ${na(t)}\n`,oa=t=>{let a=t.hotKeys?`${t.hotKeys}`:\"\";return X(t.streamType)===\"live\"&&(a+=\" noarrowleft noarrowright\"),a},na=t=>{var a,e,r,i,o,n,u,b,w,k,P,g,v,A,_,c,le,G,Y,Fe,Ue,Ye,We,Ze,je,qe,Ge,ze,Je,Xe,Qe,et,tt,at,it;return S`\n  <media-theme\n    template=\"${(a=t.themeTemplate)!=null?a:He.content.children[0]}\"\n    defaultstreamtype=\"${(e=t.defaultStreamType)!=null?e:!1}\"\n    hotkeys=\"${oa(t)||!1}\"\n    nohotkeys=\"${t.noHotKeys||!t.hasSrc||t.isDialogOpen||!1}\"\n    noautoseektolive=\"${!!((r=t.streamType)!=null&&r.includes(_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE))&&t.targetLiveWindow!==0}\"\n    novolumepref=\"${t.novolumepref||!1}\"\n    disabled=\"${!t.hasSrc||t.isDialogOpen}\"\n    audio=\"${(i=t.audio)!=null?i:!1}\"\n    style=\"${(o=st({\"--media-primary-color\":t.primaryColor,\"--media-secondary-color\":t.secondaryColor}))!=null?o:!1}\"\n    defaultsubtitles=\"${!t.defaultHiddenCaptions}\"\n    forwardseekoffset=\"${(n=t.forwardSeekOffset)!=null?n:!1}\"\n    backwardseekoffset=\"${(u=t.backwardSeekOffset)!=null?u:!1}\"\n    playbackrates=\"${(b=t.playbackRates)!=null?b:!1}\"\n    defaultshowremainingtime=\"${(w=t.defaultShowRemainingTime)!=null?w:!1}\"\n    hideduration=\"${(k=t.hideDuration)!=null?k:!1}\"\n    title=\"${(P=t.title)!=null?P:!1}\"\n    exportparts=\"top, center, bottom, layer, media-layer, poster-layer, vertical-layer, centered-layer, gesture-layer, poster, live, play, button, seek-backward, seek-forward, mute, captions, airplay, pip, fullscreen, cast, playback-rate, volume, range, time, display\"\n  >\n    <mux-video\n      slot=\"media\"\n      target-live-window=\"${(g=t.targetLiveWindow)!=null?g:!1}\"\n      stream-type=\"${(v=X(t.streamType))!=null?v:!1}\"\n      crossorigin=\"${(A=t.crossOrigin)!=null?A:\"\"}\"\n      playsinline\n      autoplay=\"${(_=t.autoplay)!=null?_:!1}\"\n      muted=\"${(c=t.muted)!=null?c:!1}\"\n      loop=\"${(le=t.loop)!=null?le:!1}\"\n      preload=\"${(G=t.preload)!=null?G:!1}\"\n      debug=\"${(Y=t.debug)!=null?Y:!1}\"\n      prefer-cmcd=\"${(Fe=t.preferCmcd)!=null?Fe:!1}\"\n      disable-cookies=\"${(Ue=t.disableCookies)!=null?Ue:!1}\"\n      prefer-playback=\"${(Ye=t.preferPlayback)!=null?Ye:!1}\"\n      start-time=\"${t.startTime!=null?t.startTime:!1}\"\n      beacon-collection-domain=\"${(We=t.beaconCollectionDomain)!=null?We:!1}\"\n      player-software-name=\"${(Ze=t.playerSoftwareName)!=null?Ze:!1}\"\n      player-software-version=\"${(je=t.playerSoftwareVersion)!=null?je:!1}\"\n      env-key=\"${(qe=t.envKey)!=null?qe:!1}\"\n      custom-domain=\"${(Ge=t.customDomain)!=null?Ge:!1}\"\n      src=\"${t.src?t.src:t.playbackId?_e(t.playbackId,{maxResolution:t.maxResolution,domain:t.customDomain,token:t.tokens.playback}):!1}\"\n      cast-src=\"${t.src?t.src:t.playbackId?_e(t.playbackId,{maxResolution:t.maxResolution,domain:t.customDomain,token:t.tokens.playback}):!1}\"\n      exportparts=\"video\"\n    >\n      ${t.storyboard?S`<track label=\"thumbnails\" default kind=\"metadata\" src=\"${t.storyboard}\" />`:S``}\n    </mux-video>\n    <media-poster-image\n      slot=\"poster\"\n      part=\"poster\"\n      src=\"${t.poster===\"\"?!1:(ze=t.poster)!=null?ze:!1}\"\n      placeholder-src=\"${(Je=t.placeholder)!=null?Je:!1}\"\n    ></media-poster-image>\n    <mxp-dialog\n      no-auto-hide\n      open=\"${(Xe=t.isDialogOpen)!=null?Xe:!1}\"\n      onclose=\"${t.onCloseErrorDialog}\"\n      oninitfocus=\"${t.onInitFocusDialog}\"\n    >\n      ${(Qe=t.dialog)!=null&&Qe.title?S`<h3>${t.dialog.title}</h3>`:S``}\n      <p>\n        ${(et=t.dialog)==null?void 0:et.message}\n        ${(tt=t.dialog)!=null&&tt.linkUrl?S`<a\n              href=\"${t.dialog.linkUrl}\"\n              target=\"_blank\"\n              rel=\"external noopener\"\n              aria-label=\"${(at=t.dialog.linkText)!=null?at:\"\"} ${d(\"(opens in a new window)\")}\"\n              >${(it=t.dialog.linkText)!=null?it:t.dialog.linkUrl}</a\n            >`:S``}\n      </p>\n    </mxp-dialog>\n  </media-theme>\n`};function ye(t,a,e,r,i){var u,b,w;let o={},n={};switch(t.code){case _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError.MEDIA_ERR_NETWORK:{switch(o.title=d(\"Network Error\",i),o.message=t.message,(u=t.data)==null?void 0:u.response.code){case 412:{o.title=d(\"Video is not currently available\",i),o.message=d(\"The live stream or video file are not yet ready.\",i),n.message=d(\"This playback-id may belong to a live stream that is not currently active or an asset that is not ready.\",i),n.file=\"412-not-playable.md\";break}case 404:{o.title=d(\"Video does not exist\",i),o.message=\"\",n.message=d(\"This playback-id does not exist. You may have used an Asset ID or an ID from a different resource.\",i),n.file=\"404-not-found.md\";break}case 403:{if(o.title=d(\"Invalid playback URL\",i),o.message=d(\"The video URL or playback-token are formatted with incorrect or incomplete information.\",i),n.message=d(\"403 error trying to access this playback URL. If this is a signed URL, you might need to provide a playback-token.\",i),n.file=\"missing-signed-tokens.md\",!r)break;let{exp:k,aud:P,sub:g}=N(r),v=Date.now()>k*1e3,A=g!==e,_=P!==\"v\",c={timeStyle:\"medium\",dateStyle:\"medium\"};if(v){o.title=d(\"Video URL has expired\",i),o.message=d(\"The video\\u2019s secured playback-token has expired.\",i),n.message=d(\"The video\\u2019s secured playback-token has expired.\",i),n.context=d(\"Expired at: {expiredDate}. Current time: {currentDate}.\",i).format({expiredDate:new Intl.DateTimeFormat(H.code,c).format(k*1e3),currentDate:new Intl.DateTimeFormat(H.code,c).format(Date.now())}),n.file=\"403-expired-token.md\";break}if(A){o.title=d(\"Video URL is formatted incorrectly\",i),o.message=d(\"The video\\u2019s playback ID does not match the one encoded in the playback-token.\",i),n.message=d(\"The video\\u2019s playback ID does not match the one encoded in the playback-token.\",i),n.context=d(\"Specified playback ID: {playbackId} and the playback ID encoded in the playback-token: {tokenPlaybackId}\",i).format({playbackId:e,tokenPlaybackId:g}),n.file=\"403-playback-id-mismatch.md\";break}if(_){o.title=d(\"Video URL is formatted incorrectly\",i),o.message=d(\"The playback-token is formatted with incorrect information.\",i),n.message=d(\"The playback-token is formatted with incorrect information.\",i),n.context=d(\"The playback-token has an incorrect aud value: {tokenType}. aud value should be v.\",i).format({tokenType:P}),n.file=\"403-incorrect-aud-value.md\";break}n.message=d(\"403 error trying to access this playback URL. If this is a signed playback ID, the token might not have been generated correctly.\",i),n.file=\"403-malformatted-token.md\";break}}break}case _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError.MEDIA_ERR_DECODE:{let{message:k}=t;o={title:d(\"Media Error\",i),message:k},n.file=\"media-decode-error.md\";break}case _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:{let k=(w=(b=t.data)==null?void 0:b.response)==null?void 0:w.code;if(k>=400&&k<500){t.code=_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError.MEDIA_ERR_NETWORK,t.data={response:{code:k}},{dialog:o,devlog:n}=ye(t,a,e,r);break}o={title:d(\"Source Not Supported\",i),message:t.message},n.file=\"media-src-not-supported.md\";break}default:o={title:d(\"Error\",i),message:t.message};break}return a&&(o={title:d(\"Your device appears to be offline\",i),message:d(\"Check your internet connection and try reloading this video.\",i)}),{dialog:o,devlog:n}}var M={SRC:\"src\",POSTER:\"poster\"},s={STYLE:\"style\",DEFAULT_HIDDEN_CAPTIONS:\"default-hidden-captions\",PRIMARY_COLOR:\"primary-color\",SECONDARY_COLOR:\"secondary-color\",FORWARD_SEEK_OFFSET:\"forward-seek-offset\",BACKWARD_SEEK_OFFSET:\"backward-seek-offset\",PLAYBACK_TOKEN:\"playback-token\",THUMBNAIL_TOKEN:\"thumbnail-token\",STORYBOARD_TOKEN:\"storyboard-token\",STORYBOARD_SRC:\"storyboard-src\",THUMBNAIL_TIME:\"thumbnail-time\",AUDIO:\"audio\",NOHOTKEYS:\"nohotkeys\",HOTKEYS:\"hotkeys\",PLAYBACK_RATES:\"playbackrates\",DEFAULT_SHOW_REMAINING_TIME:\"default-show-remaining-time\",TITLE:\"title\",PLACEHOLDER:\"placeholder\",THEME:\"theme\",DEFAULT_STREAM_TYPE:\"default-stream-type\",TARGET_LIVE_WINDOW:\"target-live-window\",NO_VOLUME_PREF:\"no-volume-pref\"},$e=[\"audio\",\"backwardseekoffset\",\"defaultshowremainingtime\",\"defaultsubtitles\",\"noautoseektolive\",\"disabled\",\"exportparts\",\"forwardseekoffset\",\"hideduration\",\"hotkeys\",\"nohotkeys\",\"playbackrates\",\"defaultstreamtype\",\"streamtype\",\"style\",\"targetlivewindow\",\"template\",\"title\",\"novolumepref\"];function ma(t,a){var r;return{src:!t.playbackId&&t.src,playbackId:t.playbackId,hasSrc:!!t.playbackId||!!t.src,poster:t.poster,storyboard:t.storyboard,storyboardSrc:t.getAttribute(s.STORYBOARD_SRC),placeholder:t.getAttribute(\"placeholder\"),themeTemplate:ca(t),thumbnailTime:!t.tokens.thumbnail&&t.thumbnailTime,autoplay:t.autoplay,crossOrigin:t.crossOrigin,loop:t.loop,noHotKeys:t.hasAttribute(s.NOHOTKEYS),hotKeys:t.getAttribute(s.HOTKEYS),muted:t.muted,paused:t.paused,preload:t.preload,envKey:t.envKey,preferCmcd:t.preferCmcd,debug:t.debug,disableCookies:t.disableCookies,tokens:t.tokens,beaconCollectionDomain:t.beaconCollectionDomain,maxResolution:t.maxResolution,metadata:t.metadata,playerSoftwareName:t.playerSoftwareName,playerSoftwareVersion:t.playerSoftwareVersion,startTime:t.startTime,preferPlayback:t.preferPlayback,audio:t.audio,defaultStreamType:t.defaultStreamType,targetLiveWindow:t.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.TARGET_LIVE_WINDOW),streamType:X(t.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.STREAM_TYPE)),primaryColor:t.primaryColor,secondaryColor:t.secondaryColor,forwardSeekOffset:t.forwardSeekOffset,backwardSeekOffset:t.backwardSeekOffset,defaultHiddenCaptions:t.defaultHiddenCaptions,defaultShowRemainingTime:t.defaultShowRemainingTime,hideDuration:pa(t),playbackRates:t.getAttribute(s.PLAYBACK_RATES),customDomain:(r=t.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.CUSTOM_DOMAIN))!=null?r:void 0,title:t.getAttribute(s.TITLE),novolumepref:t.hasAttribute(s.NO_VOLUME_PREF),...a}}function ca(t){var e,r;let a=t.getAttribute(s.THEME);if(a){let i=(r=(e=t.getRootNode())==null?void 0:e.getElementById)==null?void 0:r.call(e,a);if(i)return i;a.startsWith(\"media-theme-\")||(a=`media-theme-${a}`);let o=h.customElements.get(a);if(o!=null&&o.template)return o.template}}function pa(t){var e;let a=(e=t.mediaController)==null?void 0:e.querySelector(\"media-time-display\");return a&&getComputedStyle(a).getPropertyValue(\"--media-duration-display-display\").trim()===\"none\"}function Lt(t){return t.getAttributeNames().filter(a=>a.startsWith(\"metadata-\")).reduce((a,e)=>{let r=t.getAttribute(e);return r!==null&&(a[e.replace(/^metadata-/,\"\").replace(/-/g,\"_\")]=r),a},{})}var ba=Object.values(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes),ha=Object.values(M),ga=Object.values(s),fa=pe(),ya=\"mux-player\",Rt={dialog:void 0,isDialogOpen:!1},re,oe,C,ne,U,D,j,ke,St,se,Ke,V,q,Te,Mt,Ae,Ct,xe,Pt,we,_t,ie=class extends Ie{constructor(){super();p(this,D);p(this,ke);p(this,se);p(this,V);p(this,Te);p(this,Ae);p(this,xe);p(this,we);p(this,re,!1);p(this,oe,{});p(this,C,!0);p(this,ne,new ce(this,\"hotkeys\"));p(this,U,{...Rt,onCloseErrorDialog:()=>f(this,se,Ke).call(this,{dialog:void 0,isDialogOpen:!1}),onInitFocusDialog:e=>{Me(this,T.activeElement)||e.preventDefault()}});this.attachShadow({mode:\"open\"}),f(this,ke,St).call(this),this.isConnected&&f(this,D,j).call(this)}static get observedAttributes(){var e;return[...(e=Ie.observedAttributes)!=null?e:[],...ha,...ba,...ga]}get mediaTheme(){var e;return(e=this.shadowRoot)==null?void 0:e.querySelector(\"media-theme\")}get mediaController(){var e,r;return(r=(e=this.mediaTheme)==null?void 0:e.shadowRoot)==null?void 0:r.querySelector(\"media-controller\")}connectedCallback(){var r;let e=(r=this.shadowRoot)==null?void 0:r.querySelector(\"mux-video\");e&&(e.metadata=Lt(this))}attributeChangedCallback(e,r,i){switch(f(this,D,j).call(this),super.attributeChangedCallback(e,r,i),e){case s.HOTKEYS:m(this,ne).value=i;break;case s.THUMBNAIL_TIME:{i!=null&&this.tokens.thumbnail&&B(d(\"Use of thumbnail-time with thumbnail-token is currently unsupported. Ignore thumbnail-time.\").format({}));break}case s.THUMBNAIL_TOKEN:{let{aud:n}=N(i);i&&n!==\"t\"&&B(d(\"The provided thumbnail-token should have audience value 't' instead of '{aud}'.\").format({aud:n}));break}case s.STORYBOARD_TOKEN:{let{aud:n}=N(i);i&&n!==\"s\"&&B(d(\"The provided storyboard-token should have audience value 's' instead of '{aud}'.\").format({aud:n}));break}case _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYBACK_ID:{i!=null&&i.includes(\"?token\")&&O(d(\"The specificed playback ID {playbackId} contains a token which must be provided via the playback-token attribute.\").format({playbackId:i}));break}case _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.STREAM_TYPE:i&&![_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.ON_DEMAND,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.UNKNOWN].includes(i)?[\"ll-live\",\"live:dvr\",\"ll-live:dvr\"].includes(this.streamType)?this.targetLiveWindow=i.includes(\"dvr\")?Number.POSITIVE_INFINITY:0:Ne({file:\"invalid-stream-type.md\",message:d(\"Invalid stream-type value supplied: `{streamType}`. Please provide stream-type as either: `on-demand` or `live`\").format({streamType:this.streamType})}):this.targetLiveWindow=i===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE?0:Number.NaN}[_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYBACK_ID,M.SRC,s.PLAYBACK_TOKEN].includes(e)&&r!==i&&x(this,U,{...m(this,U),...Rt}),f(this,V,q).call(this,{[ut(e)]:i})}get preferCmcd(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_CMCD))!=null?e:void 0}set preferCmcd(e){e!==this.preferCmcd&&(e?_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.CmcdTypeValues.includes(e)?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_CMCD,e):B(`Invalid value for preferCmcd. Must be one of ${_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.CmcdTypeValues.join()}`):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_CMCD))}get hasPlayed(){var e,r;return(r=(e=this.mediaController)==null?void 0:e.hasAttribute(\"media-has-played\"))!=null?r:!1}get inLiveWindow(){var e;return(e=this.mediaController)==null?void 0:e.hasAttribute(\"media-time-is-live\")}get _hls(){var e;return(e=this.media)==null?void 0:e._hls}get mux(){var e;return(e=this.media)==null?void 0:e.mux}get theme(){var e;return(e=this.getAttribute(s.THEME))!=null?e:\"\"}set theme(e){this.setAttribute(s.THEME,`${e}`)}get themeProps(){let e=this.mediaTheme;if(!e)return;let r={};for(let i of e.getAttributeNames()){if($e.includes(i))continue;let o=e.getAttribute(i);r[ue(i)]=o===\"\"?!0:o}return r}set themeProps(e){var i,o;f(this,D,j).call(this);let r={...this.themeProps,...e};for(let n in r){if($e.includes(n))continue;let u=e==null?void 0:e[n];typeof u==\"boolean\"||u==null?(i=this.mediaTheme)==null||i.toggleAttribute(de(n),Boolean(u)):(o=this.mediaTheme)==null||o.setAttribute(de(n),u)}}get playbackId(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYBACK_ID))!=null?e:void 0}set playbackId(e){e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYBACK_ID,e):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYBACK_ID)}get src(){var e,r;return this.playbackId?(e=Z(this,M.SRC))!=null?e:void 0:(r=this.getAttribute(M.SRC))!=null?r:void 0}set src(e){e?this.setAttribute(M.SRC,e):this.removeAttribute(M.SRC)}get poster(){var r;let e=this.getAttribute(M.POSTER);if(e!=null)return e;if(this.playbackId&&!this.audio)return lt(this.playbackId,{domain:this.customDomain,thumbnailTime:(r=this.thumbnailTime)!=null?r:this.startTime,token:this.tokens.thumbnail})}set poster(e){e||e===\"\"?this.setAttribute(M.POSTER,e):this.removeAttribute(M.POSTER)}get storyboardSrc(){var e;return(e=this.getAttribute(s.STORYBOARD_SRC))!=null?e:void 0}set storyboardSrc(e){e?this.setAttribute(s.STORYBOARD_SRC,e):this.removeAttribute(s.STORYBOARD_SRC)}get storyboard(){if(this.storyboardSrc&&!this.tokens.storyboard)return this.storyboardSrc;if(!(this.audio||!this.playbackId||!this.streamType||[_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.UNKNOWN].includes(this.streamType)))return dt(this.playbackId,{domain:this.customDomain,token:this.tokens.storyboard})}get audio(){return this.hasAttribute(s.AUDIO)}set audio(e){if(!e){this.removeAttribute(s.AUDIO);return}this.setAttribute(s.AUDIO,\"\")}get hotkeys(){return m(this,ne)}get nohotkeys(){return this.hasAttribute(s.NOHOTKEYS)}set nohotkeys(e){if(!e){this.removeAttribute(s.NOHOTKEYS);return}this.setAttribute(s.NOHOTKEYS,\"\")}get thumbnailTime(){return R(this.getAttribute(s.THUMBNAIL_TIME))}set thumbnailTime(e){this.setAttribute(s.THUMBNAIL_TIME,`${e}`)}get title(){var e;return(e=this.getAttribute(s.TITLE))!=null?e:\"\"}set title(e){e!==this.title&&(e?this.setAttribute(s.TITLE,e):this.removeAttribute(\"title\"),super.title=e)}get placeholder(){var e;return(e=Z(this,s.PLACEHOLDER))!=null?e:\"\"}set placeholder(e){this.setAttribute(s.PLACEHOLDER,`${e}`)}get primaryColor(){var r,i;let e=this.getAttribute(s.PRIMARY_COLOR);if(e!=null||this.mediaTheme&&(e=(i=(r=h.getComputedStyle(this.mediaTheme))==null?void 0:r.getPropertyValue(\"--_primary-color\"))==null?void 0:i.trim(),e))return e}set primaryColor(e){this.setAttribute(s.PRIMARY_COLOR,`${e}`)}get secondaryColor(){var r,i;let e=this.getAttribute(s.SECONDARY_COLOR);if(e!=null||this.mediaTheme&&(e=(i=(r=h.getComputedStyle(this.mediaTheme))==null?void 0:r.getPropertyValue(\"--_secondary-color\"))==null?void 0:i.trim(),e))return e}set secondaryColor(e){this.setAttribute(s.SECONDARY_COLOR,`${e}`)}get defaultShowRemainingTime(){return this.hasAttribute(s.DEFAULT_SHOW_REMAINING_TIME)}set defaultShowRemainingTime(e){e?this.setAttribute(s.DEFAULT_SHOW_REMAINING_TIME,\"\"):this.removeAttribute(s.DEFAULT_SHOW_REMAINING_TIME)}get playbackRates(){if(!!this.hasAttribute(s.PLAYBACK_RATES))return this.getAttribute(s.PLAYBACK_RATES).trim().split(/\\s*,?\\s+/).map(e=>Number(e)).filter(e=>!Number.isNaN(e)).sort((e,r)=>e-r)}set playbackRates(e){if(!e){this.removeAttribute(s.PLAYBACK_RATES);return}this.setAttribute(s.PLAYBACK_RATES,e.join(\" \"))}get forwardSeekOffset(){var e;return(e=R(this.getAttribute(s.FORWARD_SEEK_OFFSET)))!=null?e:10}set forwardSeekOffset(e){this.setAttribute(s.FORWARD_SEEK_OFFSET,`${e}`)}get backwardSeekOffset(){var e;return(e=R(this.getAttribute(s.BACKWARD_SEEK_OFFSET)))!=null?e:10}set backwardSeekOffset(e){this.setAttribute(s.BACKWARD_SEEK_OFFSET,`${e}`)}get defaultHiddenCaptions(){return this.hasAttribute(s.DEFAULT_HIDDEN_CAPTIONS)}set defaultHiddenCaptions(e){e?this.setAttribute(s.DEFAULT_HIDDEN_CAPTIONS,\"\"):this.removeAttribute(s.DEFAULT_HIDDEN_CAPTIONS)}get playerSoftwareName(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYER_SOFTWARE_NAME))!=null?e:ya}get playerSoftwareVersion(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PLAYER_SOFTWARE_VERSION))!=null?e:fa}get beaconCollectionDomain(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.BEACON_COLLECTION_DOMAIN))!=null?e:void 0}set beaconCollectionDomain(e){e!==this.beaconCollectionDomain&&(e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.BEACON_COLLECTION_DOMAIN,e):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.BEACON_COLLECTION_DOMAIN))}get maxResolution(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.MAX_RESOLUTION))!=null?e:void 0}set maxResolution(e){e!==this.maxResolution&&(e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.MAX_RESOLUTION,e):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.MAX_RESOLUTION))}get customDomain(){var e;return(e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.CUSTOM_DOMAIN))!=null?e:void 0}set customDomain(e){e!==this.customDomain&&(e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.CUSTOM_DOMAIN,e):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.CUSTOM_DOMAIN))}get envKey(){var e;return(e=Z(this,_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.ENV_KEY))!=null?e:void 0}set envKey(e){this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.ENV_KEY,`${e}`)}get noVolumePref(){return this.hasAttribute(s.NO_VOLUME_PREF)}set noVolumePref(e){e?this.setAttribute(s.NO_VOLUME_PREF,\"\"):this.removeAttribute(s.NO_VOLUME_PREF)}get debug(){return Z(this,_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DEBUG)!=null}set debug(e){e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DEBUG,\"\"):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DEBUG)}get disableCookies(){return Z(this,_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DISABLE_COOKIES)!=null}set disableCookies(e){e?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DISABLE_COOKIES,\"\"):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.DISABLE_COOKIES)}get streamType(){var e,r,i;return(i=(r=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.STREAM_TYPE))!=null?r:(e=this.media)==null?void 0:e.streamType)!=null?i:_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.UNKNOWN}set streamType(e){this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.STREAM_TYPE,`${e}`)}get defaultStreamType(){var e,r,i;return(i=(r=this.getAttribute(s.DEFAULT_STREAM_TYPE))!=null?r:(e=this.mediaController)==null?void 0:e.getAttribute(s.DEFAULT_STREAM_TYPE))!=null?i:_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.ON_DEMAND}set defaultStreamType(e){e?this.setAttribute(s.DEFAULT_STREAM_TYPE,e):this.removeAttribute(s.DEFAULT_STREAM_TYPE)}get targetLiveWindow(){var e,r;return this.hasAttribute(s.TARGET_LIVE_WINDOW)?+this.getAttribute(s.TARGET_LIVE_WINDOW):(r=(e=this.media)==null?void 0:e.targetLiveWindow)!=null?r:Number.NaN}set targetLiveWindow(e){e!=this.targetLiveWindow&&(e==null?this.removeAttribute(s.TARGET_LIVE_WINDOW):this.setAttribute(s.TARGET_LIVE_WINDOW,`${+e}`))}get liveEdgeStart(){var e;return(e=this.media)==null?void 0:e.liveEdgeStart}get startTime(){return R(Z(this,_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.START_TIME))}set startTime(e){this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.START_TIME,`${e}`)}get preferPlayback(){let e=this.getAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_PLAYBACK);if(e===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.PlaybackTypes.MSE||e===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.PlaybackTypes.NATIVE)return e}set preferPlayback(e){e!==this.preferPlayback&&(e===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.PlaybackTypes.MSE||e===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.PlaybackTypes.NATIVE?this.setAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_PLAYBACK,e):this.removeAttribute(_mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.Attributes.PREFER_PLAYBACK))}get metadata(){var e;return(e=this.media)==null?void 0:e.metadata}set metadata(e){if(f(this,D,j).call(this),!this.media){O(\"underlying media element missing when trying to set metadata. metadata will not be set.\");return}this.media.metadata={...Lt(this),...e}}async addCuePoints(e){var r;if(f(this,D,j).call(this),!this.media){O(\"underlying media element missing when trying to addCuePoints. cuePoints will not be added.\");return}return(r=this.media)==null?void 0:r.addCuePoints(e)}get activeCuePoint(){var e;return(e=this.media)==null?void 0:e.activeCuePoint}get cuePoints(){var e,r;return(r=(e=this.media)==null?void 0:e.cuePoints)!=null?r:[]}getStartDate(){var e;return(e=this.media)==null?void 0:e.getStartDate()}get currentPdt(){var e;return(e=this.media)==null?void 0:e.currentPdt}get tokens(){let e=this.getAttribute(s.PLAYBACK_TOKEN),r=this.getAttribute(s.THUMBNAIL_TOKEN),i=this.getAttribute(s.STORYBOARD_TOKEN);return{...m(this,oe),...e!=null?{playback:e}:{},...r!=null?{thumbnail:r}:{},...i!=null?{storyboard:i}:{}}}set tokens(e){x(this,oe,e!=null?e:{})}get playbackToken(){var e;return(e=this.getAttribute(s.PLAYBACK_TOKEN))!=null?e:void 0}set playbackToken(e){this.setAttribute(s.PLAYBACK_TOKEN,`${e}`)}get thumbnailToken(){var e;return(e=this.getAttribute(s.THUMBNAIL_TOKEN))!=null?e:void 0}set thumbnailToken(e){this.setAttribute(s.THUMBNAIL_TOKEN,`${e}`)}get storyboardToken(){var e;return(e=this.getAttribute(s.STORYBOARD_TOKEN))!=null?e:void 0}set storyboardToken(e){this.setAttribute(s.STORYBOARD_TOKEN,`${e}`)}addTextTrack(e,r,i,o){var u;let n=(u=this.media)==null?void 0:u.nativeEl;if(!!n)return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.addTextTrack)(n,e,r,i,o)}removeTextTrack(e){var i;let r=(i=this.media)==null?void 0:i.nativeEl;if(!!r)return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.removeTextTrack)(r,e)}get textTracks(){var e;return(e=this.media)==null?void 0:e.textTracks}};re=new WeakMap,oe=new WeakMap,C=new WeakMap,ne=new WeakMap,U=new WeakMap,D=new WeakSet,j=function(){var e,r,i;if(!m(this,re)){x(this,re,!0),f(this,V,q).call(this);try{if(customElements.upgrade(this.mediaTheme),!(this.mediaTheme instanceof h.HTMLElement))throw\"\"}catch{O(\"<media-theme> failed to upgrade!\")}try{if(customElements.upgrade(this.media),!(this.media instanceof _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__[\"default\"]))throw\"\"}catch{O(\"<mux-video> failed to upgrade!\")}try{if(customElements.upgrade(this.mediaController),!(this.mediaController instanceof media_chrome__WEBPACK_IMPORTED_MODULE_0__.MediaController))throw\"\"}catch{O(\"<media-controller> failed to upgrade!\")}bt(this),f(this,Te,Mt).call(this),f(this,Ae,Ct).call(this),f(this,xe,Pt).call(this),x(this,C,(r=(e=this.mediaController)==null?void 0:e.hasAttribute(\"userinactive\"))!=null?r:!0),f(this,we,_t).call(this),(i=this.media)==null||i.addEventListener(\"streamtypechange\",()=>{f(this,V,q).call(this)})}},ke=new WeakSet,St=function(){var e,r;try{(e=window==null?void 0:window.CSS)==null||e.registerProperty({name:\"--media-primary-color\",syntax:\"<color>\",inherits:!0}),(r=window==null?void 0:window.CSS)==null||r.registerProperty({name:\"--media-secondary-color\",syntax:\"<color>\",inherits:!0})}catch{}},se=new WeakSet,Ke=function(e){Object.assign(m(this,U),e),f(this,V,q).call(this)},V=new WeakSet,q=function(e={}){xt(wt(ma(this,{...m(this,U),...e})),this.shadowRoot)},Te=new WeakSet,Mt=function(){let e=i=>{var u,b;if(!(i!=null&&i.startsWith(\"theme-\")))return;let o=i.replace(/^theme-/,\"\");if($e.includes(o))return;let n=this.getAttribute(i);n!=null?(u=this.mediaTheme)==null||u.setAttribute(o,n):(b=this.mediaTheme)==null||b.removeAttribute(o)};new MutationObserver(i=>{for(let{attributeName:o}of i)e(o)}).observe(this,{attributes:!0}),this.getAttributeNames().forEach(e)},Ae=new WeakSet,Ct=function(){var r;let e=i=>{let{detail:o}=i;if(o instanceof _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError||(o=new _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError(o.message,o.code,o.fatal)),!(o!=null&&o.fatal)){B(o),o.data&&B(`${o.name} data:`,o.data);return}let{dialog:n,devlog:u}=ye(o,!window.navigator.onLine,this.playbackId,this.playbackToken);u.message&&Ne(u),O(o),o.data&&O(`${o.name} data:`,o.data),f(this,se,Ke).call(this,{isDialogOpen:!0,dialog:n})};this.addEventListener(\"error\",e),this.media&&(this.media.errorTranslator=(i={})=>{var n,u,b;if(!(((n=this.media)==null?void 0:n.error)instanceof _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError))return i;let{devlog:o}=ye((u=this.media)==null?void 0:u.error,!window.navigator.onLine,this.playbackId,this.playbackToken,!1);return{player_error_code:(b=this.media)==null?void 0:b.error.code,player_error_message:o.message?String(o.message):i.player_error_message,player_error_context:o.context?String(o.context):i.player_error_context}}),(r=this.media)==null||r.addEventListener(\"error\",i=>{var n,u;let{detail:o}=i;if(!o){let{message:b,code:w}=(u=(n=this.media)==null?void 0:n.error)!=null?u:{};o=new _mux_mux_video__WEBPACK_IMPORTED_MODULE_2__.MediaError(b,w)}!(o!=null&&o.fatal)||this.dispatchEvent(new CustomEvent(\"error\",{detail:o}))})},xe=new WeakSet,Pt=function(){var r,i,o,n;let e=()=>f(this,V,q).call(this);(i=(r=this.media)==null?void 0:r.textTracks)==null||i.addEventListener(\"addtrack\",e),(n=(o=this.media)==null?void 0:o.textTracks)==null||n.addEventListener(\"removetrack\",e)},we=new WeakSet,_t=function(){var k,P;let e=/.*Version\\/.*Safari\\/.*/.test(navigator.userAgent);if(!/Firefox/i.test(navigator.userAgent))return;let i,o=new WeakMap,n=()=>this.streamType===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE&&!this.secondaryColor&&this.offsetWidth>=800,u=(g,v,A=!1)=>{if(n())return;Array.from(g&&g.activeCues||[]).forEach(c=>{if(!(!c.snapToLines||c.line<-5||c.line>=0&&c.line<10))if(!v||this.paused){let le=c.text.split(`\n`).length,G=e?-2:-3;this.streamType===_mux_playback_core__WEBPACK_IMPORTED_MODULE_3__.StreamTypes.LIVE&&(G=e?-1:-2);let Y=G-le;if(c.line===Y&&!A)return;o.has(c)||o.set(c,c.line),c.line=Y-1,c.line=Y}else setTimeout(()=>{c.line=o.get(c)||\"auto\"},500)})},b=()=>{var g,v;u(i,(v=(g=this.mediaController)==null?void 0:g.hasAttribute(\"userinactive\"))!=null?v:!1)},w=()=>{var A,_;let v=Array.from(((_=(A=this.mediaController)==null?void 0:A.media)==null?void 0:_.textTracks)||[]).filter(c=>[\"subtitles\",\"captions\"].includes(c.kind)&&c.mode===\"showing\")[0];v!==i&&(i==null||i.removeEventListener(\"cuechange\",b)),i=v,i==null||i.addEventListener(\"cuechange\",b),u(i,m(this,C))};if(w(),(k=this.textTracks)==null||k.addEventListener(\"change\",w),(P=this.textTracks)==null||P.addEventListener(\"addtrack\",w),navigator.userAgent.includes(\"Chrome/\")){let g=()=>{u(i,m(this,C),!0),this.paused||window.requestAnimationFrame(g)};this.addEventListener(\"playing\",()=>{g()})}this.addEventListener(\"userinactivechange\",()=>{var v,A;let g=(A=(v=this.mediaController)==null?void 0:v.hasAttribute(\"userinactive\"))!=null?A:!0;m(this,C)!==g&&(x(this,C,g),u(i,m(this,C)))})};function Z(t,a){return t.media?t.media.getAttribute(a):t.getAttribute(a)}h.customElements.get(\"mux-player\")||(h.customElements.define(\"mux-player\",ie),h.MuxPlayerElement=ie);var ki=ie;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BtdXgvbXV4LXBsYXllci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlCQUFpQiwyQ0FBMkMsb0ZBQW9GLGlGQUFpRix5Q0FBeUMsNEVBQTRFLG1EQUFtRCxZQUFZLG9CQUFvQix1QkFBdUIsaUJBQWlCLFdBQVcseUNBQXlDLG1CQUFtQiw4QkFBOEIsdUJBQXVCLHFCQUFxQixLQUFLLFFBQVEsZ0JBQWdCLGFBQWEsZ0JBQWdCLDJCQUEyQixZQUFZLGtCQUFrQixFQUFFLGlCQUFpQixrQ0FBa0MsYUFBYSxpQkFBaUIscUJBQXFCLGNBQWMsaUJBQWlCLGFBQWEsUUFBUSxVQUFVLGlCQUFpQixtR0FBbUcsc0lBQTRlLGVBQWUsU0FBUyxZQUFZLG1CQUFtQixRQUFRLDZEQUE2RCxtQkFBbUIsYUFBYSw4Q0FBOEMsNkJBQTZCLFVBQVUsK0JBQStCLE9BQU8sV0FBVyxNQUFNLDBCQUEwQixFQUFFLFdBQVcsc0JBQXNCLGVBQWUsU0FBUywyQ0FBMkMsZ0JBQWdCLE1BQU0sSUFBSSxJQUFJLEdBQUcsb0JBQW9CLGVBQWUsMERBQTBELGVBQWUsd0RBQXdELGNBQWMsa0JBQWtCLFNBQVMsZ0NBQWdDLGVBQWUsdUJBQXVCLGtCQUFrQixlQUFlLFNBQVMsdUNBQXVDLDhCQUE4QixjQUFjLG1DQUFtQyxlQUFlLG1HQUFtRyx3REFBd0QsWUFBWSxxQkFBcUIsb0VBQXNILHlCQUF5QixJQUFJLGVBQWUsT0FBTyxnQkFBZ0IsMEJBQTBCLG9DQUFvQyxHQUFHLElBQUksV0FBVyxRQUFRLEVBQUUsMkJBQTJCLGlCQUFpQixLQUFLLHdCQUF3QixFQUFFLEdBQUcsRUFBRSxPQUFPLE1BQU0sRUFBRSxRQUFRLG9DQUFvQyxHQUFHLElBQUksd0JBQXdCLE1BQU0sTUFBTSx3Q0FBd0MsRUFBRSxHQUFHLEVBQUUsaUJBQWlCLElBQUksZUFBZSxFQUFFLEVBQUUsUUFBUSxvQkFBb0IsR0FBRyxJQUFJLElBQUksTUFBTSxNQUFNLHdDQUF3QyxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsSUFBSSxzQkFBc0IsRUFBRSxFQUFFLE9BQU8sUUFBUSxJQUFJLDJEQUFFLE1BQU0sMkRBQUUsaUNBQWlDLHNDQUFzQywyREFBRSxRQUFRLFFBQVEscURBQXFELGVBQWUsTUFBTSw4QkFBOEIsbUJBQW1CLGlCQUFpQixpQkFBaUIsaUJBQWlCLGFBQWEsd0JBQXdCLG9CQUFvQiwwQkFBMEIsYUFBYSx3QkFBd0IsWUFBWSxNQUFNLHlDQUF5QyxhQUFhLE1BQU0sdUZBQXVGLFdBQVcsa0JBQWtCLFFBQVEsb0JBQW9CLFNBQVMsMEJBQTBCLE9BQU8sd0JBQXdCLFdBQVcscUJBQXFCLFVBQVUsUUFBUSxjQUFjLG9DQUFvQyw4REFBOEQsVUFBVSw4Q0FBOEMsVUFBVSxLQUFLLFdBQVcsSUFBSSxhQUFhLE1BQU0sY0FBYyx5Q0FBeUMseUNBQXlDLFVBQVUsS0FBSyxXQUFXLEdBQUcsWUFBWSw2QkFBNkIsWUFBWSwwSEFBMEgsYUFBYSw2QkFBNkIsMENBQTBDLHNCQUFzQixLQUFLLEdBQUcsaUJBQWlCLHNCQUFzQixpQkFBaUIsdUJBQXVCLGVBQWUsTUFBTSwrQkFBK0Isc0JBQXNCLFVBQVUsV0FBVyw2REFBNkQsT0FBTztBQUMxeUosRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssT0FBTyxvSEFBb0gsSUFBSSwwREFBMEQsbUJBQW1CLGtCQUFrQixZQUFZLDJHQUEyRyxFQUFFLG1EQUFtRCxZQUFZLEtBQUssU0FBUyxRQUFRLFlBQVkseUdBQXlHLEVBQUUsbURBQW1ELFlBQVksS0FBSyxVQUFVLEtBQUssdURBQUUsd0dBQXdHLGVBQWUsaURBQWlELE1BQU0sMkNBQTJDLGlCQUFpQixNQUFNLDRDQUE0QyxtQ0FBbUMsRUFBRSxFQUFFLG1DQUFtQyxnQ0FBZ0Msb0JBQW9CLGNBQWMsNERBQTRELE1BQU0sOENBQThDLEVBQUUsVUFBVSxpRUFBaUUsUUFBUSxnRUFBZ0UsTUFBTSxLQUFLLDRDQUE0QywyQkFBMkIsTUFBTSw4Q0FBOEMsSUFBSSxzQ0FBc0Msd0JBQXdCLEVBQUUsZ0NBQWdDLFFBQVEsVUFBVSxjQUFjLHVFQUF1RSxPQUFPLGVBQWUseUJBQXlCLGtDQUFrQyxPQUFPLHFCQUFxQix5QkFBeUIseUVBQXlFLFNBQVMsT0FBTyxRQUFRLHdFQUF3RSxRQUFRLE1BQU0sZ0NBQWdDLGVBQWUsTUFBTSxtREFBbUQsWUFBWSxNQUFNLG9FQUFvRSxhQUFhLFFBQVEsMERBQTBELGVBQWUsUUFBUSw2REFBNkQsWUFBWSxRQUFRLHlEQUF5RCxlQUFlLFFBQVEsNERBQTRELGVBQWUsUUFBUSw0REFBNEQsaUJBQWlCLFFBQVEsNkRBQTZELGlCQUFpQixRQUFRLDZEQUE2RCxrQkFBa0IsUUFBUSw4REFBOEQsa0JBQWtCLFFBQVEsOERBQThELG1CQUFtQiwrQ0FBK0MsYUFBYSxRQUFRLHlEQUF5RCxjQUFjLDBDQUEwQyxtQkFBbUIsUUFBUSwrREFBK0Qsb0JBQW9CLGdEQUFnRCwwQkFBMEIsTUFBTSx5REFBeUQsMkJBQTJCLDRDQUE0QyxFQUFFLHdDQUF3QyxrQkFBa0IsNkJBQTZCLG1CQUFtQixtQ0FBbUMsRUFBRSxHQUFHLGVBQWUsZ0NBQWdDLGdCQUFnQix5RkFBeUYsV0FBVyw0QkFBNEIsWUFBWSw0REFBNEQsWUFBWSxRQUFRLHlEQUF5RCxhQUFhLDBDQUEwQyxtQkFBbUIsNkJBQTZCLG9CQUFvQiw4REFBOEQsa0JBQWtCLG1DQUFtQyxtQkFBbUIsdUZBQXVGLGNBQWMsa0VBQWtFLGVBQWUsMkdBQTJHLGdCQUFnQix5REFBeUQsVUFBMkQ7QUFDM2dKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEMsa0JBQWtCLFVBQVU7QUFDNUIsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QyxjQUFjLHNCQUFzQjtBQUNwQyxrQkFBa0IsVUFBVTtBQUM1Qix1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLGNBQWMsc0JBQXNCO0FBQ3BDLGtCQUFrQixVQUFVO0FBQzVCLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsVUFBVSxtQkFBbUIsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxVQUFVLG1CQUFtQixVQUFVO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1Qix1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxVQUFVLG1CQUFtQixVQUFVO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLFVBQVUsbUJBQW1CLFVBQVU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFVBQVUsbUJBQW1CLFVBQVU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsa0JBQWtCLFVBQVU7QUFDNUIsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1Qix1QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1Qix1QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsV0FBVztBQUM1QixvQkFBb0IsY0FBYztBQUNsQyxhQUFhLE9BQU87QUFDcEIsd0JBQXdCLGtCQUFrQjtBQUMxQyx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtDQUFrQyxjQUFjLE1BQU0sUUFBUSxtQkFBbUIsWUFBWSw0RkFBNEYsT0FBTyx3RUFBd0UsdUJBQXVCLFlBQVksUUFBUSxzR0FBc0csdUJBQXVCLGFBQWEsZ0NBQWdDLHNEQUFzRCxvQkFBb0Isb0dBQW9HLHdEQUF3RCxlQUFlLG1DQUFtQyxxQ0FBcUMsRUFBRSxnREFBZ0QscURBQXFELG9NQUFvTSxtQ0FBbUMsaUJBQWlCLEVBQUUsRUFBRSxRQUFRLEVBQUUsZUFBZSxzRUFBc0UsNEJBQTRCLEVBQUUsd0RBQXdELG1EQUFtRCwyQ0FBMkMsbURBQW1ELFlBQVksd0VBQXdFLE1BQU0sU0FBUyxlQUFlLHdGQUF3RixrR0FBa0csU0FBUyxtQ0FBbUM7QUFDN3hEO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3QkFBd0IsY0FBYyxRQUFRLDhHQUE4RyxhQUFhLElBQUksZUFBZSw4RkFBOE0sNEJBQTRCLGlCQUFpQixlQUFlLFlBQVksOENBQThDLDJCQUEyQix5QkFBeUIsT0FBTyw4REFBOEQsb0dBQW9HLEtBQUssaURBQWlELDJCQUEyQix3QkFBd0IsY0FBYyw2Q0FBNkMsbURBQW1ELGtEQUFrRCxpQkFBaUIsb0JBQW9CLDhFQUFFLDhIQUE4SCxpQkFBaUIscUNBQXFDLG1GQUFFLHlCQUF5QixpQkFBaUIsbURBQW1ELG1GQUFFLHlEQUF5RCxpQkFBaUIsZ0JBQWdCLDhFQUFFLEVBQUUseUVBQXlFLDZDQUE2Qyw0QkFBNEIsaUJBQWlCLGdCQUFnQiw4RUFBRSx3QkFBd0IsZ0JBQWdCLDJIQUEySCxTQUFTLGlCQUFpQixxQ0FBcUMsOEVBQUUsRUFBRSx5RUFBeUUsb0NBQW9DLFNBQVMsaUJBQWlCLDRCQUE0QixtRkFBRSx1QkFBdUIsaUJBQWlCLDhEQUE4RCxzREFBc0QsbUJBQW1CLGVBQWUsY0FBYyxpQkFBaUIsdUNBQXVDLGVBQWUsMkRBQTJELDBEQUEwRCw2REFBNkQsRUFBRSxLQUFLLHVDQUF1QyxjQUFjLE1BQU0sb0JBQW9CLGtCQUFrQixZQUFZLFVBQVUsc0ZBQUUsK0JBQStCLHlCQUF5QixtRkFBRSwyQ0FBMkMsT0FBTyxnQkFBZ0IsMERBQTBELEtBQUssdUJBQXVCLE1BQU0sUUFBUSw0QkFBNEIsMEJBQTBCLFlBQVksbUJBQW1CLHNCQUFzQixpQkFBaUIsZ0JBQWtFLG1DQUFtQyxvQ0FBb0M7QUFDNStGO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLFNBQVMsbUJBQW1CLFVBQVUsS0FBSyxvRUFBb0UsUUFBUSwyRkFBMkY7QUFDbE47QUFDQSxnQkFBZ0IsbURBQW1EO0FBQ25FLHlCQUF5QixtQ0FBbUM7QUFDNUQsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQiwyQ0FBMkM7QUFDNUQsd0JBQXdCLHNDQUFzQywyREFBRSxnQ0FBZ0M7QUFDaEcsb0JBQW9CLG1CQUFtQjtBQUN2QyxnQkFBZ0IsMEJBQTBCO0FBQzFDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsT0FBTyxrRkFBa0YsY0FBYztBQUNwSCx3QkFBd0IseUJBQXlCO0FBQ2pELHlCQUF5QixtQ0FBbUM7QUFDNUQsMEJBQTBCLG9DQUFvQztBQUM5RCxxQkFBcUIsK0JBQStCO0FBQ3BELGdDQUFnQywwQ0FBMEM7QUFDMUUsb0JBQW9CLDhCQUE4QjtBQUNsRCxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQscUJBQXFCLCtCQUErQjtBQUNwRCxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QyxlQUFlLHVCQUF1QjtBQUN0QyxjQUFjLHdCQUF3QjtBQUN0QyxpQkFBaUIseUJBQXlCO0FBQzFDLGVBQWUsdUJBQXVCO0FBQ3RDLHFCQUFxQiw4QkFBOEI7QUFDbkQseUJBQXlCLGtDQUFrQztBQUMzRCx5QkFBeUIsa0NBQWtDO0FBQzNELG9CQUFvQixpQ0FBaUM7QUFDckQsa0NBQWtDLDBDQUEwQztBQUM1RSw4QkFBOEIsc0NBQXNDO0FBQ3BFLGlDQUFpQyx5Q0FBeUM7QUFDMUUsaUJBQWlCLDBCQUEwQjtBQUMzQyx1QkFBdUIsZ0NBQWdDO0FBQ3ZELGFBQWEsMENBQTBDLDRFQUE0RSxLQUFLO0FBQ3hJLGtCQUFrQiwwQ0FBMEMsNEVBQTRFLEtBQUs7QUFDN0k7QUFDQTtBQUNBLFFBQVEsd0VBQXdFLGFBQWE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RCx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDLGlCQUFpQixxQkFBcUI7QUFDdEMscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBLFFBQVEsc0NBQXNDLGVBQWU7QUFDN0Q7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0MsRUFBRSw2QkFBNkI7QUFDL0YsaUJBQWlCLGlEQUFpRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQWdELHVCQUF1QixVQUFVLFFBQVEsTUFBTSxlQUFlLEtBQUssc0RBQUUsb0JBQW9CLGlHQUFpRyxVQUFVLHlRQUF5USxNQUFNLFVBQVUsK0xBQStMLE1BQU0sVUFBVSwrVEFBK1QsSUFBSSxrQkFBa0IsOENBQThDLHVDQUF1QyxNQUFNLDJNQUEyTSxZQUFZLGlCQUFpQixZQUFZLGNBQWMsNkhBQTZILGdDQUFnQyxNQUFNLE1BQU0sK1JBQStSLFlBQVksb0RBQW9ELGdCQUFnQixhQUFhLCtCQUErQix1Q0FBdUMsTUFBTSxNQUFNLHlRQUF5USxVQUFVLHFDQUFxQyxZQUFZLHNDQUFzQyxNQUFNLHNMQUFzTCxPQUFPLE1BQU0sS0FBSyxzREFBRSxtQkFBbUIsSUFBSSxVQUFVLEdBQUcsR0FBRyxtQ0FBbUMsZ0NBQWdDLE1BQU0sS0FBSyxzREFBRSw4QkFBOEIsaUVBQWlFLGtCQUFrQixPQUFPLHNEQUFFLDJCQUEyQixVQUFVLFFBQVEsRUFBRSxrQkFBa0IsYUFBYSxNQUFNLEdBQUcsb0RBQW9ELHFDQUFxQyxNQUFNLFdBQVcsc0NBQXNDLE1BQU0sY0FBYywySEFBMkgsR0FBRyxtQkFBbUIsT0FBTywwQkFBMEIsSUFBSSxtckJBQW1yQixvU0FBb1MsaUJBQWlCLE1BQU0sT0FBTyxrM0JBQWszQixzREFBQyxpREFBaUQsc0RBQUMsNFZBQTRWLHNEQUFDLGtIQUFrSCxlQUFlLFFBQVEsOEJBQThCLE1BQU0scUZBQXFGLGNBQWMsZ0RBQWdELEVBQUUsR0FBRyw4QkFBOEIsMENBQTBDLGVBQWUsTUFBTSwrRUFBK0UsbUdBQW1HLGVBQWUsaUZBQWlGLHdCQUF3Qix1RUFBdUUsR0FBRyxFQUFFLHFCQUFxQixzREFBQyxzRUFBc0UsOEJBQThCLDhFQUE4RSxjQUFjLFFBQVEsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLGNBQWMsWUFBWSxFQUFFLGFBQWEsa0NBQWtDLFVBQVUsc0RBQXNELDhCQUE4Qix3QkFBd0IsOENBQThDLEVBQUUsbUJBQW1CLFlBQVksb0VBQW9FLGdDQUFnQyxNQUFNLGtFQUFrRSxpQkFBaUIsTUFBTSxzRUFBc0Usc0JBQXNCLFFBQVEseUdBQXlHLG9CQUFvQixNQUFNLG9FQUFvRSx5QkFBeUIsZ0NBQWdDLHVFQUF1RSxrQ0FBa0MsTUFBTSx1QkFBdUIsNElBQTRJLEdBQUcsTUFBTSx3QkFBd0IsSUFBSSxNQUFNLE1BQU0sMEZBQTBGLElBQUksYUFBYSxNQUFNLEdBQUcsTUFBTSx5QkFBeUIsSUFBSSxNQUFNLE1BQU0sMkZBQTJGLElBQUksYUFBYSxNQUFNLEdBQUcsTUFBTSxLQUFLLHNEQUFDLGNBQWMsZ0VBQWdFLFlBQVksb0ZBQW9GLGFBQWEsR0FBRyxNQUFNLEtBQUssc0RBQUMsa0JBQWtCLDJEQUFDLE1BQU0sMkRBQUMsV0FBVywyREFBQyw0SkFBNEosK0VBQStFLFdBQVcseUVBQXlFLDJCQUEyQixFQUFFLDRCQUE0QiwyREFBQyxtQkFBbUIsQ0FBQyxzREFBQyxtRUFBbUUsbUJBQW1CLHlCQUF5QixVQUFVLEVBQUUsaUJBQWlCLE1BQU0sMkJBQTJCLHNEQUFDLDhCQUE4QixrQkFBa0Isd0JBQXdCLDhEQUFFLCtCQUErQixzREFBQyxrRUFBa0UsOERBQUUsUUFBUSx3QkFBd0Isc0RBQUMsZUFBZSxnQkFBZ0IsUUFBUSw4RkFBOEYsbUJBQW1CLE1BQU0saUZBQWlGLFdBQVcsTUFBTSx5Q0FBeUMsVUFBVSxNQUFNLHdDQUF3QyxZQUFZLE1BQU0sZ0RBQWdELGFBQWEsNkJBQTZCLEVBQUUsR0FBRyxpQkFBaUIsc0JBQXNCLGFBQWEsU0FBUyxvQ0FBb0MsMkJBQTJCLHdCQUF3QixxQkFBcUIsU0FBUyxrQkFBa0IsUUFBUSx1QkFBdUIsT0FBTyx5QkFBeUIsZ0JBQWdCLDJCQUEyQiwwQkFBMEIsZ0pBQWdKLGlCQUFpQixNQUFNLDJCQUEyQixzREFBQyw4QkFBOEIsa0JBQWtCLG9CQUFvQixzREFBQyxxQ0FBcUMsc0RBQUMsY0FBYyxVQUFVLFFBQVEsb0dBQW9HLFdBQVcseURBQXlELGFBQWEsTUFBTSxrQ0FBa0Msb0JBQW9CLDJEQUEyRCxpSEFBaUgsRUFBRSxjQUFjLHVFQUF1RSxvQkFBb0IsTUFBTSw2REFBNkQscUJBQXFCLCtFQUErRSxpQkFBaUIseUVBQXlFLHNEQUFzRCwyREFBQyxNQUFNLDJEQUFDLGdFQUFnRSxzREFBc0QsRUFBRSxZQUFZLGtDQUFrQyxhQUFhLE9BQU8sOEJBQThCLE9BQU8sOEJBQThCLGNBQWMsa0JBQWtCLGdCQUFnQixzQ0FBc0MsaUJBQWlCLE9BQU8sa0NBQWtDLE9BQU8sa0NBQWtDLG9CQUFvQiw4Q0FBOEMscUJBQXFCLHNDQUFzQyxFQUFFLEdBQUcsWUFBWSxNQUFNLGdEQUFnRCxhQUFhLDZGQUE2RixrQkFBa0IsTUFBTSwyQ0FBMkMsbUJBQW1CLG1DQUFtQyxFQUFFLEdBQUcsbUJBQW1CLFFBQVEseUNBQXlDLGtLQUFrSyxvQkFBb0IscUNBQXFDLEVBQUUsR0FBRyxxQkFBcUIsUUFBUSwyQ0FBMkMsb0tBQW9LLHNCQUFzQix1Q0FBdUMsRUFBRSxHQUFHLCtCQUErQix3REFBd0QsZ0NBQWdDLDBHQUEwRyxvQkFBb0IsNEtBQTRLLHFCQUFxQixPQUFPLHVDQUF1QyxPQUFPLGdEQUFnRCx3QkFBd0IsTUFBTSxpRUFBaUUseUJBQXlCLDJDQUEyQyxFQUFFLEdBQUcseUJBQXlCLE1BQU0sa0VBQWtFLDBCQUEwQiw0Q0FBNEMsRUFBRSxHQUFHLDRCQUE0QixvREFBb0QsNkJBQTZCLGtHQUFrRyx5QkFBeUIsTUFBTSwyQkFBMkIsc0RBQUMsbUNBQW1DLDRCQUE0QixNQUFNLDJCQUEyQixzREFBQyxzQ0FBc0MsNkJBQTZCLE1BQU0sMkJBQTJCLHNEQUFDLDJDQUEyQyw4QkFBOEIsc0RBQXNELHNEQUFDLGtEQUFrRCxzREFBQyw0QkFBNEIsb0JBQW9CLE1BQU0sMkJBQTJCLHNEQUFDLGlDQUFpQyxxQkFBcUIsNkNBQTZDLHNEQUFDLHdDQUF3QyxzREFBQyxrQkFBa0IsbUJBQW1CLE1BQU0sMkJBQTJCLHNEQUFDLGdDQUFnQyxvQkFBb0IsNENBQTRDLHNEQUFDLHVDQUF1QyxzREFBQyxpQkFBaUIsYUFBYSxNQUFNLGdCQUFnQixzREFBQywwQkFBMEIsY0FBYyxrQkFBa0Isc0RBQUMsWUFBWSxFQUFFLEdBQUcsbUJBQW1CLDJDQUEyQyxvQkFBb0IsZ0ZBQWdGLFlBQVksY0FBYyxzREFBQyxjQUFjLGFBQWEsb0JBQW9CLHNEQUFDLGdDQUFnQyxzREFBQyxRQUFRLHFCQUFxQixjQUFjLHNEQUFDLHdCQUF3QixzQkFBc0Isb0JBQW9CLHNEQUFDLDBDQUEwQyxzREFBQyxrQkFBa0IsaUJBQWlCLFVBQVUsOEJBQThCLHNEQUFDLHlFQUF5RSwyREFBQyxTQUFTLGtCQUFrQixrQkFBa0Isc0RBQUMsZ0JBQWdCLEVBQUUsR0FBRyx3QkFBd0IsVUFBVSxtSkFBbUosMkRBQUMsV0FBVyx5QkFBeUIseUZBQXlGLHVCQUF1QixRQUFRLDhKQUE4Six3QkFBd0Isd0hBQXdILEdBQUcsSUFBSSxvQkFBb0IsTUFBTSxrREFBa0QsZ0JBQWdCLGdCQUFnQixzREFBQyxjQUFjLGlCQUFpQixrQkFBa0Isc0RBQUMsZUFBZSxFQUFFLEdBQUcscUJBQXFCLHdCQUF3QixzREFBQyxrQkFBa0IsT0FBTyw2REFBRSxVQUFVLDZEQUFFLGlCQUFpQixzQkFBc0IsOEJBQThCLDZEQUFFLFVBQVUsNkRBQUUsMEJBQTBCLHNEQUFDLHlDQUF5QyxzREFBQyxtQkFBbUIsZUFBZSxNQUFNLDZDQUE2QyxnQkFBZ0IsdUNBQXVDLDZGQUE2RixPQUFPLHFCQUFxQixrQkFBa0Isc0JBQXNCLE1BQU0sdUNBQXVDLGdHQUFnRyxPQUFPLG9EQUFvRCxxQkFBcUIsTUFBTSxtREFBbUQsZ0JBQWdCLFFBQVEsNkRBQTZELGVBQWUsTUFBTSxtREFBbUQsaUJBQWlCLE1BQU0sK0NBQStDLGFBQWEseUhBQXlILE9BQU8sMEJBQTBCLFdBQVcsR0FBRyxhQUFhLFlBQVksR0FBRyxhQUFhLGFBQWEsS0FBSyxjQUFjLHNCQUFzQixFQUFFLG9CQUFvQixNQUFNLDZEQUE2RCxxQkFBcUIsc0NBQXNDLEVBQUUsR0FBRyxxQkFBcUIsTUFBTSw4REFBOEQsc0JBQXNCLHVDQUF1QyxFQUFFLEdBQUcsc0JBQXNCLE1BQU0sK0RBQStELHVCQUF1Qix3Q0FBd0MsRUFBRSxHQUFHLHNCQUFzQixNQUFNLDZDQUE2QyxjQUFjLGdFQUFFLFlBQVksbUJBQW1CLE1BQU0sNkNBQTZDLGNBQWMsbUVBQUUsTUFBTSxpQkFBaUIsTUFBTSxpREFBaUQsb0dBQW9HLFVBQVUsZ0JBQWdCLHFDQUFxQyxJQUFJLCtGQUErRixNQUFNLHNDQUFzQyxJQUFJLDhEQUE4RCxzREFBRSxVQUFVLE1BQU0sb0NBQW9DLElBQUksa0ZBQWtGLHlEQUFFLFVBQVUsTUFBTSwyQ0FBMkMsNFFBQTRRLHVCQUF1QixHQUFHLDhCQUE4QixRQUFRLElBQUksOERBQThELDBEQUEwRCxnRUFBZ0UsNERBQTRELEVBQUUsUUFBUSwrQkFBK0Isa0RBQWtELDhCQUE4QixFQUFFLGVBQWUsa0JBQWtCLG9CQUFvQiw4QkFBOEIsVUFBVSxRQUFRLDZDQUE2Qyw4QkFBOEIseUJBQXlCLDJCQUEyQix3R0FBd0cseUJBQXlCLFFBQVEsZ0JBQWdCLFVBQVUsZ0JBQWdCLGNBQWMsc0NBQXNDLDhCQUE4QixNQUFNLFVBQVUsSUFBSSxTQUFTLEdBQUcsZ0JBQWdCLHNEQUFFLFNBQVMsc0RBQUUsaURBQWlELGtCQUFrQixRQUFRLGVBQWUsT0FBTyxJQUFJLGtCQUFrQixtRUFBbUUsbUNBQW1DLFFBQVEsd0NBQXdDLHlCQUF5QixHQUFHLDhFQUE4RSxJQUFJLFVBQVUscURBQXFELHNEQUFFLFdBQVcsSUFBSSxTQUFTLHdHQUF3RyxPQUFPLDRNQUE0TSx1REFBdUQsUUFBUSxJQUFJLFNBQVMsR0FBRyxPQUFPLElBQUksaUJBQWlCLG9EQUFvRCxNQUFNLHNEQUFFLE1BQU0saUVBQWlFLFNBQVMsR0FBRyxFQUFFLDhCQUE4QixZQUFZLGlDQUFpQyw2S0FBNkssOEJBQThCLFFBQVEsMERBQTBELGdEQUFnRCw0Q0FBNEMsMkRBQUMsa0VBQWtFLGNBQWMsNENBQTRDLDBFQUEwRTtBQUN4cXFCLG9CQUFvQixrQkFBa0IsMkRBQUMsbUJBQW1CLFdBQVcseUJBQXlCLDhDQUE4QyxxQkFBcUIsd0JBQXdCLE1BQU0sRUFBRSxRQUFRLFFBQVEseUZBQXlGLFFBQVEsUUFBUSxnTEFBZ0wsc0hBQXNILHNLQUFzSyxXQUFXLGdFQUFnRSxxQ0FBcUMsSUFBSSxFQUFFLGdEQUFnRCxRQUFRLDBGQUEwRiw0Q0FBNEMsR0FBRyxnQkFBZ0IseURBQXlELHFHQUFxRyxVQUF3RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG11eC9tdXgtcGxheWVyL2Rpc3QvaW5kZXgubWpzP2RjMmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE9lPSh0LGEsZSk9PntpZighYS5oYXModCkpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiK2UpfTt2YXIgbT0odCxhLGUpPT4oT2UodCxhLFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksZT9lLmNhbGwodCk6YS5nZXQodCkpLHA9KHQsYSxlKT0+e2lmKGEuaGFzKHQpKXRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7YSBpbnN0YW5jZW9mIFdlYWtTZXQ/YS5hZGQodCk6YS5zZXQodCxlKX0seD0odCxhLGUscik9PihPZSh0LGEsXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLHI/ci5jYWxsKHQsZSk6YS5zZXQodCxlKSxlKTt2YXIgZj0odCxhLGUpPT4oT2UodCxhLFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLGUpO3ZhciBXPWNsYXNze2FkZEV2ZW50TGlzdGVuZXIoKXt9cmVtb3ZlRXZlbnRMaXN0ZW5lcigpe31kaXNwYXRjaEV2ZW50KGEpe3JldHVybiEwfX07aWYodHlwZW9mIERvY3VtZW50RnJhZ21lbnQ9PVwidW5kZWZpbmVkXCIpe2NsYXNzIHQgZXh0ZW5kcyBXe31nbG9iYWxUaGlzLkRvY3VtZW50RnJhZ21lbnQ9dH12YXIgej1jbGFzcyBleHRlbmRzIFd7fSxMZT1jbGFzcyBleHRlbmRzIFd7fSxOdD17Z2V0KHQpe30sZGVmaW5lKHQsYSxlKXt9LHVwZ3JhZGUodCl7fSx3aGVuRGVmaW5lZCh0KXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHopfX0sSixSZT1jbGFzc3tjb25zdHJ1Y3RvcihhLGU9e30pe3AodGhpcyxKLHZvaWQgMCk7eCh0aGlzLEosZT09bnVsbD92b2lkIDA6ZS5kZXRhaWwpfWdldCBkZXRhaWwoKXtyZXR1cm4gbSh0aGlzLEopfWluaXRDdXN0b21FdmVudCgpe319O0o9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gQnQodCxhKXtyZXR1cm4gbmV3IHp9dmFyIHJ0PXtkb2N1bWVudDp7Y3JlYXRlRWxlbWVudDpCdH0sRG9jdW1lbnRGcmFnbWVudCxjdXN0b21FbGVtZW50czpOdCxDdXN0b21FdmVudDpSZSxFdmVudFRhcmdldDpXLEhUTUxFbGVtZW50OnosSFRNTFZpZGVvRWxlbWVudDpMZX0sb3Q9dHlwZW9mIHdpbmRvdz09XCJ1bmRlZmluZWRcInx8dHlwZW9mIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHM9PVwidW5kZWZpbmVkXCIsaD1vdD9ydDpnbG9iYWxUaGlzLFQ9b3Q/cnQuZG9jdW1lbnQ6Z2xvYmFsVGhpcy5kb2N1bWVudDtpbXBvcnR7TWVkaWFDb250cm9sbGVyIGFzIHNhfWZyb21cIm1lZGlhLWNocm9tZVwiO2ltcG9ydFwibWVkaWEtY2hyb21lL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLWNhcHRpb25zLXNlbGVjdG1lbnUuanNcIjtpbXBvcnQgbGEse01lZGlhRXJyb3IgYXMgdmUsQXR0cmlidXRlcyBhcyBsfWZyb21cIkBtdXgvbXV4LXZpZGVvXCI7aW1wb3J0e1N0cmVhbVR5cGVzIGFzIEwsUGxheWJhY2tUeXBlcyBhcyBFZSxhZGRUZXh0VHJhY2sgYXMgZGEscmVtb3ZlVGV4dFRyYWNrIGFzIHVhLENtY2RUeXBlVmFsdWVzIGFzIE90fWZyb21cIkBtdXgvcGxheWJhY2stY29yZVwiO2ltcG9ydHtWaWRlb0V2ZW50cyBhcyBLdH1mcm9tXCJAbXV4L211eC12aWRlb1wiO3ZhciBJdD1cImVuXCIsSD17Y29kZTpJdH07dmFyIG50PVwiZW5cIjtmdW5jdGlvbiBkKHQsYT0hMCl7dmFyIGksbztsZXQgZT1hJiYobz0oaT1IKT09bnVsbD92b2lkIDA6aVt0XSkhPW51bGw/bzp0LHI9YT9ILmNvZGU6bnQ7cmV0dXJuIG5ldyBTZShlLHIpfXZhciBTZT1jbGFzc3tjb25zdHJ1Y3RvcihhLGU9KHI9PihyPUguY29kZSkhPW51bGw/cjpudCkoKSl7dGhpcy5tZXNzYWdlPWEsdGhpcy5sb2NhbGU9ZX1mb3JtYXQoYSl7cmV0dXJuIHRoaXMubWVzc2FnZS5yZXBsYWNlKC9cXHsoXFx3KylcXH0vZywoZSxyKT0+e3ZhciBpO3JldHVybihpPWFbcl0pIT1udWxsP2k6XCJcIn0pfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMubWVzc2FnZX19O2Z1bmN0aW9uIHN0KHQpe2xldCBhPVwiXCI7cmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKFtlLHJdKT0+e3IhPW51bGwmJihhKz1gJHtkZShlKX06ICR7cn07IGApfSksYT9hLnRyaW0oKTp2b2lkIDB9ZnVuY3Rpb24gZGUodCl7cmV0dXJuIHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gdWUodCl7cmV0dXJuIHQucmVwbGFjZSgvWy1fXShbYS16XSkvZywoYSxlKT0+ZS50b1VwcGVyQ2FzZSgpKX1mdW5jdGlvbiBSKHQpe2lmKHQ9PW51bGwpcmV0dXJuO2xldCBhPSt0O3JldHVybiBOdW1iZXIuaXNOYU4oYSk/dm9pZCAwOmF9ZnVuY3Rpb24gbWUodCl7bGV0IGE9RHQodCkudG9TdHJpbmcoKTtyZXR1cm4gYT9cIj9cIithOlwiXCJ9ZnVuY3Rpb24gRHQodCl7bGV0IGE9e307Zm9yKGxldCBlIGluIHQpdFtlXSE9bnVsbCYmKGFbZV09dFtlXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoYSl9ZnVuY3Rpb24gTih0KXtsZXQgYT0odCE9bnVsbD90OlwiXCIpLnNwbGl0KFwiLlwiKVsxXTtpZighYSlyZXR1cm57fTtsZXQgZT1hLnJlcGxhY2UoLy0vZyxcIitcIikucmVwbGFjZSgvXy9nLFwiL1wiKSxyPWRlY29kZVVSSUNvbXBvbmVudChhdG9iKGUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihpKXtyZXR1cm5cIiVcIisoXCIwMFwiK2kuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKX0pLmpvaW4oXCJcIikpO3JldHVybiBKU09OLnBhcnNlKHIpfXZhciBNZT0odCxhKT0+IXR8fCFhPyExOnQuY29udGFpbnMoYSk/ITA6TWUodCxhLmdldFJvb3ROb2RlKCkuaG9zdCk7aW1wb3J0e1N0cmVhbVR5cGVzIGFzIENlfWZyb21cIkBtdXgvcGxheWJhY2stY29yZVwiO3ZhciBQZT1cIm11eC5jb21cIixWdD0oKT0+e3RyeXtyZXR1cm5cIjEuMTEuNFwifWNhdGNoe31yZXR1cm5cIlVOS05PV05cIn0sSHQ9VnQoKSxwZT0oKT0+SHQsX2U9KHQse21heFJlc29sdXRpb246YSx0b2tlbjplLGRvbWFpbjpyPVBlfT17fSk9PntsZXQgbj0hIWU/e3Rva2VuOmV9OntyZWR1bmRhbnRfc3RyZWFtczohMCwuLi5hP3ttYXhfcmVzb2x1dGlvbjphfTp7fX07cmV0dXJuYGh0dHBzOi8vc3RyZWFtLiR7cn0vJHt0fS5tM3U4JHttZShuKX1gfSxsdD0odCx7dG9rZW46YSx0aHVtYm5haWxUaW1lOmUsZG9tYWluOnI9UGV9PXt9KT0+e2xldCBpPWE9PW51bGw/ZTp2b2lkIDAse2F1ZDpvfT1OKGEpO2lmKCEoYSYmbyE9PVwidFwiKSlyZXR1cm5gaHR0cHM6Ly9pbWFnZS4ke3J9LyR7dH0vdGh1bWJuYWlsLndlYnAke21lKHt0b2tlbjphLHRpbWU6aX0pfWB9LGR0PSh0LHt0b2tlbjphLGRvbWFpbjplPVBlfT17fSk9PntsZXR7YXVkOnJ9PU4oYSk7aWYoIShhJiZyIT09XCJzXCIpKXJldHVybmBodHRwczovL2ltYWdlLiR7ZX0vJHt0fS9zdG9yeWJvYXJkLnZ0dCR7bWUoe3Rva2VuOmEsZm9ybWF0Olwid2VicFwifSl9YH0sWD10PT57aWYoISF0KXtpZihbQ2UuTElWRSxDZS5PTl9ERU1BTkRdLmluY2x1ZGVzKHQpKXJldHVybiB0O2lmKHQhPW51bGwmJnQuaW5jbHVkZXMoXCJsaXZlXCIpKXJldHVybiBDZS5MSVZFfX07dmFyICR0PXtjcm9zc29yaWdpbjpcImNyb3NzT3JpZ2luXCIscGxheXNpbmxpbmU6XCJwbGF5c0lubGluZVwifTtmdW5jdGlvbiB1dCh0KXt2YXIgYTtyZXR1cm4oYT0kdFt0XSkhPW51bGw/YTp1ZSh0KX12YXIgJCxLLEUsY2U9Y2xhc3N7Y29uc3RydWN0b3IoYSxlKXtwKHRoaXMsJCx2b2lkIDApO3AodGhpcyxLLHZvaWQgMCk7cCh0aGlzLEUsW10pO3godGhpcywkLGEpLHgodGhpcyxLLGUpfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIG0odGhpcyxFKS52YWx1ZXMoKX1nZXQgbGVuZ3RoKCl7cmV0dXJuIG0odGhpcyxFKS5sZW5ndGh9Z2V0IHZhbHVlKCl7dmFyIGE7cmV0dXJuKGE9bSh0aGlzLEUpLmpvaW4oXCIgXCIpKSE9bnVsbD9hOlwiXCJ9c2V0IHZhbHVlKGEpe3ZhciBlO2EhPT10aGlzLnZhbHVlJiYoeCh0aGlzLEUsW10pLHRoaXMuYWRkKC4uLihlPWE9PW51bGw/dm9pZCAwOmEuc3BsaXQoXCIgXCIpKSE9bnVsbD9lOltdKSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy52YWx1ZX1pdGVtKGEpe3JldHVybiBtKHRoaXMsRSlbYV19dmFsdWVzKCl7cmV0dXJuIG0odGhpcyxFKS52YWx1ZXMoKX1rZXlzKCl7cmV0dXJuIG0odGhpcyxFKS5rZXlzKCl9Zm9yRWFjaChhKXttKHRoaXMsRSkuZm9yRWFjaChhKX1hZGQoLi4uYSl7dmFyIGUscjthLmZvckVhY2goaT0+e3RoaXMuY29udGFpbnMoaSl8fG0odGhpcyxFKS5wdXNoKGkpfSksISh0aGlzLnZhbHVlPT09XCJcIiYmISgoZT1tKHRoaXMsJCkpIT1udWxsJiZlLmhhc0F0dHJpYnV0ZShgJHttKHRoaXMsSyl9YCkpKSYmKChyPW0odGhpcywkKSk9PW51bGx8fHIuc2V0QXR0cmlidXRlKGAke20odGhpcyxLKX1gLGAke3RoaXMudmFsdWV9YCkpfXJlbW92ZSguLi5hKXt2YXIgZTthLmZvckVhY2gocj0+e20odGhpcyxFKS5zcGxpY2UobSh0aGlzLEUpLmluZGV4T2YociksMSl9KSwoZT1tKHRoaXMsJCkpPT1udWxsfHxlLnNldEF0dHJpYnV0ZShgJHttKHRoaXMsSyl9YCxgJHt0aGlzLnZhbHVlfWApfWNvbnRhaW5zKGEpe3JldHVybiBtKHRoaXMsRSkuaW5jbHVkZXMoYSl9dG9nZ2xlKGEsZSl7cmV0dXJuIHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiP2U/KHRoaXMuYWRkKGEpLCEwKToodGhpcy5yZW1vdmUoYSksITEpOnRoaXMuY29udGFpbnMoYSk/KHRoaXMucmVtb3ZlKGEpLCExKToodGhpcy5hZGQoYSksITApfXJlcGxhY2UoYSxlKXt0aGlzLnJlbW92ZShhKSx0aGlzLmFkZChlKX19OyQ9bmV3IFdlYWtNYXAsSz1uZXcgV2Vha01hcCxFPW5ldyBXZWFrTWFwO3ZhciBtdD1gW211eC1wbGF5ZXIgJHtwZSgpfV1gO2Z1bmN0aW9uIEIoLi4udCl7Y29uc29sZS53YXJuKG10LC4uLnQpfWZ1bmN0aW9uIE8oLi4udCl7Y29uc29sZS5lcnJvcihtdCwuLi50KX1mdW5jdGlvbiBOZSh0KXt2YXIgZTtsZXQgYT0oZT10Lm1lc3NhZ2UpIT1udWxsP2U6XCJcIjtpZih0LmNvbnRleHQmJihhKz1gICR7dC5jb250ZXh0fWApLHQuZmlsZSl7bGV0IHI9XCJodHRwczovL2dpdGh1Yi5jb20vbXV4aW5jL2VsZW1lbnRzL2Jsb2IvbWFpbi9lcnJvcnMvXCI7YSs9YCAke2QoXCJSZWFkIG1vcmU6IFwiKX1cbiR7cn0ke3QuZmlsZX1gfUIoYSl9dmFyIHk9e0FVVE9QTEFZOlwiYXV0b3BsYXlcIixDUk9TU09SSUdJTjpcImNyb3Nzb3JpZ2luXCIsTE9PUDpcImxvb3BcIixNVVRFRDpcIm11dGVkXCIsUExBWVNJTkxJTkU6XCJwbGF5c2lubGluZVwiLFBSRUxPQUQ6XCJwcmVsb2FkXCJ9LEY9e1ZPTFVNRTpcInZvbHVtZVwiLFBMQVlCQUNLUkFURTpcInBsYXliYWNrcmF0ZVwiLE1VVEVEOlwibXV0ZWRcIn0scHQ9T2JqZWN0LmZyZWV6ZSh7bGVuZ3RoOjAsc3RhcnQodCl7bGV0IGE9dD4+PjA7aWYoYT49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihgRmFpbGVkIHRvIGV4ZWN1dGUgJ3N0YXJ0JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHthfSkgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIGJvdW5kICgke3RoaXMubGVuZ3RofSkuYCk7cmV0dXJuIDB9LGVuZCh0KXtsZXQgYT10Pj4+MDtpZihhPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZW5kJyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHthfSkgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIGJvdW5kICgke3RoaXMubGVuZ3RofSkuYCk7cmV0dXJuIDB9fSksRnQ9S3QuZmlsdGVyKHQ9PnQhPT1cImVycm9yXCIpLFV0PU9iamVjdC52YWx1ZXMoeSkuZmlsdGVyKHQ9PiFbeS5QTEFZU0lOTElORV0uaW5jbHVkZXModCkpLFl0PU9iamVjdC52YWx1ZXMoRik7ZnVuY3Rpb24gYnQodCl7dC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gdHJhY2tcIikuZm9yRWFjaChhPT57dmFyIGU7KGU9dC5tZWRpYSk9PW51bGx8fGUuYXBwZW5kKGEuY2xvbmVOb2RlKCkpfSksRnQuZm9yRWFjaChhPT57dmFyIGU7KGU9dC5tZWRpYSk9PW51bGx8fGUuYWRkRXZlbnRMaXN0ZW5lcihhLHI9Pnt0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KHIudHlwZSkpfSl9KX12YXIgQmU9Y2xhc3MgZXh0ZW5kcyBoLkhUTUxFbGVtZW50e3N0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7cmV0dXJuWy4uLlV0LC4uLll0XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gdHJhY2tcIikuZm9yRWFjaChyPT57dmFyIGk7KGk9dGhpcy5tZWRpYSk9PW51bGx8fGkuYXBwZW5kKHIuY2xvbmVOb2RlKCkpfSk7bGV0IGE9cj0+e2ZvcihsZXQgaSBvZiByKWkudHlwZT09PVwiY2hpbGRMaXN0XCImJihpLnJlbW92ZWROb2Rlcy5mb3JFYWNoKG89Pnt2YXIgdSxiO2xldCBuPSh1PXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDp1LnF1ZXJ5U2VsZWN0b3IoYHRyYWNrW3NyYz1cIiR7by5zcmN9XCJdYCk7biYmKChiPXRoaXMubWVkaWEpPT1udWxsfHxiLnJlbW92ZUNoaWxkKG4pKX0pLGkuYWRkZWROb2Rlcy5mb3JFYWNoKG89Pnt2YXIgbjsobj10aGlzLm1lZGlhKT09bnVsbHx8bi5hcHBlbmQoby5jbG9uZU5vZGUoKSl9KSl9O25ldyBNdXRhdGlvbk9ic2VydmVyKGEpLm9ic2VydmUodGhpcyx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KX1hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYSxlLHIpe3ZhciBpLG87c3dpdGNoKGEpe2Nhc2UgRi5NVVRFRDp7dGhpcy5tZWRpYSYmKHRoaXMubWVkaWEubXV0ZWQ9ciE9bnVsbCx0aGlzLm1lZGlhLmRlZmF1bHRNdXRlZD1yIT1udWxsKTtyZXR1cm59Y2FzZSBGLlZPTFVNRTp7bGV0IG49KGk9UihyKSkhPW51bGw/aToxO3RoaXMubWVkaWEmJih0aGlzLm1lZGlhLnZvbHVtZT1uKTtyZXR1cm59Y2FzZSBGLlBMQVlCQUNLUkFURTp7bGV0IG49KG89UihyKSkhPW51bGw/bzoxO3RoaXMubWVkaWEmJih0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZT1uLHRoaXMubWVkaWEuZGVmYXVsdFBsYXliYWNrUmF0ZT1uKTtyZXR1cm59fX1wbGF5KCl7dmFyIGEsZTtyZXR1cm4oZT0oYT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6YS5wbGF5KCkpIT1udWxsP2U6UHJvbWlzZS5yZWplY3QoKX1wYXVzZSgpe3ZhciBhOyhhPXRoaXMubWVkaWEpPT1udWxsfHxhLnBhdXNlKCl9cmVxdWVzdENhc3QoYSl7dmFyIGU7cmV0dXJuKGU9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmUucmVxdWVzdENhc3QoYSl9Z2V0IG1lZGlhKCl7dmFyIGE7cmV0dXJuKGE9dGhpcy5zaGFkb3dSb290KT09bnVsbD92b2lkIDA6YS5xdWVyeVNlbGVjdG9yKFwibXV4LXZpZGVvXCIpfWdldCBwYXVzZWQoKXt2YXIgYSxlO3JldHVybihlPShhPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDphLnBhdXNlZCkhPW51bGw/ZTohMH1nZXQgZHVyYXRpb24oKXt2YXIgYSxlO3JldHVybihlPShhPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDphLmR1cmF0aW9uKSE9bnVsbD9lOk5hTn1nZXQgZW5kZWQoKXt2YXIgYSxlO3JldHVybihlPShhPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDphLmVuZGVkKSE9bnVsbD9lOiExfWdldCBidWZmZXJlZCgpe3ZhciBhLGU7cmV0dXJuKGU9KGE9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmEuYnVmZmVyZWQpIT1udWxsP2U6cHR9Z2V0IHNlZWthYmxlKCl7dmFyIGEsZTtyZXR1cm4oZT0oYT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6YS5zZWVrYWJsZSkhPW51bGw/ZTpwdH1nZXQgcmVhZHlTdGF0ZSgpe3ZhciBhLGU7cmV0dXJuKGU9KGE9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmEucmVhZHlTdGF0ZSkhPW51bGw/ZTowfWdldCB2aWRlb1dpZHRoKCl7dmFyIGEsZTtyZXR1cm4oZT0oYT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6YS52aWRlb1dpZHRoKSE9bnVsbD9lOjB9Z2V0IHZpZGVvSGVpZ2h0KCl7dmFyIGEsZTtyZXR1cm4oZT0oYT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6YS52aWRlb0hlaWdodCkhPW51bGw/ZTowfWdldCBjdXJyZW50VGltZSgpe3ZhciBhLGU7cmV0dXJuKGU9KGE9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmEuY3VycmVudFRpbWUpIT1udWxsP2U6MH1zZXQgY3VycmVudFRpbWUoYSl7dGhpcy5tZWRpYSYmKHRoaXMubWVkaWEuY3VycmVudFRpbWU9TnVtYmVyKGEpKX1nZXQgdm9sdW1lKCl7dmFyIGEsZTtyZXR1cm4oZT0oYT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6YS52b2x1bWUpIT1udWxsP2U6MX1zZXQgdm9sdW1lKGEpe3RoaXMubWVkaWEmJih0aGlzLm1lZGlhLnZvbHVtZT1OdW1iZXIoYSkpfWdldCBwbGF5YmFja1JhdGUoKXt2YXIgYSxlO3JldHVybihlPShhPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDphLnBsYXliYWNrUmF0ZSkhPW51bGw/ZToxfXNldCBwbGF5YmFja1JhdGUoYSl7dGhpcy5tZWRpYSYmKHRoaXMubWVkaWEucGxheWJhY2tSYXRlPU51bWJlcihhKSl9Z2V0IGRlZmF1bHRQbGF5YmFja1JhdGUoKXt2YXIgYTtyZXR1cm4oYT1SKHRoaXMuZ2V0QXR0cmlidXRlKEYuUExBWUJBQ0tSQVRFKSkpIT1udWxsP2E6MX1zZXQgZGVmYXVsdFBsYXliYWNrUmF0ZShhKXthIT1udWxsP3RoaXMuc2V0QXR0cmlidXRlKEYuUExBWUJBQ0tSQVRFLGAke2F9YCk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoRi5QTEFZQkFDS1JBVEUpfWdldCBjcm9zc09yaWdpbigpe3JldHVybiBRKHRoaXMseS5DUk9TU09SSUdJTil9c2V0IGNyb3NzT3JpZ2luKGEpe3RoaXMuc2V0QXR0cmlidXRlKHkuQ1JPU1NPUklHSU4sYCR7YX1gKX1nZXQgYXV0b3BsYXkoKXtyZXR1cm4gUSh0aGlzLHkuQVVUT1BMQVkpIT1udWxsfXNldCBhdXRvcGxheShhKXthP3RoaXMuc2V0QXR0cmlidXRlKHkuQVVUT1BMQVksdHlwZW9mIGE9PVwic3RyaW5nXCI/YTpcIlwiKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZSh5LkFVVE9QTEFZKX1nZXQgbG9vcCgpe3JldHVybiBRKHRoaXMseS5MT09QKSE9bnVsbH1zZXQgbG9vcChhKXthP3RoaXMuc2V0QXR0cmlidXRlKHkuTE9PUCxcIlwiKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZSh5LkxPT1ApfWdldCBtdXRlZCgpe3ZhciBhLGU7cmV0dXJuKGU9KGE9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmEubXV0ZWQpIT1udWxsP2U6ITF9c2V0IG11dGVkKGEpe3RoaXMubWVkaWEmJih0aGlzLm1lZGlhLm11dGVkPUJvb2xlYW4oYSkpfWdldCBkZWZhdWx0TXV0ZWQoKXtyZXR1cm4gUSh0aGlzLHkuTVVURUQpIT1udWxsfXNldCBkZWZhdWx0TXV0ZWQoYSl7YT90aGlzLnNldEF0dHJpYnV0ZSh5Lk1VVEVELFwiXCIpOnRoaXMucmVtb3ZlQXR0cmlidXRlKHkuTVVURUQpfWdldCBwbGF5c0lubGluZSgpe3JldHVybiBRKHRoaXMseS5QTEFZU0lOTElORSkhPW51bGx9c2V0IHBsYXlzSW5saW5lKGEpe08oXCJwbGF5c0lubGluZSBpcyBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0IGFuZCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBhcyBhIHNldHRlci5cIil9Z2V0IHByZWxvYWQoKXtyZXR1cm4gdGhpcy5tZWRpYT90aGlzLm1lZGlhLnByZWxvYWQ6dGhpcy5nZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIpfXNldCBwcmVsb2FkKGEpe1tcIlwiLFwibm9uZVwiLFwibWV0YWRhdGFcIixcImF1dG9cIl0uaW5jbHVkZXMoYSk/dGhpcy5zZXRBdHRyaWJ1dGUoeS5QUkVMT0FELGEpOnRoaXMucmVtb3ZlQXR0cmlidXRlKHkuUFJFTE9BRCl9fTtmdW5jdGlvbiBRKHQsYSl7cmV0dXJuIHQubWVkaWE/dC5tZWRpYS5nZXRBdHRyaWJ1dGUoYSk6dC5nZXRBdHRyaWJ1dGUoYSl9dmFyIEllPUJlO2ltcG9ydFwibWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtdGhlbWUtZWxlbWVudC5qc1wiO3ZhciBodD1gOmhvc3Qge1xuICAtLW1lZGlhLWNvbnRyb2wtZGlzcGxheTogdmFyKC0tY29udHJvbHMpO1xuICAtLW1lZGlhLWxvYWRpbmctaW5kaWNhdG9yLWRpc3BsYXk6IHZhcigtLWxvYWRpbmctaW5kaWNhdG9yKTtcbiAgLS1tZWRpYS1kaWFsb2ctZGlzcGxheTogdmFyKC0tZGlhbG9nKTtcbiAgLS1tZWRpYS1wbGF5LWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1wbGF5LWJ1dHRvbik7XG4gIC0tbWVkaWEtbGl2ZS1idXR0b24tZGlzcGxheTogdmFyKC0tbGl2ZS1idXR0b24pO1xuICAtLW1lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uLWRpc3BsYXk6IHZhcigtLXNlZWstYmFja3dhcmQtYnV0dG9uKTtcbiAgLS1tZWRpYS1zZWVrLWZvcndhcmQtYnV0dG9uLWRpc3BsYXk6IHZhcigtLXNlZWstZm9yd2FyZC1idXR0b24pO1xuICAtLW1lZGlhLW11dGUtYnV0dG9uLWRpc3BsYXk6IHZhcigtLW11dGUtYnV0dG9uKTtcbiAgLS1tZWRpYS1jYXB0aW9ucy1idXR0b24tZGlzcGxheTogdmFyKC0tY2FwdGlvbnMtYnV0dG9uKTtcbiAgLS1tZWRpYS1jYXB0aW9ucy1zZWxlY3RtZW51LWRpc3BsYXk6IHZhcigtLWNhcHRpb25zLXNlbGVjdG1lbnUsIHZhcigtLW1lZGlhLWNhcHRpb25zLWJ1dHRvbi1kaXNwbGF5KSk7XG4gIC0tbWVkaWEtYWlycGxheS1idXR0b24tZGlzcGxheTogdmFyKC0tYWlycGxheS1idXR0b24pO1xuICAtLW1lZGlhLXBpcC1idXR0b24tZGlzcGxheTogdmFyKC0tcGlwLWJ1dHRvbik7XG4gIC0tbWVkaWEtZnVsbHNjcmVlbi1idXR0b24tZGlzcGxheTogdmFyKC0tZnVsbHNjcmVlbi1idXR0b24pO1xuICAtLW1lZGlhLWNhc3QtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWNhc3QtYnV0dG9uKTtcbiAgLS1tZWRpYS1wbGF5YmFjay1yYXRlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1wbGF5YmFjay1yYXRlLWJ1dHRvbik7XG4gIC0tbWVkaWEtdm9sdW1lLXJhbmdlLWRpc3BsYXk6IHZhcigtLXZvbHVtZS1yYW5nZSk7XG4gIC0tbWVkaWEtdGltZS1yYW5nZS1kaXNwbGF5OiB2YXIoLS10aW1lLXJhbmdlKTtcbiAgLS1tZWRpYS10aW1lLWRpc3BsYXktZGlzcGxheTogdmFyKC0tdGltZS1kaXNwbGF5KTtcbiAgLS1tZWRpYS1kdXJhdGlvbi1kaXNwbGF5LWRpc3BsYXk6IHZhcigtLWR1cmF0aW9uLWRpc3BsYXkpO1xuICAtLW1lZGlhLXRpdGxlLWRpc3BsYXktZGlzcGxheTogdmFyKC0tdGl0bGUtZGlzcGxheSk7XG5cbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB3aWR0aDogMTAwJTtcbn1cblxuLyogSGlkZSBjdXN0b20gZWxlbWVudHMgdGhhdCBhcmUgbm90IGRlZmluZWQgeWV0ICovXG46bm90KDpkZWZpbmVkKSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbmEge1xuICBjb2xvcjogI2ZmZjtcbiAgZm9udC1zaXplOiAwLjllbTtcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG59XG5cbm1lZGlhLXRoZW1lIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgZGlyZWN0aW9uOiBsdHI7XG59XG5cbjo6cGFydCh0b3ApLFxuW3BhcnR+PSd0b3AnXSB7XG4gIC0tbWVkaWEtY29udHJvbC1kaXNwbGF5OiB2YXIoLS1jb250cm9scywgdmFyKC0tdG9wLWNvbnRyb2xzKSk7XG4gIC0tbWVkaWEtcGxheS1idXR0b24tZGlzcGxheTogdmFyKC0tcGxheS1idXR0b24sIHZhcigtLXRvcC1wbGF5LWJ1dHRvbikpO1xuICAtLW1lZGlhLWxpdmUtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWxpdmUtYnV0dG9uLCB2YXIoLS10b3AtbGl2ZS1idXR0b24pKTtcbiAgLS1tZWRpYS1zZWVrLWJhY2t3YXJkLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1zZWVrLWJhY2t3YXJkLWJ1dHRvbiwgdmFyKC0tdG9wLXNlZWstYmFja3dhcmQtYnV0dG9uKSk7XG4gIC0tbWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1zZWVrLWZvcndhcmQtYnV0dG9uLCB2YXIoLS10b3Atc2Vlay1mb3J3YXJkLWJ1dHRvbikpO1xuICAtLW1lZGlhLW11dGUtYnV0dG9uLWRpc3BsYXk6IHZhcigtLW11dGUtYnV0dG9uLCB2YXIoLS10b3AtbXV0ZS1idXR0b24pKTtcbiAgLS1tZWRpYS1jYXB0aW9ucy1idXR0b24tZGlzcGxheTogdmFyKC0tY2FwdGlvbnMtYnV0dG9uLCB2YXIoLS10b3AtY2FwdGlvbnMtYnV0dG9uKSk7XG4gIC0tbWVkaWEtY2FwdGlvbnMtc2VsZWN0bWVudS1kaXNwbGF5OiB2YXIoXG4gICAgLS1jYXB0aW9ucy1zZWxlY3RtZW51LFxuICAgIHZhcigtLW1lZGlhLWNhcHRpb25zLWJ1dHRvbi1kaXNwbGF5LCB2YXIoLS10b3AtY2FwdGlvbnMtc2VsZWN0bWVudSkpXG4gICk7XG4gIC0tbWVkaWEtYWlycGxheS1idXR0b24tZGlzcGxheTogdmFyKC0tYWlycGxheS1idXR0b24sIHZhcigtLXRvcC1haXJwbGF5LWJ1dHRvbikpO1xuICAtLW1lZGlhLXBpcC1idXR0b24tZGlzcGxheTogdmFyKC0tcGlwLWJ1dHRvbiwgdmFyKC0tdG9wLXBpcC1idXR0b24pKTtcbiAgLS1tZWRpYS1mdWxsc2NyZWVuLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1mdWxsc2NyZWVuLWJ1dHRvbiwgdmFyKC0tdG9wLWZ1bGxzY3JlZW4tYnV0dG9uKSk7XG4gIC0tbWVkaWEtY2FzdC1idXR0b24tZGlzcGxheTogdmFyKC0tY2FzdC1idXR0b24sIHZhcigtLXRvcC1jYXN0LWJ1dHRvbikpO1xuICAtLW1lZGlhLXBsYXliYWNrLXJhdGUtYnV0dG9uLWRpc3BsYXk6IHZhcigtLXBsYXliYWNrLXJhdGUtYnV0dG9uLCB2YXIoLS10b3AtcGxheWJhY2stcmF0ZS1idXR0b24pKTtcbiAgLS1tZWRpYS12b2x1bWUtcmFuZ2UtZGlzcGxheTogdmFyKC0tdm9sdW1lLXJhbmdlLCB2YXIoLS10b3Atdm9sdW1lLXJhbmdlKSk7XG4gIC0tbWVkaWEtdGltZS1yYW5nZS1kaXNwbGF5OiB2YXIoLS10aW1lLXJhbmdlLCB2YXIoLS10b3AtdGltZS1yYW5nZSkpO1xuICAtLW1lZGlhLXRpbWUtZGlzcGxheS1kaXNwbGF5OiB2YXIoLS10aW1lLWRpc3BsYXksIHZhcigtLXRvcC10aW1lLWRpc3BsYXkpKTtcbiAgLS1tZWRpYS1kdXJhdGlvbi1kaXNwbGF5LWRpc3BsYXk6IHZhcigtLWR1cmF0aW9uLWRpc3BsYXksIHZhcigtLXRvcC1kdXJhdGlvbi1kaXNwbGF5KSk7XG4gIC0tbWVkaWEtdGl0bGUtZGlzcGxheS1kaXNwbGF5OiB2YXIoLS10aXRsZS1kaXNwbGF5LCB2YXIoLS10b3AtdGl0bGUtZGlzcGxheSkpO1xufVxuXG46OnBhcnQoY2VudGVyKSxcbltwYXJ0fj0nY2VudGVyJ10ge1xuICAtLW1lZGlhLWNvbnRyb2wtZGlzcGxheTogdmFyKC0tY29udHJvbHMsIHZhcigtLWNlbnRlci1jb250cm9scykpO1xuICAtLW1lZGlhLXBsYXktYnV0dG9uLWRpc3BsYXk6IHZhcigtLXBsYXktYnV0dG9uLCB2YXIoLS1jZW50ZXItcGxheS1idXR0b24pKTtcbiAgLS1tZWRpYS1saXZlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1saXZlLWJ1dHRvbiwgdmFyKC0tY2VudGVyLWxpdmUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtc2Vlay1iYWNrd2FyZC1idXR0b24tZGlzcGxheTogdmFyKC0tc2Vlay1iYWNrd2FyZC1idXR0b24sIHZhcigtLWNlbnRlci1zZWVrLWJhY2t3YXJkLWJ1dHRvbikpO1xuICAtLW1lZGlhLXNlZWstZm9yd2FyZC1idXR0b24tZGlzcGxheTogdmFyKC0tc2Vlay1mb3J3YXJkLWJ1dHRvbiwgdmFyKC0tY2VudGVyLXNlZWstZm9yd2FyZC1idXR0b24pKTtcbiAgLS1tZWRpYS1tdXRlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1tdXRlLWJ1dHRvbiwgdmFyKC0tY2VudGVyLW11dGUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtY2FwdGlvbnMtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWNhcHRpb25zLWJ1dHRvbiwgdmFyKC0tY2VudGVyLWNhcHRpb25zLWJ1dHRvbikpO1xuICAtLW1lZGlhLWNhcHRpb25zLXNlbGVjdG1lbnUtZGlzcGxheTogdmFyKFxuICAgIC0tY2FwdGlvbnMtc2VsZWN0bWVudSxcbiAgICB2YXIoLS1tZWRpYS1jYXB0aW9ucy1idXR0b24tZGlzcGxheSwgdmFyKC0tY2VudGVyLWNhcHRpb25zLXNlbGVjdG1lbnUpKVxuICApO1xuICAtLW1lZGlhLWFpcnBsYXktYnV0dG9uLWRpc3BsYXk6IHZhcigtLWFpcnBsYXktYnV0dG9uLCB2YXIoLS1jZW50ZXItYWlycGxheS1idXR0b24pKTtcbiAgLS1tZWRpYS1waXAtYnV0dG9uLWRpc3BsYXk6IHZhcigtLXBpcC1idXR0b24sIHZhcigtLWNlbnRlci1waXAtYnV0dG9uKSk7XG4gIC0tbWVkaWEtZnVsbHNjcmVlbi1idXR0b24tZGlzcGxheTogdmFyKC0tZnVsbHNjcmVlbi1idXR0b24sIHZhcigtLWNlbnRlci1mdWxsc2NyZWVuLWJ1dHRvbikpO1xuICAtLW1lZGlhLWNhc3QtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWNhc3QtYnV0dG9uLCB2YXIoLS1jZW50ZXItY2FzdC1idXR0b24pKTtcbiAgLS1tZWRpYS1wbGF5YmFjay1yYXRlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1wbGF5YmFjay1yYXRlLWJ1dHRvbiwgdmFyKC0tY2VudGVyLXBsYXliYWNrLXJhdGUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtdm9sdW1lLXJhbmdlLWRpc3BsYXk6IHZhcigtLXZvbHVtZS1yYW5nZSwgdmFyKC0tY2VudGVyLXZvbHVtZS1yYW5nZSkpO1xuICAtLW1lZGlhLXRpbWUtcmFuZ2UtZGlzcGxheTogdmFyKC0tdGltZS1yYW5nZSwgdmFyKC0tY2VudGVyLXRpbWUtcmFuZ2UpKTtcbiAgLS1tZWRpYS10aW1lLWRpc3BsYXktZGlzcGxheTogdmFyKC0tdGltZS1kaXNwbGF5LCB2YXIoLS1jZW50ZXItdGltZS1kaXNwbGF5KSk7XG4gIC0tbWVkaWEtZHVyYXRpb24tZGlzcGxheS1kaXNwbGF5OiB2YXIoLS1kdXJhdGlvbi1kaXNwbGF5LCB2YXIoLS1jZW50ZXItZHVyYXRpb24tZGlzcGxheSkpO1xufVxuXG46OnBhcnQoYm90dG9tKSxcbltwYXJ0fj0nYm90dG9tJ10ge1xuICAtLW1lZGlhLWNvbnRyb2wtZGlzcGxheTogdmFyKC0tY29udHJvbHMsIHZhcigtLWJvdHRvbS1jb250cm9scykpO1xuICAtLW1lZGlhLXBsYXktYnV0dG9uLWRpc3BsYXk6IHZhcigtLXBsYXktYnV0dG9uLCB2YXIoLS1ib3R0b20tcGxheS1idXR0b24pKTtcbiAgLS1tZWRpYS1saXZlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1saXZlLWJ1dHRvbiwgdmFyKC0tYm90dG9tLWxpdmUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtc2Vlay1iYWNrd2FyZC1idXR0b24tZGlzcGxheTogdmFyKC0tc2Vlay1iYWNrd2FyZC1idXR0b24sIHZhcigtLWJvdHRvbS1zZWVrLWJhY2t3YXJkLWJ1dHRvbikpO1xuICAtLW1lZGlhLXNlZWstZm9yd2FyZC1idXR0b24tZGlzcGxheTogdmFyKC0tc2Vlay1mb3J3YXJkLWJ1dHRvbiwgdmFyKC0tYm90dG9tLXNlZWstZm9yd2FyZC1idXR0b24pKTtcbiAgLS1tZWRpYS1tdXRlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1tdXRlLWJ1dHRvbiwgdmFyKC0tYm90dG9tLW11dGUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtY2FwdGlvbnMtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWNhcHRpb25zLWJ1dHRvbiwgdmFyKC0tYm90dG9tLWNhcHRpb25zLWJ1dHRvbikpO1xuICAtLW1lZGlhLWNhcHRpb25zLXNlbGVjdG1lbnUtZGlzcGxheTogdmFyKFxuICAgIC0tY2FwdGlvbnMtc2VsZWN0bWVudSxcbiAgICB2YXIoLS1tZWRpYS1jYXB0aW9ucy1idXR0b24tZGlzcGxheSwgdmFyKC0tYm90dG9tLWNhcHRpb25zLXNlbGVjdG1lbnUpKVxuICApO1xuICAtLW1lZGlhLWFpcnBsYXktYnV0dG9uLWRpc3BsYXk6IHZhcigtLWFpcnBsYXktYnV0dG9uLCB2YXIoLS1ib3R0b20tYWlycGxheS1idXR0b24pKTtcbiAgLS1tZWRpYS1waXAtYnV0dG9uLWRpc3BsYXk6IHZhcigtLXBpcC1idXR0b24sIHZhcigtLWJvdHRvbS1waXAtYnV0dG9uKSk7XG4gIC0tbWVkaWEtZnVsbHNjcmVlbi1idXR0b24tZGlzcGxheTogdmFyKC0tZnVsbHNjcmVlbi1idXR0b24sIHZhcigtLWJvdHRvbS1mdWxsc2NyZWVuLWJ1dHRvbikpO1xuICAtLW1lZGlhLWNhc3QtYnV0dG9uLWRpc3BsYXk6IHZhcigtLWNhc3QtYnV0dG9uLCB2YXIoLS1ib3R0b20tY2FzdC1idXR0b24pKTtcbiAgLS1tZWRpYS1wbGF5YmFjay1yYXRlLWJ1dHRvbi1kaXNwbGF5OiB2YXIoLS1wbGF5YmFjay1yYXRlLWJ1dHRvbiwgdmFyKC0tYm90dG9tLXBsYXliYWNrLXJhdGUtYnV0dG9uKSk7XG4gIC0tbWVkaWEtdm9sdW1lLXJhbmdlLWRpc3BsYXk6IHZhcigtLXZvbHVtZS1yYW5nZSwgdmFyKC0tYm90dG9tLXZvbHVtZS1yYW5nZSkpO1xuICAtLW1lZGlhLXRpbWUtcmFuZ2UtZGlzcGxheTogdmFyKC0tdGltZS1yYW5nZSwgdmFyKC0tYm90dG9tLXRpbWUtcmFuZ2UpKTtcbiAgLS1tZWRpYS10aW1lLWRpc3BsYXktZGlzcGxheTogdmFyKC0tdGltZS1kaXNwbGF5LCB2YXIoLS1ib3R0b20tdGltZS1kaXNwbGF5KSk7XG4gIC0tbWVkaWEtZHVyYXRpb24tZGlzcGxheS1kaXNwbGF5OiB2YXIoLS1kdXJhdGlvbi1kaXNwbGF5LCB2YXIoLS1ib3R0b20tZHVyYXRpb24tZGlzcGxheSkpO1xuICAtLW1lZGlhLXRpdGxlLWRpc3BsYXktZGlzcGxheTogdmFyKC0tdGl0bGUtZGlzcGxheSwgdmFyKC0tYm90dG9tLXRpdGxlLWRpc3BsYXkpKTtcbn1cbmA7dmFyIGd0PWA8IS0tIHByZXR0aWVyLWlnbm9yZSAtLT5cbjx0ZW1wbGF0ZSBpZD1cIm1lZGlhLXRoZW1lLW11eFwiPlxuICA8c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgLS1fcHJpbWFyeS1jb2xvcjogdmFyKC0tbWVkaWEtcHJpbWFyeS1jb2xvciwgd2hpdGUpO1xuICAgICAgLS1fc2Vjb25kYXJ5LWNvbG9yOiB2YXIoLS1tZWRpYS1zZWNvbmRhcnktY29sb3IsIHJnYigwIDAgMCAvIC43NSkpO1xuXG4gICAgICAtLW1lZGlhLWljb24tY29sb3I6IHZhcigtLV9wcmltYXJ5LWNvbG9yKTtcbiAgICAgIC0tbWVkaWEtcmFuZ2UtdGh1bWItYmFja2dyb3VuZDogdmFyKC0tX3ByaW1hcnktY29sb3IpO1xuICAgICAgLS1tZWRpYS1yYW5nZS1iYXItY29sb3I6IHZhcigtLV9wcmltYXJ5LWNvbG9yKTtcbiAgICAgIC0tbWVkaWEtY29udHJvbC1iYWNrZ3JvdW5kOiB2YXIoLS1fc2Vjb25kYXJ5LWNvbG9yKTtcbiAgICAgIC0tbWVkaWEtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1fc2Vjb25kYXJ5LWNvbG9yKTtcbiAgICAgIC0tbWVkaWEtdGltZS1yYW5nZS1idWZmZXJlZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xuICAgICAgLS1tZWRpYS1yYW5nZS10cmFjay1iYWNrZ3JvdW5kOlxuICAgICAgICBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkpLFxuICAgICAgICBsaW5lYXItZ3JhZGllbnQocmdiYSgyMCwgMjAsIDMwLCAwLjcpLCByZ2JhKDIwLCAyMCwgMzAsIDAuNykpO1xuICAgICAgLS1tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC1ib3JkZXI6IDA7XG4gICAgICAtLW1lZGlhLXByZXZpZXctdGh1bWJuYWlsLWJvcmRlci1yYWRpdXM6IDJweCAycHggMCAwO1xuICAgICAgLS1tZWRpYS1wcmV2aWV3LXRpbWUtYm9yZGVyLXJhZGl1czogMCAwIDJweCAycHg7XG4gICAgICAtLW1lZGlhLXByZXZpZXctdGltZS1tYXJnaW46IDAgMCA4cHg7XG4gICAgICAtLW1lZGlhLXByZXZpZXctdGltZS10ZXh0LXNoYWRvdzogbm9uZTtcblxuICAgICAgY29sb3I6IHZhcigtLV9wcmltYXJ5LWNvbG9yKTtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIDpob3N0KFthdWRpb10pIHtcbiAgICAgIC0tbWVkaWEtcHJldmlldy10aW1lLWJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgIC0tbWVkaWEtcHJldmlldy10aW1lLW1hcmdpbjogMCAwIDVweDtcbiAgICAgIC0tbWVkaWEtcHJldmlldy10aW1lLXRleHQtc2hhZG93OiBub25lO1xuICAgIH1cblxuICAgIDpob3N0KFthdWRpb10pIDo6c2xvdHRlZChbc2xvdD0nbWVkaWEnXSkge1xuICAgICAgaGVpZ2h0OiAwcHg7XG4gICAgfVxuXG4gICAgOmhvc3QoW2F1ZGlvXSkgbWVkaWEtbG9hZGluZy1pbmRpY2F0b3IsXG4gICAgOmhvc3QoW2F1ZGlvXSkgOjpzbG90dGVkKFtzbG90PXBvc3Rlcl0pIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgOmhvc3QoW2F1ZGlvXSkgbWVkaWEtY29udHJvbGxlciB7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICA6aG9zdChbYXVkaW9dKSBtZWRpYS1jb250cm9sbGVyOjpwYXJ0KHZlcnRpY2FsLWxheWVyKSB7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICA6aG9zdChbYXVkaW9dKSBtZWRpYS1jb250cm9sLWJhciB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICBbZGlzYWJsZWRdOm5vdChtZWRpYS1saXZlLWJ1dHRvbiksXG4gICAgW2FyaWEtZGlzYWJsZWQ9J3RydWUnXTpub3QobWVkaWEtbGl2ZS1idXR0b24pIHtcbiAgICAgIG9wYWNpdHk6IDYwJTtcbiAgICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdChbYXVkaW9dKSkgbWVkaWEtY2FwdGlvbnMtc2VsZWN0bWVudTo6cGFydChsaXN0Ym94KSB7XG4gICAgICB6LWluZGV4OiAxMDtcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sbGVyOm5vdChbbWVkaWFzdWJ0aXRsZXNsaXN0XSkgbWVkaWEtY2FwdGlvbnMtc2VsZWN0bWVudSB7XG4gICAgICAtLWNhcHRpb25zLXNlbGVjdG1lbnU6IG5vbmU7XG4gICAgfVxuXG5cbiAgICAvKiAwLjQzM3MgaXMgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gZm9yIFZUVCBSZWdpb25zLlxuICAgICAqIEJvcnJvd2VkIGhlcmUsIHNvIHRoZSBjYXB0aW9ucyBkb24ndCBtb3ZlIHRvbyBmYXN0LiAqL1xuICAgIG1lZGlhLWNvbnRyb2xsZXIgOjpzbG90dGVkKFtzbG90PSdtZWRpYSddKSB7XG4gICAgICAtLW1lZGlhLXdlYmtpdC10ZXh0LXRyYWNrLXRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjQzM3MgZWFzZS1vdXQgMC4zcztcbiAgICB9XG4gICAgbWVkaWEtY29udHJvbGxlcjppcyhbbWVkaWFwYXVzZWRdLDpub3QoW3VzZXJpbmFjdGl2ZV0pKSA6OnNsb3R0ZWQoW3Nsb3Q9J21lZGlhJ10pIHtcbiAgICAgIC8qIDQycHggaXMgdGhlIGhlaWdodCBvZiB0aGUgY29udHJvbCBiYXIgYW5kIHByb2dyZXNzIGJhclxuICAgICAgICogd2l0aCBhbiBhZGRpdGlvbmFsIDVweCBhcyBhIGJ1ZmZlciwgdG8gZ2V0IDQ3cHggKi9cbiAgICAgIC0tbWVkaWEtd2Via2l0LXRleHQtdHJhY2stdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00N3B4KTtcbiAgICAgIC0tbWVkaWEtd2Via2l0LXRleHQtdHJhY2stdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTVzIGVhc2U7XG4gICAgfVxuXG4gICAgbWVkaWEtY2FwdGlvbnMtc2VsZWN0bWVudSB7XG4gICAgICAtLW1lZGlhLWxpc3Rib3gtYmFja2dyb3VuZDogdmFyKC0tX3NlY29uZGFyeS1jb2xvcik7XG4gICAgICAtLW1lZGlhLWxpc3Rib3gtc2VsZWN0ZWQtYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI4KTtcbiAgICAgIC0tbWVkaWEtbGlzdGJveC1ob3Zlci1iYWNrZ3JvdW5kOiBub25lO1xuICAgICAgLS1tZWRpYS1saXN0Ym94LWhvdmVyLW91dGxpbmU6IHdoaXRlIHNvbGlkIDFweDtcbiAgICAgIC0tbWVkaWEtdGV4dC1jb2xvcjogd2hpdGU7XG4gICAgfVxuXG4gICAgbWVkaWEtdm9sdW1lLXJhbmdlW21lZGlhdm9sdW1ldW5hdmFpbGFibGVdIHtcbiAgICAgIC0tdm9sdW1lLXJhbmdlOiBub25lO1xuICAgIH1cblxuICAgIG1lZGlhLWFpcnBsYXktYnV0dG9uW21lZGlhYWlycGxheXVuYXZhaWxhYmxlXSB7XG4gICAgICAtLWFpcnBsYXktYnV0dG9uOiBub25lO1xuICAgIH1cblxuICAgIG1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uW21lZGlhZnVsbHNjcmVlbnVuYXZhaWxhYmxlXSB7XG4gICAgICAtLWZ1bGxzY3JlZW4tYnV0dG9uOiBub25lO1xuICAgIH1cblxuICAgIG1lZGlhLWNhc3QtYnV0dG9uW21lZGlhY2FzdHVuYXZhaWxhYmxlXSB7XG4gICAgICAtLWNhc3QtYnV0dG9uOiBub25lO1xuICAgIH1cblxuICAgIG1lZGlhLXBpcC1idXR0b25bbWVkaWFwaXB1bmF2YWlsYWJsZV0ge1xuICAgICAgLS1waXAtYnV0dG9uOiBub25lO1xuICAgIH1cblxuICAgIDpob3N0IG1lZGlhLXRpbWUtcmFuZ2Uge1xuICAgICAgY29sb3I6IHZhcigtLV9wcmltYXJ5LWNvbG9yKTtcbiAgICAgIC0tbWVkaWEtcmFuZ2UtdGh1bWItb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICA6aG9zdCg6bm90KFthdWRpb10pKSBtZWRpYS10aW1lLXJhbmdlIHtcbiAgICAgIC0tbWVkaWEtcmFuZ2UtcGFkZGluZzogMDtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgei1pbmRleDogMTA7XG4gICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICBib3R0b206IC0zcHg7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sLWJhciB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtcGFkZGluZzogNHB4IDNweDtcbiAgICB9XG5cbiAgICBbYnJlYWtwb2ludHNtXSBtZWRpYS1jb250cm9sLWJhciB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtcGFkZGluZzogOXB4IDVweDtcbiAgICB9XG5cbiAgICBbYnJlYWtwb2ludG1kXSBtZWRpYS1jb250cm9sLWJhciB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtcGFkZGluZzogOXB4IDdweDtcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sLWJhciA6aXMoW3JvbGU9J2J1dHRvbiddLCBbcm9sZT0nc3dpdGNoJ10sIGJ1dHRvbikge1xuICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgfVxuXG4gICAgbWVkaWEtY29udHJvbC1iYXIgOmlzKG1lZGlhLXRleHQtZGlzcGxheSwgbWVkaWEtdGltZS1kaXNwbGF5KTpmaXJzdC1jaGlsZCB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtcGFkZGluZzogOXB4IDVweCA5cHggMTBweDtcbiAgICB9XG5cbiAgICAuc3BhY2VyIHtcbiAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZCwgcmdiYSgyMCwgMjAsIDMwLCAwLjcpKTtcbiAgICB9XG5cbiAgICAvKiBBZGQgYSBzbWFsbCBzcGFjZSBvbiB0aGUgcmlnaHQgdG8gaGF2ZSB0aGUgcGxheSBidXR0b24gYW5kXG4gICAgICogZnVsbHNjcmVlbiBidXR0b24gYWxpZ25lZCBpbiByZWxhdGlvbiB0byB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICAgIG1lZGlhLWNvbnRyb2wtYmFyOm5vdChbc2xvdF0pOjphZnRlciB7XG4gICAgICBjb250ZW50OiAnJztcbiAgICAgIHdpZHRoOiAycHg7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tZWRpYS1jb250cm9sLWJhY2tncm91bmQsIHJnYmEoMjAsIDIwLCAzMCwgMC43KSk7XG4gICAgfVxuXG4gICAgbWVkaWEtY29udHJvbC1iYXJbc2xvdD0ndG9wLWNocm9tZSddIHtcbiAgICAgIG1pbi1oZWlnaHQ6IDQycHg7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICA6aG9zdChbdGl0bGVdKSBtZWRpYS1jb250cm9sLWJhcltzbG90PSd0b3AtY2hyb21lJ106OmJlZm9yZSB7XG4gICAgICBjb250ZW50OiAnJztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgcGFkZGluZy1ib3R0b206IG1pbigxNjBweCwgMjUlKTtcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2IoMCAwIDAgLyAwLjQpLCB0cmFuc3BhcmVudCk7XG4gICAgfVxuXG4gICAgbWVkaWEtY29udHJvbC1iYXJbc2xvdD0ndG9wLWNocm9tZSddID4gKiB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuXG4gICAgbWVkaWEtY29udHJvbGxlcjo6cGFydCh2ZXJ0aWNhbC1sYXllcikge1xuICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAxcztcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sbGVyOmlzKFttZWRpYXBhdXNlZF0sIDpub3QoW3VzZXJpbmFjdGl2ZV0pKTo6cGFydCh2ZXJ0aWNhbC1sYXllcikge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29udHJvbHMtYmFja2Ryb3AtY29sb3IsIHZhcigtLWNvbnRyb2xzLCB0cmFuc3BhcmVudCkpO1xuICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cztcbiAgICB9XG5cbiAgICAuY2VudGVyLWNvbnRyb2xzIHtcbiAgICAgIC0tbWVkaWEtYnV0dG9uLWljb24td2lkdGg6IDEwMCU7XG4gICAgICAtLW1lZGlhLWJ1dHRvbi1pY29uLWhlaWdodDogYXV0bztcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1mbG93OiByb3c7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KDAgMCAycHggcmdiKDAgMCAwIC8gMC4yNSkpIGRyb3Atc2hhZG93KDAgMCA2cHggcmdiKDAgMCAwIC8gMC4yNSkpO1xuICAgICAgcGFpbnQtb3JkZXI6IHN0cm9rZTtcbiAgICAgIHN0cm9rZTogcmdiYSgxMDIsIDEwMiwgMTAyLCAxKTtcbiAgICAgIHN0cm9rZS13aWR0aDogMC4zcHg7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDJweCByZ2IoMCAwIDAgLyAwLjI1KSwgMCAwIDZweCByZ2IoMCAwIDAgLyAwLjI1KTtcbiAgICB9XG5cbiAgICAuY2VudGVyLWNvbnRyb2xzIG1lZGlhLXBsYXktYnV0dG9uIHtcbiAgICAgIC0tbWVkaWEtY29udHJvbC1iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgIC0tbWVkaWEtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgIHBhZGRpbmc6IDA7XG4gICAgICB3aWR0aDogbWF4KDQzcHgsIG1pbigxMCUsIDU1cHgpKTtcbiAgICB9XG5cbiAgICAuY2VudGVyLWNvbnRyb2xzIG1lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uLFxuICAgIC5jZW50ZXItY29udHJvbHMgbWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvbiB7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAtLW1lZGlhLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBwYWRkaW5nOiAwO1xuICAgICAgbWFyZ2luOiAwIDIlO1xuICAgICAgd2lkdGg6IG1heCgzM3B4LCBtaW4oOCUsIDQwcHgpKTtcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sLWJhcjpub3QoW3Nsb3RdKSBtZWRpYS1zZWVrLWJhY2t3YXJkLWJ1dHRvbiB7XG4gICAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gICAgfVxuXG4gICAgbWVkaWEtY29udHJvbC1iYXI6bm90KFtzbG90XSkgbWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvbiB7XG4gICAgICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgICB9XG5cbiAgICBtZWRpYS1sb2FkaW5nLWluZGljYXRvciB7XG4gICAgICAtLW1lZGlhLWxvYWRpbmctaWNvbi13aWR0aDogMTAwJTtcbiAgICAgIC0tbWVkaWEtYnV0dG9uLWljb24taGVpZ2h0OiBhdXRvO1xuICAgICAgZGlzcGxheTogdmFyKC0tbWVkaWEtY29udHJvbC1kaXNwbGF5LCB2YXIoLS1tZWRpYS1sb2FkaW5nLWluZGljYXRvci1kaXNwbGF5LCBmbGV4KSk7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHdpZHRoOiBtaW4oMTUlLCAxNTBweCk7XG4gICAgICBmbGV4LWZsb3c6IHJvdztcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAvKiBJbnRlbnRpb25hbGx5IGRvbid0IHRhcmdldCB0aGUgZGl2IGZvciB0cmFuc2l0aW9uIGJ1dCB0aGUgY2hpbGRyZW5cbiAgICAgb2YgdGhlIGRpdi4gUHJldmVudHMgbWVzc2luZyB3aXRoIG1lZGlhLWNocm9tZSdzIGF1dG9oaWRlIGZlYXR1cmUuICovXG4gICAgbWVkaWEtbG9hZGluZy1pbmRpY2F0b3IgKyBkaXYgKiB7XG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMTVzO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG5cbiAgICBtZWRpYS1sb2FkaW5nLWluZGljYXRvclttZWRpYWxvYWRpbmddOm5vdChbbWVkaWFwYXVzZWRdKSB+IGRpdiA+ICoge1xuICAgICAgb3BhY2l0eTogMDtcbiAgICAgIHRyYW5zaXRpb24tZGVsYXk6IDQwMG1zO1xuICAgIH1cblxuICAgIG1lZGlhLXZvbHVtZS1yYW5nZSB7XG4gICAgICB3aWR0aDogbWluKDEwMCUsIDEwMHB4KTtcbiAgICB9XG5cbiAgICBtZWRpYS10aW1lLWRpc3BsYXkge1xuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB9XG5cbiAgICA6aXMobWVkaWEtdGltZS1kaXNwbGF5LCBtZWRpYS10ZXh0LWRpc3BsYXksIG1lZGlhLXBsYXliYWNrLXJhdGUtYnV0dG9uW3JvbGU9J2J1dHRvbiddKSB7XG4gICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgIH1cblxuICAgIDppcygudGl0bGUtZGlzcGxheSwgbWVkaWEtbGl2ZS1idXR0b24pIHtcbiAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAycHggcmdiKDAgMCAwIC8gMC42KTtcbiAgICB9XG5cbiAgICA6aG9zdChbYXVkaW9dKSAudGl0bGUtZGlzcGxheSB7XG4gICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICBmb250LXNpemU6IDIxcHg7XG4gICAgfVxuICA8L3N0eWxlPlxuXG4gIDx0ZW1wbGF0ZSBwYXJ0aWFsPVwiVGl0bGVEaXNwbGF5XCI+XG4gICAgPHRlbXBsYXRlIGlmPVwidGl0bGVcIj5cbiAgICAgIDxtZWRpYS10ZXh0LWRpc3BsYXkgcGFydD1cInRvcCB0aXRsZSBkaXNwbGF5XCIgY2xhc3M9XCJ0aXRsZS1kaXNwbGF5XCI+XG4gICAgICAgIHt7dGl0bGV9fVxuICAgICAgPC9tZWRpYS10ZXh0LWRpc3BsYXk+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8dGVtcGxhdGUgcGFydGlhbD1cIlBsYXlCdXR0b25cIj5cbiAgICA8bWVkaWEtcGxheS1idXR0b25cbiAgICAgIHBhcnQ9XCJ7e3NlY3Rpb24gPz8gJ2JvdHRvbSd9fSBwbGF5IGJ1dHRvblwiXG4gICAgICBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgICBhcmlhLWRpc2FibGVkPVwie3tkaXNhYmxlZH19XCJcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzbG90PVwicGxheVwiPlxuICAgICAgICA8cGF0aCBkPVwibTYuNzMgMjAuOTMgMTQuMDUtOC41NGEuNDYuNDYgMCAwIDAgMC0uNzhMNi43MyAzLjA3YS40OC40OCAwIDAgMC0uNzMuMzl2MTcuMDdhLjQ4LjQ4IDAgMCAwIC43My40WlwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHNsb3Q9XCJwYXVzZVwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJNNiAxOS41YS41LjUgMCAwIDAgLjUuNWgzYS41LjUgMCAwIDAgLjUtLjV2LTE1YS41LjUgMCAwIDAtLjUtLjVoLTNhLjUuNSAwIDAgMC0uNS41djE1Wk0xNC41IDRhLjUuNSAwIDAgMC0uNS41djE1YS41LjUgMCAwIDAgLjUuNWgzYS41LjUgMCAwIDAgLjUtLjV2LTE1YS41LjUgMCAwIDAtLjUtLjVoLTNaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtcGxheS1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJTZWVrQmFja3dhcmRCdXR0b25cIj5cbiAgICA8bWVkaWEtc2Vlay1iYWNrd2FyZC1idXR0b25cbiAgICAgIHNlZWtvZmZzZXQ9XCJ7e2JhY2t3YXJkc2Vla29mZnNldH19XCJcbiAgICAgIHBhcnQ9XCJ7e3NlY3Rpb24gPz8gJ2JvdHRvbSd9fSBzZWVrLWJhY2t3YXJkIGJ1dHRvblwiXG4gICAgICBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgICBhcmlhLWRpc2FibGVkPVwie3tkaXNhYmxlZH19XCJcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjIgMjRcIiBzbG90PVwiYmFja3dhcmRcIj5cbiAgICAgICAgPHBhdGggZD1cIk0xMSA2VjNMNS4zNyA3IDExIDEwLjk0VjhhNS41NCA1LjU0IDAgMCAxIDEuOSAxMC40OHYyLjEyQTcuNSA3LjUgMCAwIDAgMTEgNlpcIiAvPlxuICAgICAgICA8dGV4dCBjbGFzcz1cInZhbHVlXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIuNSAyMSlcIiBzdHlsZT1cImZvbnQtc2l6ZTogOHB4OyBmb250LWZhbWlseTogJ0FyaWFsTVQnLCAnQXJpYWwnXCI+XG4gICAgICAgICAge3tiYWNrd2FyZHNlZWtvZmZzZXR9fVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L3N2Zz5cbiAgICA8L21lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uPlxuICA8L3RlbXBsYXRlPlxuXG4gIDx0ZW1wbGF0ZSBwYXJ0aWFsPVwiU2Vla0ZvcndhcmRCdXR0b25cIj5cbiAgICA8bWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvblxuICAgICAgc2Vla29mZnNldD1cInt7Zm9yd2FyZHNlZWtvZmZzZXR9fVwiXG4gICAgICBwYXJ0PVwie3tzZWN0aW9uID8/ICdib3R0b20nfX0gc2Vlay1mb3J3YXJkIGJ1dHRvblwiXG4gICAgICBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgICBhcmlhLWRpc2FibGVkPVwie3tkaXNhYmxlZH19XCJcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjIgMjRcIiBzbG90PVwiZm9yd2FyZFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTExIDZWM2w1LjYxIDRMMTEgMTAuOTRWOGE1LjU0IDUuNTQgMCAwIDAtMS45IDEwLjQ4djIuMTJBNy41IDcuNSAwIDAgMSAxMSA2WlwiIC8+XG4gICAgICAgIDx0ZXh0IGNsYXNzPVwidmFsdWVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTAgMjEpXCIgc3R5bGU9XCJmb250LXNpemU6IDhweDsgZm9udC1mYW1pbHk6ICdBcmlhbE1UJywgJ0FyaWFsJ1wiPlxuICAgICAgICAgIHt7Zm9yd2FyZHNlZWtvZmZzZXR9fVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L3N2Zz5cbiAgICA8L21lZGlhLXNlZWstZm9yd2FyZC1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJNdXRlQnV0dG9uXCI+XG4gICAgPG1lZGlhLW11dGUtYnV0dG9uIHBhcnQ9XCJib3R0b20gbXV0ZSBidXR0b25cIiBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHNsb3Q9XCJoaWdoXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIm0xMS4xNCA0Ljg2LTQgNGEuNDkuNDkgMCAwIDEtLjM1LjE0SDMuMjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY1LjVhLjI1LjI1IDAgMCAwIC4yNS4yNWgzLjU0YS40OS40OSAwIDAgMSAuMzYuMTVsNCA0YS41LjUgMCAwIDAgLjg1LS4zNlY1LjIxYS41LjUgMCAwIDAtLjg2LS4zNVptMi43NC0xLjU2djEuNTJBNy41MiA3LjUyIDAgMCAxIDE5LjQ3IDEyYTcuNTIgNy41MiAwIDAgMS01LjU5IDcuMTh2MS41MkE5IDkgMCAwIDAgMjEgMTJhOSA5IDAgMCAwLTcuMTItOC43Wm0zLjU2IDguN2E1LjQ5IDUuNDkgMCAwIDAtMy41Ni01LjF2MS42NmEzLjkzIDMuOTMgMCAwIDEgMCA2Ljg4djEuNjZhNS40OSA1LjQ5IDAgMCAwIDMuNTYtNS4xWlwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHNsb3Q9XCJsb3dcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwibTExLjE0IDQuODUzLTQgNGEuNDkuNDkgMCAwIDEtLjM1LjE0SDMuMjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY1LjVhLjI1LjI1IDAgMCAwIC4yNS4yNWgzLjU0YS40OS40OSAwIDAgMSAuMzYuMTVsNCA0YS41LjUgMCAwIDAgLjg1LS4zNlY1LjIwM2EuNS41IDAgMCAwLS44Ni0uMzVabTYuMyA3LjE0YTUuNDkgNS40OSAwIDAgMC0zLjU2LTUuMXYxLjY2YTMuOTMgMy45MyAwIDAgMSAwIDYuODh2MS42NmE1LjQ5IDUuNDkgMCAwIDAgMy41Ni01LjFaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc2xvdD1cIm1lZGl1bVwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJtMTEuMTQgNC44NTMtNCA0YS40OS40OSAwIDAgMS0uMzUuMTRIMy4yNWEuMjUuMjUgMCAwIDAtLjI1LjI1djUuNWEuMjUuMjUgMCAwIDAgLjI1LjI1aDMuNTRhLjQ5LjQ5IDAgMCAxIC4zNi4xNWw0IDRhLjUuNSAwIDAgMCAuODUtLjM2VjUuMjAzYS41LjUgMCAwIDAtLjg2LS4zNVptNi4zIDcuMTRhNS40OSA1LjQ5IDAgMCAwLTMuNTYtNS4xdjEuNjZhMy45MyAzLjkzIDAgMCAxIDAgNi44OHYxLjY2YTUuNDkgNS40OSAwIDAgMCAzLjU2LTUuMVpcIlxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzbG90PVwib2ZmXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIm0zIDQuMDUgNC40OCA0LjQ3LS4zMy4zM2EuNDkuNDkgMCAwIDEtLjM2LjE1SDMuMjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY1LjVhLjI1LjI1IDAgMCAwIC4yNS4yNWgzLjU0YS40OS40OSAwIDAgMSAuMzYuMTVsNCA0YS40OC40OCAwIDAgMCAuMzYuMTUuNS41IDAgMCAwIC41LS41di01Ljc1bDQuNjcgNC42NmE3LjcxIDcuNzEgMCAwIDEtMi43OSAxLjQ3djEuNTJhOS4zMiA5LjMyIDAgMCAwIDMuODctMS45MUwyMCAyMWwxLTFMNC4wNiAzIDMgNC4wNVptNS4zNiA1LjM2IDIuMzkgMi4zOVYxN0w4IDE0LjI2YTEuNzQgMS43NCAwIDAgMC0xLjI0LS41MUg0LjI1di0zLjVoMi41NEExLjc0IDEuNzQgMCAwIDAgOCA5Ljc0bC4zNi0uMzNaTTE5LjQ3IDEyYTcuMTkgNy4xOSAwIDAgMS0uODkgMy40N2wxLjExIDEuMUE4LjY0IDguNjQgMCAwIDAgMjEgMTJhOSA5IDAgMCAwLTcuMTItOC43djEuNTJBNy41MiA3LjUyIDAgMCAxIDE5LjQ3IDEyWk0xMiA4Ljg4VjUuMjFhLjUuNSAwIDAgMC0uNS0uNS40OC40OCAwIDAgMC0uMzYuMTVMOS41NiA2LjQ0IDEyIDguODhaTTE1LjkxIDEyYTQuMjg0IDQuMjg0IDAgMCAxLS4wNy43MmwxLjIyIDEuMjJhNS4yIDUuMiAwIDAgMCAuMzgtMS45NCA1LjQ5IDUuNDkgMCAwIDAtMy41Ni01LjF2MS42NkE0IDQgMCAwIDEgMTUuOTEgMTJaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtbXV0ZS1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJQaXBCdXR0b25cIj5cbiAgICA8bWVkaWEtcGlwLWJ1dHRvbiBwYXJ0PVwiYm90dG9tIHBpcCBidXR0b25cIiBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiIHNsb3Q9XCJlbnRlclwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJNMjIgM0g0YTEgMSAwIDAgMC0xIDF2MTZhMSAxIDAgMCAwIDEgMWg2Ljc1di0xLjI1aC02LjVWNC4yNWgxNy41djYuNUgyM1Y0YTEgMSAwIDAgMC0xLTFabTAgMTBoLThhMSAxIDAgMCAwLTEgMXY2YTEgMSAwIDAgMCAxIDFoOGExIDEgMCAwIDAgMS0xdi02YTEgMSAwIDAgMC0xLTFabS0uNSA2LjVoLTd2LTVoN3Y1WlwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiIHNsb3Q9XCJleGl0XCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0yMiAzSDRhMSAxIDAgMCAwLTEgMXYxNmExIDEgMCAwIDAgMSAxaDYuNzV2LTEuMjVoLTYuNVY0LjI1aDE3LjV2Ni41SDIzVjRhMSAxIDAgMCAwLTEtMVptMCAxMGgtOGExIDEgMCAwIDAtMSAxdjZhMSAxIDAgMCAwIDEgMWg4YTEgMSAwIDAgMCAxLTF2LTZhMSAxIDAgMCAwLTEtMVptLS41IDYuNWgtN3YtNWg3djVaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtcGlwLWJ1dHRvbj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8dGVtcGxhdGUgcGFydGlhbD1cIkNhcHRpb25zTWVudUJ1dHRvblwiPlxuICAgIDxtZWRpYS1jYXB0aW9ucy1zZWxlY3RtZW51XG4gICAgICBwYXJ0PVwiYm90dG9tIGNhcHRpb25zIHNlbGVjdG1lbnVcIlxuICAgICAgZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgICAgYXJpYS1kaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI2IDI0XCIgc2xvdD1cIm9uXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0yMi44MzIgNS42OGEyLjU4IDIuNTggMCAwIDAtMi4zLTIuNWMtMy42Mi0uMjQtMTEuNDQtLjI0LTE1LjA2IDBhMi41OCAyLjU4IDAgMCAwLTIuMyAyLjVjLS4yMyA0LjIxLS4yMyA4LjQzIDAgMTIuNjRhMi41OCAyLjU4IDAgMCAwIDIuMyAyLjVjMy42Mi4yNCAxMS40NC4yNCAxNS4wNiAwYTIuNTggMi41OCAwIDAgMCAyLjMtMi41Yy4yMy00LjIxLjIzLTguNDMgMC0xMi42NFptLTExLjQxIDEwLjFhMy42MyAzLjYzIDAgMCAxLTEuNTEuMzIgNC43NiA0Ljc2IDAgMCAxLTEuNjMtLjI3IDQgNCAwIDAgMS0xLjI4LS44MyAzLjY3IDMuNjcgMCAwIDEtLjg0LTEuMjYgNC4yMyA0LjIzIDAgMCAxLS4zLTEuNjMgNC4yOCA0LjI4IDAgMCAxIC4zLTEuNjQgMy41MyAzLjUzIDAgMCAxIC44NC0xLjIxIDMuODkgMy44OSAwIDAgMSAxLjI5LS44IDQuNzYgNC43NiAwIDAgMSAxLjYzLS4yNyA0LjA2IDQuMDYgMCAwIDEgMS4zNS4yNGMuMjI1LjA5MS40NC4yMDUuNjQuMzRhMi43IDIuNyAwIDAgMSAuNTUuNTJsLTEuMjcgMWExLjc5IDEuNzkgMCAwIDAtLjYtLjQ2IDIgMiAwIDAgMC0uODMtLjE2IDIgMiAwIDAgMC0xLjU2LjY5IDIuMzUgMi4zNSAwIDAgMC0uNDYuNzcgMi43OCAyLjc4IDAgMCAwLS4xNiAxYy0uMDA5LjM0LjA0Ni42OC4xNiAxIC4xMDQuMjgzLjI2LjU0NS40Ni43Ny4xODguMjEuNDE1LjM4LjY3LjVhMiAyIDAgMCAwIC44NC4xOCAxLjg3IDEuODcgMCAwIDAgLjktLjIxIDEuNzggMS43OCAwIDAgMCAuNjUtLjZsMS4zOCAxYTIuODggMi44OCAwIDAgMS0xLjIyIDEuMDFabTcuNTIgMGEzLjYzIDMuNjMgMCAwIDEtMS41MS4zMiA0Ljc2IDQuNzYgMCAwIDEtMS42My0uMjcgMy44OSAzLjg5IDAgMCAxLTEuMjgtLjgzIDMuNTUgMy41NSAwIDAgMS0uODUtMS4yNiA0LjIzIDQuMjMgMCAwIDEtLjMtMS42MyA0LjI4IDQuMjggMCAwIDEgLjMtMS42NCAzLjQzIDMuNDMgMCAwIDEgLjg1LTEuMjUgMy43NSAzLjc1IDAgMCAxIDEuMjgtLjggNC43NiA0Ljc2IDAgMCAxIDEuNjMtLjI3IDQgNCAwIDAgMSAxLjM1LjI0Yy4yMjUuMDkxLjQ0LjIwNS42NC4zNC4yMS4xNDQuMzk1LjMyLjU1LjUybC0xLjI3IDFhMS43OSAxLjc5IDAgMCAwLS42LS40NiAyIDIgMCAwIDAtLjgzLS4xNiAyIDIgMCAwIDAtMS41Ni42OSAyLjM1MiAyLjM1MiAwIDAgMC0uNDYuNzcgMy4wMSAzLjAxIDAgMCAwLS4xNiAxYy0uMDAzLjM0LjA1LjY3OC4xNiAxIC4xMDguMjgyLjI2My41NDIuNDYuNzcuMTg4LjIxLjQxNi4zOC42Ny41YTIgMiAwIDAgMCAuODQuMTggMS44NyAxLjg3IDAgMCAwIC45LS4yMSAxLjc4IDEuNzggMCAwIDAgLjY1LS42bDEuMzggMWEyLjgyIDIuODIgMCAwIDEtMS4yMSAxLjA1WlwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiIHNsb3Q9XCJvZmZcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTIyLjgzMiA1LjY4YTIuNTggMi41OCAwIDAgMC0yLjMtMi41Yy0xLjgxLS4xMi00LjY3LS4xOC03LjUzLS4xOC0yLjg2IDAtNS43Mi4wNi03LjUzLjE4YTIuNTggMi41OCAwIDAgMC0yLjMgMi41Yy0uMjMgNC4yMS0uMjMgOC40MyAwIDEyLjY0YTIuNTggMi41OCAwIDAgMCAyLjMgMi41YzEuODEuMTIgNC42Ny4xOCA3LjUzLjE4IDIuODYgMCA1LjcyLS4wNiA3LjUzLS4xOGEyLjU4IDIuNTggMCAwIDAgMi4zLTIuNWMuMjMtNC4yMS4yMy04LjQzIDAtMTIuNjRabS0xLjQ5IDEyLjUzYTEuMTEgMS4xMSAwIDAgMS0uOTEgMS4xMWMtMS42Ny4xMS00LjQ1LjE4LTcuNDMuMTgtMi45OCAwLTUuNzYtLjA3LTcuNDMtLjE4YTEuMTEgMS4xMSAwIDAgMS0uOTEtMS4xMWMtLjIxLTQuMTM3LS4yMS04LjI4MyAwLTEyLjQyYTEuMTEgMS4xMSAwIDAgMSAuOTEtMS4xMWMxLjY3LS4xMSA0LjQzLS4xOCA3LjQzLS4xOHM1Ljc2LjA3IDcuNDMuMThhMS4xMSAxLjExIDAgMCAxIC45MSAxLjExYy4yMSA0LjEzNy4yMSA4LjI4MyAwIDEyLjQyWk0xMC44NDMgMTRhMS41NSAxLjU1IDAgMCAxLS43Ni4xOCAxLjU3IDEuNTcgMCAwIDEtLjcxLS4xOCAxLjY5IDEuNjkgMCAwIDEtLjU3LS40MiAyLjA5OSAyLjA5OSAwIDAgMS0uMzgtLjU4IDIuNDcgMi40NyAwIDAgMSAwLTEuNjQgMiAyIDAgMCAxIC4zOS0uNjYgMS43MyAxLjczIDAgMCAxIC41OC0uNDJjLjIzLS4xMDMuNDc5LS4xNTguNzMtLjE2LjI0MS0uMDA0LjQ4LjA0NC43LjE0LjE5OS4wODguMzczLjIyMi41MS4zOWwxLjA4LS44OWEyLjE3OSAyLjE3OSAwIDAgMC0uNDctLjQ0IDIuODEgMi44MSAwIDAgMC0uNTQtLjMyIDIuOTEgMi45MSAwIDAgMC0uNTgtLjE1IDIuNzEgMi43MSAwIDAgMC0uNTYgMCA0LjA4IDQuMDggMCAwIDAtMS4zOC4xNSAzLjI3IDMuMjcgMCAwIDAtMS4wOS42NyAzLjE0IDMuMTQgMCAwIDAtLjcxIDEuMDYgMy42MiAzLjYyIDAgMCAwLS4yNiAxLjM5IDMuNTcgMy41NyAwIDAgMCAuMjYgMS4zOCAzIDMgMCAwIDAgLjcxIDEuMDZjLjMxNi4yOTMuNjg3LjUyIDEuMDkuNjcuNDQzLjE2LjkxLjIzOCAxLjM4LjIzYTMuMiAzLjIgMCAwIDAgMS4yOC0uMjdjLjQwMS0uMTgzLjc0Ny0uNDcgMS0uODNsLTEuMTctLjg4YTEuNDIgMS40MiAwIDAgMS0uNTMuNTJabTYuNjIgMGExLjU4IDEuNTggMCAwIDEtLjc2LjE4IDEuNTQgMS41NCAwIDAgMS0uNy0uMTggMS42OSAxLjY5IDAgMCAxLS41Ny0uNDIgMi4xMiAyLjEyIDAgMCAxLS40My0uNTggMi4yOSAyLjI5IDAgMCAxIC4zOS0yLjMgMS44NCAxLjg0IDAgMCAxIDEuMzItLjU4Yy4yNDEtLjAwMy40OC4wNDUuNy4xNC4xOTkuMDg4LjM3My4yMjIuNTEuMzlsMS4wOC0uOTJhMi40MyAyLjQzIDAgMCAwLS40Ny0uNDQgMy4yMiAzLjIyIDAgMCAwLS41My0uMjkgMi45OTkgMi45OTkgMCAwIDAtLjU3LS4xNSAyLjg3IDIuODcgMCAwIDAtLjU3IDAgNC4wNiA0LjA2IDAgMCAwLTEuMzYuMTUgMy4xNyAzLjE3IDAgMCAwLTEuMDkuNjcgMyAzIDAgMCAwLS43MiAxLjA2IDMuNjIgMy42MiAwIDAgMC0uMjUgMS4zOSAzLjU3IDMuNTcgMCAwIDAgLjI1IDEuMzhjLjE2LjQwMi40MDUuNzY0LjcyIDEuMDZhMy4xNyAzLjE3IDAgMCAwIDEuMDkuNjdjLjQ0LjE2LjkwNC4yMzcgMS4zNy4yMy40NDEgMCAuODc3LS4wOTIgMS4yOC0uMjdhMi40NSAyLjQ1IDAgMCAwIDEtLjgzbC0xLjE1LS44NWExLjQ5IDEuNDkgMCAwIDEtLjU0LjQ5WlwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L21lZGlhLWNhcHRpb25zLXNlbGVjdG1lbnU+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJBaXJwbGF5QnV0dG9uXCI+XG4gICAgPG1lZGlhLWFpcnBsYXktYnV0dG9uIHBhcnQ9XCJib3R0b20gYWlycGxheSBidXR0b25cIiBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiIHNsb3Q9XCJhaXJwbGF5XCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0xMy4xOSAxNC4yMmEuMjUuMjUgMCAwIDAtLjM4IDBsLTUuNDYgNi4zN2EuMjUuMjUgMCAwIDAgLjE5LjQxaDEwLjkyYS4yNS4yNSAwIDAgMCAuMTktLjQxbC01LjQ2LTYuMzdaXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTIyIDNINGExIDEgMCAwIDAtMSAxdjEzYTEgMSAwIDAgMCAxIDFoMi45NEw4IDE2Ljc1SDQuMjVWNC4yNWgxNy41djEyLjVIMThMMTkuMDYgMThIMjJhMSAxIDAgMCAwIDEtMVY0YTEgMSAwIDAgMC0xLTFaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtYWlycGxheS1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJGdWxsc2NyZWVuQnV0dG9uXCI+XG4gICAgPG1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uIHBhcnQ9XCJib3R0b20gZnVsbHNjcmVlbiBidXR0b25cIiBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHNsb3Q9XCJlbnRlclwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJNMjAuMjUgMTQuNWEuNzYuNzYgMCAwIDAtLjc1Ljc1djQuMjVoLTQuMjVhLjc1Ljc1IDAgMSAwIDAgMS41aDVhLjc2Ljc2IDAgMCAwIC43NS0uNzV2LTVhLjc2Ljc2IDAgMCAwLS43NS0uNzVabTAtMTEuNWgtNWEuNzYuNzYgMCAwIDAtLjc1Ljc1Ljc2Ljc2IDAgMCAwIC43NS43NWg0LjI1djQuMjVhLjc1Ljc1IDAgMSAwIDEuNSAwdi01YS43Ni43NiAwIDAgMC0uNzUtLjc1Wk04Ljc1IDE5LjVINC41di00LjI1YS43Ni43NiAwIDAgMC0uNzUtLjc1Ljc2Ljc2IDAgMCAwLS43NS43NXY1YS43Ni43NiAwIDAgMCAuNzUuNzVoNWEuNzUuNzUgMCAxIDAgMC0xLjVabTAtMTYuNWgtNWEuNzYuNzYgMCAwIDAtLjc1Ljc1djVhLjc2Ljc2IDAgMCAwIC43NS43NS43Ni43NiAwIDAgMCAuNzUtLjc1VjQuNWg0LjI1YS43Ni43NiAwIDAgMCAuNzUtLjc1Ljc2Ljc2IDAgMCAwLS43NS0uNzVaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc2xvdD1cImV4aXRcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTIwLjI1IDE0LjVoLTVhLjc2Ljc2IDAgMCAwLS43NS43NXY1YS43NS43NSAwIDEgMCAxLjUgMFYxNmg0LjI1YS43NS43NSAwIDEgMCAwLTEuNVptLTUtNWg1YS43NS43NSAwIDEgMCAwLTEuNUgxNlYzLjc1YS43NS43NSAwIDEgMC0xLjUgMHY1YS43Ni43NiAwIDAgMCAuNzUuNzVabS02LjUgNWgtNWEuNzUuNzUgMCAxIDAgMCAxLjVIOHY0LjI1YS43NS43NSAwIDEgMCAxLjUgMHYtNWEuNzYuNzYgMCAwIDAtLjc1LS43NVptMC0xMS41YS43Ni43NiAwIDAgMC0uNzUuNzVWOEgzLjc1YS43NS43NSAwIDAgMCAwIDEuNWg1YS43Ni43NiAwIDAgMCAuNzUtLjc1di01QS43Ni43NiAwIDAgMCA4Ljc1IDNaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtZnVsbHNjcmVlbi1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJDYXN0QnV0dG9uXCI+XG4gICAgPG1lZGlhLWNhc3QtYnV0dG9uIHBhcnQ9XCJib3R0b20gY2FzdCBidXR0b25cIiBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiIHNsb3Q9XCJlbnRlclwiPlxuICAgICAgICA8cGF0aCBkPVwiTTMgMTUuNVYxN2MyLjIwNiAwIDQgMS43OTQgNCA0aDEuNUE1LjUgNS41IDAgMCAwIDMgMTUuNVptMCAzVjIxaDIuNUEyLjUgMi41IDAgMCAwIDMgMTguNVpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMgMTIuNVYxNGMzLjg2IDAgNyAzLjE0IDcgN2gxLjVBOC41IDguNSAwIDAgMCAzIDEyLjVaXCIgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTIyIDNINGExIDEgMCAwIDAtMSAxdjYuOTg0Yy40MjQgMCAuODQuMDM1IDEuMjUuMDg2VjQuMjVoMTcuNXYxNS41aC04LjgyYy4wNTEuNDEuMDg2LjgyNi4wODYgMS4yNUgyMmExIDEgMCAwIDAgMS0xVjRhMSAxIDAgMCAwLTEtMVpcIlxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjYgMjRcIiBzbG90PVwiZXhpdFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTMgMTUuNVYxN2MyLjIwNiAwIDQgMS43OTQgNCA0aDEuNUE1LjUgNS41IDAgMCAwIDMgMTUuNVptMCAzVjIxaDIuNUEyLjUgMi41IDAgMCAwIDMgMTguNVpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMgMTIuNVYxNGMzLjg2IDAgNyAzLjE0IDcgN2gxLjVBOC41IDguNSAwIDAgMCAzIDEyLjVaXCIgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTIyIDNINGExIDEgMCAwIDAtMSAxdjYuOTg0Yy40MjQgMCAuODQuMDM1IDEuMjUuMDg2VjQuMjVoMTcuNXYxNS41aC04LjgyYy4wNTEuNDEuMDg2LjgyNi4wODYgMS4yNUgyMmExIDEgMCAwIDAgMS0xVjRhMSAxIDAgMCAwLTEtMVpcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aCBkPVwiTTIwLjUgNS41aC0xNXY1LjgxMWMzLjUyLjkwNiA2LjI4MyAzLjY3IDcuMTg5IDcuMTlIMjAuNVY1LjVaXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvbWVkaWEtY2FzdC1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJMaXZlQnV0dG9uXCI+XG4gICAgPG1lZGlhLWxpdmUtYnV0dG9uXG4gICAgICBwYXJ0PVwie3tzZWN0aW9uID8/ICd0b3AnfX0gbGl2ZSBidXR0b25cIlxuICAgICAgZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgICAgYXJpYS1kaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgPjwvbWVkaWEtbGl2ZS1idXR0b24+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIHBhcnRpYWw9XCJQbGF5YmFja1JhdGVCdXR0b25cIj5cbiAgICA8bWVkaWEtcGxheWJhY2stcmF0ZS1idXR0b25cbiAgICAgIHJhdGVzPVwie3twbGF5YmFja3JhdGVzfX1cIlxuICAgICAgcGFydD1cImJvdHRvbSBwbGF5YmFjay1yYXRlIGJ1dHRvblwiXG4gICAgICBkaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgICBhcmlhLWRpc2FibGVkPVwie3tkaXNhYmxlZH19XCJcbiAgICA+PC9tZWRpYS1wbGF5YmFjay1yYXRlLWJ1dHRvbj5cbiAgPC90ZW1wbGF0ZT5cblxuICA8dGVtcGxhdGUgcGFydGlhbD1cIlZvbHVtZVJhbmdlXCI+XG4gICAgPG1lZGlhLXZvbHVtZS1yYW5nZVxuICAgICAgcGFydD1cImJvdHRvbSB2b2x1bWUgcmFuZ2VcIlxuICAgICAgZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgICAgYXJpYS1kaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgPjwvbWVkaWEtdm9sdW1lLXJhbmdlPlxuICA8L3RlbXBsYXRlPlxuXG4gIDx0ZW1wbGF0ZSBwYXJ0aWFsPVwiVGltZURpc3BsYXlcIj5cbiAgICA8bWVkaWEtdGltZS1kaXNwbGF5XG4gICAgICByZW1haW5pbmc9XCJ7e2RlZmF1bHRzaG93cmVtYWluaW5ndGltZX19XCJcbiAgICAgIHNob3dkdXJhdGlvbj1cInt7IWhpZGVkdXJhdGlvbn19XCJcbiAgICAgIHBhcnQ9XCJib3R0b20gdGltZSBkaXNwbGF5XCJcbiAgICAgIGRpc2FibGVkPVwie3tkaXNhYmxlZH19XCJcbiAgICAgIGFyaWEtZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgID48L21lZGlhLXRpbWUtZGlzcGxheT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8dGVtcGxhdGUgcGFydGlhbD1cIlRpbWVSYW5nZVwiPlxuICAgIDxtZWRpYS10aW1lLXJhbmdlXG4gICAgICBwYXJ0PVwiYm90dG9tIHRpbWUgcmFuZ2VcIlxuICAgICAgZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgICAgYXJpYS1kaXNhYmxlZD1cInt7ZGlzYWJsZWR9fVwiXG4gICAgPjwvbWVkaWEtdGltZS1yYW5nZT5cbiAgPC90ZW1wbGF0ZT5cblxuICA8bWVkaWEtY29udHJvbGxlclxuICAgIGRlZmF1bHRzdHJlYW10eXBlPVwie3tkZWZhdWx0c3RyZWFtdHlwZSA/PyAnb24tZGVtYW5kJ319XCJcbiAgICBicmVha3BvaW50cz1cInNtOjMwMCBtZDo3MDBcIlxuICAgIGdlc3R1cmVzZGlzYWJsZWQ9XCJ7e2Rpc2FibGVkfX1cIlxuICAgIGhvdGtleXM9XCJ7e2hvdGtleXN9fVwiXG4gICAgbm9ob3RrZXlzPVwie3tub2hvdGtleXN9fVwiXG4gICAgbm92b2x1bWVwcmVmPVwie3tub3ZvbHVtZXByZWZ9fVwiXG4gICAgYXVkaW89XCJ7e2F1ZGlvfX1cIlxuICAgIG5vYXV0b3NlZWt0b2xpdmU9XCJ7e25vYXV0b3NlZWt0b2xpdmV9fVwiXG4gICAgZGVmYXVsdHN1YnRpdGxlcz1cInt7ZGVmYXVsdHN1YnRpdGxlc319XCJcbiAgICBleHBvcnRwYXJ0cz1cImxheWVyLCBtZWRpYS1sYXllciwgcG9zdGVyLWxheWVyLCB2ZXJ0aWNhbC1sYXllciwgY2VudGVyZWQtbGF5ZXIsIGdlc3R1cmUtbGF5ZXJcIlxuICA+XG4gICAgPHNsb3QgbmFtZT1cIm1lZGlhXCIgc2xvdD1cIm1lZGlhXCI+PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJwb3N0ZXJcIiBzbG90PVwicG9zdGVyXCI+PC9zbG90PlxuICAgIDxtZWRpYS1sb2FkaW5nLWluZGljYXRvciBzbG90PVwiY2VudGVyZWQtY2hyb21lXCIgbm9hdXRvaGlkZT48L21lZGlhLWxvYWRpbmctaW5kaWNhdG9yPlxuXG4gICAgPHRlbXBsYXRlIGlmPVwiYXVkaW9cIj5cblxuICAgICAgPHRlbXBsYXRlIGlmPVwic3RyZWFtdHlwZSA9PSAnb24tZGVtYW5kJ1wiPlxuICAgICAgICA8dGVtcGxhdGUgaWY9XCJ0aXRsZVwiPlxuICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj57ez5UaXRsZURpc3BsYXl9fTwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICB7ez5QbGF5QnV0dG9ufX1cbiAgICAgICAgICB7ez5TZWVrQmFja3dhcmRCdXR0b259fVxuICAgICAgICAgIHt7PlNlZWtGb3J3YXJkQnV0dG9ufX1cbiAgICAgICAgICB7ez5UaW1lRGlzcGxheX19XG4gICAgICAgICAge3s+VGltZVJhbmdlfX1cbiAgICAgICAgICB7ez5NdXRlQnV0dG9ufX1cbiAgICAgICAgICB7ez5Wb2x1bWVSYW5nZX19XG4gICAgICAgICAge3s+UGxheWJhY2tSYXRlQnV0dG9ufX1cbiAgICAgICAgICB7ez5BaXJwbGF5QnV0dG9ufX1cbiAgICAgICAgICB7ez5DYXN0QnV0dG9ufX1cbiAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDx0ZW1wbGF0ZSBpZj1cInN0cmVhbXR5cGUgPT0gJ2xpdmUnXCI+XG5cbiAgICAgICAgPHRlbXBsYXRlIGlmPVwidGFyZ2V0bGl2ZXdpbmRvdyA+IDBcIj5cbiAgICAgICAgICA8dGVtcGxhdGUgaWY9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPnt7PlRpdGxlRGlzcGxheX19PC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIHt7PlBsYXlCdXR0b259fVxuICAgICAgICAgICAge3s+TGl2ZUJ1dHRvbiBzZWN0aW9uPVwiYm90dG9tXCJ9fVxuICAgICAgICAgICAge3s+U2Vla0JhY2t3YXJkQnV0dG9ufX1cbiAgICAgICAgICAgIHt7PlNlZWtGb3J3YXJkQnV0dG9ufX1cbiAgICAgICAgICAgIHt7PlRpbWVEaXNwbGF5fX1cbiAgICAgICAgICAgIHt7PlRpbWVSYW5nZX19XG4gICAgICAgICAgICB7ez5NdXRlQnV0dG9ufX1cbiAgICAgICAgICAgIHt7PlZvbHVtZVJhbmdlfX1cbiAgICAgICAgICAgIHt7PlBsYXliYWNrUmF0ZUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5BaXJwbGF5QnV0dG9ufX1cbiAgICAgICAgICAgIHt7PkNhc3RCdXR0b259fVxuICAgICAgICAgIDwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHRlbXBsYXRlIGlmPVwiIXRhcmdldGxpdmV3aW5kb3dcIj5cbiAgICAgICAgICA8dGVtcGxhdGUgaWY9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPnt7PlRpdGxlRGlzcGxheX19PC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIHt7PlBsYXlCdXR0b259fVxuICAgICAgICAgICAge3s+TGl2ZUJ1dHRvbiBzZWN0aW9uPVwiYm90dG9tXCJ9fVxuICAgICAgICAgICAge3s+TXV0ZUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5Wb2x1bWVSYW5nZX19XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICAgICAgICB7ez5BaXJwbGF5QnV0dG9ufX1cbiAgICAgICAgICAgIHt7PkNhc3RCdXR0b259fVxuICAgICAgICAgIDwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDwvdGVtcGxhdGU+XG4gICAgPC90ZW1wbGF0ZT5cblxuICAgIDx0ZW1wbGF0ZSBpZj1cIiFhdWRpb1wiPlxuXG4gICAgICA8dGVtcGxhdGUgaWY9XCJzdHJlYW10eXBlID09ICdvbi1kZW1hbmQnXCI+XG5cbiAgICAgICAgPHRlbXBsYXRlIGlmPVwiIWJyZWFrcG9pbnRzbVwiPlxuICAgICAgICAgIHt7PlRpbWVSYW5nZX19XG4gICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAge3s+UGxheUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5NdXRlQnV0dG9ufX1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIHt7PkNhcHRpb25zTWVudUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5GdWxsc2NyZWVuQnV0dG9ufX1cbiAgICAgICAgICA8L21lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDx0ZW1wbGF0ZSBpZj1cImJyZWFrcG9pbnRzbVwiPlxuICAgICAgICAgIDx0ZW1wbGF0ZSBpZj1cIiFicmVha3BvaW50bWRcIj5cbiAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhciBzbG90PVwidG9wLWNocm9tZVwiPlxuICAgICAgICAgICAgICB7ez5UaXRsZURpc3BsYXl9fVxuICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIDxkaXYgc2xvdD1cImNlbnRlcmVkLWNocm9tZVwiIGNsYXNzPVwiY2VudGVyLWNvbnRyb2xzXCI+XG4gICAgICAgICAgICAgIHt7PlNlZWtCYWNrd2FyZEJ1dHRvbiBzZWN0aW9uPVwiY2VudGVyXCJ9fVxuICAgICAgICAgICAgICB7ez5QbGF5QnV0dG9uIHNlY3Rpb249XCJjZW50ZXJcIn19XG4gICAgICAgICAgICAgIHt7PlNlZWtGb3J3YXJkQnV0dG9uIHNlY3Rpb249XCJjZW50ZXJcIn19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt7PlRpbWVSYW5nZX19XG4gICAgICAgICAgICA8bWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgICAgICAgIHt7PlBsYXlCdXR0b259fVxuICAgICAgICAgICAgICB7ez5UaW1lRGlzcGxheX19XG4gICAgICAgICAgICAgIHt7Pk11dGVCdXR0b259fVxuICAgICAgICAgICAgICB7ez5Wb2x1bWVSYW5nZX19XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgICAgICAgICAge3s+UGxheWJhY2tSYXRlQnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+Q2FwdGlvbnNNZW51QnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+QWlycGxheUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PkNhc3RCdXR0b259fVxuICAgICAgICAgICAgICB7ez5QaXBCdXR0b259fVxuICAgICAgICAgICAgICB7ez5GdWxsc2NyZWVuQnV0dG9ufX1cbiAgICAgICAgICAgIDwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgICA8dGVtcGxhdGUgaWY9XCJicmVha3BvaW50bWRcIj5cbiAgICAgICAgICA8bWVkaWEtY29udHJvbC1iYXIgc2xvdD1cInRvcC1jaHJvbWVcIj5cbiAgICAgICAgICAgIHt7PlRpdGxlRGlzcGxheX19XG4gICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICA8ZGl2IHNsb3Q9XCJjZW50ZXJlZC1jaHJvbWVcIiBjbGFzcz1cImNlbnRlci1jb250cm9sc1wiPlxuICAgICAgICAgICAge3s+UGxheUJ1dHRvbiBzZWN0aW9uPVwiY2VudGVyXCJ9fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt7PlRpbWVSYW5nZX19XG4gICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAge3s+UGxheUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5TZWVrQmFja3dhcmRCdXR0b259fVxuICAgICAgICAgICAge3s+U2Vla0ZvcndhcmRCdXR0b259fVxuICAgICAgICAgICAge3s+VGltZURpc3BsYXl9fVxuICAgICAgICAgICAge3s+TXV0ZUJ1dHRvbn19XG4gICAgICAgICAgICB7ez5Wb2x1bWVSYW5nZX19XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICAgICAgICB7ez5QbGF5YmFja1JhdGVCdXR0b259fVxuICAgICAgICAgICAge3s+Q2FwdGlvbnNNZW51QnV0dG9ufX1cbiAgICAgICAgICAgIHt7PkFpcnBsYXlCdXR0b259fVxuICAgICAgICAgICAge3s+Q2FzdEJ1dHRvbn19XG4gICAgICAgICAgICB7ez5QaXBCdXR0b259fVxuICAgICAgICAgICAge3s+RnVsbHNjcmVlbkJ1dHRvbn19XG4gICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgPHRlbXBsYXRlIGlmPVwic3RyZWFtdHlwZSA9PSAnbGl2ZSdcIj5cblxuICAgICAgICA8dGVtcGxhdGUgaWY9XCIhdGFyZ2V0bGl2ZXdpbmRvd1wiPlxuXG4gICAgICAgICAgPHRlbXBsYXRlIGlmPVwiIWJyZWFrcG9pbnRzbVwiPlxuICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyIHNsb3Q9XCJ0b3AtY2hyb21lXCI+XG4gICAgICAgICAgICAgIHt7PkxpdmVCdXR0b259fVxuICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgICAge3s+UGxheUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7Pk11dGVCdXR0b259fVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICAgICAgICAgIHt7PkNhcHRpb25zTWVudUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PkZ1bGxzY3JlZW5CdXR0b259fVxuICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgICAgPHRlbXBsYXRlIGlmPVwiYnJlYWtwb2ludHNtXCI+XG4gICAgICAgICAgICA8dGVtcGxhdGUgaWY9XCIhYnJlYWtwb2ludG1kXCI+XG4gICAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhciBzbG90PVwidG9wLWNocm9tZVwiPlxuICAgICAgICAgICAgICAgIHt7PkxpdmVCdXR0b259fVxuICAgICAgICAgICAgICAgIHt7PlRpdGxlRGlzcGxheX19XG4gICAgICAgICAgICAgIDwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgICAgICAgIDxkaXYgc2xvdD1cImNlbnRlcmVkLWNocm9tZVwiIGNsYXNzPVwiY2VudGVyLWNvbnRyb2xzXCI+XG4gICAgICAgICAgICAgICAge3s+UGxheUJ1dHRvbiBzZWN0aW9uPVwiY2VudGVyXCJ9fVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAgICAgIHt7PlBsYXlCdXR0b259fVxuICAgICAgICAgICAgICAgIHt7Pk11dGVCdXR0b259fVxuICAgICAgICAgICAgICAgIHt7PlZvbHVtZVJhbmdlfX1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAge3s+Q2FwdGlvbnNNZW51QnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5BaXJwbGF5QnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5DYXN0QnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5QaXBCdXR0b259fVxuICAgICAgICAgICAgICAgIHt7PkZ1bGxzY3JlZW5CdXR0b259fVxuICAgICAgICAgICAgICA8L21lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgICAgPHRlbXBsYXRlIGlmPVwiYnJlYWtwb2ludG1kXCI+XG4gICAgICAgICAgICA8bWVkaWEtY29udHJvbC1iYXIgc2xvdD1cInRvcC1jaHJvbWVcIj5cbiAgICAgICAgICAgICAge3s+TGl2ZUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PlRpdGxlRGlzcGxheX19XG4gICAgICAgICAgICA8L21lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAgPGRpdiBzbG90PVwiY2VudGVyZWQtY2hyb21lXCIgY2xhc3M9XCJjZW50ZXItY29udHJvbHNcIj5cbiAgICAgICAgICAgICAge3s+UGxheUJ1dHRvbiBzZWN0aW9uPVwiY2VudGVyXCJ9fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgICAgICAgIHt7PlBsYXlCdXR0b259fVxuICAgICAgICAgICAgICB7ez5NdXRlQnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+Vm9sdW1lUmFuZ2V9fVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICAgICAgICAgIHt7PkNhcHRpb25zTWVudUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PkFpcnBsYXlCdXR0b259fVxuICAgICAgICAgICAgICB7ez5DYXN0QnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+UGlwQnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+RnVsbHNjcmVlbkJ1dHRvbn19XG4gICAgICAgICAgICA8L21lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHRlbXBsYXRlIGlmPVwidGFyZ2V0bGl2ZXdpbmRvdyA+IDBcIj5cblxuICAgICAgICAgIDx0ZW1wbGF0ZSBpZj1cIiFicmVha3BvaW50c21cIj5cbiAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhciBzbG90PVwidG9wLWNocm9tZVwiPlxuICAgICAgICAgICAgICB7ez5MaXZlQnV0dG9ufX1cbiAgICAgICAgICAgIDwvbWVkaWEtY29udHJvbC1iYXI+XG4gICAgICAgICAgICB7ez5UaW1lUmFuZ2V9fVxuICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgICAgICB7ez5QbGF5QnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+TXV0ZUJ1dHRvbn19XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgICAgICAgICAge3s+Q2FwdGlvbnNNZW51QnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+RnVsbHNjcmVlbkJ1dHRvbn19XG4gICAgICAgICAgICA8L21lZGlhLWNvbnRyb2wtYmFyPlxuICAgICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgICA8dGVtcGxhdGUgaWY9XCJicmVha3BvaW50c21cIj5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSBpZj1cIiFicmVha3BvaW50bWRcIj5cbiAgICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyIHNsb3Q9XCJ0b3AtY2hyb21lXCI+XG4gICAgICAgICAgICAgICAge3s+TGl2ZUJ1dHRvbn19XG4gICAgICAgICAgICAgICAge3s+VGl0bGVEaXNwbGF5fX1cbiAgICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgICAgPGRpdiBzbG90PVwiY2VudGVyZWQtY2hyb21lXCIgY2xhc3M9XCJjZW50ZXItY29udHJvbHNcIj5cbiAgICAgICAgICAgICAgICB7ez5TZWVrQmFja3dhcmRCdXR0b24gc2VjdGlvbj1cImNlbnRlclwifX1cbiAgICAgICAgICAgICAgICB7ez5QbGF5QnV0dG9uIHNlY3Rpb249XCJjZW50ZXJcIn19XG4gICAgICAgICAgICAgICAge3s+U2Vla0ZvcndhcmRCdXR0b24gc2VjdGlvbj1cImNlbnRlclwifX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHt7PlRpbWVSYW5nZX19XG4gICAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgICAgICB7ez5QbGF5QnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5NdXRlQnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5Wb2x1bWVSYW5nZX19XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIHt7PkNhcHRpb25zTWVudUJ1dHRvbn19XG4gICAgICAgICAgICAgICAge3s+QWlycGxheUJ1dHRvbn19XG4gICAgICAgICAgICAgICAge3s+Q2FzdEJ1dHRvbn19XG4gICAgICAgICAgICAgICAge3s+UGlwQnV0dG9ufX1cbiAgICAgICAgICAgICAgICB7ez5GdWxsc2NyZWVuQnV0dG9ufX1cbiAgICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgICAgIDx0ZW1wbGF0ZSBpZj1cImJyZWFrcG9pbnRtZFwiPlxuICAgICAgICAgICAgPG1lZGlhLWNvbnRyb2wtYmFyIHNsb3Q9XCJ0b3AtY2hyb21lXCI+XG4gICAgICAgICAgICAgIHt7PkxpdmVCdXR0b259fVxuICAgICAgICAgICAgICB7ez5UaXRsZURpc3BsYXl9fVxuICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgIDxkaXYgc2xvdD1cImNlbnRlcmVkLWNocm9tZVwiIGNsYXNzPVwiY2VudGVyLWNvbnRyb2xzXCI+XG4gICAgICAgICAgICAgIHt7PlBsYXlCdXR0b24gc2VjdGlvbj1cImNlbnRlclwifX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3s+VGltZVJhbmdlfX1cbiAgICAgICAgICAgIDxtZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICAgICAge3s+UGxheUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PlNlZWtCYWNrd2FyZEJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PlNlZWtGb3J3YXJkQnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+TXV0ZUJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PlZvbHVtZVJhbmdlfX1cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgICAgICAgICB7ez5DYXB0aW9uc01lbnVCdXR0b259fVxuICAgICAgICAgICAgICB7ez5BaXJwbGF5QnV0dG9ufX1cbiAgICAgICAgICAgICAge3s+Q2FzdEJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PlBpcEJ1dHRvbn19XG4gICAgICAgICAgICAgIHt7PkZ1bGxzY3JlZW5CdXR0b259fVxuICAgICAgICAgICAgPC9tZWRpYS1jb250cm9sLWJhcj5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICA8L3RlbXBsYXRlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuXG4gIDwvbWVkaWEtY29udHJvbGxlcj5cbjwvdGVtcGxhdGU+XG5gO3ZhciB5dD1gXG4gIDpob3N0IHtcbiAgICB6LWluZGV4OiAxMDA7XG4gICAgZGlzcGxheTogdmFyKC0tbWVkaWEtZGlhbG9nLWRpc3BsYXksIGZsZXgpO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjtcbiAgICBwYWRkaW5nOiB2YXIoLS1tZWRpYS1kaWFsb2ctYmFja2Ryb3AtcGFkZGluZywgMCk7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtZGlhbG9nLWJhY2tkcm9wLWJhY2tncm91bmQsXG4gICAgICBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDIwLCAyMCwgMzAsIDAuNykgNTAlLCByZ2JhKDIwLCAyMCwgMzAsIDAuOSkpXG4gICAgKTtcbiAgICAvKiBOZWVkcyB0byB1c2UgIWltcG9ydGFudCB0byBwcmV2ZW50IG92ZXJ3cml0ZSBvZiBtZWRpYS1jaHJvbWUgKi9cbiAgICB0cmFuc2l0aW9uOiB2YXIoLS1tZWRpYS1kaWFsb2ctdHJhbnNpdGlvbi1vcGVuLCB2aXNpYmlsaXR5IC4ycywgb3BhY2l0eSAuMnMpICFpbXBvcnRhbnQ7XG4gICAgdHJhbnNmb3JtOiB2YXIoLS1tZWRpYS1kaWFsb2ctdHJhbnNmb3JtLW9wZW4sIG5vbmUpICFpbXBvcnRhbnQ7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICBwb2ludGVyLWV2ZW50czogYXV0byAhaW1wb3J0YW50O1xuICB9XG5cbiAgOmhvc3QoOm5vdChbb3Blbl0pKSB7XG4gICAgLyogTmVlZHMgdG8gdXNlICFpbXBvcnRhbnQgdG8gcHJldmVudCBvdmVyd3JpdGUgb2YgbWVkaWEtY2hyb21lICovXG4gICAgdHJhbnNpdGlvbjogdmFyKC0tbWVkaWEtZGlhbG9nLXRyYW5zaXRpb24tY2xvc2UsIHZpc2liaWxpdHkgLjFzLCBvcGFjaXR5IC4xcykgIWltcG9ydGFudDtcbiAgICB0cmFuc2Zvcm06IHZhcigtLW1lZGlhLWRpYWxvZy10cmFuc2Zvcm0tY2xvc2UsIG5vbmUpICFpbXBvcnRhbnQ7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHJnYmEoMjcsIDEyNywgMjA0LCAwLjkpO1xuICB9XG5cbiAgLmRpYWxvZyB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtZGlhbG9nLWJhY2tncm91bmQsIG5vbmUpO1xuICAgIHBhZGRpbmc6IHZhcigtLW1lZGlhLWRpYWxvZy1wYWRkaW5nLCAxMHB4KTtcbiAgICB3aWR0aDogbWluKDMyMHB4LCAxMDAlKTtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gICAgbWF4LWhlaWdodDogMTAwJTtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcbiAgfVxuYCx2dD1ULmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTt2dC5pbm5lckhUTUw9YFxuICA8c3R5bGU+XG4gICAgJHt5dH1cbiAgPC9zdHlsZT5cblxuICA8ZGl2IGNsYXNzPVwiZGlhbG9nXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbmA7dmFyIEk9Y2xhc3MgZXh0ZW5kcyBoLkhUTUxFbGVtZW50e2NvbnN0cnVjdG9yKCl7dmFyIGU7c3VwZXIoKTt0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pLChlPXRoaXMuc2hhZG93Um9vdCk9PW51bGx8fGUuYXBwZW5kQ2hpbGQodGhpcy5jb25zdHJ1Y3Rvci50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSghMCkpfXNob3coKXt0aGlzLnNldEF0dHJpYnV0ZShcIm9wZW5cIixcIlwiKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwib3BlblwiLHtjb21wb3NlZDohMCxidWJibGVzOiEwfSkpLGZ0KHRoaXMpfWNsb3NlKCl7IXRoaXMuaGFzQXR0cmlidXRlKFwib3BlblwiKXx8KHRoaXMucmVtb3ZlQXR0cmlidXRlKFwib3BlblwiKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xvc2VcIix7Y29tcG9zZWQ6ITAsYnViYmxlczohMH0pKSxqdCh0aGlzKSl9YXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUscixpKXtlPT09XCJvcGVuXCImJnIhPT1pJiYoaSE9bnVsbD90aGlzLnNob3coKTp0aGlzLmNsb3NlKCkpfWNvbm5lY3RlZENhbGxiYWNrKCl7dGhpcy5oYXNBdHRyaWJ1dGUoXCJyb2xlXCIpfHx0aGlzLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImRpYWxvZ1wiKSx0aGlzLmhhc0F0dHJpYnV0ZShcIm9wZW5cIikmJmZ0KHRoaXMpfX07SS5zdHlsZXM9eXQsSS50ZW1wbGF0ZT12dCxJLm9ic2VydmVkQXR0cmlidXRlcz1bXCJvcGVuXCJdO2Z1bmN0aW9uIGZ0KHQpe2xldCBhPW5ldyBDdXN0b21FdmVudChcImluaXRmb2N1c1wiLHtjb21wb3NlZDohMCxidWJibGVzOiEwLGNhbmNlbGFibGU6ITB9KTtpZih0LmRpc3BhdGNoRXZlbnQoYSksYS5kZWZhdWx0UHJldmVudGVkKXJldHVybjtsZXQgZT10LnF1ZXJ5U2VsZWN0b3IoXCJbYXV0b2ZvY3VzXTpub3QoW2Rpc2FibGVkXSlcIik7IWUmJnQudGFiSW5kZXg+PTAmJihlPXQpLGV8fChlPUV0KHQuc2hhZG93Um9vdCkpLHQuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudD1ULmFjdGl2ZUVsZW1lbnQsVC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJlQuYWN0aXZlRWxlbWVudC5ibHVyKCksdC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCgpPT57ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZlLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiEwfSl9LHtvbmNlOiEwfSl9ZnVuY3Rpb24gRXQodCl7bGV0IGU9W1wiYnV0dG9uXCIsXCJpbnB1dFwiLFwia2V5Z2VuXCIsXCJzZWxlY3RcIixcInRleHRhcmVhXCJdLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gaStcIjpub3QoW2Rpc2FibGVkXSlcIn0pO2UucHVzaCgnW3RhYmluZGV4XTpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIlwiXSknKTtsZXQgcj10PT1udWxsP3ZvaWQgMDp0LnF1ZXJ5U2VsZWN0b3IoZS5qb2luKFwiLCBcIikpO2lmKCFyJiZcImF0dGFjaFNoYWRvd1wiaW4gRWxlbWVudC5wcm90b3R5cGUpe2xldCBpPSh0PT1udWxsP3ZvaWQgMDp0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKXx8W107Zm9yKGxldCBvPTA7bzxpLmxlbmd0aCYmIShpW29dLnRhZ05hbWUmJmlbb10uc2hhZG93Um9vdCYmKHI9RXQoaVtvXS5zaGFkb3dSb290KSxyKSk7bysrKTt9cmV0dXJuIHJ9ZnVuY3Rpb24ganQodCl7dC5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJnQuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudC5mb2N1cygpfWguY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtZGlhbG9nXCIpfHwoaC5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1kaWFsb2dcIixJKSxoLk1lZGlhRGlhbG9nPUkpO3ZhciBEZT1JO3ZhciBrdD1ULmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtrdC5pbm5lckhUTUw9YFxuICA8c3R5bGU+XG4gICAgJHtEZS5zdHlsZXN9XG5cbiAgICAuY2xvc2Uge1xuICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgcGFkZGluZzogMDtcbiAgICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBvdXRsaW5lOiBpbmhlcml0O1xuICAgICAgd2lkdGg6IDI4cHg7XG4gICAgICBoZWlnaHQ6IDI4cHg7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDFyZW07XG4gICAgICByaWdodDogMXJlbTtcbiAgICB9XG4gIDwvc3R5bGU+XG5cbiAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+XG5cbiAgPHNsb3QgbmFtZT1cImNsb3NlXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cImNsb3NlXCIgdGFiaW5kZXg9XCIwXCI+XG4gICAgICA8c3ZnIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICA8L3Nsb3Q+XG5gO3ZhciBlZT1jbGFzcyBleHRlbmRzIERle2NvbnN0cnVjdG9yKCl7dmFyIGEsZTtzdXBlcigpLChlPShhPXRoaXMuc2hhZG93Um9vdCk9PW51bGw/dm9pZCAwOmEucXVlcnlTZWxlY3RvcihcIi5jbG9zZVwiKSk9PW51bGx8fGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsKCk9Pnt0aGlzLmNsb3NlKCl9KX19O2VlLnRlbXBsYXRlPWt0O2guY3VzdG9tRWxlbWVudHMuZ2V0KFwibXhwLWRpYWxvZ1wiKXx8KGguY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibXhwLWRpYWxvZ1wiLGVlKSxoLk14cERpYWxvZz1lZSk7aW1wb3J0e1RlbXBsYXRlSW5zdGFuY2UgYXMgcXQsQ2hpbGROb2RlUGFydCBhcyBoZSxBdHRyUGFydCBhcyBnZX1mcm9tXCJtZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS10aGVtZS1lbGVtZW50LmpzXCI7dmFyIHRlPW5ldyBXZWFrTWFwLGFlPWNsYXNze2NvbnN0cnVjdG9yKGEsZSl7dGhpcy5lbGVtZW50PWE7dGhpcy50eXBlPWU7dGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy50eXBlLHRoaXMpO2xldCByPXRlLmdldCh0aGlzLmVsZW1lbnQpO3ImJnIuc2V0KHRoaXMudHlwZSx0aGlzKX1zZXQoYSl7aWYodHlwZW9mIGE9PVwiZnVuY3Rpb25cIil0aGlzLmhhbmRsZUV2ZW50PWEuYmluZCh0aGlzLmVsZW1lbnQpO2Vsc2UgaWYodHlwZW9mIGE9PVwib2JqZWN0XCImJnR5cGVvZiBhLmhhbmRsZUV2ZW50PT1cImZ1bmN0aW9uXCIpdGhpcy5oYW5kbGVFdmVudD1hLmhhbmRsZUV2ZW50LmJpbmQoYSk7ZWxzZXt0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsdGhpcyk7bGV0IGU9dGUuZ2V0KHRoaXMuZWxlbWVudCk7ZSYmZS5kZWxldGUodGhpcy50eXBlKX19c3RhdGljIGZvcihhKXt0ZS5oYXMoYS5lbGVtZW50KXx8dGUuc2V0KGEuZWxlbWVudCxuZXcgTWFwKTtsZXQgZT1hLmF0dHJpYnV0ZU5hbWUuc2xpY2UoMikscj10ZS5nZXQoYS5lbGVtZW50KTtyZXR1cm4gciYmci5oYXMoZSk/ci5nZXQoZSk6bmV3IGFlKGEuZWxlbWVudCxlKX19O2Z1bmN0aW9uIEd0KHQsYSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBnZSYmdC5hdHRyaWJ1dGVOYW1lLnN0YXJ0c1dpdGgoXCJvblwiKT8oYWUuZm9yKHQpLnNldChhKSx0LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlModC5hdHRyaWJ1dGVOYW1lc3BhY2UsdC5hdHRyaWJ1dGVOYW1lKSwhMCk6ITF9ZnVuY3Rpb24genQodCxhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIGJlJiZ0IGluc3RhbmNlb2YgaGU/KGEucmVuZGVySW50byh0KSwhMCk6ITF9ZnVuY3Rpb24gSnQodCxhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQmJnQgaW5zdGFuY2VvZiBoZT8oYS5jaGlsZE5vZGVzLmxlbmd0aCYmdC5yZXBsYWNlKC4uLmEuY2hpbGROb2RlcyksITApOiExfWZ1bmN0aW9uIFh0KHQsYSl7aWYodCBpbnN0YW5jZW9mIGdlKXtsZXQgZT10LmF0dHJpYnV0ZU5hbWVzcGFjZSxyPXQuZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhlLHQuYXR0cmlidXRlTmFtZSk7cmV0dXJuIFN0cmluZyhhKSE9PXImJih0LnZhbHVlPVN0cmluZyhhKSksITB9cmV0dXJuIHQudmFsdWU9U3RyaW5nKGEpLCEwfWZ1bmN0aW9uIFF0KHQsYSl7aWYodCBpbnN0YW5jZW9mIGdlJiZhIGluc3RhbmNlb2YgRWxlbWVudCl7bGV0IGU9dC5lbGVtZW50O3JldHVybiBlW3QuYXR0cmlidXRlTmFtZV0hPT1hJiYodC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKHQuYXR0cmlidXRlTmFtZXNwYWNlLHQuYXR0cmlidXRlTmFtZSksZVt0LmF0dHJpYnV0ZU5hbWVdPWEpLCEwfXJldHVybiExfWZ1bmN0aW9uIGVhKHQsYSl7aWYodHlwZW9mIGE9PVwiYm9vbGVhblwiJiZ0IGluc3RhbmNlb2YgZ2Upe2xldCBlPXQuYXR0cmlidXRlTmFtZXNwYWNlLHI9dC5lbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKGUsdC5hdHRyaWJ1dGVOYW1lKTtyZXR1cm4gYSE9PXImJih0LmJvb2xlYW5WYWx1ZT1hKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiB0YSh0LGEpe3JldHVybiBhPT09ITEmJnQgaW5zdGFuY2VvZiBoZT8odC5yZXBsYWNlKFwiXCIpLCEwKTohMX1mdW5jdGlvbiBhYSh0LGEpe1F0KHQsYSl8fGVhKHQsYSl8fEd0KHQsYSl8fHRhKHQsYSl8fHp0KHQsYSl8fEp0KHQsYSl8fFh0KHQsYSl9dmFyIFZlPW5ldyBNYXAsVHQ9bmV3IFdlYWtNYXAsQXQ9bmV3IFdlYWtNYXAsYmU9Y2xhc3N7Y29uc3RydWN0b3IoYSxlLHIpe3RoaXMuc3RyaW5ncz1hO3RoaXMudmFsdWVzPWU7dGhpcy5wcm9jZXNzb3I9cjt0aGlzLnN0cmluZ3NLZXk9dGhpcy5zdHJpbmdzLmpvaW4oXCJcdTAwMDFcIil9Z2V0IHRlbXBsYXRlKCl7aWYoVmUuaGFzKHRoaXMuc3RyaW5nc0tleSkpcmV0dXJuIFZlLmdldCh0aGlzLnN0cmluZ3NLZXkpO3tsZXQgYT1ULmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKSxlPXRoaXMuc3RyaW5ncy5sZW5ndGgtMTtyZXR1cm4gYS5pbm5lckhUTUw9dGhpcy5zdHJpbmdzLnJlZHVjZSgocixpLG8pPT5yK2krKG88ZT9ge3sgJHtvfSB9fWA6XCJcIiksXCJcIiksVmUuc2V0KHRoaXMuc3RyaW5nc0tleSxhKSxhfX1yZW5kZXJJbnRvKGEpe3ZhciBpO2xldCBlPXRoaXMudGVtcGxhdGU7aWYoVHQuZ2V0KGEpIT09ZSl7VHQuc2V0KGEsZSk7bGV0IG89bmV3IHF0KGUsdGhpcy52YWx1ZXMsdGhpcy5wcm9jZXNzb3IpO0F0LnNldChhLG8pLGEgaW5zdGFuY2VvZiBoZT9hLnJlcGxhY2UoLi4uby5jaGlsZHJlbik6YS5hcHBlbmRDaGlsZChvKTtyZXR1cm59bGV0IHI9QXQuZ2V0KGEpOyhpPXI9PW51bGw/dm9pZCAwOnIudXBkYXRlKT09bnVsbHx8aS5jYWxsKHIsdGhpcy52YWx1ZXMpfX0saWE9e3Byb2Nlc3NDYWxsYmFjayh0LGEsZSl7dmFyIHI7aWYoISFlKXtmb3IobGV0W2ksb11vZiBhKWlmKGkgaW4gZSl7bGV0IG49KHI9ZVtpXSkhPW51bGw/cjpcIlwiO2FhKG8sbil9fX19O2Z1bmN0aW9uIFModCwuLi5hKXtyZXR1cm4gbmV3IGJlKHQsYSxpYSl9ZnVuY3Rpb24geHQodCxhKXt0LnJlbmRlckludG8oYSl9aW1wb3J0e1N0cmVhbVR5cGVzIGFzIHJhfWZyb21cIkBtdXgvcGxheWJhY2stY29yZVwiO3ZhciBIZT1ULmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcImlubmVySFRNTFwiaW4gSGUmJihIZS5pbm5lckhUTUw9Z3QpO3ZhciB3dD10PT5TYFxuICA8c3R5bGU+XG4gICAgJHtodH1cbiAgPC9zdHlsZT5cbiAgJHtuYSh0KX1cbmAsb2E9dD0+e2xldCBhPXQuaG90S2V5cz9gJHt0LmhvdEtleXN9YDpcIlwiO3JldHVybiBYKHQuc3RyZWFtVHlwZSk9PT1cImxpdmVcIiYmKGErPVwiIG5vYXJyb3dsZWZ0IG5vYXJyb3dyaWdodFwiKSxhfSxuYT10PT57dmFyIGEsZSxyLGksbyxuLHUsYix3LGssUCxnLHYsQSxfLGMsbGUsRyxZLEZlLFVlLFllLFdlLFplLGplLHFlLEdlLHplLEplLFhlLFFlLGV0LHR0LGF0LGl0O3JldHVybiBTYFxuICA8bWVkaWEtdGhlbWVcbiAgICB0ZW1wbGF0ZT1cIiR7KGE9dC50aGVtZVRlbXBsYXRlKSE9bnVsbD9hOkhlLmNvbnRlbnQuY2hpbGRyZW5bMF19XCJcbiAgICBkZWZhdWx0c3RyZWFtdHlwZT1cIiR7KGU9dC5kZWZhdWx0U3RyZWFtVHlwZSkhPW51bGw/ZTohMX1cIlxuICAgIGhvdGtleXM9XCIke29hKHQpfHwhMX1cIlxuICAgIG5vaG90a2V5cz1cIiR7dC5ub0hvdEtleXN8fCF0Lmhhc1NyY3x8dC5pc0RpYWxvZ09wZW58fCExfVwiXG4gICAgbm9hdXRvc2Vla3RvbGl2ZT1cIiR7ISEoKHI9dC5zdHJlYW1UeXBlKSE9bnVsbCYmci5pbmNsdWRlcyhyYS5MSVZFKSkmJnQudGFyZ2V0TGl2ZVdpbmRvdyE9PTB9XCJcbiAgICBub3ZvbHVtZXByZWY9XCIke3Qubm92b2x1bWVwcmVmfHwhMX1cIlxuICAgIGRpc2FibGVkPVwiJHshdC5oYXNTcmN8fHQuaXNEaWFsb2dPcGVufVwiXG4gICAgYXVkaW89XCIkeyhpPXQuYXVkaW8pIT1udWxsP2k6ITF9XCJcbiAgICBzdHlsZT1cIiR7KG89c3Qoe1wiLS1tZWRpYS1wcmltYXJ5LWNvbG9yXCI6dC5wcmltYXJ5Q29sb3IsXCItLW1lZGlhLXNlY29uZGFyeS1jb2xvclwiOnQuc2Vjb25kYXJ5Q29sb3J9KSkhPW51bGw/bzohMX1cIlxuICAgIGRlZmF1bHRzdWJ0aXRsZXM9XCIkeyF0LmRlZmF1bHRIaWRkZW5DYXB0aW9uc31cIlxuICAgIGZvcndhcmRzZWVrb2Zmc2V0PVwiJHsobj10LmZvcndhcmRTZWVrT2Zmc2V0KSE9bnVsbD9uOiExfVwiXG4gICAgYmFja3dhcmRzZWVrb2Zmc2V0PVwiJHsodT10LmJhY2t3YXJkU2Vla09mZnNldCkhPW51bGw/dTohMX1cIlxuICAgIHBsYXliYWNrcmF0ZXM9XCIkeyhiPXQucGxheWJhY2tSYXRlcykhPW51bGw/YjohMX1cIlxuICAgIGRlZmF1bHRzaG93cmVtYWluaW5ndGltZT1cIiR7KHc9dC5kZWZhdWx0U2hvd1JlbWFpbmluZ1RpbWUpIT1udWxsP3c6ITF9XCJcbiAgICBoaWRlZHVyYXRpb249XCIkeyhrPXQuaGlkZUR1cmF0aW9uKSE9bnVsbD9rOiExfVwiXG4gICAgdGl0bGU9XCIkeyhQPXQudGl0bGUpIT1udWxsP1A6ITF9XCJcbiAgICBleHBvcnRwYXJ0cz1cInRvcCwgY2VudGVyLCBib3R0b20sIGxheWVyLCBtZWRpYS1sYXllciwgcG9zdGVyLWxheWVyLCB2ZXJ0aWNhbC1sYXllciwgY2VudGVyZWQtbGF5ZXIsIGdlc3R1cmUtbGF5ZXIsIHBvc3RlciwgbGl2ZSwgcGxheSwgYnV0dG9uLCBzZWVrLWJhY2t3YXJkLCBzZWVrLWZvcndhcmQsIG11dGUsIGNhcHRpb25zLCBhaXJwbGF5LCBwaXAsIGZ1bGxzY3JlZW4sIGNhc3QsIHBsYXliYWNrLXJhdGUsIHZvbHVtZSwgcmFuZ2UsIHRpbWUsIGRpc3BsYXlcIlxuICA+XG4gICAgPG11eC12aWRlb1xuICAgICAgc2xvdD1cIm1lZGlhXCJcbiAgICAgIHRhcmdldC1saXZlLXdpbmRvdz1cIiR7KGc9dC50YXJnZXRMaXZlV2luZG93KSE9bnVsbD9nOiExfVwiXG4gICAgICBzdHJlYW0tdHlwZT1cIiR7KHY9WCh0LnN0cmVhbVR5cGUpKSE9bnVsbD92OiExfVwiXG4gICAgICBjcm9zc29yaWdpbj1cIiR7KEE9dC5jcm9zc09yaWdpbikhPW51bGw/QTpcIlwifVwiXG4gICAgICBwbGF5c2lubGluZVxuICAgICAgYXV0b3BsYXk9XCIkeyhfPXQuYXV0b3BsYXkpIT1udWxsP186ITF9XCJcbiAgICAgIG11dGVkPVwiJHsoYz10Lm11dGVkKSE9bnVsbD9jOiExfVwiXG4gICAgICBsb29wPVwiJHsobGU9dC5sb29wKSE9bnVsbD9sZTohMX1cIlxuICAgICAgcHJlbG9hZD1cIiR7KEc9dC5wcmVsb2FkKSE9bnVsbD9HOiExfVwiXG4gICAgICBkZWJ1Zz1cIiR7KFk9dC5kZWJ1ZykhPW51bGw/WTohMX1cIlxuICAgICAgcHJlZmVyLWNtY2Q9XCIkeyhGZT10LnByZWZlckNtY2QpIT1udWxsP0ZlOiExfVwiXG4gICAgICBkaXNhYmxlLWNvb2tpZXM9XCIkeyhVZT10LmRpc2FibGVDb29raWVzKSE9bnVsbD9VZTohMX1cIlxuICAgICAgcHJlZmVyLXBsYXliYWNrPVwiJHsoWWU9dC5wcmVmZXJQbGF5YmFjaykhPW51bGw/WWU6ITF9XCJcbiAgICAgIHN0YXJ0LXRpbWU9XCIke3Quc3RhcnRUaW1lIT1udWxsP3Quc3RhcnRUaW1lOiExfVwiXG4gICAgICBiZWFjb24tY29sbGVjdGlvbi1kb21haW49XCIkeyhXZT10LmJlYWNvbkNvbGxlY3Rpb25Eb21haW4pIT1udWxsP1dlOiExfVwiXG4gICAgICBwbGF5ZXItc29mdHdhcmUtbmFtZT1cIiR7KFplPXQucGxheWVyU29mdHdhcmVOYW1lKSE9bnVsbD9aZTohMX1cIlxuICAgICAgcGxheWVyLXNvZnR3YXJlLXZlcnNpb249XCIkeyhqZT10LnBsYXllclNvZnR3YXJlVmVyc2lvbikhPW51bGw/amU6ITF9XCJcbiAgICAgIGVudi1rZXk9XCIkeyhxZT10LmVudktleSkhPW51bGw/cWU6ITF9XCJcbiAgICAgIGN1c3RvbS1kb21haW49XCIkeyhHZT10LmN1c3RvbURvbWFpbikhPW51bGw/R2U6ITF9XCJcbiAgICAgIHNyYz1cIiR7dC5zcmM/dC5zcmM6dC5wbGF5YmFja0lkP19lKHQucGxheWJhY2tJZCx7bWF4UmVzb2x1dGlvbjp0Lm1heFJlc29sdXRpb24sZG9tYWluOnQuY3VzdG9tRG9tYWluLHRva2VuOnQudG9rZW5zLnBsYXliYWNrfSk6ITF9XCJcbiAgICAgIGNhc3Qtc3JjPVwiJHt0LnNyYz90LnNyYzp0LnBsYXliYWNrSWQ/X2UodC5wbGF5YmFja0lkLHttYXhSZXNvbHV0aW9uOnQubWF4UmVzb2x1dGlvbixkb21haW46dC5jdXN0b21Eb21haW4sdG9rZW46dC50b2tlbnMucGxheWJhY2t9KTohMX1cIlxuICAgICAgZXhwb3J0cGFydHM9XCJ2aWRlb1wiXG4gICAgPlxuICAgICAgJHt0LnN0b3J5Ym9hcmQ/U2A8dHJhY2sgbGFiZWw9XCJ0aHVtYm5haWxzXCIgZGVmYXVsdCBraW5kPVwibWV0YWRhdGFcIiBzcmM9XCIke3Quc3Rvcnlib2FyZH1cIiAvPmA6U2BgfVxuICAgIDwvbXV4LXZpZGVvPlxuICAgIDxtZWRpYS1wb3N0ZXItaW1hZ2VcbiAgICAgIHNsb3Q9XCJwb3N0ZXJcIlxuICAgICAgcGFydD1cInBvc3RlclwiXG4gICAgICBzcmM9XCIke3QucG9zdGVyPT09XCJcIj8hMTooemU9dC5wb3N0ZXIpIT1udWxsP3plOiExfVwiXG4gICAgICBwbGFjZWhvbGRlci1zcmM9XCIkeyhKZT10LnBsYWNlaG9sZGVyKSE9bnVsbD9KZTohMX1cIlxuICAgID48L21lZGlhLXBvc3Rlci1pbWFnZT5cbiAgICA8bXhwLWRpYWxvZ1xuICAgICAgbm8tYXV0by1oaWRlXG4gICAgICBvcGVuPVwiJHsoWGU9dC5pc0RpYWxvZ09wZW4pIT1udWxsP1hlOiExfVwiXG4gICAgICBvbmNsb3NlPVwiJHt0Lm9uQ2xvc2VFcnJvckRpYWxvZ31cIlxuICAgICAgb25pbml0Zm9jdXM9XCIke3Qub25Jbml0Rm9jdXNEaWFsb2d9XCJcbiAgICA+XG4gICAgICAkeyhRZT10LmRpYWxvZykhPW51bGwmJlFlLnRpdGxlP1NgPGgzPiR7dC5kaWFsb2cudGl0bGV9PC9oMz5gOlNgYH1cbiAgICAgIDxwPlxuICAgICAgICAkeyhldD10LmRpYWxvZyk9PW51bGw/dm9pZCAwOmV0Lm1lc3NhZ2V9XG4gICAgICAgICR7KHR0PXQuZGlhbG9nKSE9bnVsbCYmdHQubGlua1VybD9TYDxhXG4gICAgICAgICAgICAgIGhyZWY9XCIke3QuZGlhbG9nLmxpbmtVcmx9XCJcbiAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgcmVsPVwiZXh0ZXJuYWwgbm9vcGVuZXJcIlxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiJHsoYXQ9dC5kaWFsb2cubGlua1RleHQpIT1udWxsP2F0OlwiXCJ9ICR7ZChcIihvcGVucyBpbiBhIG5ldyB3aW5kb3cpXCIpfVwiXG4gICAgICAgICAgICAgID4keyhpdD10LmRpYWxvZy5saW5rVGV4dCkhPW51bGw/aXQ6dC5kaWFsb2cubGlua1VybH08L2FcbiAgICAgICAgICAgID5gOlNgYH1cbiAgICAgIDwvcD5cbiAgICA8L214cC1kaWFsb2c+XG4gIDwvbWVkaWEtdGhlbWU+XG5gfTtpbXBvcnR7TWVkaWFFcnJvciBhcyBmZX1mcm9tXCJAbXV4L211eC12aWRlb1wiO2Z1bmN0aW9uIHllKHQsYSxlLHIsaSl7dmFyIHUsYix3O2xldCBvPXt9LG49e307c3dpdGNoKHQuY29kZSl7Y2FzZSBmZS5NRURJQV9FUlJfTkVUV09SSzp7c3dpdGNoKG8udGl0bGU9ZChcIk5ldHdvcmsgRXJyb3JcIixpKSxvLm1lc3NhZ2U9dC5tZXNzYWdlLCh1PXQuZGF0YSk9PW51bGw/dm9pZCAwOnUucmVzcG9uc2UuY29kZSl7Y2FzZSA0MTI6e28udGl0bGU9ZChcIlZpZGVvIGlzIG5vdCBjdXJyZW50bHkgYXZhaWxhYmxlXCIsaSksby5tZXNzYWdlPWQoXCJUaGUgbGl2ZSBzdHJlYW0gb3IgdmlkZW8gZmlsZSBhcmUgbm90IHlldCByZWFkeS5cIixpKSxuLm1lc3NhZ2U9ZChcIlRoaXMgcGxheWJhY2staWQgbWF5IGJlbG9uZyB0byBhIGxpdmUgc3RyZWFtIHRoYXQgaXMgbm90IGN1cnJlbnRseSBhY3RpdmUgb3IgYW4gYXNzZXQgdGhhdCBpcyBub3QgcmVhZHkuXCIsaSksbi5maWxlPVwiNDEyLW5vdC1wbGF5YWJsZS5tZFwiO2JyZWFrfWNhc2UgNDA0OntvLnRpdGxlPWQoXCJWaWRlbyBkb2VzIG5vdCBleGlzdFwiLGkpLG8ubWVzc2FnZT1cIlwiLG4ubWVzc2FnZT1kKFwiVGhpcyBwbGF5YmFjay1pZCBkb2VzIG5vdCBleGlzdC4gWW91IG1heSBoYXZlIHVzZWQgYW4gQXNzZXQgSUQgb3IgYW4gSUQgZnJvbSBhIGRpZmZlcmVudCByZXNvdXJjZS5cIixpKSxuLmZpbGU9XCI0MDQtbm90LWZvdW5kLm1kXCI7YnJlYWt9Y2FzZSA0MDM6e2lmKG8udGl0bGU9ZChcIkludmFsaWQgcGxheWJhY2sgVVJMXCIsaSksby5tZXNzYWdlPWQoXCJUaGUgdmlkZW8gVVJMIG9yIHBsYXliYWNrLXRva2VuIGFyZSBmb3JtYXR0ZWQgd2l0aCBpbmNvcnJlY3Qgb3IgaW5jb21wbGV0ZSBpbmZvcm1hdGlvbi5cIixpKSxuLm1lc3NhZ2U9ZChcIjQwMyBlcnJvciB0cnlpbmcgdG8gYWNjZXNzIHRoaXMgcGxheWJhY2sgVVJMLiBJZiB0aGlzIGlzIGEgc2lnbmVkIFVSTCwgeW91IG1pZ2h0IG5lZWQgdG8gcHJvdmlkZSBhIHBsYXliYWNrLXRva2VuLlwiLGkpLG4uZmlsZT1cIm1pc3Npbmctc2lnbmVkLXRva2Vucy5tZFwiLCFyKWJyZWFrO2xldHtleHA6ayxhdWQ6UCxzdWI6Z309TihyKSx2PURhdGUubm93KCk+ayoxZTMsQT1nIT09ZSxfPVAhPT1cInZcIixjPXt0aW1lU3R5bGU6XCJtZWRpdW1cIixkYXRlU3R5bGU6XCJtZWRpdW1cIn07aWYodil7by50aXRsZT1kKFwiVmlkZW8gVVJMIGhhcyBleHBpcmVkXCIsaSksby5tZXNzYWdlPWQoXCJUaGUgdmlkZW9cXHUyMDE5cyBzZWN1cmVkIHBsYXliYWNrLXRva2VuIGhhcyBleHBpcmVkLlwiLGkpLG4ubWVzc2FnZT1kKFwiVGhlIHZpZGVvXFx1MjAxOXMgc2VjdXJlZCBwbGF5YmFjay10b2tlbiBoYXMgZXhwaXJlZC5cIixpKSxuLmNvbnRleHQ9ZChcIkV4cGlyZWQgYXQ6IHtleHBpcmVkRGF0ZX0uIEN1cnJlbnQgdGltZToge2N1cnJlbnREYXRlfS5cIixpKS5mb3JtYXQoe2V4cGlyZWREYXRlOm5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KEguY29kZSxjKS5mb3JtYXQoayoxZTMpLGN1cnJlbnREYXRlOm5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KEguY29kZSxjKS5mb3JtYXQoRGF0ZS5ub3coKSl9KSxuLmZpbGU9XCI0MDMtZXhwaXJlZC10b2tlbi5tZFwiO2JyZWFrfWlmKEEpe28udGl0bGU9ZChcIlZpZGVvIFVSTCBpcyBmb3JtYXR0ZWQgaW5jb3JyZWN0bHlcIixpKSxvLm1lc3NhZ2U9ZChcIlRoZSB2aWRlb1xcdTIwMTlzIHBsYXliYWNrIElEIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgZW5jb2RlZCBpbiB0aGUgcGxheWJhY2stdG9rZW4uXCIsaSksbi5tZXNzYWdlPWQoXCJUaGUgdmlkZW9cXHUyMDE5cyBwbGF5YmFjayBJRCBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGVuY29kZWQgaW4gdGhlIHBsYXliYWNrLXRva2VuLlwiLGkpLG4uY29udGV4dD1kKFwiU3BlY2lmaWVkIHBsYXliYWNrIElEOiB7cGxheWJhY2tJZH0gYW5kIHRoZSBwbGF5YmFjayBJRCBlbmNvZGVkIGluIHRoZSBwbGF5YmFjay10b2tlbjoge3Rva2VuUGxheWJhY2tJZH1cIixpKS5mb3JtYXQoe3BsYXliYWNrSWQ6ZSx0b2tlblBsYXliYWNrSWQ6Z30pLG4uZmlsZT1cIjQwMy1wbGF5YmFjay1pZC1taXNtYXRjaC5tZFwiO2JyZWFrfWlmKF8pe28udGl0bGU9ZChcIlZpZGVvIFVSTCBpcyBmb3JtYXR0ZWQgaW5jb3JyZWN0bHlcIixpKSxvLm1lc3NhZ2U9ZChcIlRoZSBwbGF5YmFjay10b2tlbiBpcyBmb3JtYXR0ZWQgd2l0aCBpbmNvcnJlY3QgaW5mb3JtYXRpb24uXCIsaSksbi5tZXNzYWdlPWQoXCJUaGUgcGxheWJhY2stdG9rZW4gaXMgZm9ybWF0dGVkIHdpdGggaW5jb3JyZWN0IGluZm9ybWF0aW9uLlwiLGkpLG4uY29udGV4dD1kKFwiVGhlIHBsYXliYWNrLXRva2VuIGhhcyBhbiBpbmNvcnJlY3QgYXVkIHZhbHVlOiB7dG9rZW5UeXBlfS4gYXVkIHZhbHVlIHNob3VsZCBiZSB2LlwiLGkpLmZvcm1hdCh7dG9rZW5UeXBlOlB9KSxuLmZpbGU9XCI0MDMtaW5jb3JyZWN0LWF1ZC12YWx1ZS5tZFwiO2JyZWFrfW4ubWVzc2FnZT1kKFwiNDAzIGVycm9yIHRyeWluZyB0byBhY2Nlc3MgdGhpcyBwbGF5YmFjayBVUkwuIElmIHRoaXMgaXMgYSBzaWduZWQgcGxheWJhY2sgSUQsIHRoZSB0b2tlbiBtaWdodCBub3QgaGF2ZSBiZWVuIGdlbmVyYXRlZCBjb3JyZWN0bHkuXCIsaSksbi5maWxlPVwiNDAzLW1hbGZvcm1hdHRlZC10b2tlbi5tZFwiO2JyZWFrfX1icmVha31jYXNlIGZlLk1FRElBX0VSUl9ERUNPREU6e2xldHttZXNzYWdlOmt9PXQ7bz17dGl0bGU6ZChcIk1lZGlhIEVycm9yXCIsaSksbWVzc2FnZTprfSxuLmZpbGU9XCJtZWRpYS1kZWNvZGUtZXJyb3IubWRcIjticmVha31jYXNlIGZlLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRDp7bGV0IGs9KHc9KGI9dC5kYXRhKT09bnVsbD92b2lkIDA6Yi5yZXNwb25zZSk9PW51bGw/dm9pZCAwOncuY29kZTtpZihrPj00MDAmJms8NTAwKXt0LmNvZGU9ZmUuTUVESUFfRVJSX05FVFdPUkssdC5kYXRhPXtyZXNwb25zZTp7Y29kZTprfX0se2RpYWxvZzpvLGRldmxvZzpufT15ZSh0LGEsZSxyKTticmVha31vPXt0aXRsZTpkKFwiU291cmNlIE5vdCBTdXBwb3J0ZWRcIixpKSxtZXNzYWdlOnQubWVzc2FnZX0sbi5maWxlPVwibWVkaWEtc3JjLW5vdC1zdXBwb3J0ZWQubWRcIjticmVha31kZWZhdWx0Om89e3RpdGxlOmQoXCJFcnJvclwiLGkpLG1lc3NhZ2U6dC5tZXNzYWdlfTticmVha31yZXR1cm4gYSYmKG89e3RpdGxlOmQoXCJZb3VyIGRldmljZSBhcHBlYXJzIHRvIGJlIG9mZmxpbmVcIixpKSxtZXNzYWdlOmQoXCJDaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24gYW5kIHRyeSByZWxvYWRpbmcgdGhpcyB2aWRlby5cIixpKX0pLHtkaWFsb2c6byxkZXZsb2c6bn19dmFyIE09e1NSQzpcInNyY1wiLFBPU1RFUjpcInBvc3RlclwifSxzPXtTVFlMRTpcInN0eWxlXCIsREVGQVVMVF9ISURERU5fQ0FQVElPTlM6XCJkZWZhdWx0LWhpZGRlbi1jYXB0aW9uc1wiLFBSSU1BUllfQ09MT1I6XCJwcmltYXJ5LWNvbG9yXCIsU0VDT05EQVJZX0NPTE9SOlwic2Vjb25kYXJ5LWNvbG9yXCIsRk9SV0FSRF9TRUVLX09GRlNFVDpcImZvcndhcmQtc2Vlay1vZmZzZXRcIixCQUNLV0FSRF9TRUVLX09GRlNFVDpcImJhY2t3YXJkLXNlZWstb2Zmc2V0XCIsUExBWUJBQ0tfVE9LRU46XCJwbGF5YmFjay10b2tlblwiLFRIVU1CTkFJTF9UT0tFTjpcInRodW1ibmFpbC10b2tlblwiLFNUT1JZQk9BUkRfVE9LRU46XCJzdG9yeWJvYXJkLXRva2VuXCIsU1RPUllCT0FSRF9TUkM6XCJzdG9yeWJvYXJkLXNyY1wiLFRIVU1CTkFJTF9USU1FOlwidGh1bWJuYWlsLXRpbWVcIixBVURJTzpcImF1ZGlvXCIsTk9IT1RLRVlTOlwibm9ob3RrZXlzXCIsSE9US0VZUzpcImhvdGtleXNcIixQTEFZQkFDS19SQVRFUzpcInBsYXliYWNrcmF0ZXNcIixERUZBVUxUX1NIT1dfUkVNQUlOSU5HX1RJTUU6XCJkZWZhdWx0LXNob3ctcmVtYWluaW5nLXRpbWVcIixUSVRMRTpcInRpdGxlXCIsUExBQ0VIT0xERVI6XCJwbGFjZWhvbGRlclwiLFRIRU1FOlwidGhlbWVcIixERUZBVUxUX1NUUkVBTV9UWVBFOlwiZGVmYXVsdC1zdHJlYW0tdHlwZVwiLFRBUkdFVF9MSVZFX1dJTkRPVzpcInRhcmdldC1saXZlLXdpbmRvd1wiLE5PX1ZPTFVNRV9QUkVGOlwibm8tdm9sdW1lLXByZWZcIn0sJGU9W1wiYXVkaW9cIixcImJhY2t3YXJkc2Vla29mZnNldFwiLFwiZGVmYXVsdHNob3dyZW1haW5pbmd0aW1lXCIsXCJkZWZhdWx0c3VidGl0bGVzXCIsXCJub2F1dG9zZWVrdG9saXZlXCIsXCJkaXNhYmxlZFwiLFwiZXhwb3J0cGFydHNcIixcImZvcndhcmRzZWVrb2Zmc2V0XCIsXCJoaWRlZHVyYXRpb25cIixcImhvdGtleXNcIixcIm5vaG90a2V5c1wiLFwicGxheWJhY2tyYXRlc1wiLFwiZGVmYXVsdHN0cmVhbXR5cGVcIixcInN0cmVhbXR5cGVcIixcInN0eWxlXCIsXCJ0YXJnZXRsaXZld2luZG93XCIsXCJ0ZW1wbGF0ZVwiLFwidGl0bGVcIixcIm5vdm9sdW1lcHJlZlwiXTtmdW5jdGlvbiBtYSh0LGEpe3ZhciByO3JldHVybntzcmM6IXQucGxheWJhY2tJZCYmdC5zcmMscGxheWJhY2tJZDp0LnBsYXliYWNrSWQsaGFzU3JjOiEhdC5wbGF5YmFja0lkfHwhIXQuc3JjLHBvc3Rlcjp0LnBvc3RlcixzdG9yeWJvYXJkOnQuc3Rvcnlib2FyZCxzdG9yeWJvYXJkU3JjOnQuZ2V0QXR0cmlidXRlKHMuU1RPUllCT0FSRF9TUkMpLHBsYWNlaG9sZGVyOnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiksdGhlbWVUZW1wbGF0ZTpjYSh0KSx0aHVtYm5haWxUaW1lOiF0LnRva2Vucy50aHVtYm5haWwmJnQudGh1bWJuYWlsVGltZSxhdXRvcGxheTp0LmF1dG9wbGF5LGNyb3NzT3JpZ2luOnQuY3Jvc3NPcmlnaW4sbG9vcDp0Lmxvb3Asbm9Ib3RLZXlzOnQuaGFzQXR0cmlidXRlKHMuTk9IT1RLRVlTKSxob3RLZXlzOnQuZ2V0QXR0cmlidXRlKHMuSE9US0VZUyksbXV0ZWQ6dC5tdXRlZCxwYXVzZWQ6dC5wYXVzZWQscHJlbG9hZDp0LnByZWxvYWQsZW52S2V5OnQuZW52S2V5LHByZWZlckNtY2Q6dC5wcmVmZXJDbWNkLGRlYnVnOnQuZGVidWcsZGlzYWJsZUNvb2tpZXM6dC5kaXNhYmxlQ29va2llcyx0b2tlbnM6dC50b2tlbnMsYmVhY29uQ29sbGVjdGlvbkRvbWFpbjp0LmJlYWNvbkNvbGxlY3Rpb25Eb21haW4sbWF4UmVzb2x1dGlvbjp0Lm1heFJlc29sdXRpb24sbWV0YWRhdGE6dC5tZXRhZGF0YSxwbGF5ZXJTb2Z0d2FyZU5hbWU6dC5wbGF5ZXJTb2Z0d2FyZU5hbWUscGxheWVyU29mdHdhcmVWZXJzaW9uOnQucGxheWVyU29mdHdhcmVWZXJzaW9uLHN0YXJ0VGltZTp0LnN0YXJ0VGltZSxwcmVmZXJQbGF5YmFjazp0LnByZWZlclBsYXliYWNrLGF1ZGlvOnQuYXVkaW8sZGVmYXVsdFN0cmVhbVR5cGU6dC5kZWZhdWx0U3RyZWFtVHlwZSx0YXJnZXRMaXZlV2luZG93OnQuZ2V0QXR0cmlidXRlKGwuVEFSR0VUX0xJVkVfV0lORE9XKSxzdHJlYW1UeXBlOlgodC5nZXRBdHRyaWJ1dGUobC5TVFJFQU1fVFlQRSkpLHByaW1hcnlDb2xvcjp0LnByaW1hcnlDb2xvcixzZWNvbmRhcnlDb2xvcjp0LnNlY29uZGFyeUNvbG9yLGZvcndhcmRTZWVrT2Zmc2V0OnQuZm9yd2FyZFNlZWtPZmZzZXQsYmFja3dhcmRTZWVrT2Zmc2V0OnQuYmFja3dhcmRTZWVrT2Zmc2V0LGRlZmF1bHRIaWRkZW5DYXB0aW9uczp0LmRlZmF1bHRIaWRkZW5DYXB0aW9ucyxkZWZhdWx0U2hvd1JlbWFpbmluZ1RpbWU6dC5kZWZhdWx0U2hvd1JlbWFpbmluZ1RpbWUsaGlkZUR1cmF0aW9uOnBhKHQpLHBsYXliYWNrUmF0ZXM6dC5nZXRBdHRyaWJ1dGUocy5QTEFZQkFDS19SQVRFUyksY3VzdG9tRG9tYWluOihyPXQuZ2V0QXR0cmlidXRlKGwuQ1VTVE9NX0RPTUFJTikpIT1udWxsP3I6dm9pZCAwLHRpdGxlOnQuZ2V0QXR0cmlidXRlKHMuVElUTEUpLG5vdm9sdW1lcHJlZjp0Lmhhc0F0dHJpYnV0ZShzLk5PX1ZPTFVNRV9QUkVGKSwuLi5hfX1mdW5jdGlvbiBjYSh0KXt2YXIgZSxyO2xldCBhPXQuZ2V0QXR0cmlidXRlKHMuVEhFTUUpO2lmKGEpe2xldCBpPShyPShlPXQuZ2V0Um9vdE5vZGUoKSk9PW51bGw/dm9pZCAwOmUuZ2V0RWxlbWVudEJ5SWQpPT1udWxsP3ZvaWQgMDpyLmNhbGwoZSxhKTtpZihpKXJldHVybiBpO2Euc3RhcnRzV2l0aChcIm1lZGlhLXRoZW1lLVwiKXx8KGE9YG1lZGlhLXRoZW1lLSR7YX1gKTtsZXQgbz1oLmN1c3RvbUVsZW1lbnRzLmdldChhKTtpZihvIT1udWxsJiZvLnRlbXBsYXRlKXJldHVybiBvLnRlbXBsYXRlfX1mdW5jdGlvbiBwYSh0KXt2YXIgZTtsZXQgYT0oZT10Lm1lZGlhQ29udHJvbGxlcik9PW51bGw/dm9pZCAwOmUucXVlcnlTZWxlY3RvcihcIm1lZGlhLXRpbWUtZGlzcGxheVwiKTtyZXR1cm4gYSYmZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1tZWRpYS1kdXJhdGlvbi1kaXNwbGF5LWRpc3BsYXlcIikudHJpbSgpPT09XCJub25lXCJ9ZnVuY3Rpb24gTHQodCl7cmV0dXJuIHQuZ2V0QXR0cmlidXRlTmFtZXMoKS5maWx0ZXIoYT0+YS5zdGFydHNXaXRoKFwibWV0YWRhdGEtXCIpKS5yZWR1Y2UoKGEsZSk9PntsZXQgcj10LmdldEF0dHJpYnV0ZShlKTtyZXR1cm4gciE9PW51bGwmJihhW2UucmVwbGFjZSgvXm1ldGFkYXRhLS8sXCJcIikucmVwbGFjZSgvLS9nLFwiX1wiKV09ciksYX0se30pfXZhciBiYT1PYmplY3QudmFsdWVzKGwpLGhhPU9iamVjdC52YWx1ZXMoTSksZ2E9T2JqZWN0LnZhbHVlcyhzKSxmYT1wZSgpLHlhPVwibXV4LXBsYXllclwiLFJ0PXtkaWFsb2c6dm9pZCAwLGlzRGlhbG9nT3BlbjohMX0scmUsb2UsQyxuZSxVLEQsaixrZSxTdCxzZSxLZSxWLHEsVGUsTXQsQWUsQ3QseGUsUHQsd2UsX3QsaWU9Y2xhc3MgZXh0ZW5kcyBJZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7cCh0aGlzLEQpO3AodGhpcyxrZSk7cCh0aGlzLHNlKTtwKHRoaXMsVik7cCh0aGlzLFRlKTtwKHRoaXMsQWUpO3AodGhpcyx4ZSk7cCh0aGlzLHdlKTtwKHRoaXMscmUsITEpO3AodGhpcyxvZSx7fSk7cCh0aGlzLEMsITApO3AodGhpcyxuZSxuZXcgY2UodGhpcyxcImhvdGtleXNcIikpO3AodGhpcyxVLHsuLi5SdCxvbkNsb3NlRXJyb3JEaWFsb2c6KCk9PmYodGhpcyxzZSxLZSkuY2FsbCh0aGlzLHtkaWFsb2c6dm9pZCAwLGlzRGlhbG9nT3BlbjohMX0pLG9uSW5pdEZvY3VzRGlhbG9nOmU9PntNZSh0aGlzLFQuYWN0aXZlRWxlbWVudCl8fGUucHJldmVudERlZmF1bHQoKX19KTt0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pLGYodGhpcyxrZSxTdCkuY2FsbCh0aGlzKSx0aGlzLmlzQ29ubmVjdGVkJiZmKHRoaXMsRCxqKS5jYWxsKHRoaXMpfXN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7dmFyIGU7cmV0dXJuWy4uLihlPUllLm9ic2VydmVkQXR0cmlidXRlcykhPW51bGw/ZTpbXSwuLi5oYSwuLi5iYSwuLi5nYV19Z2V0IG1lZGlhVGhlbWUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLnNoYWRvd1Jvb3QpPT1udWxsP3ZvaWQgMDplLnF1ZXJ5U2VsZWN0b3IoXCJtZWRpYS10aGVtZVwiKX1nZXQgbWVkaWFDb250cm9sbGVyKCl7dmFyIGUscjtyZXR1cm4ocj0oZT10aGlzLm1lZGlhVGhlbWUpPT1udWxsP3ZvaWQgMDplLnNoYWRvd1Jvb3QpPT1udWxsP3ZvaWQgMDpyLnF1ZXJ5U2VsZWN0b3IoXCJtZWRpYS1jb250cm9sbGVyXCIpfWNvbm5lY3RlZENhbGxiYWNrKCl7dmFyIHI7bGV0IGU9KHI9dGhpcy5zaGFkb3dSb290KT09bnVsbD92b2lkIDA6ci5xdWVyeVNlbGVjdG9yKFwibXV4LXZpZGVvXCIpO2UmJihlLm1ldGFkYXRhPUx0KHRoaXMpKX1hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSxyLGkpe3N3aXRjaChmKHRoaXMsRCxqKS5jYWxsKHRoaXMpLHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLHIsaSksZSl7Y2FzZSBzLkhPVEtFWVM6bSh0aGlzLG5lKS52YWx1ZT1pO2JyZWFrO2Nhc2Ugcy5USFVNQk5BSUxfVElNRTp7aSE9bnVsbCYmdGhpcy50b2tlbnMudGh1bWJuYWlsJiZCKGQoXCJVc2Ugb2YgdGh1bWJuYWlsLXRpbWUgd2l0aCB0aHVtYm5haWwtdG9rZW4gaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLiBJZ25vcmUgdGh1bWJuYWlsLXRpbWUuXCIpLmZvcm1hdCh7fSkpO2JyZWFrfWNhc2Ugcy5USFVNQk5BSUxfVE9LRU46e2xldHthdWQ6bn09TihpKTtpJiZuIT09XCJ0XCImJkIoZChcIlRoZSBwcm92aWRlZCB0aHVtYm5haWwtdG9rZW4gc2hvdWxkIGhhdmUgYXVkaWVuY2UgdmFsdWUgJ3QnIGluc3RlYWQgb2YgJ3thdWR9Jy5cIikuZm9ybWF0KHthdWQ6bn0pKTticmVha31jYXNlIHMuU1RPUllCT0FSRF9UT0tFTjp7bGV0e2F1ZDpufT1OKGkpO2kmJm4hPT1cInNcIiYmQihkKFwiVGhlIHByb3ZpZGVkIHN0b3J5Ym9hcmQtdG9rZW4gc2hvdWxkIGhhdmUgYXVkaWVuY2UgdmFsdWUgJ3MnIGluc3RlYWQgb2YgJ3thdWR9Jy5cIikuZm9ybWF0KHthdWQ6bn0pKTticmVha31jYXNlIGwuUExBWUJBQ0tfSUQ6e2khPW51bGwmJmkuaW5jbHVkZXMoXCI/dG9rZW5cIikmJk8oZChcIlRoZSBzcGVjaWZpY2VkIHBsYXliYWNrIElEIHtwbGF5YmFja0lkfSBjb250YWlucyBhIHRva2VuIHdoaWNoIG11c3QgYmUgcHJvdmlkZWQgdmlhIHRoZSBwbGF5YmFjay10b2tlbiBhdHRyaWJ1dGUuXCIpLmZvcm1hdCh7cGxheWJhY2tJZDppfSkpO2JyZWFrfWNhc2UgbC5TVFJFQU1fVFlQRTppJiYhW0wuTElWRSxMLk9OX0RFTUFORCxMLlVOS05PV05dLmluY2x1ZGVzKGkpP1tcImxsLWxpdmVcIixcImxpdmU6ZHZyXCIsXCJsbC1saXZlOmR2clwiXS5pbmNsdWRlcyh0aGlzLnN0cmVhbVR5cGUpP3RoaXMudGFyZ2V0TGl2ZVdpbmRvdz1pLmluY2x1ZGVzKFwiZHZyXCIpP051bWJlci5QT1NJVElWRV9JTkZJTklUWTowOk5lKHtmaWxlOlwiaW52YWxpZC1zdHJlYW0tdHlwZS5tZFwiLG1lc3NhZ2U6ZChcIkludmFsaWQgc3RyZWFtLXR5cGUgdmFsdWUgc3VwcGxpZWQ6IGB7c3RyZWFtVHlwZX1gLiBQbGVhc2UgcHJvdmlkZSBzdHJlYW0tdHlwZSBhcyBlaXRoZXI6IGBvbi1kZW1hbmRgIG9yIGBsaXZlYFwiKS5mb3JtYXQoe3N0cmVhbVR5cGU6dGhpcy5zdHJlYW1UeXBlfSl9KTp0aGlzLnRhcmdldExpdmVXaW5kb3c9aT09PUwuTElWRT8wOk51bWJlci5OYU59W2wuUExBWUJBQ0tfSUQsTS5TUkMscy5QTEFZQkFDS19UT0tFTl0uaW5jbHVkZXMoZSkmJnIhPT1pJiZ4KHRoaXMsVSx7Li4ubSh0aGlzLFUpLC4uLlJ0fSksZih0aGlzLFYscSkuY2FsbCh0aGlzLHtbdXQoZSldOml9KX1nZXQgcHJlZmVyQ21jZCgpe3ZhciBlO3JldHVybihlPXRoaXMuZ2V0QXR0cmlidXRlKGwuUFJFRkVSX0NNQ0QpKSE9bnVsbD9lOnZvaWQgMH1zZXQgcHJlZmVyQ21jZChlKXtlIT09dGhpcy5wcmVmZXJDbWNkJiYoZT9PdC5pbmNsdWRlcyhlKT90aGlzLnNldEF0dHJpYnV0ZShsLlBSRUZFUl9DTUNELGUpOkIoYEludmFsaWQgdmFsdWUgZm9yIHByZWZlckNtY2QuIE11c3QgYmUgb25lIG9mICR7T3Quam9pbigpfWApOnRoaXMucmVtb3ZlQXR0cmlidXRlKGwuUFJFRkVSX0NNQ0QpKX1nZXQgaGFzUGxheWVkKCl7dmFyIGUscjtyZXR1cm4ocj0oZT10aGlzLm1lZGlhQ29udHJvbGxlcik9PW51bGw/dm9pZCAwOmUuaGFzQXR0cmlidXRlKFwibWVkaWEtaGFzLXBsYXllZFwiKSkhPW51bGw/cjohMX1nZXQgaW5MaXZlV2luZG93KCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5tZWRpYUNvbnRyb2xsZXIpPT1udWxsP3ZvaWQgMDplLmhhc0F0dHJpYnV0ZShcIm1lZGlhLXRpbWUtaXMtbGl2ZVwiKX1nZXQgX2hscygpe3ZhciBlO3JldHVybihlPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDplLl9obHN9Z2V0IG11eCgpe3ZhciBlO3JldHVybihlPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDplLm11eH1nZXQgdGhlbWUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShzLlRIRU1FKSkhPW51bGw/ZTpcIlwifXNldCB0aGVtZShlKXt0aGlzLnNldEF0dHJpYnV0ZShzLlRIRU1FLGAke2V9YCl9Z2V0IHRoZW1lUHJvcHMoKXtsZXQgZT10aGlzLm1lZGlhVGhlbWU7aWYoIWUpcmV0dXJuO2xldCByPXt9O2ZvcihsZXQgaSBvZiBlLmdldEF0dHJpYnV0ZU5hbWVzKCkpe2lmKCRlLmluY2x1ZGVzKGkpKWNvbnRpbnVlO2xldCBvPWUuZ2V0QXR0cmlidXRlKGkpO3JbdWUoaSldPW89PT1cIlwiPyEwOm99cmV0dXJuIHJ9c2V0IHRoZW1lUHJvcHMoZSl7dmFyIGksbztmKHRoaXMsRCxqKS5jYWxsKHRoaXMpO2xldCByPXsuLi50aGlzLnRoZW1lUHJvcHMsLi4uZX07Zm9yKGxldCBuIGluIHIpe2lmKCRlLmluY2x1ZGVzKG4pKWNvbnRpbnVlO2xldCB1PWU9PW51bGw/dm9pZCAwOmVbbl07dHlwZW9mIHU9PVwiYm9vbGVhblwifHx1PT1udWxsPyhpPXRoaXMubWVkaWFUaGVtZSk9PW51bGx8fGkudG9nZ2xlQXR0cmlidXRlKGRlKG4pLEJvb2xlYW4odSkpOihvPXRoaXMubWVkaWFUaGVtZSk9PW51bGx8fG8uc2V0QXR0cmlidXRlKGRlKG4pLHUpfX1nZXQgcGxheWJhY2tJZCgpe3ZhciBlO3JldHVybihlPXRoaXMuZ2V0QXR0cmlidXRlKGwuUExBWUJBQ0tfSUQpKSE9bnVsbD9lOnZvaWQgMH1zZXQgcGxheWJhY2tJZChlKXtlP3RoaXMuc2V0QXR0cmlidXRlKGwuUExBWUJBQ0tfSUQsZSk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUobC5QTEFZQkFDS19JRCl9Z2V0IHNyYygpe3ZhciBlLHI7cmV0dXJuIHRoaXMucGxheWJhY2tJZD8oZT1aKHRoaXMsTS5TUkMpKSE9bnVsbD9lOnZvaWQgMDoocj10aGlzLmdldEF0dHJpYnV0ZShNLlNSQykpIT1udWxsP3I6dm9pZCAwfXNldCBzcmMoZSl7ZT90aGlzLnNldEF0dHJpYnV0ZShNLlNSQyxlKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShNLlNSQyl9Z2V0IHBvc3Rlcigpe3ZhciByO2xldCBlPXRoaXMuZ2V0QXR0cmlidXRlKE0uUE9TVEVSKTtpZihlIT1udWxsKXJldHVybiBlO2lmKHRoaXMucGxheWJhY2tJZCYmIXRoaXMuYXVkaW8pcmV0dXJuIGx0KHRoaXMucGxheWJhY2tJZCx7ZG9tYWluOnRoaXMuY3VzdG9tRG9tYWluLHRodW1ibmFpbFRpbWU6KHI9dGhpcy50aHVtYm5haWxUaW1lKSE9bnVsbD9yOnRoaXMuc3RhcnRUaW1lLHRva2VuOnRoaXMudG9rZW5zLnRodW1ibmFpbH0pfXNldCBwb3N0ZXIoZSl7ZXx8ZT09PVwiXCI/dGhpcy5zZXRBdHRyaWJ1dGUoTS5QT1NURVIsZSk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoTS5QT1NURVIpfWdldCBzdG9yeWJvYXJkU3JjKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5nZXRBdHRyaWJ1dGUocy5TVE9SWUJPQVJEX1NSQykpIT1udWxsP2U6dm9pZCAwfXNldCBzdG9yeWJvYXJkU3JjKGUpe2U/dGhpcy5zZXRBdHRyaWJ1dGUocy5TVE9SWUJPQVJEX1NSQyxlKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShzLlNUT1JZQk9BUkRfU1JDKX1nZXQgc3Rvcnlib2FyZCgpe2lmKHRoaXMuc3Rvcnlib2FyZFNyYyYmIXRoaXMudG9rZW5zLnN0b3J5Ym9hcmQpcmV0dXJuIHRoaXMuc3Rvcnlib2FyZFNyYztpZighKHRoaXMuYXVkaW98fCF0aGlzLnBsYXliYWNrSWR8fCF0aGlzLnN0cmVhbVR5cGV8fFtMLkxJVkUsTC5VTktOT1dOXS5pbmNsdWRlcyh0aGlzLnN0cmVhbVR5cGUpKSlyZXR1cm4gZHQodGhpcy5wbGF5YmFja0lkLHtkb21haW46dGhpcy5jdXN0b21Eb21haW4sdG9rZW46dGhpcy50b2tlbnMuc3Rvcnlib2FyZH0pfWdldCBhdWRpbygpe3JldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShzLkFVRElPKX1zZXQgYXVkaW8oZSl7aWYoIWUpe3RoaXMucmVtb3ZlQXR0cmlidXRlKHMuQVVESU8pO3JldHVybn10aGlzLnNldEF0dHJpYnV0ZShzLkFVRElPLFwiXCIpfWdldCBob3RrZXlzKCl7cmV0dXJuIG0odGhpcyxuZSl9Z2V0IG5vaG90a2V5cygpe3JldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShzLk5PSE9US0VZUyl9c2V0IG5vaG90a2V5cyhlKXtpZighZSl7dGhpcy5yZW1vdmVBdHRyaWJ1dGUocy5OT0hPVEtFWVMpO3JldHVybn10aGlzLnNldEF0dHJpYnV0ZShzLk5PSE9US0VZUyxcIlwiKX1nZXQgdGh1bWJuYWlsVGltZSgpe3JldHVybiBSKHRoaXMuZ2V0QXR0cmlidXRlKHMuVEhVTUJOQUlMX1RJTUUpKX1zZXQgdGh1bWJuYWlsVGltZShlKXt0aGlzLnNldEF0dHJpYnV0ZShzLlRIVU1CTkFJTF9USU1FLGAke2V9YCl9Z2V0IHRpdGxlKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5nZXRBdHRyaWJ1dGUocy5USVRMRSkpIT1udWxsP2U6XCJcIn1zZXQgdGl0bGUoZSl7ZSE9PXRoaXMudGl0bGUmJihlP3RoaXMuc2V0QXR0cmlidXRlKHMuVElUTEUsZSk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJ0aXRsZVwiKSxzdXBlci50aXRsZT1lKX1nZXQgcGxhY2Vob2xkZXIoKXt2YXIgZTtyZXR1cm4oZT1aKHRoaXMscy5QTEFDRUhPTERFUikpIT1udWxsP2U6XCJcIn1zZXQgcGxhY2Vob2xkZXIoZSl7dGhpcy5zZXRBdHRyaWJ1dGUocy5QTEFDRUhPTERFUixgJHtlfWApfWdldCBwcmltYXJ5Q29sb3IoKXt2YXIgcixpO2xldCBlPXRoaXMuZ2V0QXR0cmlidXRlKHMuUFJJTUFSWV9DT0xPUik7aWYoZSE9bnVsbHx8dGhpcy5tZWRpYVRoZW1lJiYoZT0oaT0ocj1oLmdldENvbXB1dGVkU3R5bGUodGhpcy5tZWRpYVRoZW1lKSk9PW51bGw/dm9pZCAwOnIuZ2V0UHJvcGVydHlWYWx1ZShcIi0tX3ByaW1hcnktY29sb3JcIikpPT1udWxsP3ZvaWQgMDppLnRyaW0oKSxlKSlyZXR1cm4gZX1zZXQgcHJpbWFyeUNvbG9yKGUpe3RoaXMuc2V0QXR0cmlidXRlKHMuUFJJTUFSWV9DT0xPUixgJHtlfWApfWdldCBzZWNvbmRhcnlDb2xvcigpe3ZhciByLGk7bGV0IGU9dGhpcy5nZXRBdHRyaWJ1dGUocy5TRUNPTkRBUllfQ09MT1IpO2lmKGUhPW51bGx8fHRoaXMubWVkaWFUaGVtZSYmKGU9KGk9KHI9aC5nZXRDb21wdXRlZFN0eWxlKHRoaXMubWVkaWFUaGVtZSkpPT1udWxsP3ZvaWQgMDpyLmdldFByb3BlcnR5VmFsdWUoXCItLV9zZWNvbmRhcnktY29sb3JcIikpPT1udWxsP3ZvaWQgMDppLnRyaW0oKSxlKSlyZXR1cm4gZX1zZXQgc2Vjb25kYXJ5Q29sb3IoZSl7dGhpcy5zZXRBdHRyaWJ1dGUocy5TRUNPTkRBUllfQ09MT1IsYCR7ZX1gKX1nZXQgZGVmYXVsdFNob3dSZW1haW5pbmdUaW1lKCl7cmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKHMuREVGQVVMVF9TSE9XX1JFTUFJTklOR19USU1FKX1zZXQgZGVmYXVsdFNob3dSZW1haW5pbmdUaW1lKGUpe2U/dGhpcy5zZXRBdHRyaWJ1dGUocy5ERUZBVUxUX1NIT1dfUkVNQUlOSU5HX1RJTUUsXCJcIik6dGhpcy5yZW1vdmVBdHRyaWJ1dGUocy5ERUZBVUxUX1NIT1dfUkVNQUlOSU5HX1RJTUUpfWdldCBwbGF5YmFja1JhdGVzKCl7aWYoISF0aGlzLmhhc0F0dHJpYnV0ZShzLlBMQVlCQUNLX1JBVEVTKSlyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUocy5QTEFZQkFDS19SQVRFUykudHJpbSgpLnNwbGl0KC9cXHMqLD9cXHMrLykubWFwKGU9Pk51bWJlcihlKSkuZmlsdGVyKGU9PiFOdW1iZXIuaXNOYU4oZSkpLnNvcnQoKGUscik9PmUtcil9c2V0IHBsYXliYWNrUmF0ZXMoZSl7aWYoIWUpe3RoaXMucmVtb3ZlQXR0cmlidXRlKHMuUExBWUJBQ0tfUkFURVMpO3JldHVybn10aGlzLnNldEF0dHJpYnV0ZShzLlBMQVlCQUNLX1JBVEVTLGUuam9pbihcIiBcIikpfWdldCBmb3J3YXJkU2Vla09mZnNldCgpe3ZhciBlO3JldHVybihlPVIodGhpcy5nZXRBdHRyaWJ1dGUocy5GT1JXQVJEX1NFRUtfT0ZGU0VUKSkpIT1udWxsP2U6MTB9c2V0IGZvcndhcmRTZWVrT2Zmc2V0KGUpe3RoaXMuc2V0QXR0cmlidXRlKHMuRk9SV0FSRF9TRUVLX09GRlNFVCxgJHtlfWApfWdldCBiYWNrd2FyZFNlZWtPZmZzZXQoKXt2YXIgZTtyZXR1cm4oZT1SKHRoaXMuZ2V0QXR0cmlidXRlKHMuQkFDS1dBUkRfU0VFS19PRkZTRVQpKSkhPW51bGw/ZToxMH1zZXQgYmFja3dhcmRTZWVrT2Zmc2V0KGUpe3RoaXMuc2V0QXR0cmlidXRlKHMuQkFDS1dBUkRfU0VFS19PRkZTRVQsYCR7ZX1gKX1nZXQgZGVmYXVsdEhpZGRlbkNhcHRpb25zKCl7cmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKHMuREVGQVVMVF9ISURERU5fQ0FQVElPTlMpfXNldCBkZWZhdWx0SGlkZGVuQ2FwdGlvbnMoZSl7ZT90aGlzLnNldEF0dHJpYnV0ZShzLkRFRkFVTFRfSElEREVOX0NBUFRJT05TLFwiXCIpOnRoaXMucmVtb3ZlQXR0cmlidXRlKHMuREVGQVVMVF9ISURERU5fQ0FQVElPTlMpfWdldCBwbGF5ZXJTb2Z0d2FyZU5hbWUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShsLlBMQVlFUl9TT0ZUV0FSRV9OQU1FKSkhPW51bGw/ZTp5YX1nZXQgcGxheWVyU29mdHdhcmVWZXJzaW9uKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5nZXRBdHRyaWJ1dGUobC5QTEFZRVJfU09GVFdBUkVfVkVSU0lPTikpIT1udWxsP2U6ZmF9Z2V0IGJlYWNvbkNvbGxlY3Rpb25Eb21haW4oKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShsLkJFQUNPTl9DT0xMRUNUSU9OX0RPTUFJTikpIT1udWxsP2U6dm9pZCAwfXNldCBiZWFjb25Db2xsZWN0aW9uRG9tYWluKGUpe2UhPT10aGlzLmJlYWNvbkNvbGxlY3Rpb25Eb21haW4mJihlP3RoaXMuc2V0QXR0cmlidXRlKGwuQkVBQ09OX0NPTExFQ1RJT05fRE9NQUlOLGUpOnRoaXMucmVtb3ZlQXR0cmlidXRlKGwuQkVBQ09OX0NPTExFQ1RJT05fRE9NQUlOKSl9Z2V0IG1heFJlc29sdXRpb24oKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShsLk1BWF9SRVNPTFVUSU9OKSkhPW51bGw/ZTp2b2lkIDB9c2V0IG1heFJlc29sdXRpb24oZSl7ZSE9PXRoaXMubWF4UmVzb2x1dGlvbiYmKGU/dGhpcy5zZXRBdHRyaWJ1dGUobC5NQVhfUkVTT0xVVElPTixlKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShsLk1BWF9SRVNPTFVUSU9OKSl9Z2V0IGN1c3RvbURvbWFpbigpe3ZhciBlO3JldHVybihlPXRoaXMuZ2V0QXR0cmlidXRlKGwuQ1VTVE9NX0RPTUFJTikpIT1udWxsP2U6dm9pZCAwfXNldCBjdXN0b21Eb21haW4oZSl7ZSE9PXRoaXMuY3VzdG9tRG9tYWluJiYoZT90aGlzLnNldEF0dHJpYnV0ZShsLkNVU1RPTV9ET01BSU4sZSk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUobC5DVVNUT01fRE9NQUlOKSl9Z2V0IGVudktleSgpe3ZhciBlO3JldHVybihlPVoodGhpcyxsLkVOVl9LRVkpKSE9bnVsbD9lOnZvaWQgMH1zZXQgZW52S2V5KGUpe3RoaXMuc2V0QXR0cmlidXRlKGwuRU5WX0tFWSxgJHtlfWApfWdldCBub1ZvbHVtZVByZWYoKXtyZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUocy5OT19WT0xVTUVfUFJFRil9c2V0IG5vVm9sdW1lUHJlZihlKXtlP3RoaXMuc2V0QXR0cmlidXRlKHMuTk9fVk9MVU1FX1BSRUYsXCJcIik6dGhpcy5yZW1vdmVBdHRyaWJ1dGUocy5OT19WT0xVTUVfUFJFRil9Z2V0IGRlYnVnKCl7cmV0dXJuIFoodGhpcyxsLkRFQlVHKSE9bnVsbH1zZXQgZGVidWcoZSl7ZT90aGlzLnNldEF0dHJpYnV0ZShsLkRFQlVHLFwiXCIpOnRoaXMucmVtb3ZlQXR0cmlidXRlKGwuREVCVUcpfWdldCBkaXNhYmxlQ29va2llcygpe3JldHVybiBaKHRoaXMsbC5ESVNBQkxFX0NPT0tJRVMpIT1udWxsfXNldCBkaXNhYmxlQ29va2llcyhlKXtlP3RoaXMuc2V0QXR0cmlidXRlKGwuRElTQUJMRV9DT09LSUVTLFwiXCIpOnRoaXMucmVtb3ZlQXR0cmlidXRlKGwuRElTQUJMRV9DT09LSUVTKX1nZXQgc3RyZWFtVHlwZSgpe3ZhciBlLHIsaTtyZXR1cm4oaT0ocj10aGlzLmdldEF0dHJpYnV0ZShsLlNUUkVBTV9UWVBFKSkhPW51bGw/cjooZT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6ZS5zdHJlYW1UeXBlKSE9bnVsbD9pOkwuVU5LTk9XTn1zZXQgc3RyZWFtVHlwZShlKXt0aGlzLnNldEF0dHJpYnV0ZShsLlNUUkVBTV9UWVBFLGAke2V9YCl9Z2V0IGRlZmF1bHRTdHJlYW1UeXBlKCl7dmFyIGUscixpO3JldHVybihpPShyPXRoaXMuZ2V0QXR0cmlidXRlKHMuREVGQVVMVF9TVFJFQU1fVFlQRSkpIT1udWxsP3I6KGU9dGhpcy5tZWRpYUNvbnRyb2xsZXIpPT1udWxsP3ZvaWQgMDplLmdldEF0dHJpYnV0ZShzLkRFRkFVTFRfU1RSRUFNX1RZUEUpKSE9bnVsbD9pOkwuT05fREVNQU5EfXNldCBkZWZhdWx0U3RyZWFtVHlwZShlKXtlP3RoaXMuc2V0QXR0cmlidXRlKHMuREVGQVVMVF9TVFJFQU1fVFlQRSxlKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShzLkRFRkFVTFRfU1RSRUFNX1RZUEUpfWdldCB0YXJnZXRMaXZlV2luZG93KCl7dmFyIGUscjtyZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUocy5UQVJHRVRfTElWRV9XSU5ET1cpPyt0aGlzLmdldEF0dHJpYnV0ZShzLlRBUkdFVF9MSVZFX1dJTkRPVyk6KHI9KGU9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmUudGFyZ2V0TGl2ZVdpbmRvdykhPW51bGw/cjpOdW1iZXIuTmFOfXNldCB0YXJnZXRMaXZlV2luZG93KGUpe2UhPXRoaXMudGFyZ2V0TGl2ZVdpbmRvdyYmKGU9PW51bGw/dGhpcy5yZW1vdmVBdHRyaWJ1dGUocy5UQVJHRVRfTElWRV9XSU5ET1cpOnRoaXMuc2V0QXR0cmlidXRlKHMuVEFSR0VUX0xJVkVfV0lORE9XLGAkeytlfWApKX1nZXQgbGl2ZUVkZ2VTdGFydCgpe3ZhciBlO3JldHVybihlPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDplLmxpdmVFZGdlU3RhcnR9Z2V0IHN0YXJ0VGltZSgpe3JldHVybiBSKFoodGhpcyxsLlNUQVJUX1RJTUUpKX1zZXQgc3RhcnRUaW1lKGUpe3RoaXMuc2V0QXR0cmlidXRlKGwuU1RBUlRfVElNRSxgJHtlfWApfWdldCBwcmVmZXJQbGF5YmFjaygpe2xldCBlPXRoaXMuZ2V0QXR0cmlidXRlKGwuUFJFRkVSX1BMQVlCQUNLKTtpZihlPT09RWUuTVNFfHxlPT09RWUuTkFUSVZFKXJldHVybiBlfXNldCBwcmVmZXJQbGF5YmFjayhlKXtlIT09dGhpcy5wcmVmZXJQbGF5YmFjayYmKGU9PT1FZS5NU0V8fGU9PT1FZS5OQVRJVkU/dGhpcy5zZXRBdHRyaWJ1dGUobC5QUkVGRVJfUExBWUJBQ0ssZSk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUobC5QUkVGRVJfUExBWUJBQ0spKX1nZXQgbWV0YWRhdGEoKXt2YXIgZTtyZXR1cm4oZT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6ZS5tZXRhZGF0YX1zZXQgbWV0YWRhdGEoZSl7aWYoZih0aGlzLEQsaikuY2FsbCh0aGlzKSwhdGhpcy5tZWRpYSl7TyhcInVuZGVybHlpbmcgbWVkaWEgZWxlbWVudCBtaXNzaW5nIHdoZW4gdHJ5aW5nIHRvIHNldCBtZXRhZGF0YS4gbWV0YWRhdGEgd2lsbCBub3QgYmUgc2V0LlwiKTtyZXR1cm59dGhpcy5tZWRpYS5tZXRhZGF0YT17Li4uTHQodGhpcyksLi4uZX19YXN5bmMgYWRkQ3VlUG9pbnRzKGUpe3ZhciByO2lmKGYodGhpcyxELGopLmNhbGwodGhpcyksIXRoaXMubWVkaWEpe08oXCJ1bmRlcmx5aW5nIG1lZGlhIGVsZW1lbnQgbWlzc2luZyB3aGVuIHRyeWluZyB0byBhZGRDdWVQb2ludHMuIGN1ZVBvaW50cyB3aWxsIG5vdCBiZSBhZGRlZC5cIik7cmV0dXJufXJldHVybihyPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDpyLmFkZEN1ZVBvaW50cyhlKX1nZXQgYWN0aXZlQ3VlUG9pbnQoKXt2YXIgZTtyZXR1cm4oZT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6ZS5hY3RpdmVDdWVQb2ludH1nZXQgY3VlUG9pbnRzKCl7dmFyIGUscjtyZXR1cm4ocj0oZT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6ZS5jdWVQb2ludHMpIT1udWxsP3I6W119Z2V0U3RhcnREYXRlKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmUuZ2V0U3RhcnREYXRlKCl9Z2V0IGN1cnJlbnRQZHQoKXt2YXIgZTtyZXR1cm4oZT10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6ZS5jdXJyZW50UGR0fWdldCB0b2tlbnMoKXtsZXQgZT10aGlzLmdldEF0dHJpYnV0ZShzLlBMQVlCQUNLX1RPS0VOKSxyPXRoaXMuZ2V0QXR0cmlidXRlKHMuVEhVTUJOQUlMX1RPS0VOKSxpPXRoaXMuZ2V0QXR0cmlidXRlKHMuU1RPUllCT0FSRF9UT0tFTik7cmV0dXJuey4uLm0odGhpcyxvZSksLi4uZSE9bnVsbD97cGxheWJhY2s6ZX06e30sLi4uciE9bnVsbD97dGh1bWJuYWlsOnJ9Ont9LC4uLmkhPW51bGw/e3N0b3J5Ym9hcmQ6aX06e319fXNldCB0b2tlbnMoZSl7eCh0aGlzLG9lLGUhPW51bGw/ZTp7fSl9Z2V0IHBsYXliYWNrVG9rZW4oKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShzLlBMQVlCQUNLX1RPS0VOKSkhPW51bGw/ZTp2b2lkIDB9c2V0IHBsYXliYWNrVG9rZW4oZSl7dGhpcy5zZXRBdHRyaWJ1dGUocy5QTEFZQkFDS19UT0tFTixgJHtlfWApfWdldCB0aHVtYm5haWxUb2tlbigpe3ZhciBlO3JldHVybihlPXRoaXMuZ2V0QXR0cmlidXRlKHMuVEhVTUJOQUlMX1RPS0VOKSkhPW51bGw/ZTp2b2lkIDB9c2V0IHRodW1ibmFpbFRva2VuKGUpe3RoaXMuc2V0QXR0cmlidXRlKHMuVEhVTUJOQUlMX1RPS0VOLGAke2V9YCl9Z2V0IHN0b3J5Ym9hcmRUb2tlbigpe3ZhciBlO3JldHVybihlPXRoaXMuZ2V0QXR0cmlidXRlKHMuU1RPUllCT0FSRF9UT0tFTikpIT1udWxsP2U6dm9pZCAwfXNldCBzdG9yeWJvYXJkVG9rZW4oZSl7dGhpcy5zZXRBdHRyaWJ1dGUocy5TVE9SWUJPQVJEX1RPS0VOLGAke2V9YCl9YWRkVGV4dFRyYWNrKGUscixpLG8pe3ZhciB1O2xldCBuPSh1PXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDp1Lm5hdGl2ZUVsO2lmKCEhbilyZXR1cm4gZGEobixlLHIsaSxvKX1yZW1vdmVUZXh0VHJhY2soZSl7dmFyIGk7bGV0IHI9KGk9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmkubmF0aXZlRWw7aWYoISFyKXJldHVybiB1YShyLGUpfWdldCB0ZXh0VHJhY2tzKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmUudGV4dFRyYWNrc319O3JlPW5ldyBXZWFrTWFwLG9lPW5ldyBXZWFrTWFwLEM9bmV3IFdlYWtNYXAsbmU9bmV3IFdlYWtNYXAsVT1uZXcgV2Vha01hcCxEPW5ldyBXZWFrU2V0LGo9ZnVuY3Rpb24oKXt2YXIgZSxyLGk7aWYoIW0odGhpcyxyZSkpe3godGhpcyxyZSwhMCksZih0aGlzLFYscSkuY2FsbCh0aGlzKTt0cnl7aWYoY3VzdG9tRWxlbWVudHMudXBncmFkZSh0aGlzLm1lZGlhVGhlbWUpLCEodGhpcy5tZWRpYVRoZW1lIGluc3RhbmNlb2YgaC5IVE1MRWxlbWVudCkpdGhyb3dcIlwifWNhdGNoe08oXCI8bWVkaWEtdGhlbWU+IGZhaWxlZCB0byB1cGdyYWRlIVwiKX10cnl7aWYoY3VzdG9tRWxlbWVudHMudXBncmFkZSh0aGlzLm1lZGlhKSwhKHRoaXMubWVkaWEgaW5zdGFuY2VvZiBsYSkpdGhyb3dcIlwifWNhdGNoe08oXCI8bXV4LXZpZGVvPiBmYWlsZWQgdG8gdXBncmFkZSFcIil9dHJ5e2lmKGN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUodGhpcy5tZWRpYUNvbnRyb2xsZXIpLCEodGhpcy5tZWRpYUNvbnRyb2xsZXIgaW5zdGFuY2VvZiBzYSkpdGhyb3dcIlwifWNhdGNoe08oXCI8bWVkaWEtY29udHJvbGxlcj4gZmFpbGVkIHRvIHVwZ3JhZGUhXCIpfWJ0KHRoaXMpLGYodGhpcyxUZSxNdCkuY2FsbCh0aGlzKSxmKHRoaXMsQWUsQ3QpLmNhbGwodGhpcyksZih0aGlzLHhlLFB0KS5jYWxsKHRoaXMpLHgodGhpcyxDLChyPShlPXRoaXMubWVkaWFDb250cm9sbGVyKT09bnVsbD92b2lkIDA6ZS5oYXNBdHRyaWJ1dGUoXCJ1c2VyaW5hY3RpdmVcIikpIT1udWxsP3I6ITApLGYodGhpcyx3ZSxfdCkuY2FsbCh0aGlzKSwoaT10aGlzLm1lZGlhKT09bnVsbHx8aS5hZGRFdmVudExpc3RlbmVyKFwic3RyZWFtdHlwZWNoYW5nZVwiLCgpPT57Zih0aGlzLFYscSkuY2FsbCh0aGlzKX0pfX0sa2U9bmV3IFdlYWtTZXQsU3Q9ZnVuY3Rpb24oKXt2YXIgZSxyO3RyeXsoZT13aW5kb3c9PW51bGw/dm9pZCAwOndpbmRvdy5DU1MpPT1udWxsfHxlLnJlZ2lzdGVyUHJvcGVydHkoe25hbWU6XCItLW1lZGlhLXByaW1hcnktY29sb3JcIixzeW50YXg6XCI8Y29sb3I+XCIsaW5oZXJpdHM6ITB9KSwocj13aW5kb3c9PW51bGw/dm9pZCAwOndpbmRvdy5DU1MpPT1udWxsfHxyLnJlZ2lzdGVyUHJvcGVydHkoe25hbWU6XCItLW1lZGlhLXNlY29uZGFyeS1jb2xvclwiLHN5bnRheDpcIjxjb2xvcj5cIixpbmhlcml0czohMH0pfWNhdGNoe319LHNlPW5ldyBXZWFrU2V0LEtlPWZ1bmN0aW9uKGUpe09iamVjdC5hc3NpZ24obSh0aGlzLFUpLGUpLGYodGhpcyxWLHEpLmNhbGwodGhpcyl9LFY9bmV3IFdlYWtTZXQscT1mdW5jdGlvbihlPXt9KXt4dCh3dChtYSh0aGlzLHsuLi5tKHRoaXMsVSksLi4uZX0pKSx0aGlzLnNoYWRvd1Jvb3QpfSxUZT1uZXcgV2Vha1NldCxNdD1mdW5jdGlvbigpe2xldCBlPWk9Pnt2YXIgdSxiO2lmKCEoaSE9bnVsbCYmaS5zdGFydHNXaXRoKFwidGhlbWUtXCIpKSlyZXR1cm47bGV0IG89aS5yZXBsYWNlKC9edGhlbWUtLyxcIlwiKTtpZigkZS5pbmNsdWRlcyhvKSlyZXR1cm47bGV0IG49dGhpcy5nZXRBdHRyaWJ1dGUoaSk7biE9bnVsbD8odT10aGlzLm1lZGlhVGhlbWUpPT1udWxsfHx1LnNldEF0dHJpYnV0ZShvLG4pOihiPXRoaXMubWVkaWFUaGVtZSk9PW51bGx8fGIucmVtb3ZlQXR0cmlidXRlKG8pfTtuZXcgTXV0YXRpb25PYnNlcnZlcihpPT57Zm9yKGxldHthdHRyaWJ1dGVOYW1lOm99b2YgaSllKG8pfSkub2JzZXJ2ZSh0aGlzLHthdHRyaWJ1dGVzOiEwfSksdGhpcy5nZXRBdHRyaWJ1dGVOYW1lcygpLmZvckVhY2goZSl9LEFlPW5ldyBXZWFrU2V0LEN0PWZ1bmN0aW9uKCl7dmFyIHI7bGV0IGU9aT0+e2xldHtkZXRhaWw6b309aTtpZihvIGluc3RhbmNlb2YgdmV8fChvPW5ldyB2ZShvLm1lc3NhZ2Usby5jb2RlLG8uZmF0YWwpKSwhKG8hPW51bGwmJm8uZmF0YWwpKXtCKG8pLG8uZGF0YSYmQihgJHtvLm5hbWV9IGRhdGE6YCxvLmRhdGEpO3JldHVybn1sZXR7ZGlhbG9nOm4sZGV2bG9nOnV9PXllKG8sIXdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lLHRoaXMucGxheWJhY2tJZCx0aGlzLnBsYXliYWNrVG9rZW4pO3UubWVzc2FnZSYmTmUodSksTyhvKSxvLmRhdGEmJk8oYCR7by5uYW1lfSBkYXRhOmAsby5kYXRhKSxmKHRoaXMsc2UsS2UpLmNhbGwodGhpcyx7aXNEaWFsb2dPcGVuOiEwLGRpYWxvZzpufSl9O3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZSksdGhpcy5tZWRpYSYmKHRoaXMubWVkaWEuZXJyb3JUcmFuc2xhdG9yPShpPXt9KT0+e3ZhciBuLHUsYjtpZighKCgobj10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6bi5lcnJvcilpbnN0YW5jZW9mIHZlKSlyZXR1cm4gaTtsZXR7ZGV2bG9nOm99PXllKCh1PXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDp1LmVycm9yLCF3aW5kb3cubmF2aWdhdG9yLm9uTGluZSx0aGlzLnBsYXliYWNrSWQsdGhpcy5wbGF5YmFja1Rva2VuLCExKTtyZXR1cm57cGxheWVyX2Vycm9yX2NvZGU6KGI9dGhpcy5tZWRpYSk9PW51bGw/dm9pZCAwOmIuZXJyb3IuY29kZSxwbGF5ZXJfZXJyb3JfbWVzc2FnZTpvLm1lc3NhZ2U/U3RyaW5nKG8ubWVzc2FnZSk6aS5wbGF5ZXJfZXJyb3JfbWVzc2FnZSxwbGF5ZXJfZXJyb3JfY29udGV4dDpvLmNvbnRleHQ/U3RyaW5nKG8uY29udGV4dCk6aS5wbGF5ZXJfZXJyb3JfY29udGV4dH19KSwocj10aGlzLm1lZGlhKT09bnVsbHx8ci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixpPT57dmFyIG4sdTtsZXR7ZGV0YWlsOm99PWk7aWYoIW8pe2xldHttZXNzYWdlOmIsY29kZTp3fT0odT0obj10aGlzLm1lZGlhKT09bnVsbD92b2lkIDA6bi5lcnJvcikhPW51bGw/dTp7fTtvPW5ldyB2ZShiLHcpfSEobyE9bnVsbCYmby5mYXRhbCl8fHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiLHtkZXRhaWw6b30pKX0pfSx4ZT1uZXcgV2Vha1NldCxQdD1mdW5jdGlvbigpe3ZhciByLGksbyxuO2xldCBlPSgpPT5mKHRoaXMsVixxKS5jYWxsKHRoaXMpOyhpPShyPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDpyLnRleHRUcmFja3MpPT1udWxsfHxpLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGR0cmFja1wiLGUpLChuPShvPXRoaXMubWVkaWEpPT1udWxsP3ZvaWQgMDpvLnRleHRUcmFja3MpPT1udWxsfHxuLmFkZEV2ZW50TGlzdGVuZXIoXCJyZW1vdmV0cmFja1wiLGUpfSx3ZT1uZXcgV2Vha1NldCxfdD1mdW5jdGlvbigpe3ZhciBrLFA7bGV0IGU9Ly4qVmVyc2lvblxcLy4qU2FmYXJpXFwvLiovLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoIS9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSlyZXR1cm47bGV0IGksbz1uZXcgV2Vha01hcCxuPSgpPT50aGlzLnN0cmVhbVR5cGU9PT1MLkxJVkUmJiF0aGlzLnNlY29uZGFyeUNvbG9yJiZ0aGlzLm9mZnNldFdpZHRoPj04MDAsdT0oZyx2LEE9ITEpPT57aWYobigpKXJldHVybjtBcnJheS5mcm9tKGcmJmcuYWN0aXZlQ3Vlc3x8W10pLmZvckVhY2goYz0+e2lmKCEoIWMuc25hcFRvTGluZXN8fGMubGluZTwtNXx8Yy5saW5lPj0wJiZjLmxpbmU8MTApKWlmKCF2fHx0aGlzLnBhdXNlZCl7bGV0IGxlPWMudGV4dC5zcGxpdChgXG5gKS5sZW5ndGgsRz1lPy0yOi0zO3RoaXMuc3RyZWFtVHlwZT09PUwuTElWRSYmKEc9ZT8tMTotMik7bGV0IFk9Ry1sZTtpZihjLmxpbmU9PT1ZJiYhQSlyZXR1cm47by5oYXMoYyl8fG8uc2V0KGMsYy5saW5lKSxjLmxpbmU9WS0xLGMubGluZT1ZfWVsc2Ugc2V0VGltZW91dCgoKT0+e2MubGluZT1vLmdldChjKXx8XCJhdXRvXCJ9LDUwMCl9KX0sYj0oKT0+e3ZhciBnLHY7dShpLCh2PShnPXRoaXMubWVkaWFDb250cm9sbGVyKT09bnVsbD92b2lkIDA6Zy5oYXNBdHRyaWJ1dGUoXCJ1c2VyaW5hY3RpdmVcIikpIT1udWxsP3Y6ITEpfSx3PSgpPT57dmFyIEEsXztsZXQgdj1BcnJheS5mcm9tKCgoXz0oQT10aGlzLm1lZGlhQ29udHJvbGxlcik9PW51bGw/dm9pZCAwOkEubWVkaWEpPT1udWxsP3ZvaWQgMDpfLnRleHRUcmFja3MpfHxbXSkuZmlsdGVyKGM9PltcInN1YnRpdGxlc1wiLFwiY2FwdGlvbnNcIl0uaW5jbHVkZXMoYy5raW5kKSYmYy5tb2RlPT09XCJzaG93aW5nXCIpWzBdO3YhPT1pJiYoaT09bnVsbHx8aS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3VlY2hhbmdlXCIsYikpLGk9dixpPT1udWxsfHxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjdWVjaGFuZ2VcIixiKSx1KGksbSh0aGlzLEMpKX07aWYodygpLChrPXRoaXMudGV4dFRyYWNrcyk9PW51bGx8fGsuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHcpLChQPXRoaXMudGV4dFRyYWNrcyk9PW51bGx8fFAuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsdyksbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkNocm9tZS9cIikpe2xldCBnPSgpPT57dShpLG0odGhpcyxDKSwhMCksdGhpcy5wYXVzZWR8fHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZyl9O3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwoKT0+e2coKX0pfXRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInVzZXJpbmFjdGl2ZWNoYW5nZVwiLCgpPT57dmFyIHYsQTtsZXQgZz0oQT0odj10aGlzLm1lZGlhQ29udHJvbGxlcik9PW51bGw/dm9pZCAwOnYuaGFzQXR0cmlidXRlKFwidXNlcmluYWN0aXZlXCIpKSE9bnVsbD9BOiEwO20odGhpcyxDKSE9PWcmJih4KHRoaXMsQyxnKSx1KGksbSh0aGlzLEMpKSl9KX07ZnVuY3Rpb24gWih0LGEpe3JldHVybiB0Lm1lZGlhP3QubWVkaWEuZ2V0QXR0cmlidXRlKGEpOnQuZ2V0QXR0cmlidXRlKGEpfWguY3VzdG9tRWxlbWVudHMuZ2V0KFwibXV4LXBsYXllclwiKXx8KGguY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibXV4LXBsYXllclwiLGllKSxoLk11eFBsYXllckVsZW1lbnQ9aWUpO3ZhciBraT1pZTtleHBvcnR7dmUgYXMgTWVkaWFFcnJvcixraSBhcyBkZWZhdWx0LFogYXMgZ2V0VmlkZW9BdHRyaWJ1dGV9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@mux/mux-player/dist/index.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@mux/mux-video/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@mux/mux-video/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ a; },\n/* harmony export */   MediaError: function() { return /* reexport safe */ _mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.MediaError; },\n/* harmony export */   VideoEvents: function() { return /* binding */ Lt; },\n/* harmony export */   \"default\": function() { return /* binding */ ts; }\n/* harmony export */ });\n/* harmony import */ var _mux_playback_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mux/playback-core */ \"(app-client)/./node_modules/@mux/playback-core/dist/index.mjs\");\nvar re=Object.defineProperty;var ae=(o,s,t)=>s in o?re(o,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[s]=t;var x=(o,s,t)=>(ae(o,typeof s!=\"symbol\"?s+\"\":s,t),t),At=(o,s,t)=>{if(!s.has(o))throw TypeError(\"Cannot \"+t)};var i=(o,s,t)=>(At(o,s,\"read from private field\"),t?t.call(o):s.get(o)),n=(o,s,t)=>{if(s.has(o))throw TypeError(\"Cannot add the same private member more than once\");s instanceof WeakSet?s.add(o):s.set(o,t)},E=(o,s,t,u)=>(At(o,s,\"write to private field\"),u?u.call(o,t):s.set(o,t),t);var f=(o,s,t)=>(At(o,s,\"access private method\"),t);var W=class{addEventListener(){}removeEventListener(){}dispatchEvent(s){return!0}};if(typeof DocumentFragment==\"undefined\"){class o extends W{}globalThis.DocumentFragment=o}var z=class extends W{},Tt=class extends W{},ne={get(o){},define(o,s,t){},upgrade(o){},whenDefined(o){return Promise.resolve(z)}},J,vt=class{constructor(s,t={}){n(this,J,void 0);E(this,J,t==null?void 0:t.detail)}get detail(){return i(this,J)}initCustomEvent(){}};J=new WeakMap;function oe(o,s){return new z}var Wt={document:{createElement:oe},DocumentFragment,customElements:ne,CustomEvent:vt,EventTarget:W,HTMLElement:z,HTMLVideoElement:Tt},Vt=typeof window==\"undefined\"||typeof globalThis.customElements==\"undefined\",Q=Vt?Wt:globalThis,_e=Vt?Wt.document:globalThis.document;var ce=()=>{try{return\"0.15.6\"}catch{}return\"UNKNOWN\"},ue=ce(),Kt=()=>ue;var Ht=o=>{var s,t,u,l,M,jt,S,Et,T,D,L,ft,U,pt,ot,qt,ut,$t,Y,St,c,p,g,h,m,A,I,Z,lt,Xt,q,Pt,dt,zt,$,Ct,ht,Jt,X,Ot;return s=class extends o{constructor(){super();n(this,I);n(this,lt);n(this,q);n(this,dt);n(this,$);n(this,ht);n(this,X);x(this,\"castEnabled\",!1);n(this,c,{paused:!1});n(this,p,void 0);n(this,g,{});n(this,h,void 0);n(this,m,void 0);n(this,A,void 0);s.instances.add(this),f(this,$,Ct).call(this)}static get castElement(){return i(s,t)}static get castEnabled(){return i(s,u)}static get castState(){var e;return(e=i(s,T,D))==null?void 0:e.getCastState()}static async exitCast(){try{await i(s,T,D).endCurrentSession(!0)}catch(r){console.error(r);return}}get castPlayer(){if(s.castElement===this)return i(this,p)}attributeChangedCallback(e){if(!!this.castPlayer)switch(e){case\"cast-stream-type\":case\"cast-src\":this.load();break}}async requestCast(e={}){var r;f(r=s,Y,St).call(r,e),E(s,t,this),Object.entries(i(this,g)).forEach(([y,v])=>{i(this,p).controller.addEventListener(y,v)});try{await i(s,T,D).requestSession()}catch{E(s,t,void 0);return}i(this,c).paused=super.paused,super.pause(),this.muted=super.muted;try{await this.load()}catch(y){console.error(y)}}async load(){var R,G;if(!this.castPlayer)return super.load();let e=new chrome.cast.media.MediaInfo(this.castSrc,this.castContentType),r=[...this.querySelectorAll(\"track\")].filter(({kind:_,src:k})=>k&&(_===\"subtitles\"||_===\"captions\")),y=[],v=0;r.length&&(e.tracks=r.map(_=>{let k=++v;y.length===0&&_.track.mode===\"showing\"&&y.push(k);let F=new chrome.cast.media.Track(k,chrome.cast.media.TrackType.TEXT);return F.trackContentId=_.src,F.trackContentType=\"text/vtt\",F.subtype=_.kind===\"captions\"?chrome.cast.media.TextTrackType.CAPTIONS:chrome.cast.media.TextTrackType.SUBTITLES,F.name=_.label,F.language=_.srclang,F})),this.castStreamType===\"live\"?e.streamType=chrome.cast.media.StreamType.LIVE:e.streamType=chrome.cast.media.StreamType.BUFFERED,e.metadata=new chrome.cast.media.GenericMediaMetadata,e.metadata.title=this.title,e.metadata.images=[{url:this.poster}];let O=new chrome.cast.media.LoadRequest(e);O.currentTime=(R=super.currentTime)!=null?R:0,O.autoplay=!i(this,c).paused,O.activeTrackIds=y,await((G=i(s,L,ft))==null?void 0:G.loadMedia(O)),this.dispatchEvent(new Event(\"volumechange\"))}play(){var e;if(this.castPlayer){this.castPlayer.isPaused&&((e=this.castPlayer.controller)==null||e.playOrPause());return}return super.play()}pause(){var e;if(this.castPlayer){this.castPlayer.isPaused||(e=this.castPlayer.controller)==null||e.playOrPause();return}super.pause()}get castSrc(){var e,r,y;return(y=(r=this.getAttribute(\"cast-src\"))!=null?r:(e=this.querySelector(\"source\"))==null?void 0:e.src)!=null?y:this.currentSrc}set castSrc(e){this.castSrc!=e&&this.setAttribute(\"cast-src\",`${e}`)}get castContentType(){var e;return(e=this.getAttribute(\"cast-content-type\"))!=null?e:void 0}set castContentType(e){this.setAttribute(\"cast-content-type\",`${e}`)}get castStreamType(){var e,r;return(r=(e=this.getAttribute(\"cast-stream-type\"))!=null?e:this.streamType)!=null?r:void 0}set castStreamType(e){this.setAttribute(\"cast-stream-type\",`${e}`)}get readyState(){if(this.castPlayer)switch(this.castPlayer.playerState){case chrome.cast.media.PlayerState.IDLE:return 0;case chrome.cast.media.PlayerState.BUFFERING:return 2;default:return 3}return super.readyState}get paused(){return this.castPlayer?this.castPlayer.isPaused:super.paused}get muted(){var e;return this.castPlayer?(e=this.castPlayer)==null?void 0:e.isMuted:super.muted}set muted(e){var r;if(this.castPlayer){(e&&!this.castPlayer.isMuted||!e&&this.castPlayer.isMuted)&&((r=this.castPlayer.controller)==null||r.muteOrUnmute());return}super.muted=e}get volume(){var e,r;return this.castPlayer?(r=(e=this.castPlayer)==null?void 0:e.volumeLevel)!=null?r:1:super.volume}set volume(e){var r;if(this.castPlayer){this.castPlayer.volumeLevel=e,(r=this.castPlayer.controller)==null||r.setVolumeLevel();return}super.volume=e}get duration(){var e,r;return this.castPlayer&&i(this,I,Z)?(r=(e=this.castPlayer)==null?void 0:e.duration)!=null?r:NaN:super.duration}get currentTime(){var e,r;return this.castPlayer&&i(this,I,Z)?(r=(e=this.castPlayer)==null?void 0:e.currentTime)!=null?r:0:super.currentTime}set currentTime(e){var r;if(this.castPlayer){this.castPlayer.currentTime=e,(r=this.castPlayer.controller)==null||r.seek();return}super.currentTime=e}get onentercast(){return i(this,h)}set onentercast(e){i(this,h)&&(this.removeEventListener(\"entercast\",i(this,h)),E(this,h,null)),typeof e==\"function\"&&(E(this,h,e),this.addEventListener(\"entercast\",e))}get onleavecast(){return i(this,m)}set onleavecast(e){i(this,m)&&(this.removeEventListener(\"leavecast\",i(this,m)),E(this,m,null)),typeof e==\"function\"&&(E(this,m,e),this.addEventListener(\"leavecast\",e))}get oncastchange(){return i(this,A)}set oncastchange(e){i(this,A)&&(this.removeEventListener(\"castchange\",i(this,A)),E(this,A,null)),typeof e==\"function\"&&(E(this,A,e),this.addEventListener(\"castchange\",e))}},t=new WeakMap,u=new WeakMap,l=new WeakMap,M=new WeakSet,jt=function(){return typeof chrome!=\"undefined\"&&chrome.cast&&chrome.cast.isAvailable},S=new WeakSet,Et=function(){return typeof cast!=\"undefined\"&&cast.framework},T=new WeakSet,D=function(){if(i(s,S,Et))return cast.framework.CastContext.getInstance()},L=new WeakSet,ft=function(){var e;return(e=i(s,T,D))==null?void 0:e.getCurrentSession()},U=new WeakSet,pt=function(){var e;return(e=i(s,L,ft))==null?void 0:e.getSessionObj().media[0]},ot=new WeakSet,qt=function(e){return new Promise((r,y)=>{i(s,U,pt).editTracksInfo(e,r,y)})},ut=new WeakSet,$t=function(e){return new Promise((r,y)=>{i(s,U,pt).getStatus(e,r,y)})},Y=new WeakSet,St=function(e){return i(s,T,D).setOptions({receiverApplicationId:chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,autoJoinPolicy:chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,androidReceiverCompatible:!1,language:\"en-US\",resumeSavedSession:!0,...e})},c=new WeakMap,p=new WeakMap,g=new WeakMap,h=new WeakMap,m=new WeakMap,A=new WeakMap,I=new WeakSet,Z=function(){var e;return(e=this.castPlayer)==null?void 0:e.isMediaLoaded},lt=new WeakSet,Xt=function(){i(s,t)===this&&(Object.entries(i(this,g)).forEach(([e,r])=>{i(this,p).controller.removeEventListener(e,r)}),E(s,t,void 0),this.muted=i(this,p).isMuted,this.currentTime=i(this,p).savedPlayerState.currentTime,i(this,p).savedPlayerState.isPaused===!1&&this.play())},q=new WeakSet,Pt=function(){this.dispatchEvent(new CustomEvent(\"castchange\",{detail:i(s,T,D).getCastState()}))},dt=new WeakSet,zt=async function(){var r,y;let{SESSION_RESUMED:e}=cast.framework.SessionState;if(i(s,T,D).getSessionState()===e&&this.castSrc===((r=i(s,U,pt))==null?void 0:r.media.contentId)){E(s,t,this),Object.entries(i(this,g)).forEach(([v,O])=>{i(this,p).controller.addEventListener(v,O)});try{await f(y=s,ut,$t).call(y,new chrome.cast.media.GetStatusRequest)}catch(v){console.error(v)}i(this,g)[cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED](),i(this,g)[cast.framework.RemotePlayerEventType.PLAYER_STATE_CHANGED]()}},$=new WeakSet,Ct=function(){var e;!i(s,S,Et)||this.castEnabled||(this.castEnabled=!0,f(e=s,Y,St).call(e),this.textTracks.addEventListener(\"change\",f(this,X,Ot).bind(this)),f(this,q,Pt).call(this),E(this,p,new cast.framework.RemotePlayer),new cast.framework.RemotePlayerController(i(this,p)),E(this,g,{[cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED]:({value:r})=>{r===!1&&f(this,lt,Xt).call(this),this.dispatchEvent(new Event(r?\"entercast\":\"leavecast\"))},[cast.framework.RemotePlayerEventType.DURATION_CHANGED]:()=>{this.dispatchEvent(new Event(\"durationchange\"))},[cast.framework.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]:()=>{this.dispatchEvent(new Event(\"volumechange\"))},[cast.framework.RemotePlayerEventType.IS_MUTED_CHANGED]:()=>{this.dispatchEvent(new Event(\"volumechange\"))},[cast.framework.RemotePlayerEventType.CURRENT_TIME_CHANGED]:()=>{!i(this,I,Z)||this.dispatchEvent(new Event(\"timeupdate\"))},[cast.framework.RemotePlayerEventType.VIDEO_INFO_CHANGED]:()=>{this.dispatchEvent(new Event(\"resize\"))},[cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED]:()=>{this.dispatchEvent(new Event(this.paused?\"pause\":\"play\"))},[cast.framework.RemotePlayerEventType.PLAYER_STATE_CHANGED]:()=>{var r,y;((r=this.castPlayer)==null?void 0:r.playerState)!==chrome.cast.media.PlayerState.PAUSED&&this.dispatchEvent(new Event({[chrome.cast.media.PlayerState.PLAYING]:\"playing\",[chrome.cast.media.PlayerState.BUFFERING]:\"waiting\",[chrome.cast.media.PlayerState.IDLE]:\"emptied\"}[(y=this.castPlayer)==null?void 0:y.playerState]))},[cast.framework.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]:async()=>{!i(this,I,Z)||(await Promise.resolve(),f(this,ht,Jt).call(this))}}))},ht=new WeakSet,Jt=function(){f(this,X,Ot).call(this)},X=new WeakSet,Ot=async function(){var Dt,wt,Nt,xt,Gt,Ft;if(!this.castPlayer)return;let r=((wt=(Dt=i(this,p).mediaInfo)==null?void 0:Dt.tracks)!=null?wt:[]).filter(({type:b})=>b===chrome.cast.media.TrackType.TEXT),y=[...this.textTracks].filter(({kind:b})=>b===\"subtitles\"||b===\"captions\"),v=r.map(({language:b,name:mt,trackId:bt})=>{var Yt;let{mode:Ut}=(Yt=y.find(Bt=>Bt.language===b&&Bt.label===mt))!=null?Yt:{};return Ut?{mode:Ut,trackId:bt}:!1}).filter(Boolean),R=v.filter(({mode:b})=>b!==\"showing\").map(({trackId:b})=>b),G=v.find(({mode:b})=>b===\"showing\"),_=(Gt=(xt=(Nt=i(s,L,ft))==null?void 0:Nt.getSessionObj().media[0])==null?void 0:xt.activeTrackIds)!=null?Gt:[],k=_;if(_.length&&(k=k.filter(b=>!R.includes(b))),G!=null&&G.trackId&&(k=[...k,G.trackId]),k=[...new Set(k)],!((b,mt)=>b.length===mt.length&&b.every(bt=>mt.includes(bt)))(_,k))try{let b=new chrome.cast.media.EditTracksInfoRequest(k);await f(Ft=s,ot,qt).call(Ft,b)}catch(b){console.error(b)}},n(s,M),n(s,S),n(s,T),n(s,L),n(s,U),n(s,ot),n(s,ut),n(s,Y),x(s,\"observedAttributes\",[\"cast-src\",\"cast-content-type\",\"cast-stream-type\"]),x(s,\"instances\",new Set),n(s,t,void 0),n(s,u,!1),x(s,\"initCast\",()=>{var e;i(s,M,jt)?i(s,S,Et)?i(e=s,l).call(e,chrome.cast.isAvailable):customElements.whenDefined(\"google-cast-button\").then(()=>{var r;return i(r=s,l).call(r,chrome.cast.isAvailable)}):globalThis.__onGCastApiAvailable=()=>{customElements.whenDefined(\"google-cast-button\").then(()=>{var r;return i(r=s,l).call(r,chrome.cast.isAvailable)})}}),n(s,l,e=>{if(e){E(s,u,!0);let{CAST_STATE_CHANGED:r}=cast.framework.CastContextEventType;i(s,T,D).addEventListener(r,v=>{s.instances.forEach(O=>{var R;return f(R=O,q,Pt).call(R,v)})});let{SESSION_STATE_CHANGED:y}=cast.framework.CastContextEventType;i(s,T,D).addEventListener(y,v=>{s.instances.forEach(O=>{var R;return f(R=O,dt,zt).call(R,v)})}),s.instances.forEach(v=>{var O;return f(O=v,$,Ct).call(O)})}}),s},Mt=globalThis.HTMLVideoElement?Ht(HTMLVideoElement):Ht(Object);globalThis.customElements&&!globalThis.customElements.get(\"castable-video\")&&(customElements.define(\"castable-video\",Mt,{extends:\"video\"}),globalThis.CastableVideoElement=Mt);Mt.initCast();var Lt=[\"abort\",\"canplay\",\"canplaythrough\",\"durationchange\",\"emptied\",\"encrypted\",\"ended\",\"error\",\"loadeddata\",\"loadedmetadata\",\"loadstart\",\"pause\",\"play\",\"playing\",\"progress\",\"ratechange\",\"seeked\",\"seeking\",\"stalled\",\"suspend\",\"timeupdate\",\"volumechange\",\"waiting\",\"waitingforkey\",\"resize\",\"enterpictureinpicture\",\"leavepictureinpicture\",\"webkitbeginfullscreen\",\"webkitendfullscreen\",\"webkitpresentationmodechanged\"],Qt,It=(Qt=globalThis.document)==null?void 0:Qt.createElement(\"template\");It&&(It.innerHTML=`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      audio {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n      }\n    </style>\n    <slot></slot>\n  `);var Zt,kt=(Zt=globalThis.document)==null?void 0:Zt.createElement(\"template\");kt&&(kt.innerHTML=`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n        object-fit: var(--media-object-fit, contain);\n        object-position: var(--media-object-position, 50% 50%);\n      }\n\n      video::-webkit-media-text-track-container {\n        transform: var(--media-webkit-text-track-transform);\n        transition: var(--media-webkit-text-track-transition);\n      }\n    </style>\n    <slot></slot>\n  `);var yt=(o,{tag:s,is:t})=>{var M,P,S,C,te,j,L,N,V,nt,ee,ct,se;let u=(M=globalThis.document)==null?void 0:M.createElement(s,{is:t}),l=u?le(u):[];return P=class extends o{constructor(){super();n(this,N);n(this,nt);n(this,ct);n(this,j,void 0);n(this,L,void 0);this.shadowRoot||(this.attachShadow({mode:\"open\"}),this.shadowRoot.append(this.constructor.template.content.cloneNode(!0)))}static get observedAttributes(){var c,p,g;return f(c=P,C,te).call(c),[...(g=(p=u==null?void 0:u.constructor)==null?void 0:p.observedAttributes)!=null?g:[],\"autopictureinpicture\",\"disablepictureinpicture\",\"disableremoteplayback\",\"autoplay\",\"controls\",\"controlslist\",\"crossorigin\",\"loop\",\"muted\",\"playsinline\",\"poster\",\"preload\",\"src\"]}get nativeEl(){var d,c;return(c=(d=i(this,L))!=null?d:this.shadowRoot.querySelector(s))!=null?c:this.querySelector(s)}set nativeEl(d){E(this,L,d)}get defaultMuted(){return this.hasAttribute(\"muted\")}set defaultMuted(d){this.toggleAttribute(\"muted\",Boolean(d))}get src(){return this.getAttribute(\"src\")}set src(d){this.setAttribute(\"src\",`${d}`)}get preload(){var d,c;return(c=this.getAttribute(\"preload\"))!=null?c:(d=this.nativeEl)==null?void 0:d.preload}set preload(d){this.setAttribute(\"preload\",`${d}`)}attributeChangedCallback(d,c,p){f(this,N,V).call(this),f(this,ct,se).call(this,d,c,p)}connectedCallback(){f(this,N,V).call(this)}},S=new WeakMap,C=new WeakSet,te=function(){if(i(this,S))return;E(this,S,!0);let d=new Set(this.observedAttributes);d.delete(\"muted\");for(let c of l){if(c in this.prototype)continue;if(typeof u[c]==\"function\")this.prototype[c]=function(...g){return f(this,N,V).call(this),(()=>this.call?this.call(c,...g):this.nativeEl[c].apply(this.nativeEl,g))()};else{let g={get(){var m,A,I;f(this,N,V).call(this);let h=c.toLowerCase();if(d.has(h)){let B=this.getAttribute(h);return B===null?!1:B===\"\"?!0:B}return(I=(m=this.get)==null?void 0:m.call(this,c))!=null?I:(A=this.nativeEl)==null?void 0:A[c]}};c!==c.toUpperCase()&&(g.set=function(h){f(this,N,V).call(this);let m=c.toLowerCase();if(d.has(m)){h===!0||h===!1||h==null?this.toggleAttribute(m,Boolean(h)):this.setAttribute(m,h);return}if(this.set){this.set(c,h);return}this.nativeEl[c]=h}),Object.defineProperty(this.prototype,c,g)}}},j=new WeakMap,L=new WeakMap,N=new WeakSet,V=function(){var p,g;if(i(this,j))return;if(E(this,j,!0),!this.nativeEl){let h=document.createElement(s,{is:t});h.part=s,this.shadowRoot.append(h)}this.nativeEl.muted=this.hasAttribute(\"muted\");for(let h of l)f(this,nt,ee).call(this,h);let d=new Map,c=this.shadowRoot.querySelector(\"slot:not([name])\");c==null||c.addEventListener(\"slotchange\",()=>{let h=new Map(d);c.assignedElements().filter(m=>[\"track\",\"source\"].includes(m.localName)).forEach(m=>{var I,B;h.delete(m);let A=d.get(m);A||(A=m.cloneNode(),d.set(m,A)),(B=(I=this.nativeEl).append)==null||B.call(I,A)}),h.forEach(m=>m.remove())});for(let h of this.constructor.Events)(g=(p=this.shadowRoot).addEventListener)==null||g.call(p,h,m=>{m.target===this.nativeEl&&this.dispatchEvent(new CustomEvent(m.type,{detail:m.detail}))},!0)},nt=new WeakSet,ee=function(d){if(Object.prototype.hasOwnProperty.call(this,d)){let c=this[d];delete this[d],this[d]=c}},ct=new WeakSet,se=function(d,c,p){var g,h,m,A;[\"id\",\"class\"].includes(d)||(p===null?(h=(g=this.nativeEl).removeAttribute)==null||h.call(g,d):(A=(m=this.nativeEl).setAttribute)==null||A.call(m,d,p))},n(P,C),x(P,\"Events\",Lt),x(P,\"template\",s.endsWith(\"audio\")?It:kt),n(P,S,void 0),P};function le(o){let s=[];for(let t=Object.getPrototypeOf(o);t&&t!==HTMLElement.prototype;t=Object.getPrototypeOf(t))s.push(...Object.getOwnPropertyNames(t));return s}var Ge=globalThis.document?yt(HTMLElement,{tag:\"video\"}):class{},Fe=globalThis.document?yt(HTMLElement,{tag:\"audio\"}):class{};Lt.push(\"castchange\",\"entercast\",\"leavecast\");var _t=yt(Q.HTMLElement,{tag:\"video\",is:\"castable-video\"}),a={BEACON_COLLECTION_DOMAIN:\"beacon-collection-domain\",CUSTOM_DOMAIN:\"custom-domain\",DEBUG:\"debug\",DISABLE_COOKIES:\"disable-cookies\",ENV_KEY:\"env-key\",MAX_RESOLUTION:\"max-resolution\",METADATA_URL:\"metadata-url\",PLAYBACK_ID:\"playback-id\",PLAYER_SOFTWARE_NAME:\"player-software-name\",PLAYER_SOFTWARE_VERSION:\"player-software-version\",PREFER_CMCD:\"prefer-cmcd\",PREFER_PLAYBACK:\"prefer-playback\",START_TIME:\"start-time\",STREAM_TYPE:\"stream-type\",TARGET_LIVE_WINDOW:\"target-live-window\",LIVE_EDGE_OFFSET:\"live-edge-offset\",TYPE:\"type\"},Oe=Object.values(a),Me=Kt(),Ie=\"mux-video\",w,K,et,H,st,it,rt,at,Rt,tt=class extends _t{constructor(){super();n(this,at);n(this,w,void 0);n(this,K,void 0);n(this,et,void 0);n(this,H,{});n(this,st,void 0);n(this,it,void 0);n(this,rt,void 0);E(this,et,(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.generatePlayerInitTime)())}static get observedAttributes(){var t;return[...Oe,...(t=_t.observedAttributes)!=null?t:[]]}get preferCmcd(){var t;return(t=this.getAttribute(a.PREFER_CMCD))!=null?t:void 0}set preferCmcd(t){t!==this.preferCmcd&&(t?_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.CmcdTypeValues.includes(t)?this.setAttribute(a.PREFER_CMCD,t):console.warn(`Invalid value for preferCmcd. Must be one of ${_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.CmcdTypeValues.join()}`):this.removeAttribute(a.PREFER_CMCD))}get playerInitTime(){return i(this,et)}get playerSoftwareName(){var t;return(t=i(this,it))!=null?t:Ie}set playerSoftwareName(t){E(this,it,t)}get playerSoftwareVersion(){var t;return(t=i(this,st))!=null?t:Me}set playerSoftwareVersion(t){E(this,st,t)}get _hls(){var t;return(t=i(this,w))==null?void 0:t.engine}get mux(){return this.nativeEl.mux}get error(){var t;return(t=(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getError)(this.nativeEl))!=null?t:null}get errorTranslator(){return i(this,rt)}set errorTranslator(t){E(this,rt,t)}get src(){return this.getAttribute(\"src\")}set src(t){t!==this.src&&(t==null?this.removeAttribute(\"src\"):this.setAttribute(\"src\",t))}get type(){var t;return(t=this.getAttribute(a.TYPE))!=null?t:void 0}set type(t){t!==this.type&&(t?this.setAttribute(a.TYPE,t):this.removeAttribute(a.TYPE))}get autoplay(){let t=this.getAttribute(\"autoplay\");return t===null?!1:t===\"\"?!0:t}set autoplay(t){let u=this.autoplay;t!==u&&(t?this.setAttribute(\"autoplay\",typeof t==\"string\"?t:\"\"):this.removeAttribute(\"autoplay\"))}get preload(){let t=this.getAttribute(\"preload\");return t===\"\"?\"auto\":[\"none\",\"metadata\",\"auto\"].includes(t)?t:super.preload}set preload(t){t!=this.getAttribute(\"preload\")&&([\"\",\"none\",\"metadata\",\"auto\"].includes(t)?this.setAttribute(\"preload\",t):this.removeAttribute(\"preload\"))}get debug(){return this.getAttribute(a.DEBUG)!=null}set debug(t){t!==this.debug&&(t?this.setAttribute(a.DEBUG,\"\"):this.removeAttribute(a.DEBUG))}get disableCookies(){return this.hasAttribute(a.DISABLE_COOKIES)}set disableCookies(t){t!==this.disableCookies&&(t?this.setAttribute(a.DISABLE_COOKIES,\"\"):this.removeAttribute(a.DISABLE_COOKIES))}get startTime(){let t=this.getAttribute(a.START_TIME);if(t==null)return;let u=+t;return Number.isNaN(u)?void 0:u}set startTime(t){t!==this.startTime&&(t==null?this.removeAttribute(a.START_TIME):this.setAttribute(a.START_TIME,`${t}`))}get playbackId(){var t;return(t=this.getAttribute(a.PLAYBACK_ID))!=null?t:void 0}set playbackId(t){t!==this.playbackId&&(t?this.setAttribute(a.PLAYBACK_ID,t):this.removeAttribute(a.PLAYBACK_ID))}get maxResolution(){var t;return(t=this.getAttribute(a.MAX_RESOLUTION))!=null?t:void 0}set maxResolution(t){t!==this.maxResolution&&(t?this.setAttribute(a.MAX_RESOLUTION,t):this.removeAttribute(a.MAX_RESOLUTION))}get customDomain(){var t;return(t=this.getAttribute(a.CUSTOM_DOMAIN))!=null?t:void 0}set customDomain(t){t!==this.customDomain&&(t?this.setAttribute(a.CUSTOM_DOMAIN,t):this.removeAttribute(a.CUSTOM_DOMAIN))}get ended(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getEnded)(this.nativeEl,this._hls)}get envKey(){var t;return(t=this.getAttribute(a.ENV_KEY))!=null?t:void 0}set envKey(t){t!==this.envKey&&(t?this.setAttribute(a.ENV_KEY,t):this.removeAttribute(a.ENV_KEY))}get beaconCollectionDomain(){var t;return(t=this.getAttribute(a.BEACON_COLLECTION_DOMAIN))!=null?t:void 0}set beaconCollectionDomain(t){t!==this.beaconCollectionDomain&&(t?this.setAttribute(a.BEACON_COLLECTION_DOMAIN,t):this.removeAttribute(a.BEACON_COLLECTION_DOMAIN))}get streamType(){var t;return(t=this.getAttribute(a.STREAM_TYPE))!=null?t:(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getStreamType)(this.nativeEl)}set streamType(t){t!==this.streamType&&(t?this.setAttribute(a.STREAM_TYPE,t):this.removeAttribute(a.STREAM_TYPE))}get targetLiveWindow(){return this.hasAttribute(a.TARGET_LIVE_WINDOW)?+this.getAttribute(a.TARGET_LIVE_WINDOW):(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getTargetLiveWindow)(this.nativeEl)}set targetLiveWindow(t){t!=this.targetLiveWindow&&(t==null?this.removeAttribute(a.TARGET_LIVE_WINDOW):this.setAttribute(a.TARGET_LIVE_WINDOW,`${+t}`))}get liveEdgeStart(){var t,u;if(this.hasAttribute(a.LIVE_EDGE_OFFSET)){let{liveEdgeOffset:l}=this,M=(t=this.nativeEl.seekable.end(0))!=null?t:0,P=(u=this.nativeEl.seekable.start(0))!=null?u:0;return Math.max(P,M-l)}return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getLiveEdgeStart)(this.nativeEl)}get liveEdgeOffset(){if(!!this.hasAttribute(a.LIVE_EDGE_OFFSET))return+this.getAttribute(a.LIVE_EDGE_OFFSET)}set liveEdgeOffset(t){t!=this.targetLiveWindow&&(t==null?this.removeAttribute(a.LIVE_EDGE_OFFSET):this.setAttribute(a.LIVE_EDGE_OFFSET,`${+t}`))}get seekable(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getSeekable)(this.nativeEl)}async addCuePoints(t){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.addCuePoints)(this.nativeEl,t)}get activeCuePoint(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getActiveCuePoint)(this.nativeEl)}get cuePoints(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getCuePoints)(this.nativeEl)}getStartDate(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getStartDate)(this.nativeEl,this._hls)}get currentPdt(){return (0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentPdt)(this.nativeEl,this._hls)}get preferPlayback(){let t=this.getAttribute(a.PREFER_PLAYBACK);if(t===_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.PlaybackTypes.MSE||t===_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.PlaybackTypes.NATIVE)return t}set preferPlayback(t){t!==this.preferPlayback&&(t===_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.PlaybackTypes.MSE||t===_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.PlaybackTypes.NATIVE?this.setAttribute(a.PREFER_PLAYBACK,t):this.removeAttribute(a.PREFER_PLAYBACK))}get metadata(){return{...this.getAttributeNames().filter(u=>u.startsWith(\"metadata-\")&&![a.METADATA_URL].includes(u)).reduce((u,l)=>{let M=this.getAttribute(l);return M!=null&&(u[l.replace(/^metadata-/,\"\").replace(/-/g,\"_\")]=M),u},{}),...i(this,H)}}set metadata(t){E(this,H,t!=null?t:{}),this.mux&&this.mux.emit(\"hb\",i(this,H))}load(){E(this,w,(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.initialize)(this,this.nativeEl,i(this,w)))}unload(){(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.teardown)(this.nativeEl,i(this,w)),E(this,w,void 0)}attributeChangedCallback(t,u,l){var P,S;switch(_t.observedAttributes.includes(t)&&![\"src\",\"autoplay\",\"preload\"].includes(t)&&super.attributeChangedCallback(t,u,l),t){case a.PLAYER_SOFTWARE_NAME:this.playerSoftwareName=l!=null?l:void 0;break;case a.PLAYER_SOFTWARE_VERSION:this.playerSoftwareVersion=l!=null?l:void 0;break;case\"src\":{let C=!!u,T=!!l;!C&&T?f(this,at,Rt).call(this):C&&!T?this.unload():C&&T&&(this.unload(),f(this,at,Rt).call(this));break}case\"autoplay\":if(l===u)break;(P=i(this,w))==null||P.setAutoplay(this.autoplay);break;case\"preload\":if(l===u)break;(S=i(this,w))==null||S.setPreload(l);break;case a.PLAYBACK_ID:this.src=(0,_mux_playback_core__WEBPACK_IMPORTED_MODULE_0__.toMuxVideoURL)(l!=null?l:void 0,{maxResolution:this.maxResolution,domain:this.customDomain});break;case a.DEBUG:{let C=this.debug;this.mux&&console.info(\"Cannot toggle debug mode of mux data after initialization. Make sure you set all metadata to override before setting the src.\"),this._hls&&(this._hls.config.debug=C);break}case a.METADATA_URL:l&&fetch(l).then(C=>C.json()).then(C=>this.metadata=C).catch(()=>console.error(`Unable to load or parse metadata JSON from metadata-url ${l}!`));break;case a.STREAM_TYPE:(l==null||l!==u)&&this.dispatchEvent(new CustomEvent(\"streamtypechange\",{composed:!0,bubbles:!0}));break;case a.TARGET_LIVE_WINDOW:(l==null||l!==u)&&this.dispatchEvent(new CustomEvent(\"targetlivewindowchange\",{composed:!0,bubbles:!0,detail:this.targetLiveWindow}));break;default:break}}disconnectedCallback(){this.unload()}};w=new WeakMap,K=new WeakMap,et=new WeakMap,H=new WeakMap,st=new WeakMap,it=new WeakMap,rt=new WeakMap,at=new WeakSet,Rt=async function(){i(this,K)||(await E(this,K,Promise.resolve()),E(this,K,null),this.load())};Q.customElements.get(\"mux-video\")||(Q.customElements.define(\"mux-video\",tt),Q.MuxVideoElement=tt);var ts=tt;\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BtdXgvbXV4LXZpZGVvL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsNkJBQTZCLCtCQUErQixrREFBa0QsU0FBUyxrRUFBa0UsMkNBQTJDLG9GQUFvRixpRkFBaUYseUNBQXlDLDRFQUE0RSxtREFBbUQsWUFBWSxvQkFBb0IsdUJBQXVCLGlCQUFpQixXQUFXLHlDQUF5QyxtQkFBbUIsOEJBQThCLHVCQUF1QixxQkFBcUIsS0FBSyxRQUFRLGdCQUFnQixhQUFhLGdCQUFnQiwyQkFBMkIsWUFBWSxrQkFBa0IsRUFBRSxpQkFBaUIsa0NBQWtDLGFBQWEsaUJBQWlCLHFCQUFxQixjQUFjLGlCQUFpQixhQUFhLFFBQVEsVUFBVSxpQkFBaUIsbUdBQW1HLHVJQUE0Z0IsWUFBWSxJQUFJLGVBQWUsT0FBTyxnQkFBZ0IsbUJBQW1CLFdBQVcsc0dBQXNHLHlCQUF5QixjQUFjLFFBQVEsVUFBVSxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsVUFBVSx5QkFBeUIsVUFBVSxVQUFVLEVBQUUsaUJBQWlCLFdBQVcsRUFBRSxpQkFBaUIsaUJBQWlCLGlCQUFpQiw4Q0FBOEMseUJBQXlCLGNBQWMseUJBQXlCLGNBQWMsdUJBQXVCLE1BQU0saURBQWlELHdCQUF3QixJQUFJLHFDQUFxQyxTQUFTLGlCQUFpQixRQUFRLGlCQUFpQix5Q0FBeUMsNEJBQTRCLCtCQUErQixrREFBa0QsT0FBTyxzQkFBc0IsRUFBRSxNQUFNLDhFQUE4RSwyQ0FBMkMsRUFBRSxJQUFJLGdDQUFnQyxNQUFNLGNBQWMsT0FBTyxtRUFBbUUsSUFBSSxrQkFBa0IsU0FBUyxrQkFBa0IsYUFBYSxRQUFRLHdDQUF3Qyx3SEFBd0gsYUFBYSxrREFBa0QsOEJBQThCLFVBQVUsa0RBQWtELHNFQUFzRSxtTkFBbU4sd09BQXdPLGdCQUFnQixFQUFFLDJDQUEyQyw2TEFBNkwsT0FBTyxNQUFNLG9CQUFvQixrRkFBa0YsT0FBTyxvQkFBb0IsUUFBUSxNQUFNLG9CQUFvQixnRkFBZ0YsT0FBTyxjQUFjLGNBQWMsVUFBVSxnSUFBZ0ksZUFBZSxpREFBaUQsRUFBRSxHQUFHLHNCQUFzQixNQUFNLGdFQUFnRSx1QkFBdUIseUNBQXlDLEVBQUUsR0FBRyxxQkFBcUIsUUFBUSwyRkFBMkYsc0JBQXNCLHdDQUF3QyxFQUFFLEdBQUcsaUJBQWlCLHVEQUF1RCxpREFBaUQsc0RBQXNELGlCQUFpQix3QkFBd0IsYUFBYSw2REFBNkQsWUFBWSxNQUFNLDhFQUE4RSxhQUFhLE1BQU0sb0JBQW9CLHFIQUFxSCxPQUFPLGNBQWMsYUFBYSxRQUFRLGlHQUFpRyxjQUFjLE1BQU0sb0JBQW9CLHVGQUF1RixPQUFPLGVBQWUsZUFBZSxRQUFRLCtHQUErRyxrQkFBa0IsUUFBUSxtSEFBbUgsbUJBQW1CLE1BQU0sb0JBQW9CLDZFQUE2RSxPQUFPLG9CQUFvQixrQkFBa0IsaUJBQWlCLG1CQUFtQixxSkFBcUosa0JBQWtCLGlCQUFpQixtQkFBbUIscUpBQXFKLG1CQUFtQixpQkFBaUIsb0JBQW9CLHdKQUF3Six1RUFBdUUsd0VBQXdFLDZCQUE2QixnREFBZ0QsNEJBQTRCLDZEQUE2RCw2QkFBNkIsTUFBTSxzREFBc0QsNkJBQTZCLE1BQU0sNERBQTRELCtCQUErQiwyQkFBMkIsZ0NBQWdDLEVBQUUsK0JBQStCLDJCQUEyQiwyQkFBMkIsRUFBRSw4QkFBOEIsNEJBQTRCLHVNQUF1TSxFQUFFLGdIQUFnSCxNQUFNLHVEQUF1RCw4QkFBOEIsNERBQTRELDhDQUE4Qyw0SkFBNEosNkJBQTZCLGlEQUFpRCwrQkFBK0IsR0FBRyxvQ0FBb0MsUUFBUSxJQUFJLGtCQUFrQiw2QkFBNkIsa0dBQWtHLHdEQUF3RCwyQ0FBMkMsRUFBRSxJQUFJLGtFQUFrRSxTQUFTLGlCQUFpQiw0SUFBNEksNkJBQTZCLE1BQU0sMlFBQTJRLDhEQUE4RCxRQUFRLElBQUksMEZBQTBGLDhEQUE4RCxnREFBZ0Qsa0VBQWtFLDhDQUE4Qyw4REFBOEQsOENBQThDLGtFQUFrRSwwREFBMEQsZ0VBQWdFLHdDQUF3QywrREFBK0QsMERBQTBELGtFQUFrRSxRQUFRLHVIQUF1SCxxSkFBcUosbURBQW1ELDBFQUEwRSxrRUFBa0UsR0FBRyw4QkFBOEIsd0JBQXdCLG1DQUFtQyxzQkFBc0IsMkJBQTJCLGtGQUFrRixPQUFPLHlFQUF5RSxPQUFPLDhDQUE4Qyw4QkFBOEIsSUFBSSxPQUFPLElBQUksUUFBUSw2REFBNkQsV0FBVyxtQkFBbUIsSUFBSSwrQkFBK0IsT0FBTyx3QkFBd0IsVUFBVSxpQkFBaUIsT0FBTyxxSUFBcUksK0tBQStLLHFEQUFxRCwrQkFBK0IsU0FBUyxrQkFBa0IsOE1BQThNLE1BQU0sd0hBQXdILE1BQU0sZ0RBQWdELHdDQUF3QywyREFBMkQsTUFBTSxnREFBZ0QsR0FBRyxZQUFZLE1BQU0sVUFBVSxJQUFJLHFCQUFxQixxQ0FBcUMsZ0NBQWdDLHdCQUF3QixNQUFNLDZCQUE2QixFQUFFLEVBQUUsSUFBSSx3QkFBd0IscUNBQXFDLGdDQUFnQyx3QkFBd0IsTUFBTSw4QkFBOEIsRUFBRSwwQkFBMEIsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLGdFQUFnRSx5SEFBeUgsZ0JBQWdCLHNDQUFzQyxjQUFjLDJlQUEyZTtBQUM5M1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2RUFBNkU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssV0FBVyxXQUFXLElBQUksbUNBQW1DLDhEQUE4RCxLQUFLLGVBQWUseUJBQXlCLGNBQWMsUUFBUSxVQUFVLFdBQVcsV0FBVyxpQkFBaUIsaUJBQWlCLHFDQUFxQyxZQUFZLDJFQUEyRSxnQ0FBZ0MsVUFBVSxvU0FBb1MsZUFBZSxRQUFRLCtGQUErRixnQkFBZ0IsWUFBWSxtQkFBbUIsa0NBQWtDLG9CQUFvQix5Q0FBeUMsVUFBVSxnQ0FBZ0MsV0FBVywyQkFBMkIsRUFBRSxHQUFHLGNBQWMsUUFBUSx3RkFBd0YsZUFBZSwrQkFBK0IsRUFBRSxHQUFHLGdDQUFnQyxzREFBc0Qsb0JBQW9CLHdCQUF3QiwyQ0FBMkMsb0JBQW9CLGFBQWEsdUNBQXVDLGtCQUFrQixnQkFBZ0IsZ0NBQWdDLDREQUE0RCwyR0FBMkcsS0FBSyxPQUFPLE1BQU0sVUFBVSx1QkFBdUIsc0JBQXNCLGFBQWEsMkJBQTJCLCtCQUErQixpR0FBaUcsd0NBQXdDLHVCQUF1QixzQkFBc0IsYUFBYSxrRkFBa0YsT0FBTyxhQUFhLGNBQWMsT0FBTyxtQkFBbUIsOENBQThDLHdEQUF3RCxRQUFRLG9CQUFvQixnQ0FBZ0MsZ0NBQWdDLEtBQUssRUFBRSxtQ0FBbUMsK0NBQStDLDBDQUEwQyxrRUFBa0UsOENBQThDLGlCQUFpQixxRkFBcUYsUUFBUSxZQUFZLGVBQWUsZ0ZBQWdGLDJCQUEyQixFQUFFLG9HQUFvRyxxRUFBcUUsZ0JBQWdCLEdBQUcsS0FBSywrQkFBK0IsaURBQWlELGNBQWMsMEJBQTBCLG1DQUFtQyxZQUFZLHdKQUF3SixvRkFBb0YsZUFBZSxTQUFTLG1DQUFtQyw2QkFBNkIsb0VBQW9FLFNBQVMsMkNBQTJDLFlBQVksU0FBUyx3Q0FBd0MsWUFBWSxVQUFVLDhDQUE4Qyx5QkFBeUIsZ0NBQWdDLEtBQUssOGdCQUE4Z0Isd0ZBQXdGLGNBQWMsUUFBUSxXQUFXLGlCQUFpQixpQkFBaUIsa0JBQWtCLFdBQVcsRUFBRSxrQkFBa0Isa0JBQWtCLGtCQUFrQixVQUFVLDBFQUFFLElBQUksZ0NBQWdDLE1BQU0sc0RBQXNELGlCQUFpQixNQUFNLDBEQUEwRCxrQkFBa0Isd0JBQXdCLDhEQUFFLDZHQUE2Ryw4REFBRSxRQUFRLHdDQUF3QyxxQkFBcUIsa0JBQWtCLHlCQUF5QixNQUFNLGdDQUFnQywwQkFBMEIsYUFBYSw0QkFBNEIsTUFBTSxnQ0FBZ0MsNkJBQTZCLGFBQWEsV0FBVyxNQUFNLDBDQUEwQyxVQUFVLHlCQUF5QixZQUFZLE1BQU0sU0FBUyw0REFBRSw4QkFBOEIsc0JBQXNCLGtCQUFrQix1QkFBdUIsYUFBYSxVQUFVLGdDQUFnQyxXQUFXLCtFQUErRSxXQUFXLE1BQU0sbURBQW1ELFlBQVksNEVBQTRFLGVBQWUsb0NBQW9DLCtCQUErQixnQkFBZ0Isb0JBQW9CLGtHQUFrRyxjQUFjLG1DQUFtQyw0RUFBNEUsZUFBZSw0SUFBNEksWUFBWSx3Q0FBd0MsYUFBYSxnRkFBZ0YscUJBQXFCLDRDQUE0QyxzQkFBc0IsNkdBQTZHLGdCQUFnQixzQ0FBc0Msa0JBQWtCLFNBQVMsZ0NBQWdDLGlCQUFpQixrR0FBa0csRUFBRSxJQUFJLGlCQUFpQixNQUFNLDBEQUEwRCxrQkFBa0IsZ0dBQWdHLG9CQUFvQixNQUFNLDZEQUE2RCxxQkFBcUIseUdBQXlHLG1CQUFtQixNQUFNLDREQUE0RCxvQkFBb0Isc0dBQXNHLFlBQVksT0FBTyw0REFBRSwwQkFBMEIsYUFBYSxNQUFNLHNEQUFzRCxjQUFjLG9GQUFvRiw2QkFBNkIsTUFBTSx1RUFBdUUsOEJBQThCLHNJQUFzSSxpQkFBaUIsTUFBTSxtREFBbUQsaUVBQUUsZ0JBQWdCLGtCQUFrQixnR0FBZ0csdUJBQXVCLHdGQUF3Rix1RUFBRSxnQkFBZ0Isd0JBQXdCLHdIQUF3SCxHQUFHLElBQUksb0JBQW9CLFFBQVEsMENBQTBDLElBQUksaUJBQWlCLG9HQUFvRyx1QkFBdUIsT0FBTyxvRUFBRSxnQkFBZ0IscUJBQXFCLHdGQUF3RixzQkFBc0Isb0hBQW9ILEdBQUcsSUFBSSxlQUFlLE9BQU8sK0RBQUUsZ0JBQWdCLHNCQUFzQixPQUFPLGdFQUFFLGtCQUFrQixxQkFBcUIsT0FBTyxxRUFBRSxnQkFBZ0IsZ0JBQWdCLE9BQU8sZ0VBQUUsZ0JBQWdCLGVBQWUsT0FBTyxnRUFBRSwwQkFBMEIsaUJBQWlCLE9BQU8saUVBQUUsMEJBQTBCLHFCQUFxQiwyQ0FBMkMsT0FBTyw2REFBRSxVQUFVLDZEQUFFLGlCQUFpQixzQkFBc0IsOEJBQThCLDZEQUFFLFVBQVUsNkRBQUUsd0ZBQXdGLGVBQWUsT0FBTywrR0FBK0csMkJBQTJCLHNFQUFzRSxHQUFHLGdCQUFnQixnQkFBZ0IscUJBQXFCLDBDQUEwQyxPQUFPLFNBQVMsOERBQUUsZ0NBQWdDLFNBQVMsNERBQUUsMkNBQTJDLGdDQUFnQyxRQUFRLDhIQUE4SCxxRUFBcUUsTUFBTSwyRUFBMkUsTUFBTSxXQUFXLGdCQUFnQixrR0FBa0csTUFBTSw4QkFBOEIsa0RBQWtELE1BQU0sNkJBQTZCLHFDQUFxQyxNQUFNLDRCQUE0QixpRUFBRSxtQkFBbUIsMERBQTBELEVBQUUsTUFBTSxjQUFjLGlCQUFpQiw4TEFBOEwsTUFBTSw4SkFBOEosRUFBRSxLQUFLLE1BQU0sNEZBQTRGLHVCQUF1QixHQUFHLE1BQU0seUdBQXlHLG9EQUFvRCxHQUFHLE1BQU0sZUFBZSx1QkFBdUIsZ0JBQWdCLHlJQUF5SSwyRUFBMkUsa0dBQWtHLFVBQW1GO0FBQ3QvVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG11eC9tdXgtdmlkZW8vZGlzdC9pbmRleC5tanM/YjJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmU9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBhZT0obyxzLHQpPT5zIGluIG8/cmUobyxzLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6b1tzXT10O3ZhciB4PShvLHMsdCk9PihhZShvLHR5cGVvZiBzIT1cInN5bWJvbFwiP3MrXCJcIjpzLHQpLHQpLEF0PShvLHMsdCk9PntpZighcy5oYXMobykpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiK3QpfTt2YXIgaT0obyxzLHQpPT4oQXQobyxzLFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksdD90LmNhbGwobyk6cy5nZXQobykpLG49KG8scyx0KT0+e2lmKHMuaGFzKG8pKXRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7cyBpbnN0YW5jZW9mIFdlYWtTZXQ/cy5hZGQobyk6cy5zZXQobyx0KX0sRT0obyxzLHQsdSk9PihBdChvLHMsXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLHU/dS5jYWxsKG8sdCk6cy5zZXQobyx0KSx0KTt2YXIgZj0obyxzLHQpPT4oQXQobyxzLFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLHQpO3ZhciBXPWNsYXNze2FkZEV2ZW50TGlzdGVuZXIoKXt9cmVtb3ZlRXZlbnRMaXN0ZW5lcigpe31kaXNwYXRjaEV2ZW50KHMpe3JldHVybiEwfX07aWYodHlwZW9mIERvY3VtZW50RnJhZ21lbnQ9PVwidW5kZWZpbmVkXCIpe2NsYXNzIG8gZXh0ZW5kcyBXe31nbG9iYWxUaGlzLkRvY3VtZW50RnJhZ21lbnQ9b312YXIgej1jbGFzcyBleHRlbmRzIFd7fSxUdD1jbGFzcyBleHRlbmRzIFd7fSxuZT17Z2V0KG8pe30sZGVmaW5lKG8scyx0KXt9LHVwZ3JhZGUobyl7fSx3aGVuRGVmaW5lZChvKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHopfX0sSix2dD1jbGFzc3tjb25zdHJ1Y3RvcihzLHQ9e30pe24odGhpcyxKLHZvaWQgMCk7RSh0aGlzLEosdD09bnVsbD92b2lkIDA6dC5kZXRhaWwpfWdldCBkZXRhaWwoKXtyZXR1cm4gaSh0aGlzLEopfWluaXRDdXN0b21FdmVudCgpe319O0o9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gb2UobyxzKXtyZXR1cm4gbmV3IHp9dmFyIFd0PXtkb2N1bWVudDp7Y3JlYXRlRWxlbWVudDpvZX0sRG9jdW1lbnRGcmFnbWVudCxjdXN0b21FbGVtZW50czpuZSxDdXN0b21FdmVudDp2dCxFdmVudFRhcmdldDpXLEhUTUxFbGVtZW50OnosSFRNTFZpZGVvRWxlbWVudDpUdH0sVnQ9dHlwZW9mIHdpbmRvdz09XCJ1bmRlZmluZWRcInx8dHlwZW9mIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHM9PVwidW5kZWZpbmVkXCIsUT1WdD9XdDpnbG9iYWxUaGlzLF9lPVZ0P1d0LmRvY3VtZW50Omdsb2JhbFRoaXMuZG9jdW1lbnQ7aW1wb3J0e2luaXRpYWxpemUgYXMgZGUsdGVhcmRvd24gYXMgaGUsZ2VuZXJhdGVQbGF5ZXJJbml0VGltZSBhcyBtZSxQbGF5YmFja1R5cGVzIGFzIGd0LHRvTXV4VmlkZW9VUkwgYXMgRWUsTWVkaWFFcnJvciBhcyBYZSxnZXRFcnJvciBhcyBmZSxDbWNkVHlwZVZhbHVlcyBhcyBpZSxhZGRDdWVQb2ludHMgYXMgcGUsZ2V0Q3VlUG9pbnRzIGFzIHllLGdldEFjdGl2ZUN1ZVBvaW50IGFzIGdlLGdldFN0YXJ0RGF0ZSBhcyBiZSxnZXRDdXJyZW50UGR0IGFzIEFlLGdldFN0cmVhbVR5cGUgYXMgVGUsZ2V0VGFyZ2V0TGl2ZVdpbmRvdyBhcyB2ZSxnZXRMaXZlRWRnZVN0YXJ0IGFzIFNlLGdldFNlZWthYmxlIGFzIFBlLGdldEVuZGVkIGFzIENlfWZyb21cIkBtdXgvcGxheWJhY2stY29yZVwiO3ZhciBjZT0oKT0+e3RyeXtyZXR1cm5cIjAuMTUuNlwifWNhdGNoe31yZXR1cm5cIlVOS05PV05cIn0sdWU9Y2UoKSxLdD0oKT0+dWU7dmFyIEh0PW89Pnt2YXIgcyx0LHUsbCxNLGp0LFMsRXQsVCxELEwsZnQsVSxwdCxvdCxxdCx1dCwkdCxZLFN0LGMscCxnLGgsbSxBLEksWixsdCxYdCxxLFB0LGR0LHp0LCQsQ3QsaHQsSnQsWCxPdDtyZXR1cm4gcz1jbGFzcyBleHRlbmRzIG97Y29uc3RydWN0b3IoKXtzdXBlcigpO24odGhpcyxJKTtuKHRoaXMsbHQpO24odGhpcyxxKTtuKHRoaXMsZHQpO24odGhpcywkKTtuKHRoaXMsaHQpO24odGhpcyxYKTt4KHRoaXMsXCJjYXN0RW5hYmxlZFwiLCExKTtuKHRoaXMsYyx7cGF1c2VkOiExfSk7bih0aGlzLHAsdm9pZCAwKTtuKHRoaXMsZyx7fSk7bih0aGlzLGgsdm9pZCAwKTtuKHRoaXMsbSx2b2lkIDApO24odGhpcyxBLHZvaWQgMCk7cy5pbnN0YW5jZXMuYWRkKHRoaXMpLGYodGhpcywkLEN0KS5jYWxsKHRoaXMpfXN0YXRpYyBnZXQgY2FzdEVsZW1lbnQoKXtyZXR1cm4gaShzLHQpfXN0YXRpYyBnZXQgY2FzdEVuYWJsZWQoKXtyZXR1cm4gaShzLHUpfXN0YXRpYyBnZXQgY2FzdFN0YXRlKCl7dmFyIGU7cmV0dXJuKGU9aShzLFQsRCkpPT1udWxsP3ZvaWQgMDplLmdldENhc3RTdGF0ZSgpfXN0YXRpYyBhc3luYyBleGl0Q2FzdCgpe3RyeXthd2FpdCBpKHMsVCxEKS5lbmRDdXJyZW50U2Vzc2lvbighMCl9Y2F0Y2gocil7Y29uc29sZS5lcnJvcihyKTtyZXR1cm59fWdldCBjYXN0UGxheWVyKCl7aWYocy5jYXN0RWxlbWVudD09PXRoaXMpcmV0dXJuIGkodGhpcyxwKX1hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSl7aWYoISF0aGlzLmNhc3RQbGF5ZXIpc3dpdGNoKGUpe2Nhc2VcImNhc3Qtc3RyZWFtLXR5cGVcIjpjYXNlXCJjYXN0LXNyY1wiOnRoaXMubG9hZCgpO2JyZWFrfX1hc3luYyByZXF1ZXN0Q2FzdChlPXt9KXt2YXIgcjtmKHI9cyxZLFN0KS5jYWxsKHIsZSksRShzLHQsdGhpcyksT2JqZWN0LmVudHJpZXMoaSh0aGlzLGcpKS5mb3JFYWNoKChbeSx2XSk9PntpKHRoaXMscCkuY29udHJvbGxlci5hZGRFdmVudExpc3RlbmVyKHksdil9KTt0cnl7YXdhaXQgaShzLFQsRCkucmVxdWVzdFNlc3Npb24oKX1jYXRjaHtFKHMsdCx2b2lkIDApO3JldHVybn1pKHRoaXMsYykucGF1c2VkPXN1cGVyLnBhdXNlZCxzdXBlci5wYXVzZSgpLHRoaXMubXV0ZWQ9c3VwZXIubXV0ZWQ7dHJ5e2F3YWl0IHRoaXMubG9hZCgpfWNhdGNoKHkpe2NvbnNvbGUuZXJyb3IoeSl9fWFzeW5jIGxvYWQoKXt2YXIgUixHO2lmKCF0aGlzLmNhc3RQbGF5ZXIpcmV0dXJuIHN1cGVyLmxvYWQoKTtsZXQgZT1uZXcgY2hyb21lLmNhc3QubWVkaWEuTWVkaWFJbmZvKHRoaXMuY2FzdFNyYyx0aGlzLmNhc3RDb250ZW50VHlwZSkscj1bLi4udGhpcy5xdWVyeVNlbGVjdG9yQWxsKFwidHJhY2tcIildLmZpbHRlcigoe2tpbmQ6XyxzcmM6a30pPT5rJiYoXz09PVwic3VidGl0bGVzXCJ8fF89PT1cImNhcHRpb25zXCIpKSx5PVtdLHY9MDtyLmxlbmd0aCYmKGUudHJhY2tzPXIubWFwKF89PntsZXQgaz0rK3Y7eS5sZW5ndGg9PT0wJiZfLnRyYWNrLm1vZGU9PT1cInNob3dpbmdcIiYmeS5wdXNoKGspO2xldCBGPW5ldyBjaHJvbWUuY2FzdC5tZWRpYS5UcmFjayhrLGNocm9tZS5jYXN0Lm1lZGlhLlRyYWNrVHlwZS5URVhUKTtyZXR1cm4gRi50cmFja0NvbnRlbnRJZD1fLnNyYyxGLnRyYWNrQ29udGVudFR5cGU9XCJ0ZXh0L3Z0dFwiLEYuc3VidHlwZT1fLmtpbmQ9PT1cImNhcHRpb25zXCI/Y2hyb21lLmNhc3QubWVkaWEuVGV4dFRyYWNrVHlwZS5DQVBUSU9OUzpjaHJvbWUuY2FzdC5tZWRpYS5UZXh0VHJhY2tUeXBlLlNVQlRJVExFUyxGLm5hbWU9Xy5sYWJlbCxGLmxhbmd1YWdlPV8uc3JjbGFuZyxGfSkpLHRoaXMuY2FzdFN0cmVhbVR5cGU9PT1cImxpdmVcIj9lLnN0cmVhbVR5cGU9Y2hyb21lLmNhc3QubWVkaWEuU3RyZWFtVHlwZS5MSVZFOmUuc3RyZWFtVHlwZT1jaHJvbWUuY2FzdC5tZWRpYS5TdHJlYW1UeXBlLkJVRkZFUkVELGUubWV0YWRhdGE9bmV3IGNocm9tZS5jYXN0Lm1lZGlhLkdlbmVyaWNNZWRpYU1ldGFkYXRhLGUubWV0YWRhdGEudGl0bGU9dGhpcy50aXRsZSxlLm1ldGFkYXRhLmltYWdlcz1be3VybDp0aGlzLnBvc3Rlcn1dO2xldCBPPW5ldyBjaHJvbWUuY2FzdC5tZWRpYS5Mb2FkUmVxdWVzdChlKTtPLmN1cnJlbnRUaW1lPShSPXN1cGVyLmN1cnJlbnRUaW1lKSE9bnVsbD9SOjAsTy5hdXRvcGxheT0haSh0aGlzLGMpLnBhdXNlZCxPLmFjdGl2ZVRyYWNrSWRzPXksYXdhaXQoKEc9aShzLEwsZnQpKT09bnVsbD92b2lkIDA6Ry5sb2FkTWVkaWEoTykpLHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJ2b2x1bWVjaGFuZ2VcIikpfXBsYXkoKXt2YXIgZTtpZih0aGlzLmNhc3RQbGF5ZXIpe3RoaXMuY2FzdFBsYXllci5pc1BhdXNlZCYmKChlPXRoaXMuY2FzdFBsYXllci5jb250cm9sbGVyKT09bnVsbHx8ZS5wbGF5T3JQYXVzZSgpKTtyZXR1cm59cmV0dXJuIHN1cGVyLnBsYXkoKX1wYXVzZSgpe3ZhciBlO2lmKHRoaXMuY2FzdFBsYXllcil7dGhpcy5jYXN0UGxheWVyLmlzUGF1c2VkfHwoZT10aGlzLmNhc3RQbGF5ZXIuY29udHJvbGxlcik9PW51bGx8fGUucGxheU9yUGF1c2UoKTtyZXR1cm59c3VwZXIucGF1c2UoKX1nZXQgY2FzdFNyYygpe3ZhciBlLHIseTtyZXR1cm4oeT0ocj10aGlzLmdldEF0dHJpYnV0ZShcImNhc3Qtc3JjXCIpKSE9bnVsbD9yOihlPXRoaXMucXVlcnlTZWxlY3RvcihcInNvdXJjZVwiKSk9PW51bGw/dm9pZCAwOmUuc3JjKSE9bnVsbD95OnRoaXMuY3VycmVudFNyY31zZXQgY2FzdFNyYyhlKXt0aGlzLmNhc3RTcmMhPWUmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2FzdC1zcmNcIixgJHtlfWApfWdldCBjYXN0Q29udGVudFR5cGUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLmdldEF0dHJpYnV0ZShcImNhc3QtY29udGVudC10eXBlXCIpKSE9bnVsbD9lOnZvaWQgMH1zZXQgY2FzdENvbnRlbnRUeXBlKGUpe3RoaXMuc2V0QXR0cmlidXRlKFwiY2FzdC1jb250ZW50LXR5cGVcIixgJHtlfWApfWdldCBjYXN0U3RyZWFtVHlwZSgpe3ZhciBlLHI7cmV0dXJuKHI9KGU9dGhpcy5nZXRBdHRyaWJ1dGUoXCJjYXN0LXN0cmVhbS10eXBlXCIpKSE9bnVsbD9lOnRoaXMuc3RyZWFtVHlwZSkhPW51bGw/cjp2b2lkIDB9c2V0IGNhc3RTdHJlYW1UeXBlKGUpe3RoaXMuc2V0QXR0cmlidXRlKFwiY2FzdC1zdHJlYW0tdHlwZVwiLGAke2V9YCl9Z2V0IHJlYWR5U3RhdGUoKXtpZih0aGlzLmNhc3RQbGF5ZXIpc3dpdGNoKHRoaXMuY2FzdFBsYXllci5wbGF5ZXJTdGF0ZSl7Y2FzZSBjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5JRExFOnJldHVybiAwO2Nhc2UgY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuQlVGRkVSSU5HOnJldHVybiAyO2RlZmF1bHQ6cmV0dXJuIDN9cmV0dXJuIHN1cGVyLnJlYWR5U3RhdGV9Z2V0IHBhdXNlZCgpe3JldHVybiB0aGlzLmNhc3RQbGF5ZXI/dGhpcy5jYXN0UGxheWVyLmlzUGF1c2VkOnN1cGVyLnBhdXNlZH1nZXQgbXV0ZWQoKXt2YXIgZTtyZXR1cm4gdGhpcy5jYXN0UGxheWVyPyhlPXRoaXMuY2FzdFBsYXllcik9PW51bGw/dm9pZCAwOmUuaXNNdXRlZDpzdXBlci5tdXRlZH1zZXQgbXV0ZWQoZSl7dmFyIHI7aWYodGhpcy5jYXN0UGxheWVyKXsoZSYmIXRoaXMuY2FzdFBsYXllci5pc011dGVkfHwhZSYmdGhpcy5jYXN0UGxheWVyLmlzTXV0ZWQpJiYoKHI9dGhpcy5jYXN0UGxheWVyLmNvbnRyb2xsZXIpPT1udWxsfHxyLm11dGVPclVubXV0ZSgpKTtyZXR1cm59c3VwZXIubXV0ZWQ9ZX1nZXQgdm9sdW1lKCl7dmFyIGUscjtyZXR1cm4gdGhpcy5jYXN0UGxheWVyPyhyPShlPXRoaXMuY2FzdFBsYXllcik9PW51bGw/dm9pZCAwOmUudm9sdW1lTGV2ZWwpIT1udWxsP3I6MTpzdXBlci52b2x1bWV9c2V0IHZvbHVtZShlKXt2YXIgcjtpZih0aGlzLmNhc3RQbGF5ZXIpe3RoaXMuY2FzdFBsYXllci52b2x1bWVMZXZlbD1lLChyPXRoaXMuY2FzdFBsYXllci5jb250cm9sbGVyKT09bnVsbHx8ci5zZXRWb2x1bWVMZXZlbCgpO3JldHVybn1zdXBlci52b2x1bWU9ZX1nZXQgZHVyYXRpb24oKXt2YXIgZSxyO3JldHVybiB0aGlzLmNhc3RQbGF5ZXImJmkodGhpcyxJLFopPyhyPShlPXRoaXMuY2FzdFBsYXllcik9PW51bGw/dm9pZCAwOmUuZHVyYXRpb24pIT1udWxsP3I6TmFOOnN1cGVyLmR1cmF0aW9ufWdldCBjdXJyZW50VGltZSgpe3ZhciBlLHI7cmV0dXJuIHRoaXMuY2FzdFBsYXllciYmaSh0aGlzLEksWik/KHI9KGU9dGhpcy5jYXN0UGxheWVyKT09bnVsbD92b2lkIDA6ZS5jdXJyZW50VGltZSkhPW51bGw/cjowOnN1cGVyLmN1cnJlbnRUaW1lfXNldCBjdXJyZW50VGltZShlKXt2YXIgcjtpZih0aGlzLmNhc3RQbGF5ZXIpe3RoaXMuY2FzdFBsYXllci5jdXJyZW50VGltZT1lLChyPXRoaXMuY2FzdFBsYXllci5jb250cm9sbGVyKT09bnVsbHx8ci5zZWVrKCk7cmV0dXJufXN1cGVyLmN1cnJlbnRUaW1lPWV9Z2V0IG9uZW50ZXJjYXN0KCl7cmV0dXJuIGkodGhpcyxoKX1zZXQgb25lbnRlcmNhc3QoZSl7aSh0aGlzLGgpJiYodGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW50ZXJjYXN0XCIsaSh0aGlzLGgpKSxFKHRoaXMsaCxudWxsKSksdHlwZW9mIGU9PVwiZnVuY3Rpb25cIiYmKEUodGhpcyxoLGUpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImVudGVyY2FzdFwiLGUpKX1nZXQgb25sZWF2ZWNhc3QoKXtyZXR1cm4gaSh0aGlzLG0pfXNldCBvbmxlYXZlY2FzdChlKXtpKHRoaXMsbSkmJih0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsZWF2ZWNhc3RcIixpKHRoaXMsbSkpLEUodGhpcyxtLG51bGwpKSx0eXBlb2YgZT09XCJmdW5jdGlvblwiJiYoRSh0aGlzLG0sZSksdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibGVhdmVjYXN0XCIsZSkpfWdldCBvbmNhc3RjaGFuZ2UoKXtyZXR1cm4gaSh0aGlzLEEpfXNldCBvbmNhc3RjaGFuZ2UoZSl7aSh0aGlzLEEpJiYodGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FzdGNoYW5nZVwiLGkodGhpcyxBKSksRSh0aGlzLEEsbnVsbCkpLHR5cGVvZiBlPT1cImZ1bmN0aW9uXCImJihFKHRoaXMsQSxlKSx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjYXN0Y2hhbmdlXCIsZSkpfX0sdD1uZXcgV2Vha01hcCx1PW5ldyBXZWFrTWFwLGw9bmV3IFdlYWtNYXAsTT1uZXcgV2Vha1NldCxqdD1mdW5jdGlvbigpe3JldHVybiB0eXBlb2YgY2hyb21lIT1cInVuZGVmaW5lZFwiJiZjaHJvbWUuY2FzdCYmY2hyb21lLmNhc3QuaXNBdmFpbGFibGV9LFM9bmV3IFdlYWtTZXQsRXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdHlwZW9mIGNhc3QhPVwidW5kZWZpbmVkXCImJmNhc3QuZnJhbWV3b3JrfSxUPW5ldyBXZWFrU2V0LEQ9ZnVuY3Rpb24oKXtpZihpKHMsUyxFdCkpcmV0dXJuIGNhc3QuZnJhbWV3b3JrLkNhc3RDb250ZXh0LmdldEluc3RhbmNlKCl9LEw9bmV3IFdlYWtTZXQsZnQ9ZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4oZT1pKHMsVCxEKSk9PW51bGw/dm9pZCAwOmUuZ2V0Q3VycmVudFNlc3Npb24oKX0sVT1uZXcgV2Vha1NldCxwdD1mdW5jdGlvbigpe3ZhciBlO3JldHVybihlPWkocyxMLGZ0KSk9PW51bGw/dm9pZCAwOmUuZ2V0U2Vzc2lvbk9iaigpLm1lZGlhWzBdfSxvdD1uZXcgV2Vha1NldCxxdD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKHIseSk9PntpKHMsVSxwdCkuZWRpdFRyYWNrc0luZm8oZSxyLHkpfSl9LHV0PW5ldyBXZWFrU2V0LCR0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgocix5KT0+e2kocyxVLHB0KS5nZXRTdGF0dXMoZSxyLHkpfSl9LFk9bmV3IFdlYWtTZXQsU3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGkocyxULEQpLnNldE9wdGlvbnMoe3JlY2VpdmVyQXBwbGljYXRpb25JZDpjaHJvbWUuY2FzdC5tZWRpYS5ERUZBVUxUX01FRElBX1JFQ0VJVkVSX0FQUF9JRCxhdXRvSm9pblBvbGljeTpjaHJvbWUuY2FzdC5BdXRvSm9pblBvbGljeS5PUklHSU5fU0NPUEVELGFuZHJvaWRSZWNlaXZlckNvbXBhdGlibGU6ITEsbGFuZ3VhZ2U6XCJlbi1VU1wiLHJlc3VtZVNhdmVkU2Vzc2lvbjohMCwuLi5lfSl9LGM9bmV3IFdlYWtNYXAscD1uZXcgV2Vha01hcCxnPW5ldyBXZWFrTWFwLGg9bmV3IFdlYWtNYXAsbT1uZXcgV2Vha01hcCxBPW5ldyBXZWFrTWFwLEk9bmV3IFdlYWtTZXQsWj1mdW5jdGlvbigpe3ZhciBlO3JldHVybihlPXRoaXMuY2FzdFBsYXllcik9PW51bGw/dm9pZCAwOmUuaXNNZWRpYUxvYWRlZH0sbHQ9bmV3IFdlYWtTZXQsWHQ9ZnVuY3Rpb24oKXtpKHMsdCk9PT10aGlzJiYoT2JqZWN0LmVudHJpZXMoaSh0aGlzLGcpKS5mb3JFYWNoKChbZSxyXSk9PntpKHRoaXMscCkuY29udHJvbGxlci5yZW1vdmVFdmVudExpc3RlbmVyKGUscil9KSxFKHMsdCx2b2lkIDApLHRoaXMubXV0ZWQ9aSh0aGlzLHApLmlzTXV0ZWQsdGhpcy5jdXJyZW50VGltZT1pKHRoaXMscCkuc2F2ZWRQbGF5ZXJTdGF0ZS5jdXJyZW50VGltZSxpKHRoaXMscCkuc2F2ZWRQbGF5ZXJTdGF0ZS5pc1BhdXNlZD09PSExJiZ0aGlzLnBsYXkoKSl9LHE9bmV3IFdlYWtTZXQsUHQ9ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2FzdGNoYW5nZVwiLHtkZXRhaWw6aShzLFQsRCkuZ2V0Q2FzdFN0YXRlKCl9KSl9LGR0PW5ldyBXZWFrU2V0LHp0PWFzeW5jIGZ1bmN0aW9uKCl7dmFyIHIseTtsZXR7U0VTU0lPTl9SRVNVTUVEOmV9PWNhc3QuZnJhbWV3b3JrLlNlc3Npb25TdGF0ZTtpZihpKHMsVCxEKS5nZXRTZXNzaW9uU3RhdGUoKT09PWUmJnRoaXMuY2FzdFNyYz09PSgocj1pKHMsVSxwdCkpPT1udWxsP3ZvaWQgMDpyLm1lZGlhLmNvbnRlbnRJZCkpe0Uocyx0LHRoaXMpLE9iamVjdC5lbnRyaWVzKGkodGhpcyxnKSkuZm9yRWFjaCgoW3YsT10pPT57aSh0aGlzLHApLmNvbnRyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcih2LE8pfSk7dHJ5e2F3YWl0IGYoeT1zLHV0LCR0KS5jYWxsKHksbmV3IGNocm9tZS5jYXN0Lm1lZGlhLkdldFN0YXR1c1JlcXVlc3QpfWNhdGNoKHYpe2NvbnNvbGUuZXJyb3Iodil9aSh0aGlzLGcpW2Nhc3QuZnJhbWV3b3JrLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19QQVVTRURfQ0hBTkdFRF0oKSxpKHRoaXMsZylbY2FzdC5mcmFtZXdvcmsuUmVtb3RlUGxheWVyRXZlbnRUeXBlLlBMQVlFUl9TVEFURV9DSEFOR0VEXSgpfX0sJD1uZXcgV2Vha1NldCxDdD1mdW5jdGlvbigpe3ZhciBlOyFpKHMsUyxFdCl8fHRoaXMuY2FzdEVuYWJsZWR8fCh0aGlzLmNhc3RFbmFibGVkPSEwLGYoZT1zLFksU3QpLmNhbGwoZSksdGhpcy50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixmKHRoaXMsWCxPdCkuYmluZCh0aGlzKSksZih0aGlzLHEsUHQpLmNhbGwodGhpcyksRSh0aGlzLHAsbmV3IGNhc3QuZnJhbWV3b3JrLlJlbW90ZVBsYXllciksbmV3IGNhc3QuZnJhbWV3b3JrLlJlbW90ZVBsYXllckNvbnRyb2xsZXIoaSh0aGlzLHApKSxFKHRoaXMsZyx7W2Nhc3QuZnJhbWV3b3JrLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19DT05ORUNURURfQ0hBTkdFRF06KHt2YWx1ZTpyfSk9PntyPT09ITEmJmYodGhpcyxsdCxYdCkuY2FsbCh0aGlzKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KHI/XCJlbnRlcmNhc3RcIjpcImxlYXZlY2FzdFwiKSl9LFtjYXN0LmZyYW1ld29yay5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuRFVSQVRJT05fQ0hBTkdFRF06KCk9Pnt0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZHVyYXRpb25jaGFuZ2VcIikpfSxbY2FzdC5mcmFtZXdvcmsuUmVtb3RlUGxheWVyRXZlbnRUeXBlLlZPTFVNRV9MRVZFTF9DSEFOR0VEXTooKT0+e3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJ2b2x1bWVjaGFuZ2VcIikpfSxbY2FzdC5mcmFtZXdvcmsuUmVtb3RlUGxheWVyRXZlbnRUeXBlLklTX01VVEVEX0NIQU5HRURdOigpPT57dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInZvbHVtZWNoYW5nZVwiKSl9LFtjYXN0LmZyYW1ld29yay5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuQ1VSUkVOVF9USU1FX0NIQU5HRURdOigpPT57IWkodGhpcyxJLFopfHx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwidGltZXVwZGF0ZVwiKSl9LFtjYXN0LmZyYW1ld29yay5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuVklERU9fSU5GT19DSEFOR0VEXTooKT0+e3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNpemVcIikpfSxbY2FzdC5mcmFtZXdvcmsuUmVtb3RlUGxheWVyRXZlbnRUeXBlLklTX1BBVVNFRF9DSEFOR0VEXTooKT0+e3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodGhpcy5wYXVzZWQ/XCJwYXVzZVwiOlwicGxheVwiKSl9LFtjYXN0LmZyYW1ld29yay5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuUExBWUVSX1NUQVRFX0NIQU5HRURdOigpPT57dmFyIHIseTsoKHI9dGhpcy5jYXN0UGxheWVyKT09bnVsbD92b2lkIDA6ci5wbGF5ZXJTdGF0ZSkhPT1jaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5QQVVTRUQmJnRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoe1tjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5QTEFZSU5HXTpcInBsYXlpbmdcIixbY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuQlVGRkVSSU5HXTpcIndhaXRpbmdcIixbY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuSURMRV06XCJlbXB0aWVkXCJ9Wyh5PXRoaXMuY2FzdFBsYXllcik9PW51bGw/dm9pZCAwOnkucGxheWVyU3RhdGVdKSl9LFtjYXN0LmZyYW1ld29yay5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuSVNfTUVESUFfTE9BREVEX0NIQU5HRURdOmFzeW5jKCk9PnshaSh0aGlzLEksWil8fChhd2FpdCBQcm9taXNlLnJlc29sdmUoKSxmKHRoaXMsaHQsSnQpLmNhbGwodGhpcykpfX0pKX0saHQ9bmV3IFdlYWtTZXQsSnQ9ZnVuY3Rpb24oKXtmKHRoaXMsWCxPdCkuY2FsbCh0aGlzKX0sWD1uZXcgV2Vha1NldCxPdD1hc3luYyBmdW5jdGlvbigpe3ZhciBEdCx3dCxOdCx4dCxHdCxGdDtpZighdGhpcy5jYXN0UGxheWVyKXJldHVybjtsZXQgcj0oKHd0PShEdD1pKHRoaXMscCkubWVkaWFJbmZvKT09bnVsbD92b2lkIDA6RHQudHJhY2tzKSE9bnVsbD93dDpbXSkuZmlsdGVyKCh7dHlwZTpifSk9PmI9PT1jaHJvbWUuY2FzdC5tZWRpYS5UcmFja1R5cGUuVEVYVCkseT1bLi4udGhpcy50ZXh0VHJhY2tzXS5maWx0ZXIoKHtraW5kOmJ9KT0+Yj09PVwic3VidGl0bGVzXCJ8fGI9PT1cImNhcHRpb25zXCIpLHY9ci5tYXAoKHtsYW5ndWFnZTpiLG5hbWU6bXQsdHJhY2tJZDpidH0pPT57dmFyIFl0O2xldHttb2RlOlV0fT0oWXQ9eS5maW5kKEJ0PT5CdC5sYW5ndWFnZT09PWImJkJ0LmxhYmVsPT09bXQpKSE9bnVsbD9ZdDp7fTtyZXR1cm4gVXQ/e21vZGU6VXQsdHJhY2tJZDpidH06ITF9KS5maWx0ZXIoQm9vbGVhbiksUj12LmZpbHRlcigoe21vZGU6Yn0pPT5iIT09XCJzaG93aW5nXCIpLm1hcCgoe3RyYWNrSWQ6Yn0pPT5iKSxHPXYuZmluZCgoe21vZGU6Yn0pPT5iPT09XCJzaG93aW5nXCIpLF89KEd0PSh4dD0oTnQ9aShzLEwsZnQpKT09bnVsbD92b2lkIDA6TnQuZ2V0U2Vzc2lvbk9iaigpLm1lZGlhWzBdKT09bnVsbD92b2lkIDA6eHQuYWN0aXZlVHJhY2tJZHMpIT1udWxsP0d0OltdLGs9XztpZihfLmxlbmd0aCYmKGs9ay5maWx0ZXIoYj0+IVIuaW5jbHVkZXMoYikpKSxHIT1udWxsJiZHLnRyYWNrSWQmJihrPVsuLi5rLEcudHJhY2tJZF0pLGs9Wy4uLm5ldyBTZXQoayldLCEoKGIsbXQpPT5iLmxlbmd0aD09PW10Lmxlbmd0aCYmYi5ldmVyeShidD0+bXQuaW5jbHVkZXMoYnQpKSkoXyxrKSl0cnl7bGV0IGI9bmV3IGNocm9tZS5jYXN0Lm1lZGlhLkVkaXRUcmFja3NJbmZvUmVxdWVzdChrKTthd2FpdCBmKEZ0PXMsb3QscXQpLmNhbGwoRnQsYil9Y2F0Y2goYil7Y29uc29sZS5lcnJvcihiKX19LG4ocyxNKSxuKHMsUyksbihzLFQpLG4ocyxMKSxuKHMsVSksbihzLG90KSxuKHMsdXQpLG4ocyxZKSx4KHMsXCJvYnNlcnZlZEF0dHJpYnV0ZXNcIixbXCJjYXN0LXNyY1wiLFwiY2FzdC1jb250ZW50LXR5cGVcIixcImNhc3Qtc3RyZWFtLXR5cGVcIl0pLHgocyxcImluc3RhbmNlc1wiLG5ldyBTZXQpLG4ocyx0LHZvaWQgMCksbihzLHUsITEpLHgocyxcImluaXRDYXN0XCIsKCk9Pnt2YXIgZTtpKHMsTSxqdCk/aShzLFMsRXQpP2koZT1zLGwpLmNhbGwoZSxjaHJvbWUuY2FzdC5pc0F2YWlsYWJsZSk6Y3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoXCJnb29nbGUtY2FzdC1idXR0b25cIikudGhlbigoKT0+e3ZhciByO3JldHVybiBpKHI9cyxsKS5jYWxsKHIsY2hyb21lLmNhc3QuaXNBdmFpbGFibGUpfSk6Z2xvYmFsVGhpcy5fX29uR0Nhc3RBcGlBdmFpbGFibGU9KCk9PntjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChcImdvb2dsZS1jYXN0LWJ1dHRvblwiKS50aGVuKCgpPT57dmFyIHI7cmV0dXJuIGkocj1zLGwpLmNhbGwocixjaHJvbWUuY2FzdC5pc0F2YWlsYWJsZSl9KX19KSxuKHMsbCxlPT57aWYoZSl7RShzLHUsITApO2xldHtDQVNUX1NUQVRFX0NIQU5HRUQ6cn09Y2FzdC5mcmFtZXdvcmsuQ2FzdENvbnRleHRFdmVudFR5cGU7aShzLFQsRCkuYWRkRXZlbnRMaXN0ZW5lcihyLHY9PntzLmluc3RhbmNlcy5mb3JFYWNoKE89Pnt2YXIgUjtyZXR1cm4gZihSPU8scSxQdCkuY2FsbChSLHYpfSl9KTtsZXR7U0VTU0lPTl9TVEFURV9DSEFOR0VEOnl9PWNhc3QuZnJhbWV3b3JrLkNhc3RDb250ZXh0RXZlbnRUeXBlO2kocyxULEQpLmFkZEV2ZW50TGlzdGVuZXIoeSx2PT57cy5pbnN0YW5jZXMuZm9yRWFjaChPPT57dmFyIFI7cmV0dXJuIGYoUj1PLGR0LHp0KS5jYWxsKFIsdil9KX0pLHMuaW5zdGFuY2VzLmZvckVhY2godj0+e3ZhciBPO3JldHVybiBmKE89diwkLEN0KS5jYWxsKE8pfSl9fSksc30sTXQ9Z2xvYmFsVGhpcy5IVE1MVmlkZW9FbGVtZW50P0h0KEhUTUxWaWRlb0VsZW1lbnQpOkh0KE9iamVjdCk7Z2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cyYmIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwiY2FzdGFibGUtdmlkZW9cIikmJihjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJjYXN0YWJsZS12aWRlb1wiLE10LHtleHRlbmRzOlwidmlkZW9cIn0pLGdsb2JhbFRoaXMuQ2FzdGFibGVWaWRlb0VsZW1lbnQ9TXQpO010LmluaXRDYXN0KCk7dmFyIEx0PVtcImFib3J0XCIsXCJjYW5wbGF5XCIsXCJjYW5wbGF5dGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImVtcHRpZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVycm9yXCIsXCJsb2FkZWRkYXRhXCIsXCJsb2FkZWRtZXRhZGF0YVwiLFwibG9hZHN0YXJ0XCIsXCJwYXVzZVwiLFwicGxheVwiLFwicGxheWluZ1wiLFwicHJvZ3Jlc3NcIixcInJhdGVjaGFuZ2VcIixcInNlZWtlZFwiLFwic2Vla2luZ1wiLFwic3RhbGxlZFwiLFwic3VzcGVuZFwiLFwidGltZXVwZGF0ZVwiLFwidm9sdW1lY2hhbmdlXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nZm9ya2V5XCIsXCJyZXNpemVcIixcImVudGVycGljdHVyZWlucGljdHVyZVwiLFwibGVhdmVwaWN0dXJlaW5waWN0dXJlXCIsXCJ3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cIixcIndlYmtpdGVuZGZ1bGxzY3JlZW5cIixcIndlYmtpdHByZXNlbnRhdGlvbm1vZGVjaGFuZ2VkXCJdLFF0LEl0PShRdD1nbG9iYWxUaGlzLmRvY3VtZW50KT09bnVsbD92b2lkIDA6UXQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO0l0JiYoSXQuaW5uZXJIVE1MPWBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICB9XG5cbiAgICAgIGF1ZGlvIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuICAgICAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIGApO3ZhciBadCxrdD0oWnQ9Z2xvYmFsVGhpcy5kb2N1bWVudCk9PW51bGw/dm9pZCAwOlp0LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtrdCYmKGt0LmlubmVySFRNTD1gXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xuICAgICAgfVxuXG4gICAgICB2aWRlbyB7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgbWF4LWhlaWdodDogMTAwJTtcbiAgICAgICAgbWluLXdpZHRoOiAxMDAlO1xuICAgICAgICBtaW4taGVpZ2h0OiAxMDAlO1xuICAgICAgICBvYmplY3QtZml0OiB2YXIoLS1tZWRpYS1vYmplY3QtZml0LCBjb250YWluKTtcbiAgICAgICAgb2JqZWN0LXBvc2l0aW9uOiB2YXIoLS1tZWRpYS1vYmplY3QtcG9zaXRpb24sIDUwJSA1MCUpO1xuICAgICAgfVxuXG4gICAgICB2aWRlbzo6LXdlYmtpdC1tZWRpYS10ZXh0LXRyYWNrLWNvbnRhaW5lciB7XG4gICAgICAgIHRyYW5zZm9ybTogdmFyKC0tbWVkaWEtd2Via2l0LXRleHQtdHJhY2stdHJhbnNmb3JtKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdmFyKC0tbWVkaWEtd2Via2l0LXRleHQtdHJhY2stdHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIGApO3ZhciB5dD0obyx7dGFnOnMsaXM6dH0pPT57dmFyIE0sUCxTLEMsdGUsaixMLE4sVixudCxlZSxjdCxzZTtsZXQgdT0oTT1nbG9iYWxUaGlzLmRvY3VtZW50KT09bnVsbD92b2lkIDA6TS5jcmVhdGVFbGVtZW50KHMse2lzOnR9KSxsPXU/bGUodSk6W107cmV0dXJuIFA9Y2xhc3MgZXh0ZW5kcyBve2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtuKHRoaXMsTik7bih0aGlzLG50KTtuKHRoaXMsY3QpO24odGhpcyxqLHZvaWQgMCk7bih0aGlzLEwsdm9pZCAwKTt0aGlzLnNoYWRvd1Jvb3R8fCh0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pLHRoaXMuc2hhZG93Um9vdC5hcHBlbmQodGhpcy5jb25zdHJ1Y3Rvci50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSghMCkpKX1zdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpe3ZhciBjLHAsZztyZXR1cm4gZihjPVAsQyx0ZSkuY2FsbChjKSxbLi4uKGc9KHA9dT09bnVsbD92b2lkIDA6dS5jb25zdHJ1Y3Rvcik9PW51bGw/dm9pZCAwOnAub2JzZXJ2ZWRBdHRyaWJ1dGVzKSE9bnVsbD9nOltdLFwiYXV0b3BpY3R1cmVpbnBpY3R1cmVcIixcImRpc2FibGVwaWN0dXJlaW5waWN0dXJlXCIsXCJkaXNhYmxlcmVtb3RlcGxheWJhY2tcIixcImF1dG9wbGF5XCIsXCJjb250cm9sc1wiLFwiY29udHJvbHNsaXN0XCIsXCJjcm9zc29yaWdpblwiLFwibG9vcFwiLFwibXV0ZWRcIixcInBsYXlzaW5saW5lXCIsXCJwb3N0ZXJcIixcInByZWxvYWRcIixcInNyY1wiXX1nZXQgbmF0aXZlRWwoKXt2YXIgZCxjO3JldHVybihjPShkPWkodGhpcyxMKSkhPW51bGw/ZDp0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihzKSkhPW51bGw/Yzp0aGlzLnF1ZXJ5U2VsZWN0b3Iocyl9c2V0IG5hdGl2ZUVsKGQpe0UodGhpcyxMLGQpfWdldCBkZWZhdWx0TXV0ZWQoKXtyZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoXCJtdXRlZFwiKX1zZXQgZGVmYXVsdE11dGVkKGQpe3RoaXMudG9nZ2xlQXR0cmlidXRlKFwibXV0ZWRcIixCb29sZWFuKGQpKX1nZXQgc3JjKCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic3JjXCIpfXNldCBzcmMoZCl7dGhpcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIixgJHtkfWApfWdldCBwcmVsb2FkKCl7dmFyIGQsYztyZXR1cm4oYz10aGlzLmdldEF0dHJpYnV0ZShcInByZWxvYWRcIikpIT1udWxsP2M6KGQ9dGhpcy5uYXRpdmVFbCk9PW51bGw/dm9pZCAwOmQucHJlbG9hZH1zZXQgcHJlbG9hZChkKXt0aGlzLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIixgJHtkfWApfWF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhkLGMscCl7Zih0aGlzLE4sVikuY2FsbCh0aGlzKSxmKHRoaXMsY3Qsc2UpLmNhbGwodGhpcyxkLGMscCl9Y29ubmVjdGVkQ2FsbGJhY2soKXtmKHRoaXMsTixWKS5jYWxsKHRoaXMpfX0sUz1uZXcgV2Vha01hcCxDPW5ldyBXZWFrU2V0LHRlPWZ1bmN0aW9uKCl7aWYoaSh0aGlzLFMpKXJldHVybjtFKHRoaXMsUywhMCk7bGV0IGQ9bmV3IFNldCh0aGlzLm9ic2VydmVkQXR0cmlidXRlcyk7ZC5kZWxldGUoXCJtdXRlZFwiKTtmb3IobGV0IGMgb2YgbCl7aWYoYyBpbiB0aGlzLnByb3RvdHlwZSljb250aW51ZTtpZih0eXBlb2YgdVtjXT09XCJmdW5jdGlvblwiKXRoaXMucHJvdG90eXBlW2NdPWZ1bmN0aW9uKC4uLmcpe3JldHVybiBmKHRoaXMsTixWKS5jYWxsKHRoaXMpLCgoKT0+dGhpcy5jYWxsP3RoaXMuY2FsbChjLC4uLmcpOnRoaXMubmF0aXZlRWxbY10uYXBwbHkodGhpcy5uYXRpdmVFbCxnKSkoKX07ZWxzZXtsZXQgZz17Z2V0KCl7dmFyIG0sQSxJO2YodGhpcyxOLFYpLmNhbGwodGhpcyk7bGV0IGg9Yy50b0xvd2VyQ2FzZSgpO2lmKGQuaGFzKGgpKXtsZXQgQj10aGlzLmdldEF0dHJpYnV0ZShoKTtyZXR1cm4gQj09PW51bGw/ITE6Qj09PVwiXCI/ITA6Qn1yZXR1cm4oST0obT10aGlzLmdldCk9PW51bGw/dm9pZCAwOm0uY2FsbCh0aGlzLGMpKSE9bnVsbD9JOihBPXRoaXMubmF0aXZlRWwpPT1udWxsP3ZvaWQgMDpBW2NdfX07YyE9PWMudG9VcHBlckNhc2UoKSYmKGcuc2V0PWZ1bmN0aW9uKGgpe2YodGhpcyxOLFYpLmNhbGwodGhpcyk7bGV0IG09Yy50b0xvd2VyQ2FzZSgpO2lmKGQuaGFzKG0pKXtoPT09ITB8fGg9PT0hMXx8aD09bnVsbD90aGlzLnRvZ2dsZUF0dHJpYnV0ZShtLEJvb2xlYW4oaCkpOnRoaXMuc2V0QXR0cmlidXRlKG0saCk7cmV0dXJufWlmKHRoaXMuc2V0KXt0aGlzLnNldChjLGgpO3JldHVybn10aGlzLm5hdGl2ZUVsW2NdPWh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsYyxnKX19fSxqPW5ldyBXZWFrTWFwLEw9bmV3IFdlYWtNYXAsTj1uZXcgV2Vha1NldCxWPWZ1bmN0aW9uKCl7dmFyIHAsZztpZihpKHRoaXMsaikpcmV0dXJuO2lmKEUodGhpcyxqLCEwKSwhdGhpcy5uYXRpdmVFbCl7bGV0IGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzLHtpczp0fSk7aC5wYXJ0PXMsdGhpcy5zaGFkb3dSb290LmFwcGVuZChoKX10aGlzLm5hdGl2ZUVsLm11dGVkPXRoaXMuaGFzQXR0cmlidXRlKFwibXV0ZWRcIik7Zm9yKGxldCBoIG9mIGwpZih0aGlzLG50LGVlKS5jYWxsKHRoaXMsaCk7bGV0IGQ9bmV3IE1hcCxjPXRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic2xvdDpub3QoW25hbWVdKVwiKTtjPT1udWxsfHxjLmFkZEV2ZW50TGlzdGVuZXIoXCJzbG90Y2hhbmdlXCIsKCk9PntsZXQgaD1uZXcgTWFwKGQpO2MuYXNzaWduZWRFbGVtZW50cygpLmZpbHRlcihtPT5bXCJ0cmFja1wiLFwic291cmNlXCJdLmluY2x1ZGVzKG0ubG9jYWxOYW1lKSkuZm9yRWFjaChtPT57dmFyIEksQjtoLmRlbGV0ZShtKTtsZXQgQT1kLmdldChtKTtBfHwoQT1tLmNsb25lTm9kZSgpLGQuc2V0KG0sQSkpLChCPShJPXRoaXMubmF0aXZlRWwpLmFwcGVuZCk9PW51bGx8fEIuY2FsbChJLEEpfSksaC5mb3JFYWNoKG09Pm0ucmVtb3ZlKCkpfSk7Zm9yKGxldCBoIG9mIHRoaXMuY29uc3RydWN0b3IuRXZlbnRzKShnPShwPXRoaXMuc2hhZG93Um9vdCkuYWRkRXZlbnRMaXN0ZW5lcik9PW51bGx8fGcuY2FsbChwLGgsbT0+e20udGFyZ2V0PT09dGhpcy5uYXRpdmVFbCYmdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChtLnR5cGUse2RldGFpbDptLmRldGFpbH0pKX0sITApfSxudD1uZXcgV2Vha1NldCxlZT1mdW5jdGlvbihkKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcyxkKSl7bGV0IGM9dGhpc1tkXTtkZWxldGUgdGhpc1tkXSx0aGlzW2RdPWN9fSxjdD1uZXcgV2Vha1NldCxzZT1mdW5jdGlvbihkLGMscCl7dmFyIGcsaCxtLEE7W1wiaWRcIixcImNsYXNzXCJdLmluY2x1ZGVzKGQpfHwocD09PW51bGw/KGg9KGc9dGhpcy5uYXRpdmVFbCkucmVtb3ZlQXR0cmlidXRlKT09bnVsbHx8aC5jYWxsKGcsZCk6KEE9KG09dGhpcy5uYXRpdmVFbCkuc2V0QXR0cmlidXRlKT09bnVsbHx8QS5jYWxsKG0sZCxwKSl9LG4oUCxDKSx4KFAsXCJFdmVudHNcIixMdCkseChQLFwidGVtcGxhdGVcIixzLmVuZHNXaXRoKFwiYXVkaW9cIik/SXQ6a3QpLG4oUCxTLHZvaWQgMCksUH07ZnVuY3Rpb24gbGUobyl7bGV0IHM9W107Zm9yKGxldCB0PU9iamVjdC5nZXRQcm90b3R5cGVPZihvKTt0JiZ0IT09SFRNTEVsZW1lbnQucHJvdG90eXBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKXMucHVzaCguLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KSk7cmV0dXJuIHN9dmFyIEdlPWdsb2JhbFRoaXMuZG9jdW1lbnQ/eXQoSFRNTEVsZW1lbnQse3RhZzpcInZpZGVvXCJ9KTpjbGFzc3t9LEZlPWdsb2JhbFRoaXMuZG9jdW1lbnQ/eXQoSFRNTEVsZW1lbnQse3RhZzpcImF1ZGlvXCJ9KTpjbGFzc3t9O0x0LnB1c2goXCJjYXN0Y2hhbmdlXCIsXCJlbnRlcmNhc3RcIixcImxlYXZlY2FzdFwiKTt2YXIgX3Q9eXQoUS5IVE1MRWxlbWVudCx7dGFnOlwidmlkZW9cIixpczpcImNhc3RhYmxlLXZpZGVvXCJ9KSxhPXtCRUFDT05fQ09MTEVDVElPTl9ET01BSU46XCJiZWFjb24tY29sbGVjdGlvbi1kb21haW5cIixDVVNUT01fRE9NQUlOOlwiY3VzdG9tLWRvbWFpblwiLERFQlVHOlwiZGVidWdcIixESVNBQkxFX0NPT0tJRVM6XCJkaXNhYmxlLWNvb2tpZXNcIixFTlZfS0VZOlwiZW52LWtleVwiLE1BWF9SRVNPTFVUSU9OOlwibWF4LXJlc29sdXRpb25cIixNRVRBREFUQV9VUkw6XCJtZXRhZGF0YS11cmxcIixQTEFZQkFDS19JRDpcInBsYXliYWNrLWlkXCIsUExBWUVSX1NPRlRXQVJFX05BTUU6XCJwbGF5ZXItc29mdHdhcmUtbmFtZVwiLFBMQVlFUl9TT0ZUV0FSRV9WRVJTSU9OOlwicGxheWVyLXNvZnR3YXJlLXZlcnNpb25cIixQUkVGRVJfQ01DRDpcInByZWZlci1jbWNkXCIsUFJFRkVSX1BMQVlCQUNLOlwicHJlZmVyLXBsYXliYWNrXCIsU1RBUlRfVElNRTpcInN0YXJ0LXRpbWVcIixTVFJFQU1fVFlQRTpcInN0cmVhbS10eXBlXCIsVEFSR0VUX0xJVkVfV0lORE9XOlwidGFyZ2V0LWxpdmUtd2luZG93XCIsTElWRV9FREdFX09GRlNFVDpcImxpdmUtZWRnZS1vZmZzZXRcIixUWVBFOlwidHlwZVwifSxPZT1PYmplY3QudmFsdWVzKGEpLE1lPUt0KCksSWU9XCJtdXgtdmlkZW9cIix3LEssZXQsSCxzdCxpdCxydCxhdCxSdCx0dD1jbGFzcyBleHRlbmRzIF90e2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtuKHRoaXMsYXQpO24odGhpcyx3LHZvaWQgMCk7bih0aGlzLEssdm9pZCAwKTtuKHRoaXMsZXQsdm9pZCAwKTtuKHRoaXMsSCx7fSk7bih0aGlzLHN0LHZvaWQgMCk7bih0aGlzLGl0LHZvaWQgMCk7bih0aGlzLHJ0LHZvaWQgMCk7RSh0aGlzLGV0LG1lKCkpfXN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7dmFyIHQ7cmV0dXJuWy4uLk9lLC4uLih0PV90Lm9ic2VydmVkQXR0cmlidXRlcykhPW51bGw/dDpbXV19Z2V0IHByZWZlckNtY2QoKXt2YXIgdDtyZXR1cm4odD10aGlzLmdldEF0dHJpYnV0ZShhLlBSRUZFUl9DTUNEKSkhPW51bGw/dDp2b2lkIDB9c2V0IHByZWZlckNtY2QodCl7dCE9PXRoaXMucHJlZmVyQ21jZCYmKHQ/aWUuaW5jbHVkZXModCk/dGhpcy5zZXRBdHRyaWJ1dGUoYS5QUkVGRVJfQ01DRCx0KTpjb25zb2xlLndhcm4oYEludmFsaWQgdmFsdWUgZm9yIHByZWZlckNtY2QuIE11c3QgYmUgb25lIG9mICR7aWUuam9pbigpfWApOnRoaXMucmVtb3ZlQXR0cmlidXRlKGEuUFJFRkVSX0NNQ0QpKX1nZXQgcGxheWVySW5pdFRpbWUoKXtyZXR1cm4gaSh0aGlzLGV0KX1nZXQgcGxheWVyU29mdHdhcmVOYW1lKCl7dmFyIHQ7cmV0dXJuKHQ9aSh0aGlzLGl0KSkhPW51bGw/dDpJZX1zZXQgcGxheWVyU29mdHdhcmVOYW1lKHQpe0UodGhpcyxpdCx0KX1nZXQgcGxheWVyU29mdHdhcmVWZXJzaW9uKCl7dmFyIHQ7cmV0dXJuKHQ9aSh0aGlzLHN0KSkhPW51bGw/dDpNZX1zZXQgcGxheWVyU29mdHdhcmVWZXJzaW9uKHQpe0UodGhpcyxzdCx0KX1nZXQgX2hscygpe3ZhciB0O3JldHVybih0PWkodGhpcyx3KSk9PW51bGw/dm9pZCAwOnQuZW5naW5lfWdldCBtdXgoKXtyZXR1cm4gdGhpcy5uYXRpdmVFbC5tdXh9Z2V0IGVycm9yKCl7dmFyIHQ7cmV0dXJuKHQ9ZmUodGhpcy5uYXRpdmVFbCkpIT1udWxsP3Q6bnVsbH1nZXQgZXJyb3JUcmFuc2xhdG9yKCl7cmV0dXJuIGkodGhpcyxydCl9c2V0IGVycm9yVHJhbnNsYXRvcih0KXtFKHRoaXMscnQsdCl9Z2V0IHNyYygpe3JldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcInNyY1wiKX1zZXQgc3JjKHQpe3QhPT10aGlzLnNyYyYmKHQ9PW51bGw/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik6dGhpcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIix0KSl9Z2V0IHR5cGUoKXt2YXIgdDtyZXR1cm4odD10aGlzLmdldEF0dHJpYnV0ZShhLlRZUEUpKSE9bnVsbD90OnZvaWQgMH1zZXQgdHlwZSh0KXt0IT09dGhpcy50eXBlJiYodD90aGlzLnNldEF0dHJpYnV0ZShhLlRZUEUsdCk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5UWVBFKSl9Z2V0IGF1dG9wbGF5KCl7bGV0IHQ9dGhpcy5nZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiKTtyZXR1cm4gdD09PW51bGw/ITE6dD09PVwiXCI/ITA6dH1zZXQgYXV0b3BsYXkodCl7bGV0IHU9dGhpcy5hdXRvcGxheTt0IT09dSYmKHQ/dGhpcy5zZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiLHR5cGVvZiB0PT1cInN0cmluZ1wiP3Q6XCJcIik6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJhdXRvcGxheVwiKSl9Z2V0IHByZWxvYWQoKXtsZXQgdD10aGlzLmdldEF0dHJpYnV0ZShcInByZWxvYWRcIik7cmV0dXJuIHQ9PT1cIlwiP1wiYXV0b1wiOltcIm5vbmVcIixcIm1ldGFkYXRhXCIsXCJhdXRvXCJdLmluY2x1ZGVzKHQpP3Q6c3VwZXIucHJlbG9hZH1zZXQgcHJlbG9hZCh0KXt0IT10aGlzLmdldEF0dHJpYnV0ZShcInByZWxvYWRcIikmJihbXCJcIixcIm5vbmVcIixcIm1ldGFkYXRhXCIsXCJhdXRvXCJdLmluY2x1ZGVzKHQpP3RoaXMuc2V0QXR0cmlidXRlKFwicHJlbG9hZFwiLHQpOnRoaXMucmVtb3ZlQXR0cmlidXRlKFwicHJlbG9hZFwiKSl9Z2V0IGRlYnVnKCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGEuREVCVUcpIT1udWxsfXNldCBkZWJ1Zyh0KXt0IT09dGhpcy5kZWJ1ZyYmKHQ/dGhpcy5zZXRBdHRyaWJ1dGUoYS5ERUJVRyxcIlwiKTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShhLkRFQlVHKSl9Z2V0IGRpc2FibGVDb29raWVzKCl7cmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGEuRElTQUJMRV9DT09LSUVTKX1zZXQgZGlzYWJsZUNvb2tpZXModCl7dCE9PXRoaXMuZGlzYWJsZUNvb2tpZXMmJih0P3RoaXMuc2V0QXR0cmlidXRlKGEuRElTQUJMRV9DT09LSUVTLFwiXCIpOnRoaXMucmVtb3ZlQXR0cmlidXRlKGEuRElTQUJMRV9DT09LSUVTKSl9Z2V0IHN0YXJ0VGltZSgpe2xldCB0PXRoaXMuZ2V0QXR0cmlidXRlKGEuU1RBUlRfVElNRSk7aWYodD09bnVsbClyZXR1cm47bGV0IHU9K3Q7cmV0dXJuIE51bWJlci5pc05hTih1KT92b2lkIDA6dX1zZXQgc3RhcnRUaW1lKHQpe3QhPT10aGlzLnN0YXJ0VGltZSYmKHQ9PW51bGw/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5TVEFSVF9USU1FKTp0aGlzLnNldEF0dHJpYnV0ZShhLlNUQVJUX1RJTUUsYCR7dH1gKSl9Z2V0IHBsYXliYWNrSWQoKXt2YXIgdDtyZXR1cm4odD10aGlzLmdldEF0dHJpYnV0ZShhLlBMQVlCQUNLX0lEKSkhPW51bGw/dDp2b2lkIDB9c2V0IHBsYXliYWNrSWQodCl7dCE9PXRoaXMucGxheWJhY2tJZCYmKHQ/dGhpcy5zZXRBdHRyaWJ1dGUoYS5QTEFZQkFDS19JRCx0KTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShhLlBMQVlCQUNLX0lEKSl9Z2V0IG1heFJlc29sdXRpb24oKXt2YXIgdDtyZXR1cm4odD10aGlzLmdldEF0dHJpYnV0ZShhLk1BWF9SRVNPTFVUSU9OKSkhPW51bGw/dDp2b2lkIDB9c2V0IG1heFJlc29sdXRpb24odCl7dCE9PXRoaXMubWF4UmVzb2x1dGlvbiYmKHQ/dGhpcy5zZXRBdHRyaWJ1dGUoYS5NQVhfUkVTT0xVVElPTix0KTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShhLk1BWF9SRVNPTFVUSU9OKSl9Z2V0IGN1c3RvbURvbWFpbigpe3ZhciB0O3JldHVybih0PXRoaXMuZ2V0QXR0cmlidXRlKGEuQ1VTVE9NX0RPTUFJTikpIT1udWxsP3Q6dm9pZCAwfXNldCBjdXN0b21Eb21haW4odCl7dCE9PXRoaXMuY3VzdG9tRG9tYWluJiYodD90aGlzLnNldEF0dHJpYnV0ZShhLkNVU1RPTV9ET01BSU4sdCk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5DVVNUT01fRE9NQUlOKSl9Z2V0IGVuZGVkKCl7cmV0dXJuIENlKHRoaXMubmF0aXZlRWwsdGhpcy5faGxzKX1nZXQgZW52S2V5KCl7dmFyIHQ7cmV0dXJuKHQ9dGhpcy5nZXRBdHRyaWJ1dGUoYS5FTlZfS0VZKSkhPW51bGw/dDp2b2lkIDB9c2V0IGVudktleSh0KXt0IT09dGhpcy5lbnZLZXkmJih0P3RoaXMuc2V0QXR0cmlidXRlKGEuRU5WX0tFWSx0KTp0aGlzLnJlbW92ZUF0dHJpYnV0ZShhLkVOVl9LRVkpKX1nZXQgYmVhY29uQ29sbGVjdGlvbkRvbWFpbigpe3ZhciB0O3JldHVybih0PXRoaXMuZ2V0QXR0cmlidXRlKGEuQkVBQ09OX0NPTExFQ1RJT05fRE9NQUlOKSkhPW51bGw/dDp2b2lkIDB9c2V0IGJlYWNvbkNvbGxlY3Rpb25Eb21haW4odCl7dCE9PXRoaXMuYmVhY29uQ29sbGVjdGlvbkRvbWFpbiYmKHQ/dGhpcy5zZXRBdHRyaWJ1dGUoYS5CRUFDT05fQ09MTEVDVElPTl9ET01BSU4sdCk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5CRUFDT05fQ09MTEVDVElPTl9ET01BSU4pKX1nZXQgc3RyZWFtVHlwZSgpe3ZhciB0O3JldHVybih0PXRoaXMuZ2V0QXR0cmlidXRlKGEuU1RSRUFNX1RZUEUpKSE9bnVsbD90OlRlKHRoaXMubmF0aXZlRWwpfXNldCBzdHJlYW1UeXBlKHQpe3QhPT10aGlzLnN0cmVhbVR5cGUmJih0P3RoaXMuc2V0QXR0cmlidXRlKGEuU1RSRUFNX1RZUEUsdCk6dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5TVFJFQU1fVFlQRSkpfWdldCB0YXJnZXRMaXZlV2luZG93KCl7cmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGEuVEFSR0VUX0xJVkVfV0lORE9XKT8rdGhpcy5nZXRBdHRyaWJ1dGUoYS5UQVJHRVRfTElWRV9XSU5ET1cpOnZlKHRoaXMubmF0aXZlRWwpfXNldCB0YXJnZXRMaXZlV2luZG93KHQpe3QhPXRoaXMudGFyZ2V0TGl2ZVdpbmRvdyYmKHQ9PW51bGw/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoYS5UQVJHRVRfTElWRV9XSU5ET1cpOnRoaXMuc2V0QXR0cmlidXRlKGEuVEFSR0VUX0xJVkVfV0lORE9XLGAkeyt0fWApKX1nZXQgbGl2ZUVkZ2VTdGFydCgpe3ZhciB0LHU7aWYodGhpcy5oYXNBdHRyaWJ1dGUoYS5MSVZFX0VER0VfT0ZGU0VUKSl7bGV0e2xpdmVFZGdlT2Zmc2V0Omx9PXRoaXMsTT0odD10aGlzLm5hdGl2ZUVsLnNlZWthYmxlLmVuZCgwKSkhPW51bGw/dDowLFA9KHU9dGhpcy5uYXRpdmVFbC5zZWVrYWJsZS5zdGFydCgwKSkhPW51bGw/dTowO3JldHVybiBNYXRoLm1heChQLE0tbCl9cmV0dXJuIFNlKHRoaXMubmF0aXZlRWwpfWdldCBsaXZlRWRnZU9mZnNldCgpe2lmKCEhdGhpcy5oYXNBdHRyaWJ1dGUoYS5MSVZFX0VER0VfT0ZGU0VUKSlyZXR1cm4rdGhpcy5nZXRBdHRyaWJ1dGUoYS5MSVZFX0VER0VfT0ZGU0VUKX1zZXQgbGl2ZUVkZ2VPZmZzZXQodCl7dCE9dGhpcy50YXJnZXRMaXZlV2luZG93JiYodD09bnVsbD90aGlzLnJlbW92ZUF0dHJpYnV0ZShhLkxJVkVfRURHRV9PRkZTRVQpOnRoaXMuc2V0QXR0cmlidXRlKGEuTElWRV9FREdFX09GRlNFVCxgJHsrdH1gKSl9Z2V0IHNlZWthYmxlKCl7cmV0dXJuIFBlKHRoaXMubmF0aXZlRWwpfWFzeW5jIGFkZEN1ZVBvaW50cyh0KXtyZXR1cm4gcGUodGhpcy5uYXRpdmVFbCx0KX1nZXQgYWN0aXZlQ3VlUG9pbnQoKXtyZXR1cm4gZ2UodGhpcy5uYXRpdmVFbCl9Z2V0IGN1ZVBvaW50cygpe3JldHVybiB5ZSh0aGlzLm5hdGl2ZUVsKX1nZXRTdGFydERhdGUoKXtyZXR1cm4gYmUodGhpcy5uYXRpdmVFbCx0aGlzLl9obHMpfWdldCBjdXJyZW50UGR0KCl7cmV0dXJuIEFlKHRoaXMubmF0aXZlRWwsdGhpcy5faGxzKX1nZXQgcHJlZmVyUGxheWJhY2soKXtsZXQgdD10aGlzLmdldEF0dHJpYnV0ZShhLlBSRUZFUl9QTEFZQkFDSyk7aWYodD09PWd0Lk1TRXx8dD09PWd0Lk5BVElWRSlyZXR1cm4gdH1zZXQgcHJlZmVyUGxheWJhY2sodCl7dCE9PXRoaXMucHJlZmVyUGxheWJhY2smJih0PT09Z3QuTVNFfHx0PT09Z3QuTkFUSVZFP3RoaXMuc2V0QXR0cmlidXRlKGEuUFJFRkVSX1BMQVlCQUNLLHQpOnRoaXMucmVtb3ZlQXR0cmlidXRlKGEuUFJFRkVSX1BMQVlCQUNLKSl9Z2V0IG1ldGFkYXRhKCl7cmV0dXJuey4uLnRoaXMuZ2V0QXR0cmlidXRlTmFtZXMoKS5maWx0ZXIodT0+dS5zdGFydHNXaXRoKFwibWV0YWRhdGEtXCIpJiYhW2EuTUVUQURBVEFfVVJMXS5pbmNsdWRlcyh1KSkucmVkdWNlKCh1LGwpPT57bGV0IE09dGhpcy5nZXRBdHRyaWJ1dGUobCk7cmV0dXJuIE0hPW51bGwmJih1W2wucmVwbGFjZSgvXm1ldGFkYXRhLS8sXCJcIikucmVwbGFjZSgvLS9nLFwiX1wiKV09TSksdX0se30pLC4uLmkodGhpcyxIKX19c2V0IG1ldGFkYXRhKHQpe0UodGhpcyxILHQhPW51bGw/dDp7fSksdGhpcy5tdXgmJnRoaXMubXV4LmVtaXQoXCJoYlwiLGkodGhpcyxIKSl9bG9hZCgpe0UodGhpcyx3LGRlKHRoaXMsdGhpcy5uYXRpdmVFbCxpKHRoaXMsdykpKX11bmxvYWQoKXtoZSh0aGlzLm5hdGl2ZUVsLGkodGhpcyx3KSksRSh0aGlzLHcsdm9pZCAwKX1hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodCx1LGwpe3ZhciBQLFM7c3dpdGNoKF90Lm9ic2VydmVkQXR0cmlidXRlcy5pbmNsdWRlcyh0KSYmIVtcInNyY1wiLFwiYXV0b3BsYXlcIixcInByZWxvYWRcIl0uaW5jbHVkZXModCkmJnN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0LHUsbCksdCl7Y2FzZSBhLlBMQVlFUl9TT0ZUV0FSRV9OQU1FOnRoaXMucGxheWVyU29mdHdhcmVOYW1lPWwhPW51bGw/bDp2b2lkIDA7YnJlYWs7Y2FzZSBhLlBMQVlFUl9TT0ZUV0FSRV9WRVJTSU9OOnRoaXMucGxheWVyU29mdHdhcmVWZXJzaW9uPWwhPW51bGw/bDp2b2lkIDA7YnJlYWs7Y2FzZVwic3JjXCI6e2xldCBDPSEhdSxUPSEhbDshQyYmVD9mKHRoaXMsYXQsUnQpLmNhbGwodGhpcyk6QyYmIVQ/dGhpcy51bmxvYWQoKTpDJiZUJiYodGhpcy51bmxvYWQoKSxmKHRoaXMsYXQsUnQpLmNhbGwodGhpcykpO2JyZWFrfWNhc2VcImF1dG9wbGF5XCI6aWYobD09PXUpYnJlYWs7KFA9aSh0aGlzLHcpKT09bnVsbHx8UC5zZXRBdXRvcGxheSh0aGlzLmF1dG9wbGF5KTticmVhaztjYXNlXCJwcmVsb2FkXCI6aWYobD09PXUpYnJlYWs7KFM9aSh0aGlzLHcpKT09bnVsbHx8Uy5zZXRQcmVsb2FkKGwpO2JyZWFrO2Nhc2UgYS5QTEFZQkFDS19JRDp0aGlzLnNyYz1FZShsIT1udWxsP2w6dm9pZCAwLHttYXhSZXNvbHV0aW9uOnRoaXMubWF4UmVzb2x1dGlvbixkb21haW46dGhpcy5jdXN0b21Eb21haW59KTticmVhaztjYXNlIGEuREVCVUc6e2xldCBDPXRoaXMuZGVidWc7dGhpcy5tdXgmJmNvbnNvbGUuaW5mbyhcIkNhbm5vdCB0b2dnbGUgZGVidWcgbW9kZSBvZiBtdXggZGF0YSBhZnRlciBpbml0aWFsaXphdGlvbi4gTWFrZSBzdXJlIHlvdSBzZXQgYWxsIG1ldGFkYXRhIHRvIG92ZXJyaWRlIGJlZm9yZSBzZXR0aW5nIHRoZSBzcmMuXCIpLHRoaXMuX2hscyYmKHRoaXMuX2hscy5jb25maWcuZGVidWc9Qyk7YnJlYWt9Y2FzZSBhLk1FVEFEQVRBX1VSTDpsJiZmZXRjaChsKS50aGVuKEM9PkMuanNvbigpKS50aGVuKEM9PnRoaXMubWV0YWRhdGE9QykuY2F0Y2goKCk9PmNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBsb2FkIG9yIHBhcnNlIG1ldGFkYXRhIEpTT04gZnJvbSBtZXRhZGF0YS11cmwgJHtsfSFgKSk7YnJlYWs7Y2FzZSBhLlNUUkVBTV9UWVBFOihsPT1udWxsfHxsIT09dSkmJnRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzdHJlYW10eXBlY2hhbmdlXCIse2NvbXBvc2VkOiEwLGJ1YmJsZXM6ITB9KSk7YnJlYWs7Y2FzZSBhLlRBUkdFVF9MSVZFX1dJTkRPVzoobD09bnVsbHx8bCE9PXUpJiZ0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidGFyZ2V0bGl2ZXdpbmRvd2NoYW5nZVwiLHtjb21wb3NlZDohMCxidWJibGVzOiEwLGRldGFpbDp0aGlzLnRhcmdldExpdmVXaW5kb3d9KSk7YnJlYWs7ZGVmYXVsdDpicmVha319ZGlzY29ubmVjdGVkQ2FsbGJhY2soKXt0aGlzLnVubG9hZCgpfX07dz1uZXcgV2Vha01hcCxLPW5ldyBXZWFrTWFwLGV0PW5ldyBXZWFrTWFwLEg9bmV3IFdlYWtNYXAsc3Q9bmV3IFdlYWtNYXAsaXQ9bmV3IFdlYWtNYXAscnQ9bmV3IFdlYWtNYXAsYXQ9bmV3IFdlYWtTZXQsUnQ9YXN5bmMgZnVuY3Rpb24oKXtpKHRoaXMsSyl8fChhd2FpdCBFKHRoaXMsSyxQcm9taXNlLnJlc29sdmUoKSksRSh0aGlzLEssbnVsbCksdGhpcy5sb2FkKCkpfTtRLmN1c3RvbUVsZW1lbnRzLmdldChcIm11eC12aWRlb1wiKXx8KFEuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibXV4LXZpZGVvXCIsdHQpLFEuTXV4VmlkZW9FbGVtZW50PXR0KTt2YXIgdHM9dHQ7ZXhwb3J0e2EgYXMgQXR0cmlidXRlcyxYZSBhcyBNZWRpYUVycm9yLEx0IGFzIFZpZGVvRXZlbnRzLHRzIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@mux/mux-video/dist/index.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@mux/playback-core/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@mux/playback-core/dist/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoplayTypes: function() { return /* binding */ k; },\n/* harmony export */   CmcdTypeValues: function() { return /* binding */ We; },\n/* harmony export */   CmcdTypes: function() { return /* binding */ C; },\n/* harmony export */   ExtensionMimeTypeMap: function() { return /* binding */ M; },\n/* harmony export */   Hls: function() { return /* binding */ l; },\n/* harmony export */   MediaError: function() { return /* binding */ T; },\n/* harmony export */   MimeTypeShorthandMap: function() { return /* binding */ A; },\n/* harmony export */   PlaybackTypes: function() { return /* binding */ D; },\n/* harmony export */   StreamTypes: function() { return /* binding */ g; },\n/* harmony export */   addCuePoints: function() { return /* binding */ Y; },\n/* harmony export */   addTextTrack: function() { return /* binding */ N; },\n/* harmony export */   allMediaTypes: function() { return /* binding */ Ke; },\n/* harmony export */   generatePlayerInitTime: function() { return /* binding */ mt; },\n/* harmony export */   generateUUID: function() { return /* binding */ ve; },\n/* harmony export */   getActiveCuePoint: function() { return /* binding */ X; },\n/* harmony export */   getCuePoints: function() { return /* binding */ fe; },\n/* harmony export */   getCuePointsTrack: function() { return /* binding */ S; },\n/* harmony export */   getCurrentPdt: function() { return /* binding */ Te; },\n/* harmony export */   getEnded: function() { return /* binding */ we; },\n/* harmony export */   getError: function() { return /* binding */ Mt; },\n/* harmony export */   getLiveEdgeStart: function() { return /* binding */ Pt; },\n/* harmony export */   getMediaPlaylistLinesFromMultivariantPlaylistSrc: function() { return /* binding */ me; },\n/* harmony export */   getSeekable: function() { return /* binding */ Se; },\n/* harmony export */   getStartDate: function() { return /* binding */ ye; },\n/* harmony export */   getStreamInfoFromHlsjsLevelDetails: function() { return /* binding */ be; },\n/* harmony export */   getStreamInfoFromPlaylistLines: function() { return /* binding */ ge; },\n/* harmony export */   getStreamInfoFromSrcAndType: function() { return /* binding */ Me; },\n/* harmony export */   getStreamType: function() { return /* binding */ bt; },\n/* harmony export */   getStreamTypeConfig: function() { return /* binding */ Ne; },\n/* harmony export */   getTargetLiveWindow: function() { return /* binding */ xt; },\n/* harmony export */   initialize: function() { return /* binding */ Et; },\n/* harmony export */   isKeyOf: function() { return /* binding */ h; },\n/* harmony export */   isMuxVideoSrc: function() { return /* binding */ oe; },\n/* harmony export */   isPseudoEnded: function() { return /* binding */ De; },\n/* harmony export */   loadMedia: function() { return /* binding */ Re; },\n/* harmony export */   mux: function() { return /* reexport default export from named module */ mux_embed__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   muxMediaState: function() { return /* binding */ f; },\n/* harmony export */   removeTextTrack: function() { return /* binding */ le; },\n/* harmony export */   setupCuePoints: function() { return /* binding */ $; },\n/* harmony export */   setupHls: function() { return /* binding */ Ie; },\n/* harmony export */   setupMux: function() { return /* binding */ _e; },\n/* harmony export */   shorthandKeys: function() { return /* binding */ Fe; },\n/* harmony export */   teardown: function() { return /* binding */ He; },\n/* harmony export */   toMuxVideoURL: function() { return /* binding */ gt; },\n/* harmony export */   updateStreamInfoFromHlsjsLevelDetails: function() { return /* binding */ xe; },\n/* harmony export */   updateStreamInfoFromSrc: function() { return /* binding */ G; }\n/* harmony export */ });\n/* harmony import */ var mux_embed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mux-embed */ \"(app-client)/./node_modules/mux-embed/dist/mux.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hls.js */ \"(app-client)/./node_modules/hls.js/dist/hls.mjs\");\nvar l=hls_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];var P=class extends Error{constructor(r,n=P.MEDIA_ERR_CUSTOM,o,a){var i;super(r);this.name=\"MediaError\",this.code=n,this.context=a,this.fatal=o!=null?o:n>=P.MEDIA_ERR_NETWORK&&n<=P.MEDIA_ERR_ENCRYPTED,this.message||(this.message=(i=P.defaultMessages[this.code])!=null?i:\"\")}},T=P;T.MEDIA_ERR_ABORTED=1,T.MEDIA_ERR_NETWORK=2,T.MEDIA_ERR_DECODE=3,T.MEDIA_ERR_SRC_NOT_SUPPORTED=4,T.MEDIA_ERR_ENCRYPTED=5,T.MEDIA_ERR_CUSTOM=100,T.defaultMessages={1:\"You aborted the media playback\",2:\"A network error caused the media download to fail.\",3:\"A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.\",4:\"An unsupported error occurred. The server or network failed, or your browser does not support this format.\",5:\"The media is encrypted and there are no keys to decrypt it.\"};var ue=e=>e==null,h=(e,t)=>ue(t)?!1:e in t,k={ANY:\"any\",MUTED:\"muted\"},g={ON_DEMAND:\"on-demand\",LIVE:\"live\",UNKNOWN:\"unknown\"},D={MSE:\"mse\",NATIVE:\"native\"},C={HEADER:\"header\",QUERY:\"query\",NONE:\"none\"},We=Object.values(C),M={M3U8:\"application/vnd.apple.mpegurl\",MP4:\"video/mp4\"},A={HLS:M.M3U8},Fe=Object.keys(A),Ke=[...Object.values(M),\"hls\",\"HLS\"];var m=(e,t,r,n,o=e)=>{o.addEventListener(t,r,n),e.addEventListener(\"teardown\",()=>{o.removeEventListener(t,r)},{once:!0})};function V(e,t,r){t&&r>t&&(r=t);for(let n=0;n<e.length;n++)if(e.start(n)<=r&&e.end(n)>=r)return!0;return!1}var W=e=>{let t=e.indexOf(\"?\");if(t<0)return[e];let r=e.slice(0,t),n=e.slice(t);return[r,n]},L=e=>{let t=e.type;if(t){let n=t.toUpperCase();return h(n,A)?A[n]:t}let{src:r}=e;return r?de(r):\"\"},w=e=>e===\"VOD\"?g.ON_DEMAND:g.LIVE,H=e=>e===\"EVENT\"?Number.POSITIVE_INFINITY:e===\"VOD\"?Number.NaN:0,de=e=>{let t=\"\";try{t=new URL(e).pathname}catch{console.error(\"invalid url\")}let r=t.lastIndexOf(\".\");if(r<0)return\"\";let o=t.slice(r+1).toUpperCase();return h(o,M)?M[o]:\"\"};var pe=Object.values(k),F=e=>typeof e==\"boolean\"||typeof e==\"string\"&&pe.includes(e),K=({autoplay:e},t,r)=>{let n=!1,o=!1,a=F(e)?e:!!e,i=()=>{n||m(t,\"playing\",()=>{n=!0},{once:!0})};if(i(),m(t,\"loadstart\",()=>{n=!1,i(),I(t,a)},{once:!0}),m(t,\"loadstart\",()=>{r||(o=!Number.isFinite(t.duration)),I(t,a)},{once:!0}),r&&r.once(l.Events.LEVEL_LOADED,(c,u)=>{var d;o=(d=u.details.live)!=null?d:!1}),!a){let c=()=>{!o||(r!=null&&r.liveSyncPosition?t.currentTime=r.liveSyncPosition:Number.isFinite(t.seekable.end(0))&&(t.currentTime=t.seekable.end(0)))};r&&m(t,\"play\",()=>{t.preload===\"metadata\"?r.once(l.Events.LEVEL_UPDATED,c):c()},{once:!0})}return c=>{n||(a=F(c)?c:!!c,I(t,a))}},I=(e,t)=>{if(!t)return;let r=e.muted,n=()=>e.muted=r;switch(t){case k.ANY:e.play().catch(()=>{e.muted=!0,e.play().catch(n)});break;case k.MUTED:e.muted=!0,e.play().catch(n);break;default:e.play().catch(()=>{});break}};var B=({preload:e,src:t},r,n)=>{let o=p=>{p!=null&&[\"\",\"none\",\"metadata\",\"auto\"].includes(p)?r.setAttribute(\"preload\",p):r.removeAttribute(\"preload\")};if(!n)return o(e),o;let a=!1,i=!1,s=n.config.maxBufferLength,c=n.config.maxBufferSize,u=p=>{o(p);let y=p!=null?p:r.preload;i||y===\"none\"||(y===\"metadata\"?(n.config.maxBufferLength=1,n.config.maxBufferSize=1):(n.config.maxBufferLength=s,n.config.maxBufferSize=c),d())},d=()=>{!a&&t&&(a=!0,n.loadSource(t))};return m(r,\"play\",()=>{i=!0,n.config.maxBufferLength=s,n.config.maxBufferSize=c,d()},{once:!0}),u(e),u};function q(e,t){t.on(l.Events.NON_NATIVE_TEXT_TRACKS_FOUND,(o,{tracks:a})=>{a.forEach(i=>{var u;let s=(u=i.subtitleTrack)!=null?u:i.closedCaptions,c=t.subtitleTracks.findIndex(({lang:d,name:p,type:y})=>d==(s==null?void 0:s.lang)&&p===i.label&&y.toLowerCase()===i.kind);N(e,i.kind,i.label,s==null?void 0:s.lang,`${i.kind}${c}`)})});let r=()=>{var i;if(!t.subtitleTracks.length)return;let o=Array.from(e.textTracks).find(s=>s.id&&s.mode===\"showing\"&&[\"subtitles\",\"captions\"].includes(s.kind)),a=`${(i=t.subtitleTracks[t.subtitleTrack])==null?void 0:i.type.toLowerCase()}${t.subtitleTrack}`;if(o&&(t.subtitleTrack<0||(o==null?void 0:o.id)!==a)){let s=t.subtitleTracks.findIndex(({lang:c,name:u,type:d})=>c==o.language&&u===o.label&&d.toLowerCase()===o.kind);t.subtitleTrack=s}o&&(o==null?void 0:o.id)===a&&o.cues&&Array.from(o.cues).forEach(s=>{o.addCue(s)})};e.textTracks.addEventListener(\"change\",r),t.on(l.Events.CUES_PARSED,(o,{track:a,cues:i})=>{let s=e.textTracks.getTrackById(a);if(!s)return;let c=s.mode===\"disabled\";c&&(s.mode=\"hidden\"),i.forEach(u=>{var d;(d=s.cues)!=null&&d.getCueById(u.id)||s.addCue(u)}),c&&(s.mode=\"disabled\")}),t.once(l.Events.DESTROYING,()=>{e.textTracks.removeEventListener(\"change\",r),e.querySelectorAll(\"track[data-removeondestroy]\").forEach(a=>{a.remove()})});let n=()=>{Array.from(e.textTracks).forEach(o=>{var a,i;if(![\"subtitles\",\"caption\"].includes(o.kind)&&o.label===\"thumbnails\"){if(!((a=o.cues)!=null&&a.length)){let s=e.querySelector('track[label=\"thumbnails\"]'),c=(i=s==null?void 0:s.getAttribute(\"src\"))!=null?i:\"\";s==null||s.removeAttribute(\"src\"),setTimeout(()=>{s==null||s.setAttribute(\"src\",c)},0)}o.mode!==\"hidden\"&&(o.mode=\"hidden\")}})};t.once(l.Events.MANIFEST_LOADED,n),t.once(l.Events.MEDIA_ATTACHED,n)}function N(e,t,r,n,o){let a=document.createElement(\"track\");return a.kind=t,a.label=r,n&&(a.srclang=n),o&&(a.id=o),a.track.mode=[\"subtitles\",\"captions\"].includes(t)?\"disabled\":\"hidden\",a.setAttribute(\"data-removeondestroy\",\"\"),e.append(a),a.track}function le(e,t){let r=Array.prototype.find.call(e.querySelectorAll(\"track\"),n=>n.track===t);r==null||r.remove()}var v=\"cuepoints\",_=Object.freeze({label:v}),S=(e,{label:t=v}=_)=>{var r;return(r=Array.from(e.querySelectorAll(\"track\")).find(n=>n.track.label===t&&n.track.kind===\"metadata\"))==null?void 0:r.track};async function Y(e,t,r=_){let n=S(e,r);if(!n){let{label:o=v}=r;n=N(e,\"metadata\",o),n.mode=\"hidden\",await new Promise(a=>setTimeout(()=>a(void 0),0))}return n.mode!==\"hidden\"&&(n.mode=\"hidden\"),[...t].sort(({time:o},{time:a})=>a-o).forEach(({time:o,value:a})=>{var p,y;let i=Array.prototype.findIndex.call(n==null?void 0:n.cues,b=>b.startTime>=o),s=(p=n==null?void 0:n.cues)==null?void 0:p[i],c=s?s.startTime:Number.isFinite(e.duration)?e.duration:Number.MAX_SAFE_INTEGER,u=(y=n==null?void 0:n.cues)==null?void 0:y[i-1];u&&(u.endTime=o);let d=new VTTCue(o,c,JSON.stringify(a!=null?a:null));n.addCue(d)}),n}var z=e=>({time:e.startTime,value:JSON.parse(e.text)});function fe(e,t={label:v}){let r=S(e,t);return r!=null&&r.cues?Array.from(r.cues,n=>z(n)):[]}function X(e,t={label:v}){var a,i;let r=S(e,t);if(!((a=r==null?void 0:r.activeCues)!=null&&a.length))return;let{currentTime:n}=e,o=Array.prototype.find.call((i=r.activeCues)!=null?i:[],({startTime:s,endTime:c})=>s<=n&&c>n);return z(o)}async function $(e,t=_){return new Promise(r=>{m(e,\"loadstart\",async()=>{let n=await Y(e,[],t);m(e,\"cuechange\",()=>{let o=X(e);if(o){let a=new CustomEvent(\"cuepointchange\",{composed:!0,bubbles:!0,detail:o});e.dispatchEvent(a)}},{},n),r(n)})})}function ye(e,t){if(t){let r=t.playingDate;if(r!=null)return new Date(r.getTime()-e.currentTime*1e3)}return typeof e.getStartDate==\"function\"?e.getStartDate():new Date(NaN)}function Te(e,t){if(t&&t.playingDate)return t.playingDate;if(typeof e.getStartDate==\"function\"){let r=e.getStartDate();return new Date(r.getTime()+e.currentTime*1e3)}return new Date(NaN)}var me=async e=>fetch(e).then(t=>t.text()).then(t=>{let r=t.split(`\n`).find((n,o,a)=>o&&a[o-1].startsWith(\"#EXT-X-STREAM-INF\"));return fetch(r).then(n=>n.text()).then(n=>n.split(`\n`))}),ge=e=>{var i,s;let r=(s=((i=e.find(c=>c.startsWith(\"#EXT-X-PLAYLIST-TYPE\")))!=null?i:\"\").split(\":\")[1])==null?void 0:s.trim(),n=w(r),o=H(r),a;if(n===g.LIVE){let c=e.find(d=>d.startsWith(\"#EXT-X-PART-INF\"));!!c?a=+c.split(\":\")[1].split(\"=\")[1]*2:a=+e.find(y=>y.startsWith(\"#EXT-X-TARGETDURATION\")).split(\":\")[1]*3}return{streamType:n,targetLiveWindow:o,liveEdgeStartOffset:a}},Me=async(e,t)=>{if(t===M.MP4)return{streamType:g.ON_DEMAND,targetLiveWindow:Number.NaN,liveEdgeStartOffset:void 0};if(t===M.M3U8){let r=await me(e);return ge(r)}return console.error(`Media type ${t} is an unrecognized or unsupported type for src ${e}.`),{streamType:void 0,targetLiveWindow:void 0,liveEdgeStartOffset:void 0}},G=async(e,t,r=L({src:e}))=>{var i,s,c;let{streamType:n,targetLiveWindow:o,liveEdgeStartOffset:a}=await Me(e,r);((i=f.get(t))!=null?i:{}).liveEdgeStartOffset=a,((s=f.get(t))!=null?s:{}).targetLiveWindow=o,t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\",{composed:!0,bubbles:!0})),((c=f.get(t))!=null?c:{}).streamType=n,t.dispatchEvent(new CustomEvent(\"streamtypechange\",{composed:!0,bubbles:!0}))},be=e=>{var i;let t=e.type,r=w(t),n=H(t),o,a=!!((i=e.partList)!=null&&i.length);return r===g.LIVE&&(o=a?e.partTarget*2:e.targetduration*3),{streamType:r,targetLiveWindow:n,liveEdgeStartOffset:o,lowLatency:a}},xe=(e,t,r)=>{var s,c,u,d,p,y,b,x;let{streamType:n,targetLiveWindow:o,liveEdgeStartOffset:a,lowLatency:i}=be(e);if(n===g.LIVE){i?(r.config.backBufferLength=(s=r.userConfig.backBufferLength)!=null?s:4,r.config.maxFragLookUpTolerance=(c=r.userConfig.maxFragLookUpTolerance)!=null?c:.001,r.config.abrBandWidthUpFactor=(u=r.userConfig.abrBandWidthUpFactor)!=null?u:r.config.abrBandWidthFactor):r.config.backBufferLength=(d=r.userConfig.backBufferLength)!=null?d:8;let ie=Object.freeze({get length(){return t.seekable.length},start(E){return t.seekable.start(E)},end(E){var U;return E>this.length?t.seekable.end(E):(U=r.liveSyncPosition)!=null?U:t.seekable.end(E)}});((p=f.get(t))!=null?p:{}).seekable=ie}((y=f.get(t))!=null?y:{}).liveEdgeStartOffset=a,((b=f.get(t))!=null?b:{}).targetLiveWindow=o,t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\",{composed:!0,bubbles:!0})),((x=f.get(t))!=null?x:{}).streamType=n,t.dispatchEvent(new CustomEvent(\"streamtypechange\",{composed:!0,bubbles:!0}))},J,Q,Pe=(Q=(J=globalThis==null?void 0:globalThis.navigator)==null?void 0:J.userAgent)!=null?Q:\"\",Ee=Pe.toLowerCase().indexOf(\"android\")!==-1,f=new WeakMap,ee=\"mux.com\",Z,j,te=(j=(Z=l).isSupported)==null?void 0:j.call(Z),Le=Ee,mt=()=>mux_embed__WEBPACK_IMPORTED_MODULE_0__.utils.now(),ve=mux_embed__WEBPACK_IMPORTED_MODULE_0__.utils.generateUUID,gt=(e,{domain:t=ee,maxResolution:r=\"\"}={})=>{if(!e)return;let[n,o=\"\"]=W(e),a=new URL(`https://stream.${t}/${n}.m3u8${o}`);return r&&a.searchParams.set(\"max_resolution\",r),a.toString()},ke=e=>{if(!e)return;let[t]=e.split(\"?\");return t||void 0},Ce=e=>{if(!e||!e.startsWith(\"https://stream.\"))return;let[t]=new URL(e).pathname.slice(1).split(\".m3u8\");return t||void 0},Ae=e=>{var t,r,n;return(t=e==null?void 0:e.metadata)!=null&&t.video_id?e.metadata.video_id:oe(e)&&(n=(r=ke(e.playbackId))!=null?r:Ce(e.src))!=null?n:e.src},Mt=e=>{var t;return(t=f.get(e))==null?void 0:t.error},bt=e=>{var t,r;return(r=(t=f.get(e))==null?void 0:t.streamType)!=null?r:g.UNKNOWN},xt=e=>{var t,r;return(r=(t=f.get(e))==null?void 0:t.targetLiveWindow)!=null?r:Number.NaN},Se=e=>{var t,r;return(r=(t=f.get(e))==null?void 0:t.seekable)!=null?r:e.seekable},Pt=e=>{var n;let t=(n=f.get(e))==null?void 0:n.liveEdgeStartOffset;if(typeof t!=\"number\")return Number.NaN;let r=Se(e);return r.length?r.end(r.length-1)-t:Number.NaN},he=(e,t,r=.001)=>Math.abs(e-t)<=r,re=(e,t,r=.001)=>e>t||he(e,t,r),De=e=>e.paused&&re(e.currentTime,e.duration),we=(e,t)=>e.loop||!!t?e.ended:e.ended||De(e),Et=(e,t,r)=>{He(t,r);let{metadata:n={}}=e,{view_session_id:o=ve()}=n,a=Ae(e);n.view_session_id=o,n.video_id=a,e.metadata=n,f.set(t,{});let i=Ie(e,t);_e(e,t,i),Re(e,t,i),$(t);let s=K(e,t,i),c=B(e,t,i);return{engine:i,setAutoplay:s,setPreload:c}},He=(e,t)=>{let r=t==null?void 0:t.engine;r&&(r.detachMedia(),r.destroy()),(e==null?void 0:e.mux)&&!e.mux.deleted&&(e.mux.destroy(),delete e.mux),e&&(e.removeAttribute(\"src\"),e.load(),e.removeEventListener(\"error\",se),e.removeEventListener(\"error\",R),e.removeEventListener(\"durationchange\",ae),f.delete(e),e.dispatchEvent(new Event(\"teardown\")))};function ne(e,t){var u;let r=L(e);if(!(r===M.M3U8))return!0;let o=!r||((u=t.canPlayType(r))!=null?u:!0),{preferPlayback:a}=e,i=a===D.MSE,s=a===D.NATIVE;return o&&(s||!(te&&(i||Le)))}var Ie=(e,t)=>{let{debug:r,streamType:n,startTime:o=-1,metadata:a,preferCmcd:i}=e,c=L(e)===M.M3U8,u=ne(e,t);if(c&&!u&&te){let d={backBufferLength:30,renderTextTracksNatively:!1,liveDurationInfinity:!0,capLevelToPlayerSize:!0,capLevelOnFPSDrop:!0},p=Ne(n),y=i!==C.NONE?{useHeaders:i===C.HEADER,sessionId:a==null?void 0:a.view_session_id,contentId:a==null?void 0:a.video_id}:void 0;return new l({debug:r,startPosition:o,cmcd:y,...d,...p})}},Ne=e=>e===g.LIVE?{backBufferLength:8}:{},oe=({playbackId:e,src:t,customDomain:r})=>{if(e)return!0;if(typeof t!=\"string\")return!1;let n=window==null?void 0:window.location.href,o=new URL(t,n).hostname.toLocaleLowerCase();return o.includes(ee)||!!r&&o.includes(r.toLocaleLowerCase())},_e=(e,t,r)=>{var a;let{envKey:n}=e,o=oe(e);if(n||o){let{playerInitTime:i,playerSoftwareName:s,playerSoftwareVersion:c,beaconCollectionDomain:u,debug:d,disableCookies:p}=e,y={...e.metadata,video_title:((a=e==null?void 0:e.metadata)==null?void 0:a.video_title)||void 0},b=x=>typeof x.player_error_code==\"string\"?!1:typeof e.errorTranslator==\"function\"?e.errorTranslator(x):x;mux_embed__WEBPACK_IMPORTED_MODULE_0__.monitor(t,{debug:d,beaconCollectionDomain:u,hlsjs:r,Hls:r?l:void 0,automaticErrorTracking:!1,errorTranslator:b,disableCookies:p,data:{...n?{env_key:n}:{},player_software_name:s,player_software:s,player_software_version:c,player_init_time:i,...y}})}},Re=(e,t,r)=>{var a;let n=ne(e,t),{src:o}=e;if(t&&n){let i=L(e);typeof o==\"string\"?(t.preload===\"none\"?m(t,\"loadstart\",()=>G(o,t,i)):G(o,t,i),t.setAttribute(\"src\",o),e.startTime&&(((a=f.get(t))!=null?a:{}).startTime=e.startTime,t.addEventListener(\"durationchange\",ae,{once:!0}))):t.removeAttribute(\"src\"),t.addEventListener(\"error\",se),t.addEventListener(\"error\",R),t.addEventListener(\"emptied\",()=>{t.querySelectorAll(\"track[data-removeondestroy]\").forEach(u=>{u.remove()})},{once:!0});let s=()=>{t.ended||!we(t)||t.dispatchEvent(new Event(\"ended\"))};m(t,\"pause\",s),m(t,\"seeked\",s),m(t,\"play\",()=>{t.ended||!re(t.currentTime,t.duration)||(t.currentTime=t.seekable.start(0))})}else r&&o?(r.once(l.Events.LEVEL_LOADED,(i,s)=>{xe(s.details,t,r)}),r.on(l.Events.ERROR,(i,s)=>{let c={[l.ErrorTypes.NETWORK_ERROR]:T.MEDIA_ERR_NETWORK,[l.ErrorTypes.MEDIA_ERROR]:T.MEDIA_ERR_DECODE},u=new T(\"\",c[s.type]);u.fatal=s.fatal,u.data=s,t.dispatchEvent(new CustomEvent(\"error\",{detail:u}))}),t.addEventListener(\"error\",R),q(t,r),r.attachMedia(t)):console.error(\"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\")};function ae(e){var n;let t=e.target,r=(n=f.get(t))==null?void 0:n.startTime;if(!!r&&V(t.seekable,t.duration,r)){let o=t.preload===\"auto\";o&&(t.preload=\"none\"),t.currentTime=r,o&&(t.preload=\"auto\")}}async function se(e){if(!e.isTrusted)return;e.stopImmediatePropagation();let t=e.target;if(!(t!=null&&t.error))return;let{message:r,code:n}=t.error,o=new T(r,n);if(t.src&&(n!==T.MEDIA_ERR_DECODE||n!==void 0))try{let{status:a}=await fetch(t.src);o.data={response:{code:a}}}catch{}t.dispatchEvent(new CustomEvent(\"error\",{detail:o}))}function R(e){var n,o;if(!(e instanceof CustomEvent)||!(e.detail instanceof T))return;let t=e.target,r=e.detail;!r||!r.fatal||(((n=f.get(t))!=null?n:{}).error=r,(o=t.mux)==null||o.emit(\"error\",{player_error_code:r.code,player_error_message:r.message,player_error_context:r.context}))}\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BtdXgvcGxheWJhY2stY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0QsTUFBTSw4Q0FBRSxDQUFDLDBCQUEwQix3Q0FBd0MsTUFBTSxTQUFTLGtNQUFrTSxLQUFLLG1LQUFtSyxvWUFBb1ksOENBQThDLHdCQUF3QixJQUFJLG9EQUFvRCxJQUFJLDBCQUEwQixJQUFJLDBDQUEwQyx3QkFBd0IscURBQXFELElBQUksV0FBVyx3REFBd0Qsc0JBQXNCLDZEQUE2RCwyQkFBMkIsRUFBRSxRQUFRLEdBQUcsa0JBQWtCLGNBQWMsWUFBWSxXQUFXLDJDQUEyQyxTQUFTLFVBQVUscUJBQXFCLGlCQUFpQixnQ0FBZ0MsWUFBWSxPQUFPLGFBQWEsTUFBTSxzQkFBc0IscUJBQXFCLElBQUksTUFBTSxHQUFHLGtCQUFrQiwyR0FBMkcsU0FBUyxJQUFJLHNCQUFzQixNQUFNLDZCQUE2Qix5QkFBeUIsZ0JBQWdCLGlDQUFpQyx1QkFBdUIseUZBQXlGLFdBQVcsUUFBUSxrQ0FBa0Msc0JBQXNCLEtBQUssRUFBRSxRQUFRLEdBQUcsNEJBQTRCLGdCQUFnQixFQUFFLFFBQVEsdUJBQXVCLDJDQUEyQyxFQUFFLFFBQVEsMENBQTBDLE1BQU0sZ0NBQWdDLE1BQU0sV0FBVywwSUFBMEksbUJBQW1CLDREQUE0RCxFQUFFLFFBQVEsRUFBRSxXQUFXLDBCQUEwQixXQUFXLGFBQWEsOEJBQThCLFVBQVUsK0JBQStCLDZCQUE2QixFQUFFLE1BQU0sMENBQTBDLE1BQU0sNkJBQTZCLEVBQUUsUUFBUSxRQUFRLGdCQUFnQixRQUFRLFVBQVUsNkdBQTZHLG9CQUFvQix3RUFBd0UsS0FBSywwQkFBMEIsZ0pBQWdKLFFBQVEsK0JBQStCLHVCQUF1Qiw2REFBNkQsRUFBRSxRQUFRLFVBQVUsZ0JBQWdCLCtDQUErQyxTQUFTLElBQUksY0FBYyxNQUFNLGtGQUFrRixxQkFBcUIsc0VBQXNFLDRDQUE0QyxPQUFPLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxXQUFXLE1BQU0sbUNBQW1DLGlIQUFpSCx3RUFBd0UsRUFBRSxnQkFBZ0IsRUFBRSxzREFBc0QsbUNBQW1DLHFCQUFxQix5REFBeUQsa0JBQWtCLHFFQUFxRSxZQUFZLEdBQUcsd0VBQXdFLGVBQWUsSUFBSSxtQ0FBbUMsYUFBYSwwQkFBMEIsbUNBQW1DLE1BQU0sa0RBQWtELHlCQUF5QixrQ0FBa0MsMkdBQTJHLFdBQVcsRUFBRSxFQUFFLFdBQVcscUNBQXFDLFFBQVEsc0VBQXNFLGtDQUFrQyx5R0FBeUcsa0RBQWtELGlDQUFpQyxJQUFJLHNDQUFzQyxHQUFHLHFFQUFxRSxzQkFBc0Isc0NBQXNDLDJMQUEyTCxpQkFBaUIsNEVBQTRFLG9CQUFvQixtQ0FBbUMsUUFBUSxRQUFRLFVBQVUsTUFBTSxNQUFNLDhIQUE4SCwwQkFBMEIsYUFBYSxPQUFPLElBQUksVUFBVSxHQUFHLHNGQUFzRiwwREFBMEQsT0FBTyxFQUFFLE9BQU8sa0JBQWtCLGVBQWUsSUFBSSxRQUFRLDJQQUEyUCxpQkFBaUIscURBQXFELFlBQVksSUFBSSxXQUFXLDBDQUEwQyxFQUFFLGlCQUFpQixRQUFRLEVBQUUsYUFBYSxxREFBcUQsZ0JBQWdCLFFBQVEsRUFBRSxRQUFRLGFBQWEsNkRBQTZELElBQUksY0FBYyw2REFBNkQsc0JBQXNCLGNBQWMsWUFBWSx3QkFBd0IsdUJBQXVCLDBCQUEwQixzQkFBc0IscUJBQXFCLFdBQVcsTUFBTSx3Q0FBd0MsZ0NBQWdDLEVBQUUsb0JBQW9CLEdBQUcsU0FBUyxFQUFFLEVBQUUsaUJBQWlCLE1BQU0sb0JBQW9CLDBEQUEwRCx3RUFBd0UsaUJBQWlCLHlDQUF5QyxzQ0FBc0MsdUJBQXVCLCtDQUErQyxxQkFBcUIsb0RBQW9EO0FBQ25yTyw0REFBNEQ7QUFDNUQsSUFBSSxTQUFTLFFBQVEsK0hBQStILGVBQWUsaURBQWlELDJHQUEyRyxPQUFPLHVEQUF1RCxpQkFBaUIsb0JBQW9CLCtFQUErRSxlQUFlLGtCQUFrQixhQUFhLG1DQUFtQyxHQUFHLGlEQUFpRCxFQUFFLEtBQUssc0VBQXNFLGtCQUFrQixNQUFNLEtBQUssVUFBVSxJQUFJLHNEQUFzRCxlQUFlLHdCQUF3QixnREFBZ0QsK0VBQStFLHVCQUF1QiwyQkFBMkIsbUVBQW1FLHVCQUF1QixHQUFHLFFBQVEsTUFBTSxrRUFBa0UsNERBQTRELG9FQUFvRSxjQUFjLG9CQUFvQixJQUFJLG1FQUFtRSxPQUFPLGVBQWUsNlVBQTZVLHNCQUFzQixhQUFhLHlCQUF5QixVQUFVLDJCQUEyQixRQUFRLE1BQU0seUZBQXlGLEVBQUUsd0JBQXdCLGNBQWMsd0JBQXdCLGdEQUFnRCwrRUFBK0UsdUJBQXVCLDJCQUEyQixtRUFBbUUsdUJBQXVCLEdBQUcseU9BQXlPLDRDQUFPLFVBQVUsNENBQU8scUJBQXFCLCtCQUErQixHQUFHLElBQUksYUFBYSw2Q0FBNkMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsOERBQThELFFBQVEsYUFBYSxvQkFBb0IsaUJBQWlCLFFBQVEsK0NBQStDLG1EQUFtRCxpQkFBaUIsUUFBUSxVQUFVLDBJQUEwSSxRQUFRLE1BQU0sd0NBQXdDLFFBQVEsUUFBUSxtRUFBbUUsUUFBUSxRQUFRLDBFQUEwRSxRQUFRLFFBQVEsa0VBQWtFLFFBQVEsTUFBTSxzREFBc0Qsd0NBQXdDLFlBQVksK0NBQStDLDBLQUEwSyxRQUFRLElBQUksY0FBYyxJQUFJLHVCQUF1QixXQUFXLHdEQUF3RCxFQUFFLGNBQWMseUJBQXlCLDBCQUEwQixPQUFPLHFDQUFxQyxZQUFZLDhCQUE4QixpVEFBaVQsaUJBQWlCLE1BQU0sV0FBVywwQkFBMEIsNkNBQTZDLGlCQUFpQiw4QkFBOEIsOEJBQThCLGVBQWUsSUFBSSw0REFBNEQsNkJBQTZCLGNBQWMsT0FBTyxxSEFBcUgsdUJBQXVCLHVHQUF1RyxRQUFRLGNBQWMseUNBQXlDLEdBQUcsbUJBQW1CLG1CQUFtQixHQUFHLE1BQU0sa0NBQWtDLElBQUksY0FBYywrQkFBK0IsMkZBQTJGLDhEQUE4RCxjQUFjLE1BQU0sSUFBSSxTQUFTLFdBQVcsU0FBUyxJQUFJLGdIQUFnSCxNQUFNLDZGQUE2RiwwR0FBMEcsOENBQVMsSUFBSSwySEFBMkgsTUFBTSxVQUFVLEdBQUcsNkZBQTZGLEdBQUcsY0FBYyxNQUFNLGVBQWUsTUFBTSxHQUFHLFNBQVMsV0FBVyw0SUFBNEksZ0VBQWdFLFFBQVEsNEhBQTRILDhEQUE4RCxXQUFXLEVBQUUsRUFBRSxRQUFRLEVBQUUsV0FBVyxzREFBc0QsK0NBQStDLDRFQUE0RSxFQUFFLGdEQUFnRCxrQkFBa0IsOEJBQThCLE9BQU8sK0ZBQStGLHVCQUF1QixrRUFBa0UsU0FBUyxHQUFHLHNPQUFzTyxlQUFlLE1BQU0sdURBQXVELG9DQUFvQyx5QkFBeUIsNkRBQTZELHFCQUFxQix1QkFBdUIsNkJBQTZCLGVBQWUsOEJBQThCLElBQUksaUJBQWlCLHNCQUFzQixtREFBbUQsSUFBSSxTQUFTLG9CQUFvQixRQUFRLFVBQVUsU0FBUyxPQUFPLHlDQUF5QyxTQUFTLEdBQUcsY0FBYyxRQUFRLGdFQUFnRSwwQkFBMEIsdUNBQXVDLDJDQUEyQyx1RkFBdUYsR0FBbS9CO0FBQ3ZyUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG11eC9wbGF5YmFjay1jb3JlL2Rpc3QvaW5kZXgubWpzP2ZjY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE8gZnJvbVwibXV4LWVtYmVkXCI7aW1wb3J0IGNlIGZyb21cImhscy5qc1wiO3ZhciBsPWNlO3ZhciBQPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IocixuPVAuTUVESUFfRVJSX0NVU1RPTSxvLGEpe3ZhciBpO3N1cGVyKHIpO3RoaXMubmFtZT1cIk1lZGlhRXJyb3JcIix0aGlzLmNvZGU9bix0aGlzLmNvbnRleHQ9YSx0aGlzLmZhdGFsPW8hPW51bGw/bzpuPj1QLk1FRElBX0VSUl9ORVRXT1JLJiZuPD1QLk1FRElBX0VSUl9FTkNSWVBURUQsdGhpcy5tZXNzYWdlfHwodGhpcy5tZXNzYWdlPShpPVAuZGVmYXVsdE1lc3NhZ2VzW3RoaXMuY29kZV0pIT1udWxsP2k6XCJcIil9fSxUPVA7VC5NRURJQV9FUlJfQUJPUlRFRD0xLFQuTUVESUFfRVJSX05FVFdPUks9MixULk1FRElBX0VSUl9ERUNPREU9MyxULk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRD00LFQuTUVESUFfRVJSX0VOQ1JZUFRFRD01LFQuTUVESUFfRVJSX0NVU1RPTT0xMDAsVC5kZWZhdWx0TWVzc2FnZXM9ezE6XCJZb3UgYWJvcnRlZCB0aGUgbWVkaWEgcGxheWJhY2tcIiwyOlwiQSBuZXR3b3JrIGVycm9yIGNhdXNlZCB0aGUgbWVkaWEgZG93bmxvYWQgdG8gZmFpbC5cIiwzOlwiQSBtZWRpYSBlcnJvciBjYXVzZWQgcGxheWJhY2sgdG8gYmUgYWJvcnRlZC4gVGhlIG1lZGlhIGNvdWxkIGJlIGNvcnJ1cHQgb3IgeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBmb3JtYXQuXCIsNDpcIkFuIHVuc3VwcG9ydGVkIGVycm9yIG9jY3VycmVkLiBUaGUgc2VydmVyIG9yIG5ldHdvcmsgZmFpbGVkLCBvciB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIGZvcm1hdC5cIiw1OlwiVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgdGhlcmUgYXJlIG5vIGtleXMgdG8gZGVjcnlwdCBpdC5cIn07dmFyIHVlPWU9PmU9PW51bGwsaD0oZSx0KT0+dWUodCk/ITE6ZSBpbiB0LGs9e0FOWTpcImFueVwiLE1VVEVEOlwibXV0ZWRcIn0sZz17T05fREVNQU5EOlwib24tZGVtYW5kXCIsTElWRTpcImxpdmVcIixVTktOT1dOOlwidW5rbm93blwifSxEPXtNU0U6XCJtc2VcIixOQVRJVkU6XCJuYXRpdmVcIn0sQz17SEVBREVSOlwiaGVhZGVyXCIsUVVFUlk6XCJxdWVyeVwiLE5PTkU6XCJub25lXCJ9LFdlPU9iamVjdC52YWx1ZXMoQyksTT17TTNVODpcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCIsTVA0OlwidmlkZW8vbXA0XCJ9LEE9e0hMUzpNLk0zVTh9LEZlPU9iamVjdC5rZXlzKEEpLEtlPVsuLi5PYmplY3QudmFsdWVzKE0pLFwiaGxzXCIsXCJITFNcIl07dmFyIG09KGUsdCxyLG4sbz1lKT0+e28uYWRkRXZlbnRMaXN0ZW5lcih0LHIsbiksZS5hZGRFdmVudExpc3RlbmVyKFwidGVhcmRvd25cIiwoKT0+e28ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LHIpfSx7b25jZTohMH0pfTtmdW5jdGlvbiBWKGUsdCxyKXt0JiZyPnQmJihyPXQpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKGUuc3RhcnQobik8PXImJmUuZW5kKG4pPj1yKXJldHVybiEwO3JldHVybiExfXZhciBXPWU9PntsZXQgdD1lLmluZGV4T2YoXCI/XCIpO2lmKHQ8MClyZXR1cm5bZV07bGV0IHI9ZS5zbGljZSgwLHQpLG49ZS5zbGljZSh0KTtyZXR1cm5bcixuXX0sTD1lPT57bGV0IHQ9ZS50eXBlO2lmKHQpe2xldCBuPXQudG9VcHBlckNhc2UoKTtyZXR1cm4gaChuLEEpP0Fbbl06dH1sZXR7c3JjOnJ9PWU7cmV0dXJuIHI/ZGUocik6XCJcIn0sdz1lPT5lPT09XCJWT0RcIj9nLk9OX0RFTUFORDpnLkxJVkUsSD1lPT5lPT09XCJFVkVOVFwiP051bWJlci5QT1NJVElWRV9JTkZJTklUWTplPT09XCJWT0RcIj9OdW1iZXIuTmFOOjAsZGU9ZT0+e2xldCB0PVwiXCI7dHJ5e3Q9bmV3IFVSTChlKS5wYXRobmFtZX1jYXRjaHtjb25zb2xlLmVycm9yKFwiaW52YWxpZCB1cmxcIil9bGV0IHI9dC5sYXN0SW5kZXhPZihcIi5cIik7aWYocjwwKXJldHVyblwiXCI7bGV0IG89dC5zbGljZShyKzEpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGgobyxNKT9NW29dOlwiXCJ9O3ZhciBwZT1PYmplY3QudmFsdWVzKGspLEY9ZT0+dHlwZW9mIGU9PVwiYm9vbGVhblwifHx0eXBlb2YgZT09XCJzdHJpbmdcIiYmcGUuaW5jbHVkZXMoZSksSz0oe2F1dG9wbGF5OmV9LHQscik9PntsZXQgbj0hMSxvPSExLGE9RihlKT9lOiEhZSxpPSgpPT57bnx8bSh0LFwicGxheWluZ1wiLCgpPT57bj0hMH0se29uY2U6ITB9KX07aWYoaSgpLG0odCxcImxvYWRzdGFydFwiLCgpPT57bj0hMSxpKCksSSh0LGEpfSx7b25jZTohMH0pLG0odCxcImxvYWRzdGFydFwiLCgpPT57cnx8KG89IU51bWJlci5pc0Zpbml0ZSh0LmR1cmF0aW9uKSksSSh0LGEpfSx7b25jZTohMH0pLHImJnIub25jZShsLkV2ZW50cy5MRVZFTF9MT0FERUQsKGMsdSk9Pnt2YXIgZDtvPShkPXUuZGV0YWlscy5saXZlKSE9bnVsbD9kOiExfSksIWEpe2xldCBjPSgpPT57IW98fChyIT1udWxsJiZyLmxpdmVTeW5jUG9zaXRpb24/dC5jdXJyZW50VGltZT1yLmxpdmVTeW5jUG9zaXRpb246TnVtYmVyLmlzRmluaXRlKHQuc2Vla2FibGUuZW5kKDApKSYmKHQuY3VycmVudFRpbWU9dC5zZWVrYWJsZS5lbmQoMCkpKX07ciYmbSh0LFwicGxheVwiLCgpPT57dC5wcmVsb2FkPT09XCJtZXRhZGF0YVwiP3Iub25jZShsLkV2ZW50cy5MRVZFTF9VUERBVEVELGMpOmMoKX0se29uY2U6ITB9KX1yZXR1cm4gYz0+e258fChhPUYoYyk/YzohIWMsSSh0LGEpKX19LEk9KGUsdCk9PntpZighdClyZXR1cm47bGV0IHI9ZS5tdXRlZCxuPSgpPT5lLm11dGVkPXI7c3dpdGNoKHQpe2Nhc2Ugay5BTlk6ZS5wbGF5KCkuY2F0Y2goKCk9PntlLm11dGVkPSEwLGUucGxheSgpLmNhdGNoKG4pfSk7YnJlYWs7Y2FzZSBrLk1VVEVEOmUubXV0ZWQ9ITAsZS5wbGF5KCkuY2F0Y2gobik7YnJlYWs7ZGVmYXVsdDplLnBsYXkoKS5jYXRjaCgoKT0+e30pO2JyZWFrfX07dmFyIEI9KHtwcmVsb2FkOmUsc3JjOnR9LHIsbik9PntsZXQgbz1wPT57cCE9bnVsbCYmW1wiXCIsXCJub25lXCIsXCJtZXRhZGF0YVwiLFwiYXV0b1wiXS5pbmNsdWRlcyhwKT9yLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIixwKTpyLnJlbW92ZUF0dHJpYnV0ZShcInByZWxvYWRcIil9O2lmKCFuKXJldHVybiBvKGUpLG87bGV0IGE9ITEsaT0hMSxzPW4uY29uZmlnLm1heEJ1ZmZlckxlbmd0aCxjPW4uY29uZmlnLm1heEJ1ZmZlclNpemUsdT1wPT57byhwKTtsZXQgeT1wIT1udWxsP3A6ci5wcmVsb2FkO2l8fHk9PT1cIm5vbmVcInx8KHk9PT1cIm1ldGFkYXRhXCI/KG4uY29uZmlnLm1heEJ1ZmZlckxlbmd0aD0xLG4uY29uZmlnLm1heEJ1ZmZlclNpemU9MSk6KG4uY29uZmlnLm1heEJ1ZmZlckxlbmd0aD1zLG4uY29uZmlnLm1heEJ1ZmZlclNpemU9YyksZCgpKX0sZD0oKT0+eyFhJiZ0JiYoYT0hMCxuLmxvYWRTb3VyY2UodCkpfTtyZXR1cm4gbShyLFwicGxheVwiLCgpPT57aT0hMCxuLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGg9cyxuLmNvbmZpZy5tYXhCdWZmZXJTaXplPWMsZCgpfSx7b25jZTohMH0pLHUoZSksdX07ZnVuY3Rpb24gcShlLHQpe3Qub24obC5FdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwobyx7dHJhY2tzOmF9KT0+e2EuZm9yRWFjaChpPT57dmFyIHU7bGV0IHM9KHU9aS5zdWJ0aXRsZVRyYWNrKSE9bnVsbD91OmkuY2xvc2VkQ2FwdGlvbnMsYz10LnN1YnRpdGxlVHJhY2tzLmZpbmRJbmRleCgoe2xhbmc6ZCxuYW1lOnAsdHlwZTp5fSk9PmQ9PShzPT1udWxsP3ZvaWQgMDpzLmxhbmcpJiZwPT09aS5sYWJlbCYmeS50b0xvd2VyQ2FzZSgpPT09aS5raW5kKTtOKGUsaS5raW5kLGkubGFiZWwscz09bnVsbD92b2lkIDA6cy5sYW5nLGAke2kua2luZH0ke2N9YCl9KX0pO2xldCByPSgpPT57dmFyIGk7aWYoIXQuc3VidGl0bGVUcmFja3MubGVuZ3RoKXJldHVybjtsZXQgbz1BcnJheS5mcm9tKGUudGV4dFRyYWNrcykuZmluZChzPT5zLmlkJiZzLm1vZGU9PT1cInNob3dpbmdcIiYmW1wic3VidGl0bGVzXCIsXCJjYXB0aW9uc1wiXS5pbmNsdWRlcyhzLmtpbmQpKSxhPWAkeyhpPXQuc3VidGl0bGVUcmFja3NbdC5zdWJ0aXRsZVRyYWNrXSk9PW51bGw/dm9pZCAwOmkudHlwZS50b0xvd2VyQ2FzZSgpfSR7dC5zdWJ0aXRsZVRyYWNrfWA7aWYobyYmKHQuc3VidGl0bGVUcmFjazwwfHwobz09bnVsbD92b2lkIDA6by5pZCkhPT1hKSl7bGV0IHM9dC5zdWJ0aXRsZVRyYWNrcy5maW5kSW5kZXgoKHtsYW5nOmMsbmFtZTp1LHR5cGU6ZH0pPT5jPT1vLmxhbmd1YWdlJiZ1PT09by5sYWJlbCYmZC50b0xvd2VyQ2FzZSgpPT09by5raW5kKTt0LnN1YnRpdGxlVHJhY2s9c31vJiYobz09bnVsbD92b2lkIDA6by5pZCk9PT1hJiZvLmN1ZXMmJkFycmF5LmZyb20oby5jdWVzKS5mb3JFYWNoKHM9PntvLmFkZEN1ZShzKX0pfTtlLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHIpLHQub24obC5FdmVudHMuQ1VFU19QQVJTRUQsKG8se3RyYWNrOmEsY3VlczppfSk9PntsZXQgcz1lLnRleHRUcmFja3MuZ2V0VHJhY2tCeUlkKGEpO2lmKCFzKXJldHVybjtsZXQgYz1zLm1vZGU9PT1cImRpc2FibGVkXCI7YyYmKHMubW9kZT1cImhpZGRlblwiKSxpLmZvckVhY2godT0+e3ZhciBkOyhkPXMuY3VlcykhPW51bGwmJmQuZ2V0Q3VlQnlJZCh1LmlkKXx8cy5hZGRDdWUodSl9KSxjJiYocy5tb2RlPVwiZGlzYWJsZWRcIil9KSx0Lm9uY2UobC5FdmVudHMuREVTVFJPWUlORywoKT0+e2UudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsciksZS5xdWVyeVNlbGVjdG9yQWxsKFwidHJhY2tbZGF0YS1yZW1vdmVvbmRlc3Ryb3ldXCIpLmZvckVhY2goYT0+e2EucmVtb3ZlKCl9KX0pO2xldCBuPSgpPT57QXJyYXkuZnJvbShlLnRleHRUcmFja3MpLmZvckVhY2gobz0+e3ZhciBhLGk7aWYoIVtcInN1YnRpdGxlc1wiLFwiY2FwdGlvblwiXS5pbmNsdWRlcyhvLmtpbmQpJiZvLmxhYmVsPT09XCJ0aHVtYm5haWxzXCIpe2lmKCEoKGE9by5jdWVzKSE9bnVsbCYmYS5sZW5ndGgpKXtsZXQgcz1lLnF1ZXJ5U2VsZWN0b3IoJ3RyYWNrW2xhYmVsPVwidGh1bWJuYWlsc1wiXScpLGM9KGk9cz09bnVsbD92b2lkIDA6cy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpIT1udWxsP2k6XCJcIjtzPT1udWxsfHxzLnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKSxzZXRUaW1lb3V0KCgpPT57cz09bnVsbHx8cy5zZXRBdHRyaWJ1dGUoXCJzcmNcIixjKX0sMCl9by5tb2RlIT09XCJoaWRkZW5cIiYmKG8ubW9kZT1cImhpZGRlblwiKX19KX07dC5vbmNlKGwuRXZlbnRzLk1BTklGRVNUX0xPQURFRCxuKSx0Lm9uY2UobC5FdmVudHMuTUVESUFfQVRUQUNIRUQsbil9ZnVuY3Rpb24gTihlLHQscixuLG8pe2xldCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0cmFja1wiKTtyZXR1cm4gYS5raW5kPXQsYS5sYWJlbD1yLG4mJihhLnNyY2xhbmc9biksbyYmKGEuaWQ9byksYS50cmFjay5tb2RlPVtcInN1YnRpdGxlc1wiLFwiY2FwdGlvbnNcIl0uaW5jbHVkZXModCk/XCJkaXNhYmxlZFwiOlwiaGlkZGVuXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbW92ZW9uZGVzdHJveVwiLFwiXCIpLGUuYXBwZW5kKGEpLGEudHJhY2t9ZnVuY3Rpb24gbGUoZSx0KXtsZXQgcj1BcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUucXVlcnlTZWxlY3RvckFsbChcInRyYWNrXCIpLG49Pm4udHJhY2s9PT10KTtyPT1udWxsfHxyLnJlbW92ZSgpfXZhciB2PVwiY3VlcG9pbnRzXCIsXz1PYmplY3QuZnJlZXplKHtsYWJlbDp2fSksUz0oZSx7bGFiZWw6dD12fT1fKT0+e3ZhciByO3JldHVybihyPUFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKFwidHJhY2tcIikpLmZpbmQobj0+bi50cmFjay5sYWJlbD09PXQmJm4udHJhY2sua2luZD09PVwibWV0YWRhdGFcIikpPT1udWxsP3ZvaWQgMDpyLnRyYWNrfTthc3luYyBmdW5jdGlvbiBZKGUsdCxyPV8pe2xldCBuPVMoZSxyKTtpZighbil7bGV0e2xhYmVsOm89dn09cjtuPU4oZSxcIm1ldGFkYXRhXCIsbyksbi5tb2RlPVwiaGlkZGVuXCIsYXdhaXQgbmV3IFByb21pc2UoYT0+c2V0VGltZW91dCgoKT0+YSh2b2lkIDApLDApKX1yZXR1cm4gbi5tb2RlIT09XCJoaWRkZW5cIiYmKG4ubW9kZT1cImhpZGRlblwiKSxbLi4udF0uc29ydCgoe3RpbWU6b30se3RpbWU6YX0pPT5hLW8pLmZvckVhY2goKHt0aW1lOm8sdmFsdWU6YX0pPT57dmFyIHAseTtsZXQgaT1BcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwobj09bnVsbD92b2lkIDA6bi5jdWVzLGI9PmIuc3RhcnRUaW1lPj1vKSxzPShwPW49PW51bGw/dm9pZCAwOm4uY3Vlcyk9PW51bGw/dm9pZCAwOnBbaV0sYz1zP3Muc3RhcnRUaW1lOk51bWJlci5pc0Zpbml0ZShlLmR1cmF0aW9uKT9lLmR1cmF0aW9uOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLHU9KHk9bj09bnVsbD92b2lkIDA6bi5jdWVzKT09bnVsbD92b2lkIDA6eVtpLTFdO3UmJih1LmVuZFRpbWU9byk7bGV0IGQ9bmV3IFZUVEN1ZShvLGMsSlNPTi5zdHJpbmdpZnkoYSE9bnVsbD9hOm51bGwpKTtuLmFkZEN1ZShkKX0pLG59dmFyIHo9ZT0+KHt0aW1lOmUuc3RhcnRUaW1lLHZhbHVlOkpTT04ucGFyc2UoZS50ZXh0KX0pO2Z1bmN0aW9uIGZlKGUsdD17bGFiZWw6dn0pe2xldCByPVMoZSx0KTtyZXR1cm4gciE9bnVsbCYmci5jdWVzP0FycmF5LmZyb20oci5jdWVzLG49PnoobikpOltdfWZ1bmN0aW9uIFgoZSx0PXtsYWJlbDp2fSl7dmFyIGEsaTtsZXQgcj1TKGUsdCk7aWYoISgoYT1yPT1udWxsP3ZvaWQgMDpyLmFjdGl2ZUN1ZXMpIT1udWxsJiZhLmxlbmd0aCkpcmV0dXJuO2xldHtjdXJyZW50VGltZTpufT1lLG89QXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbCgoaT1yLmFjdGl2ZUN1ZXMpIT1udWxsP2k6W10sKHtzdGFydFRpbWU6cyxlbmRUaW1lOmN9KT0+czw9biYmYz5uKTtyZXR1cm4geihvKX1hc3luYyBmdW5jdGlvbiAkKGUsdD1fKXtyZXR1cm4gbmV3IFByb21pc2Uocj0+e20oZSxcImxvYWRzdGFydFwiLGFzeW5jKCk9PntsZXQgbj1hd2FpdCBZKGUsW10sdCk7bShlLFwiY3VlY2hhbmdlXCIsKCk9PntsZXQgbz1YKGUpO2lmKG8pe2xldCBhPW5ldyBDdXN0b21FdmVudChcImN1ZXBvaW50Y2hhbmdlXCIse2NvbXBvc2VkOiEwLGJ1YmJsZXM6ITAsZGV0YWlsOm99KTtlLmRpc3BhdGNoRXZlbnQoYSl9fSx7fSxuKSxyKG4pfSl9KX1mdW5jdGlvbiB5ZShlLHQpe2lmKHQpe2xldCByPXQucGxheWluZ0RhdGU7aWYociE9bnVsbClyZXR1cm4gbmV3IERhdGUoci5nZXRUaW1lKCktZS5jdXJyZW50VGltZSoxZTMpfXJldHVybiB0eXBlb2YgZS5nZXRTdGFydERhdGU9PVwiZnVuY3Rpb25cIj9lLmdldFN0YXJ0RGF0ZSgpOm5ldyBEYXRlKE5hTil9ZnVuY3Rpb24gVGUoZSx0KXtpZih0JiZ0LnBsYXlpbmdEYXRlKXJldHVybiB0LnBsYXlpbmdEYXRlO2lmKHR5cGVvZiBlLmdldFN0YXJ0RGF0ZT09XCJmdW5jdGlvblwiKXtsZXQgcj1lLmdldFN0YXJ0RGF0ZSgpO3JldHVybiBuZXcgRGF0ZShyLmdldFRpbWUoKStlLmN1cnJlbnRUaW1lKjFlMyl9cmV0dXJuIG5ldyBEYXRlKE5hTil9dmFyIG1lPWFzeW5jIGU9PmZldGNoKGUpLnRoZW4odD0+dC50ZXh0KCkpLnRoZW4odD0+e2xldCByPXQuc3BsaXQoYFxuYCkuZmluZCgobixvLGEpPT5vJiZhW28tMV0uc3RhcnRzV2l0aChcIiNFWFQtWC1TVFJFQU0tSU5GXCIpKTtyZXR1cm4gZmV0Y2gocikudGhlbihuPT5uLnRleHQoKSkudGhlbihuPT5uLnNwbGl0KGBcbmApKX0pLGdlPWU9Pnt2YXIgaSxzO2xldCByPShzPSgoaT1lLmZpbmQoYz0+Yy5zdGFydHNXaXRoKFwiI0VYVC1YLVBMQVlMSVNULVRZUEVcIikpKSE9bnVsbD9pOlwiXCIpLnNwbGl0KFwiOlwiKVsxXSk9PW51bGw/dm9pZCAwOnMudHJpbSgpLG49dyhyKSxvPUgociksYTtpZihuPT09Zy5MSVZFKXtsZXQgYz1lLmZpbmQoZD0+ZC5zdGFydHNXaXRoKFwiI0VYVC1YLVBBUlQtSU5GXCIpKTshIWM/YT0rYy5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI9XCIpWzFdKjI6YT0rZS5maW5kKHk9Pnkuc3RhcnRzV2l0aChcIiNFWFQtWC1UQVJHRVREVVJBVElPTlwiKSkuc3BsaXQoXCI6XCIpWzFdKjN9cmV0dXJue3N0cmVhbVR5cGU6bix0YXJnZXRMaXZlV2luZG93Om8sbGl2ZUVkZ2VTdGFydE9mZnNldDphfX0sTWU9YXN5bmMoZSx0KT0+e2lmKHQ9PT1NLk1QNClyZXR1cm57c3RyZWFtVHlwZTpnLk9OX0RFTUFORCx0YXJnZXRMaXZlV2luZG93Ok51bWJlci5OYU4sbGl2ZUVkZ2VTdGFydE9mZnNldDp2b2lkIDB9O2lmKHQ9PT1NLk0zVTgpe2xldCByPWF3YWl0IG1lKGUpO3JldHVybiBnZShyKX1yZXR1cm4gY29uc29sZS5lcnJvcihgTWVkaWEgdHlwZSAke3R9IGlzIGFuIHVucmVjb2duaXplZCBvciB1bnN1cHBvcnRlZCB0eXBlIGZvciBzcmMgJHtlfS5gKSx7c3RyZWFtVHlwZTp2b2lkIDAsdGFyZ2V0TGl2ZVdpbmRvdzp2b2lkIDAsbGl2ZUVkZ2VTdGFydE9mZnNldDp2b2lkIDB9fSxHPWFzeW5jKGUsdCxyPUwoe3NyYzplfSkpPT57dmFyIGkscyxjO2xldHtzdHJlYW1UeXBlOm4sdGFyZ2V0TGl2ZVdpbmRvdzpvLGxpdmVFZGdlU3RhcnRPZmZzZXQ6YX09YXdhaXQgTWUoZSxyKTsoKGk9Zi5nZXQodCkpIT1udWxsP2k6e30pLmxpdmVFZGdlU3RhcnRPZmZzZXQ9YSwoKHM9Zi5nZXQodCkpIT1udWxsP3M6e30pLnRhcmdldExpdmVXaW5kb3c9byx0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidGFyZ2V0bGl2ZXdpbmRvd2NoYW5nZVwiLHtjb21wb3NlZDohMCxidWJibGVzOiEwfSkpLCgoYz1mLmdldCh0KSkhPW51bGw/Yzp7fSkuc3RyZWFtVHlwZT1uLHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzdHJlYW10eXBlY2hhbmdlXCIse2NvbXBvc2VkOiEwLGJ1YmJsZXM6ITB9KSl9LGJlPWU9Pnt2YXIgaTtsZXQgdD1lLnR5cGUscj13KHQpLG49SCh0KSxvLGE9ISEoKGk9ZS5wYXJ0TGlzdCkhPW51bGwmJmkubGVuZ3RoKTtyZXR1cm4gcj09PWcuTElWRSYmKG89YT9lLnBhcnRUYXJnZXQqMjplLnRhcmdldGR1cmF0aW9uKjMpLHtzdHJlYW1UeXBlOnIsdGFyZ2V0TGl2ZVdpbmRvdzpuLGxpdmVFZGdlU3RhcnRPZmZzZXQ6byxsb3dMYXRlbmN5OmF9fSx4ZT0oZSx0LHIpPT57dmFyIHMsYyx1LGQscCx5LGIseDtsZXR7c3RyZWFtVHlwZTpuLHRhcmdldExpdmVXaW5kb3c6byxsaXZlRWRnZVN0YXJ0T2Zmc2V0OmEsbG93TGF0ZW5jeTppfT1iZShlKTtpZihuPT09Zy5MSVZFKXtpPyhyLmNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoPShzPXIudXNlckNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoKSE9bnVsbD9zOjQsci5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZT0oYz1yLnVzZXJDb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkhPW51bGw/YzouMDAxLHIuY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yPSh1PXIudXNlckNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcikhPW51bGw/dTpyLmNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IpOnIuY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg9KGQ9ci51c2VyQ29uZmlnLmJhY2tCdWZmZXJMZW5ndGgpIT1udWxsP2Q6ODtsZXQgaWU9T2JqZWN0LmZyZWV6ZSh7Z2V0IGxlbmd0aCgpe3JldHVybiB0LnNlZWthYmxlLmxlbmd0aH0sc3RhcnQoRSl7cmV0dXJuIHQuc2Vla2FibGUuc3RhcnQoRSl9LGVuZChFKXt2YXIgVTtyZXR1cm4gRT50aGlzLmxlbmd0aD90LnNlZWthYmxlLmVuZChFKTooVT1yLmxpdmVTeW5jUG9zaXRpb24pIT1udWxsP1U6dC5zZWVrYWJsZS5lbmQoRSl9fSk7KChwPWYuZ2V0KHQpKSE9bnVsbD9wOnt9KS5zZWVrYWJsZT1pZX0oKHk9Zi5nZXQodCkpIT1udWxsP3k6e30pLmxpdmVFZGdlU3RhcnRPZmZzZXQ9YSwoKGI9Zi5nZXQodCkpIT1udWxsP2I6e30pLnRhcmdldExpdmVXaW5kb3c9byx0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidGFyZ2V0bGl2ZXdpbmRvd2NoYW5nZVwiLHtjb21wb3NlZDohMCxidWJibGVzOiEwfSkpLCgoeD1mLmdldCh0KSkhPW51bGw/eDp7fSkuc3RyZWFtVHlwZT1uLHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzdHJlYW10eXBlY2hhbmdlXCIse2NvbXBvc2VkOiEwLGJ1YmJsZXM6ITB9KSl9LEosUSxQZT0oUT0oSj1nbG9iYWxUaGlzPT1udWxsP3ZvaWQgMDpnbG9iYWxUaGlzLm5hdmlnYXRvcik9PW51bGw/dm9pZCAwOkoudXNlckFnZW50KSE9bnVsbD9ROlwiXCIsRWU9UGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYW5kcm9pZFwiKSE9PS0xLGY9bmV3IFdlYWtNYXAsZWU9XCJtdXguY29tXCIsWixqLHRlPShqPShaPWwpLmlzU3VwcG9ydGVkKT09bnVsbD92b2lkIDA6ai5jYWxsKFopLExlPUVlLG10PSgpPT5PLnV0aWxzLm5vdygpLHZlPU8udXRpbHMuZ2VuZXJhdGVVVUlELGd0PShlLHtkb21haW46dD1lZSxtYXhSZXNvbHV0aW9uOnI9XCJcIn09e30pPT57aWYoIWUpcmV0dXJuO2xldFtuLG89XCJcIl09VyhlKSxhPW5ldyBVUkwoYGh0dHBzOi8vc3RyZWFtLiR7dH0vJHtufS5tM3U4JHtvfWApO3JldHVybiByJiZhLnNlYXJjaFBhcmFtcy5zZXQoXCJtYXhfcmVzb2x1dGlvblwiLHIpLGEudG9TdHJpbmcoKX0sa2U9ZT0+e2lmKCFlKXJldHVybjtsZXRbdF09ZS5zcGxpdChcIj9cIik7cmV0dXJuIHR8fHZvaWQgMH0sQ2U9ZT0+e2lmKCFlfHwhZS5zdGFydHNXaXRoKFwiaHR0cHM6Ly9zdHJlYW0uXCIpKXJldHVybjtsZXRbdF09bmV3IFVSTChlKS5wYXRobmFtZS5zbGljZSgxKS5zcGxpdChcIi5tM3U4XCIpO3JldHVybiB0fHx2b2lkIDB9LEFlPWU9Pnt2YXIgdCxyLG47cmV0dXJuKHQ9ZT09bnVsbD92b2lkIDA6ZS5tZXRhZGF0YSkhPW51bGwmJnQudmlkZW9faWQ/ZS5tZXRhZGF0YS52aWRlb19pZDpvZShlKSYmKG49KHI9a2UoZS5wbGF5YmFja0lkKSkhPW51bGw/cjpDZShlLnNyYykpIT1udWxsP246ZS5zcmN9LE10PWU9Pnt2YXIgdDtyZXR1cm4odD1mLmdldChlKSk9PW51bGw/dm9pZCAwOnQuZXJyb3J9LGJ0PWU9Pnt2YXIgdCxyO3JldHVybihyPSh0PWYuZ2V0KGUpKT09bnVsbD92b2lkIDA6dC5zdHJlYW1UeXBlKSE9bnVsbD9yOmcuVU5LTk9XTn0seHQ9ZT0+e3ZhciB0LHI7cmV0dXJuKHI9KHQ9Zi5nZXQoZSkpPT1udWxsP3ZvaWQgMDp0LnRhcmdldExpdmVXaW5kb3cpIT1udWxsP3I6TnVtYmVyLk5hTn0sU2U9ZT0+e3ZhciB0LHI7cmV0dXJuKHI9KHQ9Zi5nZXQoZSkpPT1udWxsP3ZvaWQgMDp0LnNlZWthYmxlKSE9bnVsbD9yOmUuc2Vla2FibGV9LFB0PWU9Pnt2YXIgbjtsZXQgdD0obj1mLmdldChlKSk9PW51bGw/dm9pZCAwOm4ubGl2ZUVkZ2VTdGFydE9mZnNldDtpZih0eXBlb2YgdCE9XCJudW1iZXJcIilyZXR1cm4gTnVtYmVyLk5hTjtsZXQgcj1TZShlKTtyZXR1cm4gci5sZW5ndGg/ci5lbmQoci5sZW5ndGgtMSktdDpOdW1iZXIuTmFOfSxoZT0oZSx0LHI9LjAwMSk9Pk1hdGguYWJzKGUtdCk8PXIscmU9KGUsdCxyPS4wMDEpPT5lPnR8fGhlKGUsdCxyKSxEZT1lPT5lLnBhdXNlZCYmcmUoZS5jdXJyZW50VGltZSxlLmR1cmF0aW9uKSx3ZT0oZSx0KT0+ZS5sb29wfHwhIXQ/ZS5lbmRlZDplLmVuZGVkfHxEZShlKSxFdD0oZSx0LHIpPT57SGUodCxyKTtsZXR7bWV0YWRhdGE6bj17fX09ZSx7dmlld19zZXNzaW9uX2lkOm89dmUoKX09bixhPUFlKGUpO24udmlld19zZXNzaW9uX2lkPW8sbi52aWRlb19pZD1hLGUubWV0YWRhdGE9bixmLnNldCh0LHt9KTtsZXQgaT1JZShlLHQpO19lKGUsdCxpKSxSZShlLHQsaSksJCh0KTtsZXQgcz1LKGUsdCxpKSxjPUIoZSx0LGkpO3JldHVybntlbmdpbmU6aSxzZXRBdXRvcGxheTpzLHNldFByZWxvYWQ6Y319LEhlPShlLHQpPT57bGV0IHI9dD09bnVsbD92b2lkIDA6dC5lbmdpbmU7ciYmKHIuZGV0YWNoTWVkaWEoKSxyLmRlc3Ryb3koKSksKGU9PW51bGw/dm9pZCAwOmUubXV4KSYmIWUubXV4LmRlbGV0ZWQmJihlLm11eC5kZXN0cm95KCksZGVsZXRlIGUubXV4KSxlJiYoZS5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIiksZS5sb2FkKCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixzZSksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixSKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkdXJhdGlvbmNoYW5nZVwiLGFlKSxmLmRlbGV0ZShlKSxlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwidGVhcmRvd25cIikpKX07ZnVuY3Rpb24gbmUoZSx0KXt2YXIgdTtsZXQgcj1MKGUpO2lmKCEocj09PU0uTTNVOCkpcmV0dXJuITA7bGV0IG89IXJ8fCgodT10LmNhblBsYXlUeXBlKHIpKSE9bnVsbD91OiEwKSx7cHJlZmVyUGxheWJhY2s6YX09ZSxpPWE9PT1ELk1TRSxzPWE9PT1ELk5BVElWRTtyZXR1cm4gbyYmKHN8fCEodGUmJihpfHxMZSkpKX12YXIgSWU9KGUsdCk9PntsZXR7ZGVidWc6cixzdHJlYW1UeXBlOm4sc3RhcnRUaW1lOm89LTEsbWV0YWRhdGE6YSxwcmVmZXJDbWNkOml9PWUsYz1MKGUpPT09TS5NM1U4LHU9bmUoZSx0KTtpZihjJiYhdSYmdGUpe2xldCBkPXtiYWNrQnVmZmVyTGVuZ3RoOjMwLHJlbmRlclRleHRUcmFja3NOYXRpdmVseTohMSxsaXZlRHVyYXRpb25JbmZpbml0eTohMCxjYXBMZXZlbFRvUGxheWVyU2l6ZTohMCxjYXBMZXZlbE9uRlBTRHJvcDohMH0scD1OZShuKSx5PWkhPT1DLk5PTkU/e3VzZUhlYWRlcnM6aT09PUMuSEVBREVSLHNlc3Npb25JZDphPT1udWxsP3ZvaWQgMDphLnZpZXdfc2Vzc2lvbl9pZCxjb250ZW50SWQ6YT09bnVsbD92b2lkIDA6YS52aWRlb19pZH06dm9pZCAwO3JldHVybiBuZXcgbCh7ZGVidWc6cixzdGFydFBvc2l0aW9uOm8sY21jZDp5LC4uLmQsLi4ucH0pfX0sTmU9ZT0+ZT09PWcuTElWRT97YmFja0J1ZmZlckxlbmd0aDo4fTp7fSxvZT0oe3BsYXliYWNrSWQ6ZSxzcmM6dCxjdXN0b21Eb21haW46cn0pPT57aWYoZSlyZXR1cm4hMDtpZih0eXBlb2YgdCE9XCJzdHJpbmdcIilyZXR1cm4hMTtsZXQgbj13aW5kb3c9PW51bGw/dm9pZCAwOndpbmRvdy5sb2NhdGlvbi5ocmVmLG89bmV3IFVSTCh0LG4pLmhvc3RuYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7cmV0dXJuIG8uaW5jbHVkZXMoZWUpfHwhIXImJm8uaW5jbHVkZXMoci50b0xvY2FsZUxvd2VyQ2FzZSgpKX0sX2U9KGUsdCxyKT0+e3ZhciBhO2xldHtlbnZLZXk6bn09ZSxvPW9lKGUpO2lmKG58fG8pe2xldHtwbGF5ZXJJbml0VGltZTppLHBsYXllclNvZnR3YXJlTmFtZTpzLHBsYXllclNvZnR3YXJlVmVyc2lvbjpjLGJlYWNvbkNvbGxlY3Rpb25Eb21haW46dSxkZWJ1ZzpkLGRpc2FibGVDb29raWVzOnB9PWUseT17Li4uZS5tZXRhZGF0YSx2aWRlb190aXRsZTooKGE9ZT09bnVsbD92b2lkIDA6ZS5tZXRhZGF0YSk9PW51bGw/dm9pZCAwOmEudmlkZW9fdGl0bGUpfHx2b2lkIDB9LGI9eD0+dHlwZW9mIHgucGxheWVyX2Vycm9yX2NvZGU9PVwic3RyaW5nXCI/ITE6dHlwZW9mIGUuZXJyb3JUcmFuc2xhdG9yPT1cImZ1bmN0aW9uXCI/ZS5lcnJvclRyYW5zbGF0b3IoeCk6eDtPLm1vbml0b3IodCx7ZGVidWc6ZCxiZWFjb25Db2xsZWN0aW9uRG9tYWluOnUsaGxzanM6cixIbHM6cj9sOnZvaWQgMCxhdXRvbWF0aWNFcnJvclRyYWNraW5nOiExLGVycm9yVHJhbnNsYXRvcjpiLGRpc2FibGVDb29raWVzOnAsZGF0YTp7Li4ubj97ZW52X2tleTpufTp7fSxwbGF5ZXJfc29mdHdhcmVfbmFtZTpzLHBsYXllcl9zb2Z0d2FyZTpzLHBsYXllcl9zb2Z0d2FyZV92ZXJzaW9uOmMscGxheWVyX2luaXRfdGltZTppLC4uLnl9fSl9fSxSZT0oZSx0LHIpPT57dmFyIGE7bGV0IG49bmUoZSx0KSx7c3JjOm99PWU7aWYodCYmbil7bGV0IGk9TChlKTt0eXBlb2Ygbz09XCJzdHJpbmdcIj8odC5wcmVsb2FkPT09XCJub25lXCI/bSh0LFwibG9hZHN0YXJ0XCIsKCk9Pkcobyx0LGkpKTpHKG8sdCxpKSx0LnNldEF0dHJpYnV0ZShcInNyY1wiLG8pLGUuc3RhcnRUaW1lJiYoKChhPWYuZ2V0KHQpKSE9bnVsbD9hOnt9KS5zdGFydFRpbWU9ZS5zdGFydFRpbWUsdC5hZGRFdmVudExpc3RlbmVyKFwiZHVyYXRpb25jaGFuZ2VcIixhZSx7b25jZTohMH0pKSk6dC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIiksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixzZSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixSKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJlbXB0aWVkXCIsKCk9Pnt0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0cmFja1tkYXRhLXJlbW92ZW9uZGVzdHJveV1cIikuZm9yRWFjaCh1PT57dS5yZW1vdmUoKX0pfSx7b25jZTohMH0pO2xldCBzPSgpPT57dC5lbmRlZHx8IXdlKHQpfHx0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZW5kZWRcIikpfTttKHQsXCJwYXVzZVwiLHMpLG0odCxcInNlZWtlZFwiLHMpLG0odCxcInBsYXlcIiwoKT0+e3QuZW5kZWR8fCFyZSh0LmN1cnJlbnRUaW1lLHQuZHVyYXRpb24pfHwodC5jdXJyZW50VGltZT10LnNlZWthYmxlLnN0YXJ0KDApKX0pfWVsc2UgciYmbz8oci5vbmNlKGwuRXZlbnRzLkxFVkVMX0xPQURFRCwoaSxzKT0+e3hlKHMuZGV0YWlscyx0LHIpfSksci5vbihsLkV2ZW50cy5FUlJPUiwoaSxzKT0+e2xldCBjPXtbbC5FcnJvclR5cGVzLk5FVFdPUktfRVJST1JdOlQuTUVESUFfRVJSX05FVFdPUkssW2wuRXJyb3JUeXBlcy5NRURJQV9FUlJPUl06VC5NRURJQV9FUlJfREVDT0RFfSx1PW5ldyBUKFwiXCIsY1tzLnR5cGVdKTt1LmZhdGFsPXMuZmF0YWwsdS5kYXRhPXMsdC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImVycm9yXCIse2RldGFpbDp1fSkpfSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixSKSxxKHQsciksci5hdHRhY2hNZWRpYSh0KSk6Y29uc29sZS5lcnJvcihcIkl0IGxvb2tzIGxpa2UgdGhlIHZpZGVvIHlvdSdyZSB0cnlpbmcgdG8gcGxheSB3aWxsIG5vdCB3b3JrIG9uIHRoaXMgc3lzdGVtISBJZiBwb3NzaWJsZSwgdHJ5IHVwZ3JhZGluZyB0byB0aGUgbmV3ZXN0IHZlcnNpb25zIG9mIHlvdXIgYnJvd3NlciBvciBzb2Z0d2FyZS5cIil9O2Z1bmN0aW9uIGFlKGUpe3ZhciBuO2xldCB0PWUudGFyZ2V0LHI9KG49Zi5nZXQodCkpPT1udWxsP3ZvaWQgMDpuLnN0YXJ0VGltZTtpZighIXImJlYodC5zZWVrYWJsZSx0LmR1cmF0aW9uLHIpKXtsZXQgbz10LnByZWxvYWQ9PT1cImF1dG9cIjtvJiYodC5wcmVsb2FkPVwibm9uZVwiKSx0LmN1cnJlbnRUaW1lPXIsbyYmKHQucHJlbG9hZD1cImF1dG9cIil9fWFzeW5jIGZ1bmN0aW9uIHNlKGUpe2lmKCFlLmlzVHJ1c3RlZClyZXR1cm47ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtsZXQgdD1lLnRhcmdldDtpZighKHQhPW51bGwmJnQuZXJyb3IpKXJldHVybjtsZXR7bWVzc2FnZTpyLGNvZGU6bn09dC5lcnJvcixvPW5ldyBUKHIsbik7aWYodC5zcmMmJihuIT09VC5NRURJQV9FUlJfREVDT0RFfHxuIT09dm9pZCAwKSl0cnl7bGV0e3N0YXR1czphfT1hd2FpdCBmZXRjaCh0LnNyYyk7by5kYXRhPXtyZXNwb25zZTp7Y29kZTphfX19Y2F0Y2h7fXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiLHtkZXRhaWw6b30pKX1mdW5jdGlvbiBSKGUpe3ZhciBuLG87aWYoIShlIGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQpfHwhKGUuZGV0YWlsIGluc3RhbmNlb2YgVCkpcmV0dXJuO2xldCB0PWUudGFyZ2V0LHI9ZS5kZXRhaWw7IXJ8fCFyLmZhdGFsfHwoKChuPWYuZ2V0KHQpKSE9bnVsbD9uOnt9KS5lcnJvcj1yLChvPXQubXV4KT09bnVsbHx8by5lbWl0KFwiZXJyb3JcIix7cGxheWVyX2Vycm9yX2NvZGU6ci5jb2RlLHBsYXllcl9lcnJvcl9tZXNzYWdlOnIubWVzc2FnZSxwbGF5ZXJfZXJyb3JfY29udGV4dDpyLmNvbnRleHR9KSl9ZXhwb3J0e2sgYXMgQXV0b3BsYXlUeXBlcyxXZSBhcyBDbWNkVHlwZVZhbHVlcyxDIGFzIENtY2RUeXBlcyxNIGFzIEV4dGVuc2lvbk1pbWVUeXBlTWFwLGwgYXMgSGxzLFQgYXMgTWVkaWFFcnJvcixBIGFzIE1pbWVUeXBlU2hvcnRoYW5kTWFwLEQgYXMgUGxheWJhY2tUeXBlcyxnIGFzIFN0cmVhbVR5cGVzLFkgYXMgYWRkQ3VlUG9pbnRzLE4gYXMgYWRkVGV4dFRyYWNrLEtlIGFzIGFsbE1lZGlhVHlwZXMsbXQgYXMgZ2VuZXJhdGVQbGF5ZXJJbml0VGltZSx2ZSBhcyBnZW5lcmF0ZVVVSUQsWCBhcyBnZXRBY3RpdmVDdWVQb2ludCxmZSBhcyBnZXRDdWVQb2ludHMsUyBhcyBnZXRDdWVQb2ludHNUcmFjayxUZSBhcyBnZXRDdXJyZW50UGR0LHdlIGFzIGdldEVuZGVkLE10IGFzIGdldEVycm9yLFB0IGFzIGdldExpdmVFZGdlU3RhcnQsbWUgYXMgZ2V0TWVkaWFQbGF5bGlzdExpbmVzRnJvbU11bHRpdmFyaWFudFBsYXlsaXN0U3JjLFNlIGFzIGdldFNlZWthYmxlLHllIGFzIGdldFN0YXJ0RGF0ZSxiZSBhcyBnZXRTdHJlYW1JbmZvRnJvbUhsc2pzTGV2ZWxEZXRhaWxzLGdlIGFzIGdldFN0cmVhbUluZm9Gcm9tUGxheWxpc3RMaW5lcyxNZSBhcyBnZXRTdHJlYW1JbmZvRnJvbVNyY0FuZFR5cGUsYnQgYXMgZ2V0U3RyZWFtVHlwZSxOZSBhcyBnZXRTdHJlYW1UeXBlQ29uZmlnLHh0IGFzIGdldFRhcmdldExpdmVXaW5kb3csRXQgYXMgaW5pdGlhbGl6ZSxoIGFzIGlzS2V5T2Ysb2UgYXMgaXNNdXhWaWRlb1NyYyxEZSBhcyBpc1BzZXVkb0VuZGVkLFJlIGFzIGxvYWRNZWRpYSxPIGFzIG11eCxmIGFzIG11eE1lZGlhU3RhdGUsbGUgYXMgcmVtb3ZlVGV4dFRyYWNrLCQgYXMgc2V0dXBDdWVQb2ludHMsSWUgYXMgc2V0dXBIbHMsX2UgYXMgc2V0dXBNdXgsRmUgYXMgc2hvcnRoYW5kS2V5cyxIZSBhcyB0ZWFyZG93bixndCBhcyB0b011eFZpZGVvVVJMLHhlIGFzIHVwZGF0ZVN0cmVhbUluZm9Gcm9tSGxzanNMZXZlbERldGFpbHMsRyBhcyB1cGRhdGVTdHJlYW1JbmZvRnJvbVNyY307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@mux/playback-core/dist/index.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Hls; }\n/* harmony export */ });\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar urlToolkit = {exports: {}};\n\n(function (module, exports) {\n\t// see https://tools.ietf.org/html/rfc1808\n\n\t(function (root) {\n\t  var URL_REGEX =\n\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n\t  var URLToolkit = {\n\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n\t    // E.g\n\t    // With opts.alwaysNormalize = false (default, spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n\t    // With opts.alwaysNormalize = true (not spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n\t      opts = opts || {};\n\t      // remove any remaining space and CRLF\n\t      baseURL = baseURL.trim();\n\t      relativeURL = relativeURL.trim();\n\t      if (!relativeURL) {\n\t        // 2a) If the embedded URL is entirely empty, it inherits the\n\t        // entire base URL (i.e., is set equal to the base URL)\n\t        // and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return baseURL;\n\t        }\n\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\t        if (!basePartsForNormalise) {\n\t          throw new Error('Error trying to parse base URL.');\n\t        }\n\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n\t          basePartsForNormalise.path\n\t        );\n\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n\t      }\n\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n\t      if (!relativeParts) {\n\t        throw new Error('Error trying to parse relative URL.');\n\t      }\n\t      if (relativeParts.scheme) {\n\t        // 2b) If the embedded URL starts with a scheme name, it is\n\t        // interpreted as an absolute URL and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return relativeURL;\n\t        }\n\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n\t        return URLToolkit.buildURLFromParts(relativeParts);\n\t      }\n\t      var baseParts = URLToolkit.parseURL(baseURL);\n\t      if (!baseParts) {\n\t        throw new Error('Error trying to parse base URL.');\n\t      }\n\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n\t        baseParts.netLoc = pathParts[1];\n\t        baseParts.path = pathParts[2];\n\t      }\n\t      if (baseParts.netLoc && !baseParts.path) {\n\t        baseParts.path = '/';\n\t      }\n\t      var builtParts = {\n\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n\t        // the base URL.\n\t        scheme: baseParts.scheme,\n\t        netLoc: relativeParts.netLoc,\n\t        path: null,\n\t        params: relativeParts.params,\n\t        query: relativeParts.query,\n\t        fragment: relativeParts.fragment,\n\t      };\n\t      if (!relativeParts.netLoc) {\n\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n\t        // (if any) of the base URL.\n\t        builtParts.netLoc = baseParts.netLoc;\n\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n\t        // path is not relative and we skip to Step 7.\n\t        if (relativeParts.path[0] !== '/') {\n\t          if (!relativeParts.path) {\n\t            // 5) If the embedded URL path is empty (and not preceded by a\n\t            // slash), then the embedded URL inherits the base URL path\n\t            builtParts.path = baseParts.path;\n\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n\t            // step 7; otherwise, it inherits the <params> of the base\n\t            // URL (if any) and\n\t            if (!relativeParts.params) {\n\t              builtParts.params = baseParts.params;\n\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n\t              // step 7; otherwise, it inherits the <query> of the base\n\t              // URL (if any) and we skip to step 7.\n\t              if (!relativeParts.query) {\n\t                builtParts.query = baseParts.query;\n\t              }\n\t            }\n\t          } else {\n\t            // 6) The last segment of the base URL's path (anything\n\t            // following the rightmost slash \"/\", or the entire path if no\n\t            // slash is present) is removed and the embedded URL's path is\n\t            // appended in its place.\n\t            var baseURLPath = baseParts.path;\n\t            var newPath =\n\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n\t              relativeParts.path;\n\t            builtParts.path = URLToolkit.normalizePath(newPath);\n\t          }\n\t        }\n\t      }\n\t      if (builtParts.path === null) {\n\t        builtParts.path = opts.alwaysNormalize\n\t          ? URLToolkit.normalizePath(relativeParts.path)\n\t          : relativeParts.path;\n\t      }\n\t      return URLToolkit.buildURLFromParts(builtParts);\n\t    },\n\t    parseURL: function (url) {\n\t      var parts = URL_REGEX.exec(url);\n\t      if (!parts) {\n\t        return null;\n\t      }\n\t      return {\n\t        scheme: parts[1] || '',\n\t        netLoc: parts[2] || '',\n\t        path: parts[3] || '',\n\t        params: parts[4] || '',\n\t        query: parts[5] || '',\n\t        fragment: parts[6] || '',\n\t      };\n\t    },\n\t    normalizePath: function (path) {\n\t      // The following operations are\n\t      // then applied, in order, to the new path:\n\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n\t      // segment, are removed.\n\t      // 6b) If the path ends with \".\" as a complete path segment,\n\t      // that \".\" is removed.\n\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n\t      // complete path segment not equal to \"..\", are removed.\n\t      // Removal of these path segments is performed iteratively,\n\t      // removing the leftmost matching pattern on each iteration,\n\t      // until no matching pattern remains.\n\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n\t      // complete path segment not equal to \"..\", that\n\t      // \"<segment>/..\" is removed.\n\t      while (\n\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n\t      ) {}\n\t      return path.split('').reverse().join('');\n\t    },\n\t    buildURLFromParts: function (parts) {\n\t      return (\n\t        parts.scheme +\n\t        parts.netLoc +\n\t        parts.path +\n\t        parts.params +\n\t        parts.query +\n\t        parts.fragment\n\t      );\n\t    },\n\t  };\n\n\t  module.exports = URLToolkit;\n\t})(); \n} (urlToolkit));\n\nvar urlToolkitExports = urlToolkit.exports;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\nlet Events = /*#__PURE__*/function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\n\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nlet exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  const func = self.console[type];\n  if (func) {\n    return func.bind(self.console, `[${type}] >`);\n  }\n  return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\nfunction enableLogs(debugConfig, id) {\n  // check that console is available\n  if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.4.10\"}`);\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nconst logger = exportedLogger;\n\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    for (const attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        if (attr.substring(0, 2) === 'X-') {\n          this.clientAttrs = this.clientAttrs || [];\n          this.clientAttrs.push(attr);\n        }\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    } else {\n      return null;\n    }\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      let value = match[2];\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n      const name = match[1].trim();\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    if (\"END-DATE\" in this.attr) {\n      const endDate = new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    if (this._endDate) {\n      return this._endDate;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n  }\n}\n\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\n\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  // baseurl is the URL to the playlist\n\n  // relurl is the portion of the URL that comes from inside the playlist.\n\n  // Holds the types of data this fragment supports\n\n  constructor(baseurl) {\n    this._byteRange = null;\n    this._url = null;\n    this.baseurl = void 0;\n    this.relurl = void 0;\n    this.elementaryStreams = {\n      [ElementaryStreamTypes.AUDIO]: null,\n      [ElementaryStreamTypes.VIDEO]: null,\n      [ElementaryStreamTypes.AUDIOVIDEO]: null\n    };\n    this.baseurl = baseurl;\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    const byteRange = [];\n    if (params.length === 1) {\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n    } else {\n      byteRange[0] = parseInt(params[1]);\n    }\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\n    this._byteRange = byteRange;\n  }\n  get byteRange() {\n    if (!this._byteRange) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  // EXTINF has to be present for a m3u8 to be considered valid\n\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n\n  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n  // A string representing the fragment type\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n  // The level/track index to which the fragment belongs\n  // The continuity counter of the fragment\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n  // Set by `updateFragPTSDTS` in level-helper\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // Load/parse timing information\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n  // #EXTINF  segment title\n  // The Media Initialization Section for this segment\n  // Fragment is the last fragment in the media playlist\n  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n  constructor(type, baseurl) {\n    super(baseurl);\n    this._decryptdata = null;\n    this.rawProgramDateTime = null;\n    this.programDateTime = null;\n    this.tagList = [];\n    this.duration = 0;\n    this.sn = 0;\n    this.levelkeys = void 0;\n    this.type = void 0;\n    this.loader = null;\n    this.keyLoader = null;\n    this.level = -1;\n    this.cc = 0;\n    this.startPTS = void 0;\n    this.endPTS = void 0;\n    this.startDTS = void 0;\n    this.endDTS = void 0;\n    this.start = 0;\n    this.deltaPTS = void 0;\n    this.maxStartPTS = void 0;\n    this.minEndPTS = void 0;\n    this.stats = new LoadStats();\n    this.urlId = 0;\n    this.data = void 0;\n    this.bitrateTest = false;\n    this.title = null;\n    this.initSegment = null;\n    this.endList = void 0;\n    this.gap = void 0;\n    this.type = type;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    if (!isFiniteNumber(this.programDateTime)) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, baseurl, index, previous) {\n    super(baseurl);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.stats = new LoadStats();\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\n\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  // Manifest reload synchronization\n\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n    this.availabilityDelay = previous.availabilityDelay;\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n}\n\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));\n}\n\nfunction getKeyIdBytes(str) {\n  const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  const paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  const swap = function swap(array, from, to) {\n    const cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  const colonsplit = uri.split(':');\n  let keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    const semicolonsplit = colonsplit[1].split(';');\n    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      const isbase64 = commasplit[0] === 'base64';\n      const data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = base64Decode(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n};\n\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\n\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds = {\n  WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n};\nfunction keySystemIdToKeySystemDomain(systemId) {\n  if (systemId === KeySystemIds.WIDEVINE) {\n    return KeySystems.WIDEVINE;\n    // } else if (systemId === KeySystemIds.PLAYREADY) {\n    //   return KeySystems.PLAYREADY;\n    // } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    //   return KeySystems.CLEARKEY;\n  }\n}\n\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  const {\n    drmSystems,\n    widevineLicenseUrl\n  } = config;\n  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function () {\n  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  let initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${keySystem}`);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  const baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'not-allowed',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'not-allowed',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(codec => ({\n      contentType: `audio/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.audioRobustness || '',\n      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n    })),\n    videoCapabilities: videoCodecs.map(codec => ({\n      contentType: `video/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.videoRobustness || '',\n      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n    }))\n  };\n  return [baseConfig];\n}\n\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isHeader$2 = (data, offset) => {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isFooter = (data, offset) => {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nconst getID3Data = (data, offset) => {\n  const front = offset;\n  let length = 0;\n  while (isHeader$2(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readSize(data, offset + 6);\n    length += size;\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n};\nconst readSize = (data, offset) => {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\nconst canParse$2 = (data, offset) => {\n  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */\nconst getTimeStamp = data => {\n  const frames = getID3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */\nconst isTimeStampFrame = frame => {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\nconst getFrameData = data => {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */\nconst getID3Frames = id3Data => {\n  let offset = 0;\n  const frames = [];\n  while (isHeader$2(id3Data, offset)) {\n    const size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      const frameData = getFrameData(id3Data.subarray(offset));\n      const frame = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n  return frames;\n};\nconst decodeFrame = frame => {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n  return decodeTextFrame(frame);\n};\nconst decodePrivFrame = frame => {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\nconst decodeTextFrame = frame => {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\nconst decodeURLFrame = frame => {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\nconst readTimeStamp = timeStampFrame => {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nconst utf8ArrayToStr = (array, exitOnNull = false) => {\n  const decoder = getTextDecoder();\n  if (decoder) {\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n  return decoder;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\n\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n\n  // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n  const earliestPresentationTime = 0;\n  const firstOffset = 0;\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      let index = version === 0 ? 12 : 20;\n      const trackId = readUint32(tkhd, index);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        index = version === 0 ? 12 : 20;\n        const timescale = readUint32(mdhd, index);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            let codec;\n            if (stsd) {\n              codec = bin2str(stsd.subarray(12, 16));\n              // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n\n            result[trackId] = {\n              timescale,\n              type\n            };\n            result[type] = {\n              timescale,\n              id: trackId,\n              codec\n            };\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  logger.error(`[eme] missing 'schm' box`);\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce((result, traf) => {\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    const version = tfdt[0];\n    const start = findBox(traf, ['tfhd']).reduce((result, tfhd) => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (track) {\n        let baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n          // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n          // https://github.com/video-dev/hls.js/issues/5303\n          if (baseTime === UINT32_MAX$1) {\n            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n            return result;\n          }\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const scale = track.timescale || 90e3;\n        // convert base time to seconds\n        const startTime = baseTime / scale;\n        if (isFinite(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n      return result;\n    }, null);\n    if (start !== null && isFinite(start) && (result === null || start < result)) {\n      return start;\n    }\n    return result;\n  }, null);\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nfunction getDuration(data, initData) {\n  let rawDuration = 0;\n  let videoDuration = 0;\n  let audioDuration = 0;\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    const timescale = track.timescale || 90e3;\n    const truns = findBox(traf, ['trun']);\n    for (let j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        const sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxDuration = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxDuration += sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n      }\n    }\n    return sidxDuration;\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nfunction computeRawDurationFromSamples(trun) {\n  const flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  let offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n  let duration = 0;\n  const sampleCount = readUint32(trun, 4);\n  for (let i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      const sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(traf => {\n    findBox(traf, ['tfhd']).forEach(tfhd => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      const timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach(tfdt => {\n        const version = tfdt[0];\n        let baseMediaDecodeTime = readUint32(tfdt, 4);\n        if (version === 0) {\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          writeUint32(tfdt, 4, baseMediaDecodeTime);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n          const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const delimit = codec.indexOf('.');\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let endOfCaptions = false;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n      endOfCaptions = true;\n      const countryCode = data[seiPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, seiPtr);\n        seiPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, seiPtr);\n          seiPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[seiPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[seiPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[seiPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5 && payloadSize < leftOver) {\n      endOfCaptions = true;\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[seiPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[seiPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    } else if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      break;\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nfunction mp4Box(type, ...payload) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (let ix = 0; ix < keyids.length; ix++) {\n      const k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parsePssh(initData) {\n  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n    return null;\n  }\n  const result = {\n    version: 0,\n    systemId: '',\n    kids: null,\n    data: null\n  };\n  const view = new DataView(initData);\n  const boxSize = view.getUint32(0);\n  if (initData.byteLength !== boxSize && boxSize > 44) {\n    return null;\n  }\n  const type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return null;\n  }\n  result.version = view.getUint32(8) >>> 24;\n  if (result.version > 1) {\n    return null;\n  }\n  result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\n  const dataSizeOrKidCount = view.getUint32(28);\n  if (result.version === 0) {\n    if (boxSize - 32 < dataSizeOrKidCount) {\n      return null;\n    }\n    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n  } else if (result.version === 1) {\n    result.kids = [];\n    for (let i = 0; i < dataSizeOrKidCount; i++) {\n      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n    }\n  }\n  return result;\n}\n\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  }\n  constructor(method, uri, format, formatversions = [1], iv = null) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (this.method === 'AES-128' || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      } else {\n        switch (this.keyFormat) {\n          case KeySystemFormats.FAIRPLAY:\n          case KeySystemFormats.WIDEVINE:\n          case KeySystemFormats.PLAYREADY:\n          case KeySystemFormats.CLEARKEY:\n            return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n        }\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (this.method === 'AES-128' && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        if (this.method === 'AES-128' && !this.iv) {\n          logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n        }\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n\n    // Initialize keyId if possible\n    const keyBytes = convertDataUriToArrayBytes(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case KeySystemFormats.WIDEVINE:\n          this.pssh = keyBytes;\n          // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n          if (keyBytes.length >= 22) {\n            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n          }\n          break;\n        case KeySystemFormats.PLAYREADY:\n          {\n            const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n            const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n            const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n            // Parse Playready WRMHeader XML\n            const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n            const keyData = xmlDoc.getElementsByTagName('KID')[0];\n            if (keyData) {\n              const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n              if (keyId) {\n                const keyIdArray = base64Decode(keyId).subarray(0, 16);\n                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                changeEndianness(keyIdArray);\n                this.keyId = keyIdArray;\n              }\n            }\n            break;\n          }\n        default:\n          {\n            let keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              const padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let keyId = keyUriToKeyIdMap[this.uri];\n      if (!keyId) {\n        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        keyId = new Uint8Array(16);\n        const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = keyId;\n      }\n      this.keyId = keyId;\n    }\n    return this;\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n  return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariablesInAttributes(parsed, attr, attributeNames) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    for (let i = attributeNames.length; i--;) {\n      const name = attributeNames[i];\n      const value = attr[name];\n      if (value) {\n        attr[name] = substituteVariables(parsed, value);\n      }\n    }\n  }\n}\nfunction substituteVariables(parsed, value) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    const variableList = parsed.variableList;\n    return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {\n      const variableName = variableReference.substring(2, variableReference.length - 1);\n      const variableValue = variableList == null ? void 0 : variableList[variableName];\n      if (variableValue === undefined) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n        return variableReference;\n      }\n      return variableValue;\n    });\n  }\n  return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n  let variableList = parsed.variableList;\n  if (!variableList) {\n    parsed.variableList = variableList = {};\n  }\n  let NAME;\n  let VALUE;\n  if ('QUERYPARAM' in attr) {\n    NAME = attr.QUERYPARAM;\n    try {\n      const searchParams = new self.URL(parentUrl).searchParams;\n      if (searchParams.has(NAME)) {\n        VALUE = searchParams.get(NAME);\n      } else {\n        throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n      }\n    } catch (error) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n    }\n  } else {\n    NAME = attr.NAME;\n    VALUE = attr.VALUE;\n  }\n  if (NAME in variableList) {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n  } else {\n    variableList[NAME] = VALUE || '';\n  }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n  const IMPORT = attr.IMPORT;\n  if (sourceVariableList && IMPORT in sourceVariableList) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    variableList[IMPORT] = sourceVariableList[IMPORT];\n  } else {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n  }\n}\n\n/**\n * MediaSource helper\n */\n\nfunction getMediaSource() {\n  if (typeof self === 'undefined') return undefined;\n  return self.MediaSource || self.WebKitMediaSource;\n}\n\n// from http://mp4ra.org/codecs.html\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: true,\n    'ac-3': true,\n    'ac-4': true,\n    alac: true,\n    alaw: true,\n    dra1: true,\n    'dts+': true,\n    'dts-': true,\n    dtsc: true,\n    dtse: true,\n    dtsh: true,\n    'ec-3': true,\n    enca: true,\n    g719: true,\n    g726: true,\n    m4ae: true,\n    mha1: true,\n    mha2: true,\n    mhm1: true,\n    mhm2: true,\n    mlpa: true,\n    mp4a: true,\n    'raw ': true,\n    Opus: true,\n    opus: true,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: true,\n    sawb: true,\n    sawp: true,\n    sevc: true,\n    sqcp: true,\n    ssmv: true,\n    twos: true,\n    ulaw: true\n  },\n  video: {\n    avc1: true,\n    avc2: true,\n    avc3: true,\n    avc4: true,\n    avcp: true,\n    av01: true,\n    drac: true,\n    dva1: true,\n    dvav: true,\n    dvh1: true,\n    dvhe: true,\n    encv: true,\n    hev1: true,\n    hvc1: true,\n    mjp2: true,\n    mp4v: true,\n    mvc1: true,\n    mvc2: true,\n    mvc3: true,\n    mvc4: true,\n    resv: true,\n    rv60: true,\n    s263: true,\n    svc1: true,\n    svc2: true,\n    'vc-1': true,\n    vp08: true,\n    vp09: true\n  },\n  text: {\n    stpp: true,\n    wvtt: true\n  }\n};\nconst MediaSource$2 = getMediaSource();\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\nfunction isCodecSupportedInMp4(codec, type) {\n  var _MediaSource$isTypeSu;\n  return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported(`${type || 'video'}/mp4;codecs=\"${codec}\"`)) != null ? _MediaSource$isTypeSu : false;\n}\n\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source,\n// next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n// next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    const avcdata = codec.split('.');\n    if (avcdata.length > 2) {\n      let result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n      return result;\n    }\n    return codec;\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = hasVariableReferences(string) ;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1]);\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);\n        }\n        const uri = substituteVariables(parsed, result[2]) ;\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(c => c), level);\n        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n        }\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);\n              }\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl, parsed);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              // #EXT-X-DEFINE\n              {\n                const variableAttributes = new AttrList(attributes);\n                substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);\n                addVariableDefinition(parsed, variableAttributes, baseurl);\n              }\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);\n              }\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1]);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);\n        }\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          instreamId: attrs['INSTREAM-ID'],\n          name: attrs.NAME || attrs.LANGUAGE || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang: attrs.LANGUAGE,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, baseurl);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = hasVariableReferences(string) ;\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, baseurl);\n        // setup the next fragment for part loading\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          frag.urlId = levelUrlId;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = substituteVariables(level, uri) ;\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        const data = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              const skipAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);\n              }\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments = skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n          case 'EXTM3U':\n            break;\n          case 'ENDLIST':\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);\n                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n              }\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              {\n                const variableAttributes = new AttrList(value1);\n                substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);\n                if ('IMPORT' in variableAttributes) {\n                  importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                } else {\n                  addVariableDefinition(level, variableAttributes, baseurl);\n                }\n              }\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl, level);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                if (levelkeys[levelKey.keyFormat]) {\n                  levelkeys = _extends({}, levelkeys);\n                }\n                levelkeys[levelKey.keyFormat] = levelKey;\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);\n              }\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              const serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);\n              }\n              const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);\n              }\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);\n              }\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n    return level;\n  }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes);\n  {\n    substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);\n  }\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecs, level) {\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      const preferred = filtered.filter(codec => {\n        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n      });\n      level[`${type}Codec`] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n      // remove from list\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n  if (!isFiniteNumber(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\n\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\n\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      level,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.url === context.url) {\n        // same URL can't overlap\n        logger.trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string)) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelUrlId = isFiniteNumber(id) ? id : 0;\n    const levelId = isFiniteNumber(level) ? level : levelUrlId;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_PARSING_ERROR,\n        fatal: false,\n        url,\n        error,\n        reason: error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\n\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(`addCue is failed for: ${cue}`);\n      }\n    } catch (err) {\n      logger.debug(`[texttrack-utils]: ${err}`);\n      try {\n        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n        textTrackCue.id = cue.id;\n        track.addCue(textTrackCue);\n      } catch (err2) {\n        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  while (left <= right) {\n    const mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\n\nvar MetadataSchema = {\n  audioId3: \"org.id3\",\n  dateRange: \"com.apple.quicktime.HLS\",\n  emsg: \"https://aomedia.org/emsg/ID3\"\n};\n\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n\n  // Attempt to recreate Safari functionality by creating\n  // WebKitDataCue objects when available and store the decoded\n  // ID3 data in the value property of the cue\n  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n\n  // Add ID3 metatadata text track.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n  }\n  onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n    clearCurrentCues(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getID3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isTimeStampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = new Cue(startTime, endTime, '');\n            cue.value = frame;\n            if (type) {\n              cue.type = type;\n            }\n            this.id3Track.addCue(cue);\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      dateRangeCuesAppended,\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track) {\n      const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n      for (let i = idsToRemove.length; i--;) {\n        const id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(key => {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n      let endTime = MAX_CUE_ENDTIME;\n      const endDate = dateRange.endDate;\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((filterMapArray, id) => {\n          const candidate = dateRanges[id];\n          if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n            filterMapArray.push(candidate);\n          }\n          return filterMapArray;\n        }, []).sort((a, b) => a.startDate.getTime() - b.startDate.getTime())[0];\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        let cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else {\n          let data = dateRange.attr[key];\n          cue = new Cue(startTime, endTime, '');\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          cue.value = {\n            key,\n            data\n          };\n          cue.type = MetadataSchema.dateRange;\n          cue.id = id;\n          this.id3Track.addCue(cue);\n          cues[key] = cue;\n        }\n      }\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\n\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this.timeupdateHandler = () => this.timeupdate();\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config,\n      levelDetails\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    const liveSyncOnStallIncrease = 1.0;\n    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    const levelDetails = this.levelDetails;\n    if (liveEdge === null || targetLatency === null || levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null;\n    // @ts-ignore\n    this.hls = this.timeupdateHandler = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.levelDetails = details;\n    if (details.advanced) {\n      this.timeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  timeupdate() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return;\n    }\n    this.currentTime = media.currentTime;\n    const latency = this.computeLatency();\n    if (latency === null) {\n      return;\n    }\n    this._latency = latency;\n\n    // Adapt playbackRate to meet target latency in low-latency mode\n    const {\n      lowLatencyMode,\n      maxLiveSyncPlaybackRate\n    } = this.config;\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n      return;\n    }\n    const targetLatency = this.targetLatency;\n    if (targetLatency === null) {\n      return;\n    }\n    const distanceFromTarget = latency - targetLatency;\n    // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  }\n  estimateLiveEdge() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\n\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details, msn) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    endSN\n  } = details;\n  const snChangeGoal = msn !== undefined ? msn - endSN : 0;\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.unknownCodecs = void 0;\n    this.audioGroupIds = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.textGroupIds = void 0;\n    this.url = void 0;\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.unknownCodecs = data.unknownCodecs;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => c).join(',').replace(/\\.[^.,]+/g, '');\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get attrs() {\n    return this._attrs[this._urlId];\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get uri() {\n    return this.url[this._urlId] || '';\n  }\n  get urlId() {\n    return this._urlId;\n  }\n  set urlId(value) {\n    const newValue = value % this.url.length;\n    if (this._urlId !== newValue) {\n      this.fragmentError = 0;\n      this.loadError = 0;\n      this.details = undefined;\n      this._urlId = newValue;\n    }\n  }\n  get audioGroupId() {\n    var _this$audioGroupIds;\n    return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];\n  }\n  get textGroupId() {\n    var _this$textGroupIds;\n    return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];\n  }\n  addFallback(data) {\n    this.url.push(data.url);\n    this._attrs.push(data.attrs);\n  }\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.start = startPTS;\n  }\n  frag.duration = endPTS - frag.start;\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n  let ccOffset = 0;\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    newFrag.urlId = oldFrag.urlId;\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  if (currentInitSegment) {\n    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newDetails.fragments.shift();\n      }\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n  const newFragments = newDetails.fragments;\n  if (ccOffset) {\n    logger.warn('discontinuity sliding from playlist, take drift into account');\n    for (let i = 0; i < newFragments.length; i++) {\n      newFragments[i].cc += ccOffset;\n    }\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  Object.keys(deltaDateRanges).forEach(id => {\n    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n    }\n  });\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  const levelDetails = level.details;\n  let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = levelDetails.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  var _level$details;\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\n\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {\n  return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\n\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return BinarySearch.search(fragments, candidate => {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\nconst RENDITION_PENALTY_DURATION_MS = 300000;\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[info]:`);\n    this.warn = logger.warn.bind(logger, `[warning]:`);\n    this.error = logger.error.bind(logger, `[error]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {\n    this.playlistError = 0;\n  }\n  stopLoad() {}\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag, _data$level;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = {\n            action: NetworkErrorAction.DoNothing,\n            flags: ErrorActionFlags.None\n          };\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.levels[hls.loadLevel];\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.levels[hls.loadLevel];\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = {\n          action: NetworkErrorAction.DoNothing,\n          flags: ErrorActionFlags.None\n        };\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      const levelIndex = this.getVariantLevelIndex(data.frag);\n      // Do not retry level. Escalate to fatal if switching levels fails.\n      data.levelRetry = false;\n      data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n      return;\n    }\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    var _data$response;\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      var _data$response2;\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      level.loadError++;\n      if (hls.autoLevelEnabled) {\n        var _data$frag2, _data$context2;\n        // Search for next level to retry\n        let nextLevel = -1;\n        const {\n          levels,\n          loadLevel,\n          minAutoLevel,\n          maxAutoLevel\n        } = hls;\n        const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n        const {\n          type: playlistErrorType,\n          groupId: playlistErrorGroupId\n        } = (_data$context2 = data.context) != null ? _data$context2 : {};\n        for (let i = levels.length; i--;) {\n          const candidate = (i + loadLevel) % levels.length;\n          if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n            const levelCandidate = levels[candidate];\n            // Skip level switch if GAP tag is found in next level at same position\n            if (data.details === ErrorDetails.FRAG_GAP && data.frag) {\n              const levelDetails = levels[candidate].details;\n              if (levelDetails) {\n                const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                if (fragCandidate != null && fragCandidate.gap) {\n                  continue;\n                }\n              }\n            } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {\n              // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n              continue;\n            } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {\n              // For audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n              continue;\n            }\n            nextLevel = candidate;\n            break;\n          }\n        }\n        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n          data.levelRetry = true;\n          this.playlistError = 0;\n          return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.None,\n            nextAutoLevel: nextLevel\n          };\n        }\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        }\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHost:\n        {\n          // Handle Redundant Levels here. Pathway switching is handled by content-steering-controller\n          if (!errorAction.resolved) {\n            errorAction.resolved = this.redundantFailover(data);\n          }\n        }\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n    }\n  }\n  redundantFailover(data) {\n    const {\n      hls,\n      penalizedRenditions\n    } = this;\n    const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n    const level = hls.levels[levelIndex];\n    const redundantLevels = level.url.length;\n    const errorUrlId = data.frag ? data.frag.urlId : level.urlId;\n    if (level.urlId === errorUrlId && (!data.frag || level.details)) {\n      this.penalizeRendition(level, data);\n    }\n    for (let i = 1; i < redundantLevels; i++) {\n      const newUrlId = (errorUrlId + i) % redundantLevels;\n      const penalizedRendition = penalizedRenditions[newUrlId];\n      // Check if rendition is penalized and skip if it is a bad fit for failover\n      if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {\n        // delete penalizedRenditions[newUrlId];\n        // Update the url id of all levels so that we stay on the same set of variants when level switching\n        this.warn(`Switching to Redundant Stream ${newUrlId + 1}/${redundantLevels}: \"${level.url[newUrlId]}\" after ${data.details}`);\n        this.playlistError = 0;\n        hls.levels.forEach(lv => {\n          lv.urlId = newUrlId;\n        });\n        hls.nextLoadLevel = levelIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n  penalizeRendition(level, data) {\n    const {\n      penalizedRenditions\n    } = this;\n    const penalizedRendition = penalizedRenditions[level.urlId] || {\n      lastErrorPerfMs: 0,\n      errors: [],\n      details: undefined\n    };\n    penalizedRendition.lastErrorPerfMs = performance.now();\n    penalizedRendition.errors.push(data);\n    penalizedRendition.details = level.details;\n    penalizedRenditions[level.urlId] = penalizedRendition;\n  }\n}\nfunction checkExpired(penalizedRendition, data, currentPenaltyState) {\n  // Expire penalty for switching back to rendition after RENDITION_PENALTY_DURATION_MS\n  if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {\n    return true;\n  }\n  // Expire penalty on GAP tag error if rendition has no GAP at position (does not cover media tracks)\n  const lastErrorDetails = penalizedRendition.details;\n  if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {\n    const position = data.frag.start;\n    const candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);\n    if (candidateFrag && !candidateFrag.gap) {\n      return true;\n    }\n  }\n  // Expire penalty if there are more errors in currentLevel than in penalizedRendition\n  if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {\n    const lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];\n    if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {\n      return true;\n    }\n  }\n  return false;\n}\n\nclass BasePlaylistController {\n  constructor(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.requestScheduled = -1;\n    this.canLoad = false;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    clearTimeout(this.timer);\n    this.timer = -1;\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.requestScheduled = -1;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    if (this.requestScheduled === -1) {\n      this.requestScheduled = self.performance.now();\n    }\n    // Loading is handled by the subclasses\n  }\n\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  shouldReloadPlaylist(playlist) {\n    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      details.reloaded(previousDetails);\n      if (previousDetails) {\n        this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'}`);\n      }\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n      }\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const lastPart = lastPartSn === endSn;\n        // When low latency mode is disabled, we'll skip part requests once the last part index is found\n        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.updated && now > this.requestScheduled + reloadInterval) {\n        this.requestScheduled = stats.loading.start;\n      }\n      if (msn !== undefined && details.canBlockReload) {\n        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n        this.requestScheduled = now;\n      } else if (this.requestScheduled - now <= 0) {\n        this.requestScheduled += reloadInterval;\n      }\n      let estimatedTimeUntilUpdate = this.requestScheduled - now;\n      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n      // this.log(\n      //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n      // reload in ${estimatedTimeUntilUpdate / 1000}\n      // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n      // diff ${\n      //   (reloadInterval -\n      //     (estimatedTimeUntilUpdate +\n      //       stats.loading.end -\n      //       stats.loading.start)) /\n      //   1000\n      // }\n      // reload interval ${reloadInterval / 1000}\n      // target duration ${details.targetduration}\n      // distance to edge ${distanceToLiveEdgeMs / 1000}`\n      // );\n\n      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n    } else {\n      this.clearTimer();\n    }\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details, msn);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      this.requestScheduled = -1;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, '[level-controller]');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  startLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.startLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const levels = [];\n    const levelSet = {};\n    let levelFromSet;\n\n    // regroup redundant levels together\n    data.levels.forEach(levelParsed => {\n      var _levelParsed$audioCod;\n      const attributes = levelParsed.attrs;\n\n      // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n      if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf('mp4a.40.34')) !== -1) {\n        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n        if (chromeOrFirefox) {\n          levelParsed.audioCodec = undefined;\n        }\n      }\n      const {\n        AUDIO,\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        SUBTITLES\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-` ;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}`;\n      levelFromSet = levelSet[levelKey];\n      if (!levelFromSet) {\n        levelFromSet = new Level(levelParsed);\n        levelSet[levelKey] = levelFromSet;\n        levels.push(levelFromSet);\n      } else {\n        levelFromSet.addFallback(levelParsed);\n      }\n      addGroupId(levelFromSet, 'audio', AUDIO);\n      addGroupId(levelFromSet, 'text', SUBTITLES);\n    });\n    this.filterAndSortMediaOptions(levels, data);\n  }\n  filterAndSortMediaOptions(unfilteredLevels, data) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n\n    // only keep levels with supported audio/video codecs\n    let levels = unfilteredLevels.filter(({\n      audioCodec,\n      videoCodec,\n      width,\n      height,\n      unknownCodecs\n    }) => {\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || isCodecSupportedInMp4(videoCodec, 'video'));\n    });\n\n    // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        width,\n        height\n      }) => !!videoCodec || !!(width && height));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          const error = new Error('no level with compatible codecs found in manifest');\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason: error.message\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, 'audio'));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      if (a.bitrate !== b.bitrate) {\n        return a.bitrate - b.bitrate;\n      }\n      if (a.attrs['FRAME-RATE'] !== b.attrs['FRAME-RATE']) {\n        return a.attrs.decimalFloatingPoint('FRAME-RATE') - b.attrs.decimalFloatingPoint('FRAME-RATE');\n      }\n      if (a.attrs.SCORE !== b.attrs.SCORE) {\n        return a.attrs.decimalFloatingPoint('SCORE') - b.attrs.decimalFloatingPoint('SCORE');\n      }\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        this._firstLevel = i;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelInPlaylist.bitrate}`);\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n    // Initiate loading after all controllers have received MANIFEST_PARSED\n    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n      this.hls.startLoad(this.hls.config.startPosition);\n    }\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel}${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = _extends({}, level, {\n      level: newLevel,\n      maxBitrate: level.maxBitrate,\n      attrs: level.attrs,\n      uri: level.uri,\n      urlId: level.urlId\n    });\n    // @ts-ignore\n    delete levelSwitchingData._attrs;\n    // @ts-ignore\n    delete levelSwitchingData._urlId;\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // hls.startLevel takes precedence over config.startLevel\n    // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      } else {\n        return this._firstLevel;\n      }\n    } else {\n      return this._startLevel;\n    }\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragLoaded(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const level = this._levels[frag.level];\n      if (level !== undefined) {\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = this._levels[level];\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const currentLevel = this.currentLevel;\n    if (!currentLevel) {\n      return;\n    }\n    const audioGroupId = this.hls.audioTracks[data.id].groupId;\n    if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {\n      let urlId = -1;\n      for (let i = 0; i < currentLevel.audioGroupIds.length; i++) {\n        if (currentLevel.audioGroupIds[i] === audioGroupId) {\n          urlId = i;\n          break;\n        }\n      }\n      if (urlId !== -1 && urlId !== currentLevel.urlId) {\n        currentLevel.urlId = urlId;\n        if (this.canLoad) {\n          this.startLoad();\n        }\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentLevelIndex = this.currentLevelIndex;\n    const currentLevel = this.currentLevel;\n    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n      const id = currentLevel.urlId;\n      let url = currentLevel.uri;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''} with${pathwayId ? ' Pathway ' + pathwayId : ''} URI ${id + 1}/${currentLevel.url.length} ${url}`);\n\n      // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n      this.clearTimer();\n      this.hls.trigger(Events.LEVEL_LOADING, {\n        url,\n        level: currentLevelIndex,\n        id,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex, urlId) {\n    const filterLevelAndGroupByIdIndex = (url, id) => id !== urlId;\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (level.url.length > 1 && urlId !== undefined) {\n        level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n        if (level.audioGroupIds) {\n          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        if (level.textGroupIds) {\n          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        level.urlId = 0;\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      return false;\n    });\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    levels.forEach((level, index) => {\n      const {\n        details\n      } = level;\n      if (details != null && details.fragments) {\n        details.fragments.forEach(fragment => {\n          fragment.level = index;\n        });\n      }\n    });\n    this._levels = levels;\n  }\n}\nfunction addGroupId(level, type, id) {\n  if (!id) {\n    return;\n  }\n  if (type === 'audio') {\n    if (!level.audioGroupIds) {\n      level.audioGroupIds = [];\n    }\n    level.audioGroupIds[level.url.length - 1] = id;\n  } else if (type === 'text') {\n    if (!level.textGroupIds) {\n      level.textGroupIds = [];\n    }\n    level.textGroupIds[level.url.length - 1] = id;\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\n\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    const {\n      frag,\n      part\n    } = data;\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      if (fragmentEntity.body.endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = activeParts.filter(part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        buffered.partial = true;\n        // Check for intersection with buffer\n        // Get playable sections of the fragment\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (frag.sn === 'initSegment' || frag.bitrateTest) {\n      return;\n    }\n\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const timeRange = timeRanges[elementaryStream];\n      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n    });\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = activeParts.filter(part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.urlId}_${fragment.sn}`;\n}\n\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        },\n        onProgress: (stats, context, data, networkDetails) => {\n          if (onProgress) {\n            onProgress({\n              frag,\n              part: null,\n              payload: data,\n              networkDetails\n            });\n          }\n        }\n      });\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n      // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\n\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        if (type && type !== loader.context.frag.type) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments) {\n    if (this.emeController && this.config.emeEnabled) {\n      // access key-system with nearest key on start (loaidng frag is unencrypted)\n      const {\n        sn,\n        cc\n      } = loadingFrag;\n      for (let i = 0; i < encryptedFragments.length; i++) {\n        const frag = encryptedFragments[i];\n        if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n          this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n            frag.setKeyFormat(keySystemFormat);\n          });\n          break;\n        }\n      }\n    }\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop {\n  constructor() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    try {\n      if (media) {\n        const buffered = BufferHelper.getBuffered(media);\n        for (let i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return false;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        const vbuffered = BufferHelper.getBuffered(media);\n        const buffered = [];\n        let i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    buffered.sort(function (a, b) {\n      const diff = a.start - b.start;\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n\n    // bufferStartNext can possibly be undefined based on the conditional logic below\n    let bufferStartNext;\n\n    // bufferStart and bufferEnd are buffer boundaries around current video position\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\n\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\nfunction findFirstFragWithCC(fragments, cc) {\n  let firstFrag = null;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    const currentFrag = fragments[i];\n    if (currentFrag && currentFrag.cc === cc) {\n      firstFrag = currentFrag;\n      break;\n    }\n  }\n  return firstFrag;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n  if (lastLevel.details) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex = 0) {\n  const prevFrags = prevDetails.fragments;\n  const curFrags = curDetails.fragments;\n  if (!curFrags.length || !prevFrags.length) {\n    logger.log('No fragments to align');\n    return;\n  }\n  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    logger.log('No frag in previous level to align on');\n    return;\n  }\n  return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\nfunction alignStream(lastFrag, lastLevel, details) {\n  if (!lastLevel) {\n    return;\n  }\n  alignDiscontinuities(lastFrag, details, lastLevel);\n  if (!details.alignedSliding && lastLevel.details) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignPDT(details, lastLevel.details);\n  }\n  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(lastLevel.details, details);\n  }\n}\n\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(lastFrag, details, lastLevel) {\n  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n    const referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n\n/**\n * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n * @param details - The details of the new level\n * @param lastDetails - The details of the last loaded level\n */\nfunction alignPDT(details, lastDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n    return;\n  }\n  // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n  // then we can deduce that playlist B sliding is 1000+8 = 1008s\n  const lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n  const newPDT = details.fragments[0].programDateTime;\n  // date diff is in ms. frag.start is in seconds\n  const sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n  if (sliding && isFiniteNumber(sliding)) {\n    logger.log(`Adjusting PTS using programDateTime delta ${newPDT - lastPDT}ms, sliding:${sliding.toFixed(3)} ${details.url} `);\n    adjustSlidingStart(sliding, details);\n  }\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT. Unlike `alignPDT`, which adjusts\n * the timeline based on the delta between PDTs of the 0th fragment of two playlists/`LevelDetails`,\n * this function assumes the timelines represented in `refDetails` are accurate, including the PDTs,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  const middleFrag = Math.round(refFragments.length / 2) - 1;\n  const refFrag = refFragments[middleFrag];\n  const frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (refPDT === null || targetPDT === null) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\nclass AESCrypto {\n  constructor(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n  decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  }\n}\n\nclass FastAESKey {\n  constructor(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n  expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    if (this.subtle === null) {\n      this.useSoftware = true;\n    }\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv) {\n    const subtle = this.subtle;\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new FastAESKey(subtle, key);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(subtle, new Uint8Array(iv));\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv);\n    });\n  }\n  onWebCryptoError(data, key, iv) {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    const decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = sliceUint8(data, 0, splitPoint);\n      this.remainderData = sliceUint8(data, splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\n\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super();\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.loadedmetadata = false;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.onvseeking = null;\n    this.onvended = null;\n    this.logPrefix = '';\n    this.log = void 0;\n    this.warn = void 0;\n    this.playlistType = playlistType;\n    this.logPrefix = logPrefix;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n    // of nothing loading/loaded return false\n    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levels$this$lev;\n      return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;\n    }\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching() {\n    const media = this.media;\n    if (media != null && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    if (media && this.onvseeking && this.onvended) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n    if (this.keyLoader) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onMediaSeeking() {\n    const {\n      config,\n      fragCurrent,\n      media,\n      mediaBuffer,\n      state\n    } = this;\n    const currentTime = media ? media.currentTime : 0;\n    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent) {\n      // Seeking while frag load is in progress\n      const tolerance = config.maxFragLookUpTolerance;\n      const fragStartOffset = fragCurrent.start - tolerance;\n      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      // if seeking out of buffered range or into new one\n      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n        const pastFragment = currentTime > fragEndOffset;\n        // if the seek position is outside the current fragment range\n        if (currentTime < fragStartOffset || pastFragment) {\n          if (pastFragment && fragCurrent.loader) {\n            this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n            fragCurrent.abortRequests();\n            this.resetLoadingState();\n          }\n          this.fragPrevious = null;\n        }\n      }\n    }\n    if (media) {\n      // Remove gap fragments\n      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n      this.lastCurrentTime = currentTime;\n    }\n\n    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    }\n\n    // Async tick to speed up processing\n    this.tickImmediate();\n  }\n  onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  }\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n    this.initPTS = [];\n  }\n  onHandlerDestroying() {\n    this.stopLoad();\n    super.onHandlerDestroying();\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(frag, level, targetBufferTime) {\n    const progressCallback = data => {\n      if (this.fragContextChanged(frag)) {\n        this.warn(`Fragment ${frag.sn}${data.part ? ' p: ' + data.part.index : ''} of level ${frag.level} was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the buffer size and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(frag, level) {\n    this._doFragLoad(frag, level).then(data => {\n      if (!data || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return data;\n        });\n      }\n      return data;\n    }).then(data => {\n      const {\n        fragCurrent,\n        hls,\n        levels\n      } = this;\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n      const stats = frag.stats;\n      this.state = State.IDLE;\n      level.fragmentError = 0;\n      frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now();\n\n      // Silence FRAG_BUFFERED event if fragCurrent is null\n      if (data.frag === fragCurrent) {\n        hls.trigger(Events.FRAG_BUFFERED, {\n          stats,\n          frag: fragCurrent,\n          part: null,\n          id: frag.type\n        });\n      }\n      this.tick();\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n  }\n  fragBufferedComplete(frag, part) {\n    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track'} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    this.state = State.IDLE;\n    if (!media) {\n      return;\n    }\n    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    }\n    this.tick();\n  }\n  seekToStartPos() {}\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted && details.encryptedFragments.length) {\n      this.keyLoader.loadClear(frag, details.encryptedFragments);\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type) {\n    const {\n      config: {\n        maxBufferHole\n      }\n    } = this;\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold) {\n    const config = this.config;\n    const minLength = threshold || config.maxBufferLength;\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    let frag;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(frag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    const gapStart = frag.gap;\n    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    if (nextFragment === null) {\n      return nextFragment;\n    }\n    frag = nextFragment;\n    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n      // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n        // Returning here might result in not finding an audio and video candiate to skip to\n        this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n        return null;\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails, fragments) {\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findFragWithCC(fragments, fragPrevious.cc);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const tolerance = config.maxFragLookUpTolerance;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = media.currentTime;\n    const start = levelDetails.fragments[0].start;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  }\n  alignPlaylists(details, previousDetails) {\n    const {\n      levels,\n      levelLastLoaded,\n      fragPrevious\n    } = this;\n    const lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;\n\n    // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragments[0].start;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      alignStream(fragPrevious, lastLevel, details);\n      const alignedSlidingStart = details.fragments[0].start;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : 'na'} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist, adjust startPosition to ${startPosition}`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition;\n    }\n    this.nextLoadPosition = startPosition;\n  }\n  getLoadPosition() {\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent2;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n      var _this$levelLastLoaded;\n      this.resetStartWhenNotLoaded((_this$levelLastLoaded = this.levelLastLoaded) != null ? _this$levelLastLoaded : frag.level);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered) {\n          errorAction.resolved = true;\n        }\n      } else {\n        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n      }\n    } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (data.frag) {\n        this.fragmentTracker.removeFragment(data.frag);\n        this.nextLoadPosition = data.frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      const details = this.levels ? this.levels[level].details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    var _this$levelLastLoaded2;\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded((_this$levelLastLoaded2 = this.levelLastLoaded) != null ? _this$levelLastLoaded2 : chunkMeta.level);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    var _this$transmuxer;\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (parsed) {\n      level.fragmentError = 0;\n    } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        level.fragmentError++;\n        frag.gap = true;\n        this.fragmentTracker.removeFragment(frag);\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        frag,\n        reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n      });\n      if (!this.hls) {\n        return;\n      }\n      this.resetTransmuxer();\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n\n    this.state = State.PARSED;\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      var _ref, _this$levelLastLoaded3, _this$fragCurrent3;\n      this.fragmentTracker.removeAllFragments();\n      this.resetTransmuxer();\n      this.resetStartWhenNotLoaded((_ref = (_this$levelLastLoaded3 = this.levelLastLoaded) != null ? _this$levelLastLoaded3 : (_this$fragCurrent3 = this.fragCurrent) == null ? void 0 : _this$fragCurrent3.level) != null ? _ref : 0);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\n\n/**\n * @ignore\n */\nfunction isSupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n  const sourceBuffer = getSourceBuffer();\n  const isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  return !!isTypeSupported && !!sourceBufferValidAPI;\n}\n\n/**\n * @ignore\n */\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  return {\n    worker,\n    objectURL\n  };\n}\nfunction loadWorker(path) {\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  return {\n    worker,\n    scriptURL\n  };\n}\n\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getID3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParse$2(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = getID3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = sliceUint8(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {}\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  let adtsObjectType;\n  let adtsExtensionSamplingIndex;\n  let adtsChannelConfig;\n  let config;\n  const userAgent = navigator.userAgent.toLowerCase();\n  const manifestCodec = audioCodec;\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n    observer.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      reason: `invalid ADTS sampling index:${adtsSamplingIndex}`\n    });\n    return;\n  }\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n  // byte 3\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChannelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSamplingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return {\n    config,\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\n    channelCount: adtsChannelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    // ensure we find a moof box in the first 16 kB\n    data = data.length > 16384 ? data.subarray(0, 16384) : data;\n    return findBox(data, ['moof']).length > 0;\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {}\n}\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\n\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\n\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS() {\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = this.readUByte.bind(this);\n    const readBits = this.readBits.bind(this);\n    const readUEG = this.readUEG.bind(this);\n    const readBoolean = this.readBoolean.bind(this);\n    const skipBits = this.skipBits.bind(this);\n    const skipEG = this.skipEG.bind(this);\n    const skipUEG = this.skipUEG.bind(this);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n  readSliceType() {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  }\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._avcTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n  }\n  static probe(data) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets (#5501)\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._avcTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _avcTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_avcTrack) {\n      _avcTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._avcTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let avcId = videoTrack.pid;\n    let avcData = videoTrack.pesData;\n    let audioId = audioTrack.pid;\n    let id3Id = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case avcId:\n            if (stt) {\n              if (avcData && (pes = parsePES(avcData))) {\n                this.parseAVCPES(videoTrack, textTrack, pes, false);\n              }\n              avcData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (avcData) {\n              avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              avcData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioId:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Id:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              avcId = parsedPIDs.avc;\n              if (avcId > 0) {\n                videoTrack.pid = avcId;\n              }\n              audioId = parsedPIDs.audio;\n              if (audioId > 0) {\n                audioTrack.pid = audioId;\n                audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n              }\n              id3Id = parsedPIDs.id3;\n              if (id3Id > 0) {\n                id3Track.pid = id3Id;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        reason: error.message\n      });\n    }\n    videoTrack.pesData = avcData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._avcTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const avcData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (avcData && (pes = parsePES(avcData))) {\n      this.parseAVCPES(videoTrack, textTrack, pes, true);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = avcData;\n    }\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    this._duration = 0;\n  }\n  parseAVCPES(track, textTrack, pes, last) {\n    const units = this.parseAVCNALu(track, pes.data);\n    let avcSample = this.avcSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (avcSample && units.length && !track.audFound) {\n      pushAccessUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n    units.forEach(unit => {\n      var _avcSample2;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = new ExpGolomb(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _avcSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_avcSample = avcSample) != null && _avcSample.frame && !avcSample.key) {\n                pushAccessUnit(avcSample, track);\n                avcSample = this.avcSample = null;\n              }\n            }\n            if (!avcSample) {\n              avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n            }\n            avcSample.frame = true;\n            avcSample.key = iskey;\n            break;\n            // IDR\n          }\n\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n          if ((_avcSample2 = avcSample) != null && _avcSample2.frame && !avcSample.key) {\n            pushAccessUnit(avcSample, track);\n            avcSample = this.avcSample = null;\n          }\n          if (!avcSample) {\n            avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n          }\n          avcSample.key = true;\n          avcSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n\n        case 7:\n          push = true;\n          spsfound = true;\n          if (!track.sps) {\n            const sps = unit.data;\n            const expGolombDecoder = new ExpGolomb(sps);\n            const config = expGolombDecoder.readSPS();\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.sps = [sps];\n            track.duration = this._duration;\n            const codecarray = sps.subarray(1, 4);\n            let codecstring = 'avc1.';\n            for (let i = 0; i < 3; i++) {\n              let h = codecarray[i].toString(16);\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n              codecstring += h;\n            }\n            track.codec = codecstring;\n          }\n          break;\n        // PPS\n        case 8:\n          push = true;\n          if (!track.pps) {\n            track.pps = [unit.data];\n          }\n          break;\n        // AUD\n        case 9:\n          push = false;\n          track.audFound = true;\n          if (avcSample) {\n            pushAccessUnit(avcSample, track);\n          }\n          avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          if (avcSample) {\n            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n          break;\n      }\n      if (avcSample && push) {\n        const units = avcSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && avcSample) {\n      pushAccessUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  }\n  getLastNalUnit(samples) {\n    var _avcSample3;\n    let avcSample = this.avcSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!avcSample || avcSample.units.length === 0) {\n      avcSample = samples[samples.length - 1];\n    }\n    if ((_avcSample3 = avcSample) != null && _avcSample3.units) {\n      const units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  parseAVCNALu(track, array) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, i - state - 1),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n            overflow = i - state - 1;\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              const tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        const tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);\n        tmp.set(lastUnit.data, 0);\n        tmp.set(array, lastUnit.data.byteLength);\n        lastUnit.data = tmp;\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        const tmp = new Uint8Array(sampleLength + data.byteLength);\n        tmp.set(aacOverFlow.sample.unit, 0);\n        tmp.set(data, sampleLength);\n        data = tmp;\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      const error = new Error(reason);\n      logger.warn(`parsing error: ${reason}`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        levelRetry: recoverable,\n        error,\n        reason\n      });\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$1(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction createAVCSample(key, pts, dts, debug) {\n  return {\n    key,\n    frame: false,\n    pts,\n    dts,\n    units: [],\n    debug,\n    length: 0\n  };\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n  const result = {\n    audio: -1,\n    avc: -1,\n    id3: -1,\n    segmentCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logger.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logger.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.segmentCodec = 'mp3';\n        }\n        break;\n      case 0x24:\n        logger.warn('Unsupported HEVC stream type found');\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n  }\n  return result;\n}\nfunction parsePES(stream) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    const newData = new Uint8Array(data[0].length + data[1].length);\n    newData.set(data[0]);\n    newData.set(data[1], data[0].length);\n    data[0] = newData;\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\nfunction pushAccessUnit(avcSample, avcTrack) {\n  if (avcSample.units.length && avcSample.frame) {\n    // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n    if (avcSample.pts === undefined) {\n      const samples = avcTrack.samples;\n      const nbSamples = samples.length;\n      if (nbSamples) {\n        const lastSample = samples[nbSamples - 1];\n        avcSample.pts = lastSample.pts;\n        avcSample.dts = lastSample.dts;\n      } else {\n        // dropping samples, no timestamp found\n        avcTrack.dropped++;\n        return;\n      }\n    }\n    avcTrack.samples.push(avcSample);\n  }\n  if (avcSample.debug.length) {\n    logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n  }\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const configlen = track.config.length;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x17 + configlen,\n    // length\n    0x00, 0x01,\n    // es_id\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x0f + configlen,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  }\n\n  static mp4a(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]));\n  }\n  static stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = track.duration * track.timescale;\n    const width = track.width;\n    const height = track.height;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n  constructor(observer, config, typeSupported, vendor = '') {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {}\n  resetTimeStamp(defaultTimeStamp) {\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  }\n  getVideoStartPts(videoSamples) {\n    let rolloverDetected = false;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      const delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    let nextAvcDts = this.nextAvcDts;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      const pts = timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      // if not contiguous, let's use target timeOffset\n      nextAvcDts = pts - cts;\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextAvcDts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected, filling it`);\n        } else {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected`);\n        }\n        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {\n          firstDTS = nextAvcDts;\n          const firstPTS = inputSamples[0].pts - delta;\n          inputSamples[0].dts = firstDTS;\n          inputSamples[0].pts = firstPTS;\n          logger.log(`Video: First PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      sample.dts = Math.max(sample.dts, firstDTS);\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const avcSample = inputSamples[i];\n      const avcSampleUnits = avcSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n        const unit = avcSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - avcSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? avcSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? avcSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioPts = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            const newStamp = Math.max(nextPts, 0);\n            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = firstPTS / inputTimeScale;\n    const end = nextAudioPts / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const nextAudioPts = this.nextAudioPts;\n    // sync with video's timestamp\n    const initDTS = this._initDTS;\n    const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n    // one sample's duration value\n    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n    const samples = [];\n    for (let i = 0; i < nbSamples; i++) {\n      const stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nclass Mp4Sample {\n  constructor(isKeyframe, duration, size, cts) {\n    this.size = void 0;\n    this.duration = void 0;\n    this.cts = void 0;\n    this.flags = void 0;\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = new Mp4SampleFlags(isKeyframe);\n  }\n}\nclass Mp4SampleFlags {\n  constructor(isKeyframe) {\n    this.isLeading = 0;\n    this.isDependedOn = 0;\n    this.hasRedundancy = 0;\n    this.degradPrio = 0;\n    this.dependsOn = 1;\n    this.isNonSync = 1;\n    this.dependsOn = isKeyframe ? 2 : 1;\n    this.isNonSync = isKeyframe ? 0 : 1;\n  }\n}\n\nclass PassThroughRemuxer {\n  constructor() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndTime = null;\n  }\n  resetNextTimestamp() {\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment or fallback to default\n    if (!audioCodec) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n    }\n    if (!videoCodec) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const duration = getDuration(data, initData);\n    const startDTS = getStartDTS(initData, data);\n    const decodeTime = startDTS === null ? timeOffset : startDTS;\n    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      if (initPTS && initPTS.timescale === 1) {\n        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      logger.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.6.L120.90';\n  }\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n  if (parsedCodec === 'avc1' || type === ElementaryStreamTypes.VIDEO) {\n    return 'avc1.42e01e';\n  }\n  return 'mp4a.40.5';\n}\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  logger.debug('Unable to use Performance API on this environment');\n  now = typeof self !== 'undefined' && self.Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id) {\n    this.async = false;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      const decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''} of level ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported,\n      vendor\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n\nvar eventemitter3 = {exports: {}};\n\n(function (module) {\n\n\tvar has = Object.prototype.hasOwnProperty\n\t  , prefix = '~';\n\n\t/**\n\t * Constructor to create a storage for our `EE` objects.\n\t * An `Events` instance is a plain object whose properties are event names.\n\t *\n\t * @constructor\n\t * @private\n\t */\n\tfunction Events() {}\n\n\t//\n\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// character to make sure that the built-in object properties are not\n\t// overridden or used as an attack vector.\n\t//\n\tif (Object.create) {\n\t  Events.prototype = Object.create(null);\n\n\t  //\n\t  // This hack is needed because the `__proto__` property is still inherited in\n\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t  //\n\t  if (!new Events().__proto__) prefix = false;\n\t}\n\n\t/**\n\t * Representation of a single event listener.\n\t *\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t * @constructor\n\t * @private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t * @returns {EventEmitter}\n\t * @private\n\t */\n\tfunction addListener(emitter, event, fn, context, once) {\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('The listener must be a function');\n\t  }\n\n\t  var listener = new EE(fn, context || emitter, once)\n\t    , evt = prefix ? prefix + event : event;\n\n\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t  return emitter;\n\t}\n\n\t/**\n\t * Clear event by name.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} evt The Event name.\n\t * @private\n\t */\n\tfunction clearEvent(emitter, evt) {\n\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t  else delete emitter._events[evt];\n\t}\n\n\t/**\n\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t * `EventEmitter` interface.\n\t *\n\t * @constructor\n\t * @public\n\t */\n\tfunction EventEmitter() {\n\t  this._events = new Events();\n\t  this._eventsCount = 0;\n\t}\n\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var names = []\n\t    , events\n\t    , name;\n\n\t  if (this._eventsCount === 0) return names;\n\n\t  for (name in (events = this._events)) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\n\t  return names;\n\t};\n\n\t/**\n\t * Return the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Array} The registered listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , handlers = this._events[evt];\n\n\t  if (!handlers) return [];\n\t  if (handlers.fn) return [handlers.fn];\n\n\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = handlers[i].fn;\n\t  }\n\n\t  return ee;\n\t};\n\n\t/**\n\t * Return the number of listeners listening to a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Number} The number of listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , listeners = this._events[evt];\n\n\t  if (!listeners) return 0;\n\t  if (listeners.fn) return 1;\n\t  return listeners.length;\n\t};\n\n\t/**\n\t * Calls each of the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t * @public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return false;\n\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\n\t  if (listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\n\t  return true;\n\t};\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  return addListener(this, event, fn, context, false);\n\t};\n\n\t/**\n\t * Add a one-time listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  return addListener(this, event, fn, context, true);\n\t};\n\n\t/**\n\t * Remove the listeners of a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn Only remove the listeners that match this function.\n\t * @param {*} context Only remove the listeners that have this context.\n\t * @param {Boolean} once Only remove one-time listeners.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return this;\n\t  if (!fn) {\n\t    clearEvent(this, evt);\n\t    return this;\n\t  }\n\n\t  var listeners = this._events[evt];\n\n\t  if (listeners.fn) {\n\t    if (\n\t      listeners.fn === fn &&\n\t      (!once || listeners.once) &&\n\t      (!context || listeners.context === context)\n\t    ) {\n\t      clearEvent(this, evt);\n\t    }\n\t  } else {\n\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t      if (\n\t        listeners[i].fn !== fn ||\n\t        (once && !listeners[i].once) ||\n\t        (context && listeners[i].context !== context)\n\t      ) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\n\t    //\n\t    // Reset the array, or remove it completely if we have no more listeners.\n\t    //\n\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t    else clearEvent(this, evt);\n\t  }\n\n\t  return this;\n\t};\n\n\t/**\n\t * Remove all listeners, or those of the specified event.\n\t *\n\t * @param {(String|Symbol)} [event] The event name.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  var evt;\n\n\t  if (event) {\n\t    evt = prefix ? prefix + event : event;\n\t    if (this._events[evt]) clearEvent(this, evt);\n\t  } else {\n\t    this._events = new Events();\n\t    this._eventsCount = 0;\n\t  }\n\n\t  return this;\n\t};\n\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\n\t//\n\t// Allow `EventEmitter` to be imported as module namespace.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\n\t//\n\t// Expose the module.\n\t//\n\t{\n\t  module.exports = EventEmitter;\n\t} \n} (eventemitter3));\n\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\nconst MediaSource$1 = getMediaSource() || {\n  isTypeSupported: () => false\n};\nclass TransmuxerInterface {\n  constructor(hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    const config = hls.config;\n    this.hls = hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      if (ev === Events.ERROR) {\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const typeSupported = {\n      mp4: MediaSource$1.isTypeSupported('video/mp4'),\n      mpeg: MediaSource$1.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    };\n    // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n    const vendor = navigator.vendor;\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          this.onwmsg = ev => this.onWorkerMessage(ev);\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onwmsg);\n          worker.onerror = event => {\n            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n            config.enableWorker = false;\n            logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: 'demuxerWorker',\n              error\n            });\n          };\n          worker.postMessage({\n            cmd: 'init',\n            typeSupported: typeSupported,\n            vendor: vendor,\n            id: id,\n            config: JSON.stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.resetWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n  }\n  resetWorker() {\n    if (this.workerContext) {\n      const {\n        worker,\n        objectURL\n      } = this.workerContext;\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.removeEventListener('message', this.onwmsg);\n      worker.onerror = null;\n      worker.terminate();\n      this.workerContext = null;\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.resetWorker();\n      this.onwmsg = undefined;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxer.async = true;\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        transmuxer.async = false;\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      let transmuxResult = transmuxer.flush(chunkMeta);\n      const asyncFlush = isPromise(transmuxResult);\n      if (asyncFlush || transmuxer.async) {\n        if (!isPromise(transmuxResult)) {\n          transmuxResult = Promise.resolve(transmuxResult);\n        }\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  onWorkerMessage(ev) {\n    const data = ev.data;\n    const hls = this.hls;\n    switch (data.event) {\n      case 'init':\n        {\n          var _this$workerContext;\n          const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          break;\n        }\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      // pass logs from the worker thread to the main logger\n      case 'workerLog':\n        if (logger[data.data.logType]) {\n          logger[data.data.logType](data.data.message);\n        }\n        break;\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  }\n  configureTransmuxer(config) {\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\n\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n  constructor(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n  destroy() {\n    this.media = null;\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(lastCurrentTime, activeFrag) {\n    const {\n      config,\n      media,\n      stalled\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const {\n      currentTime,\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          const _stalledDuration = self.performance.now() - stalled;\n          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n          this.stallReported = false;\n        }\n        this.stalled = null;\n        this.nudgeRetry = 0;\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      this.stalled = null;\n      return;\n    }\n\n    // The playhead should not be moving\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n      return;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const isBuffered = bufferInfo.len > 0;\n    const nextStart = bufferInfo.nextStart || 0;\n\n    // There is no playable buffer (seeked, waiting for buffer)\n    if (!isBuffered && !nextStart) {\n      return;\n    }\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        this._trySkipBufferHole(partialOrGap);\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const tnow = self.performance.now();\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    const {\n      config,\n      fragmentTracker,\n      media\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      logger.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n      this.stalled = null;\n      this._tryNudgeBuffer();\n    }\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported\n    } = this;\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n      logger.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    const {\n      config,\n      hls,\n      media\n    } = this;\n    if (media === null) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          const {\n            fragmentTracker\n          } = this;\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n        if (partial && !partial.gap) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer() {\n    const {\n      config,\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      logger.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      logger.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true\n      });\n    }\n  }\n}\n\nconst TICK_INTERVAL$2 = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.gapController = null;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this.altAudio = false;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.onvplaying = null;\n    this.onvseeked = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.onMediaDetaching();\n  }\n  startLoad(startPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL$2);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.nextAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          var _levels$level;\n          const {\n            levels,\n            level\n          } = this;\n          const details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;\n          if (details && (!details.live || this.levelLastLoaded === this.level)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            this.resetStartWhenNotLoaded(this.level);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    super.onTickEnd();\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n    const {\n      config,\n      nextLoadLevel: level\n    } = hls;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n  }\n  onMediaDetaching() {\n    const {\n      media\n    } = this;\n    if (media && this.onvplaying && this.onvseeked) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n    this.fragPlaying = null;\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n    super.onMediaDetaching();\n  }\n  onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onMediaSeeked() {\n    const media = this.media;\n    const currentTime = media ? media.currentTime : null;\n    if (isFiniteNumber(currentTime)) {\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n    }\n\n    // If seeked was issued before buffer was appended do not tick immediately\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null || bufferInfo.len === 0) {\n      this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n      return;\n    }\n\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = false;\n    this.startPosition = this.lastCurrentTime = 0;\n    this.levels = this.fragPlaying = this.backtrackFragment = null;\n    this.altAudio = this.audioOnly = false;\n  }\n  onManifestParsed(event, data) {\n    let aac = false;\n    let heaac = false;\n    let codec;\n    data.levels.forEach(level => {\n      // detect if we have different kind of audio codecs used amongst playlists\n      codec = level.audioCodec;\n      if (codec) {\n        if (codec.indexOf('mp4a.40.2') !== -1) {\n          aac = true;\n        }\n        if (codec.indexOf('mp4a.40.5') !== -1) {\n          heaac = true;\n        }\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = levels[data.level];\n    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = levels[newLevelId];\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = newLevelId;\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio;\n    const altAudio = !!data.url;\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      const hls = this.hls;\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        this.fragmentTracker.removeAllFragments();\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const trackId = data.id;\n    const altAudio = !!this.hls.audioTracks[trackId].url;\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag && frag.type !== PlaylistLevelType.MAIN) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n      if (this.state === State.PARSED) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n\n  // Checks the health of the buffer and attempts to resolve playback stalls.\n  checkBuffer() {\n    const {\n      media,\n      gapController\n    } = this;\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n    }\n  }\n  onLevelsUpdated(event, data) {\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n      media.currentTime = startPosition;\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(frag, level) {\n    frag.bitrateTest = true;\n    this._doFragLoad(frag, level).then(data => {\n      const {\n        hls\n      } = this;\n      if (!data || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'main';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const initPTS = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      if (isFiniteNumber(initPTS)) {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details && frag.sn !== 'initSegment') {\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      let audioCodec = currentLevel.audioCodec;\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${currentLevel.audioCodec || ''}/${audio.codec}]`);\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${video.codec}]`);\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.attrs.CODECS || ''}/${audiovideo.codec}]`);\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    // loop through tracks that are going to be provided to bufferController\n    Object.keys(tracks).forEach(trackName => {\n      const track = tracks[trackName];\n      const initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        this.hls.trigger(Events.BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag,\n          part: null,\n          chunkMeta,\n          parent: frag.type\n        });\n      }\n    });\n    // trigger handler right now\n    this.tick();\n  }\n  getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    const media = this.media;\n    if (media) {\n      return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    const media = this.media;\n    if (media) {\n      const currentTime = media.currentTime;\n      const frag = this.currentFrag;\n      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n        return new Date(epocMs);\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  destroy() {}\n}\n\nclass AbrController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = 0;\n    this._nextAutoLevel = -1;\n    this.timer = -1;\n    this.onCheck = this._abandonRulesCheck.bind(this);\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    this.hls = hls;\n    const config = hls.config;\n    this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.onCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onFragLoading(event, data) {\n    var _data$part;\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    this.fragCurrent = frag;\n    this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    this.clearTimer();\n    this.timer = self.setInterval(this.onCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      total,\n      bwEstimate\n    } = data.stats;\n    // Total is the bytelength and bwEstimate in bits/sec\n    if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {\n      this.lastLevelLoadSec = 8 * total / bwEstimate;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n\n  /*\n      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n      quickly enough to prevent underbuffering\n    */\n  _abandonRulesCheck() {\n    const {\n      fragCurrent: frag,\n      partCurrent: part,\n      hls\n    } = this;\n    const {\n      autoLevelEnabled,\n      media\n    } = hls;\n    if (!frag || !media) {\n      return;\n    }\n    const now = performance.now();\n    const stats = part ? part.stats : frag.stats;\n    const duration = part ? part.duration : frag.duration;\n    const timeLoading = now - stats.loading.start;\n    // If frag loading is aborted, complete, or from lowest level, stop timer and return\n    if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {\n      this.clearTimer();\n      // reset forced auto level value so that next level will be selected\n      this._nextAutoLevel = -1;\n      return;\n    }\n\n    // This check only runs if we're in ABR mode and actually playing\n    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n      return;\n    }\n    const bufferInfo = hls.mainForwardBufferInfo;\n    if (bufferInfo === null) {\n      return;\n    }\n    const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n    const playbackRate = Math.abs(media.playbackRate);\n    // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n    if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n      return;\n    }\n\n    // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n    const bufferStarvationDelay = bufferInfo.len / playbackRate;\n    // Only downswitch if less than 2 fragment lengths are buffered\n    if (bufferStarvationDelay >= 2 * duration / playbackRate) {\n      return;\n    }\n    const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n    const loadedFirstByte = stats.loaded && ttfb > -1;\n    const bwEstimate = this.bwEstimator.getEstimate();\n    const {\n      levels,\n      minAutoLevel\n    } = hls;\n    const level = levels[frag.level];\n    const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n    let timeStreaming = timeLoading - ttfb;\n    if (timeStreaming < 1 && loadedFirstByte) {\n      timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n    }\n    const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n    // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n    const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n    // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n    if (fragLoadedDelay <= bufferStarvationDelay) {\n      return;\n    }\n    const bwe = loadRate ? loadRate * 8 : bwEstimate;\n    let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n    let nextLoadLevel;\n    // Iterate through lower level and try to find the largest one that avoids rebuffering\n    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n      // compute time to load next fragment at lower level\n      // 8 = bits per byte (bps/Bps)\n      const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n      fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n        break;\n      }\n    }\n    // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n    // to load the current one\n    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n      return;\n    }\n\n    // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n    if (fragLevelNextLoadedDelay > duration * 10) {\n      return;\n    }\n    hls.nextLoadLevel = nextLoadLevel;\n    if (loadedFirstByte) {\n      // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n      this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n    } else {\n      // If there has been no loading progress, sample TTFB\n      this.bwEstimator.sampleTTFB(timeLoading);\n    }\n    this.clearTimer();\n    logger.warn(`[abr] Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb}\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown'} Kb/s\n      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s\n      Aborting and switching to level ${nextLoadLevel}`);\n    if (frag.loader) {\n      this.fragCurrent = this.partCurrent = null;\n      frag.abortRequests();\n    }\n    hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n      frag,\n      part,\n      stats\n    });\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // store level id after successful fragment load\n    this.lastLoadedFragLevel = frag.level;\n    // reset forced auto level value so that next level will be selected\n    this._nextAutoLevel = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.bwEstimator.getEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    self.clearInterval(this.timer);\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this._nextAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    let nextABRAutoLevel = this.getNextABRAutoLevel();\n    // use forced auto level when ABR selected level has errored\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n    // if forced auto level has been defined, use it to cap ABR computed quality level\n    if (forcedAutoLevel !== -1) {\n      nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n    }\n    return nextABRAutoLevel;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel,\n      media\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferInfo = hls.mainForwardBufferInfo;\n    const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    let bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n    if (bestLevel >= 0) {\n      return bestLevel;\n    }\n    logger.trace(`[abr] ${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, finding optimal quality level`);\n    // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    // if no matching level found, logic will return 0\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        logger.trace(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n    return Math.max(bestLevel, 0);\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n    var _level$details;\n    const {\n      fragCurrent,\n      partCurrent,\n      lastLoadedFragLevel: currentLevel\n    } = this;\n    const {\n      levels\n    } = this.hls;\n    const level = levels[currentLevel];\n    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n    const currentCodecSet = level == null ? void 0 : level.codecSet;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    let levelSkippedMin = minAutoLevel;\n    let levelSkippedMax = -1;\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      const levelInfo = levels[i];\n      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n        if (levelInfo) {\n          levelSkippedMin = Math.min(i, levelSkippedMin);\n          levelSkippedMax = Math.max(i, levelSkippedMax);\n        }\n        continue;\n      }\n      if (levelSkippedMax !== -1) {\n        logger.trace(`[abr] Skipped level(s) ${levelSkippedMin}-${levelSkippedMax} with CODECS:\"${levels[levelSkippedMax].attrs.CODECS}\"; not compatible with \"${level.attrs.CODECS}\"`);\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (i <= currentLevel) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n      const bitrate = levels[i].maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      logger.trace(`[abr] level:${i} adjustedbw-bitrate:${Math.round(adjustedbw - bitrate)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)}`);\n      // if adjusted bw is greater than level bitrate AND\n      if (adjustedbw > bitrate && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    this._nextAutoLevel = nextLevel;\n  }\n}\n\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\nconst TICK_INTERVAL$1 = 100; // how often to tick in ms\n\nclass AudioStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[audio-stream-controller]', PlaylistLevelType.AUDIO);\n    this.videoBuffer = null;\n    this.videoTrackCC = -1;\n    this.waitingVideoCC = -1;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n    this.trackId = -1;\n    this.waitingData = null;\n    this.mainDetails = null;\n    this.bufferFlushed = false;\n    this.cachedTrackLoadedData = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      const cc = frag.cc;\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);\n      this.videoTrackCC = cc;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === State.WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  }\n  startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = State.STOPPED;\n      return;\n    }\n    const lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL$1);\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n      startPosition = lastCurrentTime;\n      this.state = State.IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.IDLE:\n        this.doTickIdle();\n        break;\n      case State.WAITING_TRACK:\n        {\n          var _levels$trackId;\n          const {\n            levels,\n            trackId\n          } = this;\n          const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded(this.trackId);\n            this.state = State.IDLE;\n          }\n          break;\n        }\n      case State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          const waitingData = this.waitingData;\n          if (waitingData) {\n            const {\n              frag,\n              part,\n              cache,\n              complete\n            } = waitingData;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = State.FRAG_LOADING;\n              const payload = cache.flush();\n              const data = {\n                frag,\n                part,\n                payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                super._handleFragmentLoadComplete(data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              const pos = this.getLoadPosition();\n              const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n              if (waitingFragmentAtPosition < 0) {\n                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  }\n  clearWaitingFragment() {\n    const waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = State.IDLE;\n    }\n  }\n  resetLoadingState() {\n    this.clearWaitingFragment();\n    super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media\n    } = this;\n    if (!(media != null && media.readyState)) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levels,\n      media,\n      trackId\n    } = this;\n    const config = hls.config;\n    if (!(levels != null && levels[trackId])) {\n      return;\n    }\n\n    // if video not attached AND\n    // start fragment already requested OR start frag prefetch not enabled\n    // exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n    const levelInfo = levels[trackId];\n    const trackDetails = levelInfo.details;\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = State.WAITING_TRACK;\n      return;\n    }\n    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n    }\n    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    const {\n      bufferedTrack,\n      switchingTrack\n    } = this;\n    if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = State.ENDED;\n      return;\n    }\n    const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n    const bufferLen = bufferInfo.len;\n    const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n    if (bufferLen >= maxBufLen && !switchingTrack) {\n      return;\n    }\n    const fragments = trackDetails.fragments;\n    const start = fragments[0].start;\n    let targetBufferTime = bufferInfo.end;\n    if (switchingTrack && media) {\n      const pos = this.getLoadPosition();\n      if (bufferedTrack && switchingTrack.attrs !== bufferedTrack.attrs) {\n        targetBufferTime = pos;\n      }\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n    let frag = this.getNextFragment(targetBufferTime, trackDetails);\n    let atGap = false;\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      atGap = !!frag.gap;\n      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    // Buffer audio up to one target duration ahead of main buffer\n    const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n    if (atBufferSyncLimit ||\n    // Or wait for main buffer after buffing some audio\n    !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n      // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n      const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n      if (mainFrag === null) {\n        return;\n      }\n      // Bridge gaps in main buffer\n      atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n      if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n        return;\n      }\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n  }\n  onMediaDetaching() {\n    this.videoBuffer = null;\n    super.onMediaDetaching();\n  }\n  onAudioTracksUpdated(event, {\n    audioTracks\n  }) {\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const altAudio = !!data.url;\n    this.trackId = data.id;\n    const {\n      fragCurrent\n    } = this;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.removeUnbufferedFrags(fragCurrent.start);\n    }\n    this.resetLoadingState();\n    // destroy useless transmuxer when switching audio to main\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL$1);\n    }\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.switchingTrack = data;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.state = State.IDLE;\n    } else {\n      this.switchingTrack = null;\n      this.bufferedTrack = data;\n      this.state = State.STOPPED;\n    }\n    this.tick();\n  }\n  onManifestLoading() {\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = false;\n    this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n    this.startFragRequested = false;\n    this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    if (this.cachedTrackLoadedData !== null) {\n      this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n      this.cachedTrackLoadedData = null;\n    }\n  }\n  onAudioTrackLoaded(event, data) {\n    var _track$details;\n    if (this.mainDetails == null) {\n      this.cachedTrackLoadedData = data;\n      return;\n    }\n    const {\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    this.log(`Track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    const track = levels[trackId];\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      const mainDetails = this.mainDetails;\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        alignMediaPlaylistByPDT(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      config,\n      trackId,\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const track = levels[trackId];\n    if (!track) {\n      this.warn('Audio track is undefined on fragment load progress');\n      return;\n    }\n    const details = track.details;\n    if (!details) {\n      this.warn('Audio track details undefined on fragment load progress');\n      this.removeUnbufferedFrags(frag.start);\n      return;\n    }\n    const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    let transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    const initPTS = this.initPTS[frag.cc];\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      const partIndex = part ? part.index : -1;\n      const partial = partIndex !== -1;\n      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      const {\n        cache\n      } = this.waitingData = this.waitingData || {\n        frag,\n        part,\n        cache: new ChunkCache(),\n        complete: false\n      };\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = State.WAITING_INIT_PTS;\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    super._handleFragmentLoadComplete(fragLoadedData);\n  }\n  onBufferReset( /* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  }\n  onBufferCreated(event, data) {\n    const audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer || null;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag.type !== PlaylistLevelType.AUDIO) {\n      if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n        const bufferable = this.videoBuffer || this.media;\n        if (bufferable) {\n          const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n          if (bufferedTimeRanges.length) {\n            this.loadedmetadata = true;\n          }\n        }\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);\n      return;\n    }\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n      const track = this.switchingTrack;\n      if (track) {\n        this.bufferedTrack = track;\n        this.switchingTrack = null;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n        break;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'audio') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.bufferedTrack = null;\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type === ElementaryStreamTypes.AUDIO) {\n      this.bufferFlushed = true;\n      if (this.state === State.ENDED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'audio';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      details\n    } = level;\n    const {\n      audio,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (this.switchingTrack && audio) {\n      this.completeAudioSwitch(this.switchingTrack);\n    }\n    if (initSegment != null && initSegment.tracks) {\n      const mapFragment = frag.initSegment || frag;\n      this._bufferInitSegment(initSegment.tracks, mapFragment, chunkMeta);\n      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: mapFragment,\n        id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = _extends({\n        id,\n        frag,\n        details\n      }, id3);\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      const emittedText = _extends({\n        id,\n        frag,\n        details\n      }, text);\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n\n    // include levelCodec in audio and video tracks\n    const track = tracks.audio;\n    if (!track) {\n      return;\n    }\n    track.levelCodec = track.codec;\n    track.id = 'audio';\n    this.log(`Init audio buffer, container:${track.container}, codecs[parsed]=[${track.codec}]`);\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    const initSegment = track.initSegment;\n    if (initSegment != null && initSegment.byteLength) {\n      const segment = {\n        type: 'audio',\n        frag,\n        part: null,\n        chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tick();\n  }\n  loadFragment(frag, track, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      var _track$details2;\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, track);\n      } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n        this.state = State.WAITING_INIT_PTS;\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, track, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  completeAudioSwitch(switchingTrack) {\n    const {\n      hls,\n      media,\n      bufferedTrack\n    } = this;\n    const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n    const switchAttributes = switchingTrack.attrs;\n    if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedAttributes.NAME !== switchAttributes.NAME || bufferedAttributes.LANGUAGE !== switchAttributes.LANGUAGE)) {\n      this.log('Switching audio track : flushing all audio');\n      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n    }\n    this.bufferedTrack = switchingTrack;\n    this.switchingTrack = null;\n    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n  }\n}\n\nclass AudioTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[audio-track-controller]');\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n  }\n  onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  }\n  onAudioTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`audio-track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo != null && levelInfo.audioGroupIds)) {\n      return;\n    }\n    const audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];\n    if (this.groupId !== audioGroupId) {\n      this.groupId = audioGroupId || null;\n      const audioTracks = this.tracks.filter(track => !audioGroupId || track.groupId === audioGroupId);\n\n      // Disable selectDefaultTrack if there are no default tracks\n      if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {\n        this.selectDefaultTrack = false;\n      }\n      this.tracksInGroup = audioTracks;\n      const audioTracksUpdated = {\n        audioTracks\n      };\n      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group:${audioGroupId}`);\n      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      this.selectInitialTrack();\n    } else if (this.shouldReloadPlaylist(this.currentTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setAudioTrack(this.trackId);\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.requestScheduled = -1;\n      this.checkRetry(data);\n    }\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(newId) {\n    // If audio track is selected from API then don't choose from the manifest default track\n    this.selectDefaultTrack = false;\n    this.setAudioTrack(newId);\n  }\n  setAudioTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn('Invalid id passed to audio-track controller');\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    const lastTrack = this.currentTrack;\n    tracks[this.trackId];\n    const track = tracks[newId];\n    const {\n      groupId,\n      name\n    } = track;\n    this.log(`Switching to audio-track ${newId} \"${name}\" lang:${track.lang} group:${groupId}`);\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.selectDefaultTrack = false;\n    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n    // Do not reload track unless live\n    if (track.details && !track.details.live) {\n      return;\n    }\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n  selectInitialTrack() {\n    const audioTracks = this.tracksInGroup;\n    const trackId = this.findTrackId(this.currentTrack) | this.findTrackId(null);\n    if (trackId !== -1) {\n      this.setAudioTrack(trackId);\n    } else {\n      const error = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${audioTracks.length}`);\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n        fatal: true,\n        error\n      });\n    }\n  }\n  findTrackId(currentTrack) {\n    const audioTracks = this.tracksInGroup;\n    for (let i = 0; i < audioTracks.length; i++) {\n      const track = audioTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!currentTrack || currentTrack.attrs['STABLE-RENDITION-ID'] !== undefined && currentTrack.attrs['STABLE-RENDITION-ID'] === track.attrs['STABLE-RENDITION-ID']) {\n          return track.id;\n        }\n        if (currentTrack.name === track.name && currentTrack.lang === track.lang) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const audioTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadPlaylist(audioTrack)) {\n      const id = audioTrack.id;\n      const groupId = audioTrack.groupId;\n      let url = audioTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      // track not retrieved yet, or live playlist we need to (re)load it\n      this.log(`loading audio-track playlist ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}`);\n      this.clearTimer();\n      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n}\n\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n  if (trackList1.length !== trackList2.length) {\n    return false;\n  }\n  for (let i = 0; i < trackList1.length; i++) {\n    if (!subtitleAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction subtitleAttributesIdentical(attrs1, attrs2) {\n  // Media options with the same rendition ID must be bit identical\n  const stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n  if (stableRenditionId) {\n    return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n  }\n  // When rendition ID is not present, compare attributes\n  return !['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED'].some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\n\nconst TICK_INTERVAL = 500; // how often to tick in ms\n\nclass SubtitleStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]', PlaylistLevelType.SUBTITLE);\n    this.levels = [];\n    this.currentTrackId = -1;\n    this.tracksBuffered = [];\n    this.mainDetails = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  startLoad(startPosition) {\n    this.stopLoad();\n    this.state = State.IDLE;\n    this.setInterval(TICK_INTERVAL);\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  }\n  onMediaDetaching() {\n    this.tracksBuffered = [];\n    super.onMediaDetaching();\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  }\n  onSubtitleFragProcessed(event, data) {\n    const {\n      frag,\n      success\n    } = data;\n    this.fragPrevious = frag;\n    this.state = State.IDLE;\n    if (!success) {\n      return;\n    }\n    const buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    let timeRange;\n    const fragStart = frag.start;\n    for (let i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    const fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      startOffset,\n      endOffset\n    } = data;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      const endOffsetSubtitles = endOffset - 1;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(buffered => {\n        for (let i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n    }\n  }\n  onFragBuffered(event, data) {\n    if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n      var _this$media;\n      if ((_this$media = this.media) != null && _this$media.buffered.length) {\n        this.loadedmetadata = true;\n      }\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(event, data) {\n    const frag = data.frag;\n    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n      if (this.fragCurrent) {\n        this.fragCurrent.abortRequests();\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(event, {\n    subtitleTracks\n  }) {\n    if (subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n      this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n      return;\n    }\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(mediaPlaylist => {\n      const level = new Level(mediaPlaylist);\n      this.tracksBuffered[level.id] = [];\n      return level;\n    });\n    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n    this.fragPrevious = null;\n    this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(event, data) {\n    this.currentTrackId = data.id;\n    if (!this.levels.length || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    const currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack != null && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    const {\n      currentTrackId,\n      levels\n    } = this;\n    if (!levels.length) {\n      return;\n    }\n    const track = levels[currentTrackId];\n    if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n      return;\n    }\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      const mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      const mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragments[0].start;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    const {\n      frag,\n      payload\n    } = fragLoadedData;\n    const decryptData = frag.decryptdata;\n    const hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      const startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: false,\n          error: err,\n          reason: err.message,\n          frag\n        });\n        throw err;\n      }).then(decryptedData => {\n        const endTime = performance.now();\n        hls.trigger(Events.FRAG_DECRYPTED, {\n          frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(err => {\n        this.warn(`${err.name}: ${err.message}`);\n        this.state = State.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = State.IDLE;\n      return;\n    }\n    if (this.state === State.IDLE) {\n      const {\n        currentTrackId,\n        levels\n      } = this;\n      const track = levels[currentTrackId];\n      if (!levels.length || !track || !track.details) {\n        return;\n      }\n      const {\n        config\n      } = this;\n      const currentTime = this.getLoadPosition();\n      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n      const {\n        end: targetBufferTime,\n        len: bufferLen\n      } = bufferedInfo;\n      const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n      const trackDetails = track.details;\n      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      const fragments = trackDetails.fragments;\n      const fragLen = fragments.length;\n      const end = trackDetails.edge;\n      let foundFrag = null;\n      const fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        const tolerance = config.maxFragLookUpTolerance;\n        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (!foundFrag) {\n        return;\n      }\n      foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n      if (foundFrag.sn !== 'initSegment') {\n        // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n        const curSNIdx = foundFrag.sn - trackDetails.startSN;\n        const prevFrag = fragments[curSNIdx - 1];\n        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n          foundFrag = prevFrag;\n        }\n      }\n      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, track, targetBufferTime);\n      }\n    }\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this.fragCurrent = frag;\n    if (frag.sn === 'initSegment') {\n      this._loadInitSegment(frag, level);\n    } else {\n      this.startFragRequested = true;\n      super.loadFragment(frag, level, targetBufferTime);\n    }\n  }\n  get mediaBufferTimeRanges() {\n    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass BufferableInstance {\n  constructor(timeranges) {\n    this.buffered = void 0;\n    const getRange = (name, index, length) => {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  }\n}\n\nclass SubtitleTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[subtitle-track-controller]');\n    this.media = null;\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n    this.queuedDefaultTrack = -1;\n    this.trackChangeListener = () => this.onTextTracksChanged();\n    this.asyncPollTrackChange = () => this.pollTrackChange(0);\n    this.useTextTrackPolling = false;\n    this.subtitlePollingInterval = -1;\n    this._subtitleDisplay = true;\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.trackChangeListener = this.asyncPollTrackChange = null;\n    super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(value) {\n    this._subtitleDisplay = value;\n    if (this.trackId > -1) {\n      this.toggleTrackModes(this.trackId);\n    }\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  }\n  pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);\n  }\n  onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n    const textTracks = filterSubtitleTracks(this.media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(track => {\n      clearCurrentCues(track);\n    });\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(event, data) {\n    const {\n      id,\n      details\n    } = data;\n    const {\n      trackId\n    } = this;\n    const currentTrack = this.tracksInGroup[trackId];\n    if (!currentTrack) {\n      this.warn(`Invalid subtitle track id ${id}`);\n      return;\n    }\n    const curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(`subtitle track ${id} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo != null && levelInfo.textGroupIds)) {\n      return;\n    }\n    const textGroupId = levelInfo.textGroupIds[levelInfo.urlId];\n    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n    if (this.groupId !== textGroupId) {\n      const subtitleTracks = this.tracks.filter(track => !textGroupId || track.groupId === textGroupId);\n      this.tracksInGroup = subtitleTracks;\n      const initialTrackId = this.findTrackId(lastTrack == null ? void 0 : lastTrack.name) || this.findTrackId();\n      this.groupId = textGroupId || null;\n      const subtitleTracksUpdated = {\n        subtitleTracks\n      };\n      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${textGroupId}\" group-id`);\n      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (initialTrackId !== -1) {\n        this.setSubtitleTrack(initialTrackId, lastTrack);\n      }\n    } else if (this.shouldReloadPlaylist(lastTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setSubtitleTrack(this.trackId, lastTrack);\n    }\n  }\n  findTrackId(name) {\n    const textTracks = this.tracksInGroup;\n    for (let i = 0; i < textTracks.length; i++) {\n      const track = textTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.checkRetry(data);\n    }\n  }\n\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(newId) {\n    this.selectDefaultTrack = false;\n    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n    this.setSubtitleTrack(newId, lastTrack);\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadPlaylist(currentTrack)) {\n      const id = currentTrack.id;\n      const groupId = currentTrack.groupId;\n      let url = currentTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      this.log(`Loading subtitle playlist for id ${id}`);\n      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes(newId) {\n    const {\n      media,\n      trackId\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    const groupTracks = textTracks.filter(track => track.groupId === this.groupId);\n    if (newId === -1) {\n      [].slice.call(textTracks).forEach(track => {\n        track.mode = 'disabled';\n      });\n    } else {\n      const oldTrack = groupTracks[trackId];\n      if (oldTrack) {\n        oldTrack.mode = 'disabled';\n      }\n    }\n    const nextTrack = groupTracks[newId];\n    if (nextTrack) {\n      nextTrack.mode = this.subtitleDisplay ? 'showing' : 'hidden';\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(newId, lastTrack) {\n    var _tracks$newId;\n    const tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n    if (this.trackId !== newId) {\n      this.toggleTrackModes(newId);\n    }\n\n    // exit if track id as already set or invalid\n    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) != null && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    const track = tracks[newId];\n    this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : ''));\n    this.trackId = newId;\n    if (track) {\n      const {\n        id,\n        groupId = '',\n        name,\n        type,\n        url\n      } = track;\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id,\n        groupId,\n        name,\n        type,\n        url\n      });\n      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n      this.loadPlaylist(hlsUrlParameters);\n    } else {\n      // switch to -1\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n    }\n  }\n  onTextTracksChanged() {\n    if (!this.useTextTrackPolling) {\n      self.clearInterval(this.subtitlePollingInterval);\n    }\n    // Media is undefined when switching streams via loadSource()\n    if (!this.media || !this.hls.config.renderTextTracksNatively) {\n      return;\n    }\n    let trackId = -1;\n    const tracks = filterSubtitleTracks(this.media.textTracks);\n    for (let id = 0; id < tracks.length; id++) {\n      if (tracks[id].mode === 'hidden') {\n        // Do not break in case there is a following track with showing.\n        trackId = id;\n      } else if (tracks[id].mode === 'showing') {\n        trackId = id;\n        break;\n      }\n    }\n\n    // Setting current subtitleTrack will invoke code.\n    if (this.subtitleTrack !== trackId) {\n      this.subtitleTrack = trackId;\n    }\n  }\n}\nfunction filterSubtitleTracks(textTrackList) {\n  const tracks = [];\n  for (let i = 0; i < textTrackList.length; i++) {\n    const track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n  append(operation, type) {\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && this.buffers[type]) {\n      this.executeNext(type);\n    }\n  }\n  insertAbort(operation, type) {\n    const queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  }\n  appendBlocker(type) {\n    let execute;\n    const promise = new Promise(resolve => {\n      execute = resolve;\n    });\n    const operation = {\n      execute,\n      onStart: () => {},\n      onComplete: () => {},\n      onError: () => {}\n    };\n    this.append(operation, type);\n    return promise;\n  }\n  executeNext(type) {\n    const {\n      buffers,\n      queues\n    } = this;\n    const sb = buffers[type];\n    const queue = queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (e) {\n        logger.warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n        operation.onError(e);\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        if (!(sb != null && sb.updating)) {\n          queue.shift();\n          this.executeNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    return this.queues[type][0];\n  }\n}\n\nconst MediaSource = getMediaSource();\nconst VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\nclass BufferController {\n  // The level details used to determine duration, target-duration and live\n\n  // cache the self generated object url to detect hijack of video tag\n\n  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n\n  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n\n  // The number of BUFFER_CODEC events received before any sourceBuffers are created\n\n  // The total number of BUFFER_CODEC events received\n\n  // A reference to the attached media element\n\n  // A reference to the active media source\n\n  // Last MP3 audio chunk appended\n\n  // counters\n\n  constructor(hls) {\n    this.details = null;\n    this._objectUrl = null;\n    this.operationQueue = void 0;\n    this.listeners = void 0;\n    this.hls = void 0;\n    this.bufferCodecEventsExpected = 0;\n    this._bufferCodecEventsTotal = 0;\n    this.media = null;\n    this.mediaSource = null;\n    this.lastMpegAudioChunk = null;\n    this.appendError = 0;\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = () => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      logger.log('[buffer-controller]: Media source opened');\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        this.updateMediaElementDuration();\n        this.hls.trigger(Events.MEDIA_ATTACHED, {\n          media\n        });\n      }\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      }\n      this.checkPendingTracks();\n    };\n    this._onMediaSourceClose = () => {\n      logger.log('[buffer-controller]: Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      logger.log('[buffer-controller]: Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        media,\n        _objectUrl\n      } = this;\n      if (media && media.src !== _objectUrl) {\n        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${media.src})`);\n      }\n    };\n    this.hls = hls;\n    this._initSourceBuffer();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n    this.lastMpegAudioChunk = null;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio || !true) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    logger.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    if (media && MediaSource) {\n      const ms = this.mediaSource = new MediaSource();\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      // link video and media Source\n      media.src = self.URL.createObjectURL(ms);\n      // cache the locally generated object url\n      this._objectUrl = media.src;\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  onMediaDetaching() {\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      logger.log('[buffer-controller]: media source detaching');\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          logger.warn(`[buffer-controller]: onMediaDetaching: ${err.message} while calling endOfStream`);\n        }\n      }\n      // Clean up the SourceBuffers by invoking onBufferReset\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (media.src === _objectUrl) {\n          media.removeAttribute('src');\n          media.load();\n        } else {\n          logger.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n  }\n  onBufferReset() {\n    this.getSourceBufferTypes().forEach(type => {\n      const sb = this.sourceBuffer[type];\n      try {\n        if (sb) {\n          this.removeBufferListeners(type);\n          if (this.mediaSource) {\n            this.mediaSource.removeSourceBuffer(sb);\n          }\n          // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n          this.sourceBuffer[type] = undefined;\n        }\n      } catch (err) {\n        logger.warn(`[buffer-controller]: Failed to reset the ${type} buffer`, err);\n      }\n    });\n    this._initSourceBuffer();\n  }\n  onBufferCodecs(event, data) {\n    const sourceBufferCount = this.getSourceBufferTypes().length;\n    Object.keys(data).forEach(trackName => {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        const track = this.tracks[trackName];\n        if (track && typeof track.buffer.changeType === 'function') {\n          const {\n            id,\n            codec,\n            levelCodec,\n            container,\n            metadata\n          } = data[trackName];\n          const currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          const nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          if (currentCodec !== nextCodec) {\n            const mimeType = `${container};codecs=${levelCodec || codec}`;\n            this.appendChangeType(trackName, mimeType);\n            logger.log(`[buffer-controller]: switching codec ${currentCodec} to ${nextCodec}`);\n            this.tracks[trackName] = {\n              buffer: track.buffer,\n              codec,\n              container,\n              levelCodec,\n              metadata,\n              id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        this.pendingTracks[trackName] = data[trackName];\n      }\n    });\n\n    // if sourcebuffers already created, do nothing ...\n    if (sourceBufferCount) {\n      return;\n    }\n    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  }\n  appendChangeType(type, mimeType) {\n    const {\n      operationQueue\n    } = this;\n    const operation = {\n      execute: () => {\n        const sb = this.sourceBuffer[type];\n        if (sb) {\n          logger.log(`[buffer-controller]: changing ${type} sourceBuffer type to ${mimeType}`);\n          sb.changeType(mimeType);\n        }\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: e => {\n        logger.warn(`[buffer-controller]: Failed to change ${type} SourceBuffer type`, e);\n      }\n    };\n    operationQueue.append(operation, type);\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      hls,\n      operationQueue,\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      frag,\n      part,\n      chunkMeta\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n    const fragStart = frag.start;\n    const operation = {\n      execute: () => {\n        chunkStats.executeStart = self.performance.now();\n        if (checkTimestampOffset) {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            const delta = fragStart - sb.timestampOffset;\n            if (Math.abs(delta) >= 0.1) {\n              logger.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n              sb.timestampOffset = fragStart;\n            }\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const {\n          sourceBuffer\n        } = this;\n        const timeRanges = {};\n        for (const type in sourceBuffer) {\n          timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n        }\n        this.appendError = 0;\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: err => {\n        // in case any error occured while appending, put back segment in segments table\n        logger.error(`[buffer-controller]: Error encountered while trying to append to the ${type} SourceBuffer`, err);\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          frag,\n          part,\n          chunkMeta,\n          error: err,\n          err,\n          fatal: false\n        };\n        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else {\n          this.appendError++;\n          event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          if (this.appendError > hls.config.appendErrorMaxRetry) {\n            logger.error(`[buffer-controller]: Failed ${hls.config.appendErrorMaxRetry} times to append segment in sourceBuffer`);\n            event.fatal = true;\n          }\n        }\n        hls.trigger(Events.ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      operationQueue\n    } = this;\n    const flushOperation = type => ({\n      execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: e => {\n        logger.warn(`[buffer-controller]: Failed to remove from ${type} SourceBuffer`, e);\n      }\n    });\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(type => {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      logger.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  }\n  onFragChanged(event, data) {\n    this.flushBackBuffer();\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    const ended = this.getSourceBufferTypes().reduce((acc, type) => {\n      const sb = this.sourceBuffer[type];\n      if (sb && (!data.type || data.type === type)) {\n        sb.ending = true;\n        if (!sb.ended) {\n          sb.ended = true;\n          logger.log(`[buffer-controller]: ${type} sourceBuffer now EOS`);\n        }\n      }\n      return acc && !!(!sb || sb.ended);\n    }, true);\n    if (ended) {\n      logger.log(`[buffer-controller]: Queueing mediaSource.endOfStream()`);\n      this.blockBuffers(() => {\n        this.getSourceBufferTypes().forEach(type => {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            sb.ending = false;\n          }\n        });\n        const {\n          mediaSource\n        } = this;\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          if (mediaSource) {\n            logger.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n          }\n          return;\n        }\n        logger.log(`[buffer-controller]: Calling mediaSource.endOfStream()`);\n        // Allow this to throw and be caught by the enqueueing function\n        mediaSource.endOfStream();\n      });\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  }\n  flushBackBuffer() {\n    const {\n      hls,\n      details,\n      media,\n      sourceBuffer\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    if (!sourceBufferTypes.length) {\n      return;\n    }\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n    if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n    const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n    const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          if (details.live) {\n            hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n            logger.info(`[buffer-controller]: Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    const {\n      details,\n      hls,\n      media,\n      mediaSource\n    } = this;\n    const levelDuration = details.fragments[0].start + details.totalduration;\n    const mediaDuration = media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      logger.log('[buffer-controller]: Media Source duration is set to Infinity');\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      logger.log(`[buffer-controller]: Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n      mediaSource.duration = levelDuration;\n    }\n  }\n  updateSeekableRange(levelDetails) {\n    const mediaSource = this.mediaSource;\n    const fragments = levelDetails.fragments;\n    const len = fragments.length;\n    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n      const start = Math.max(0, fragments[0].start);\n      const end = Math.max(start, start + levelDetails.totalduration);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsExpected,\n      operationQueue,\n      pendingTracks\n    } = this;\n\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    const pendingTracksCount = Object.keys(pendingTracks).length;\n    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {};\n      // append any pending segments now !\n      const buffers = this.getSourceBufferTypes();\n      if (buffers.length) {\n        this.hls.trigger(Events.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n        buffers.forEach(type => {\n          operationQueue.executeNext(type);\n        });\n      } else {\n        const error = new Error('could not create source buffer for media codec(s)');\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          error,\n          reason: error.message\n        });\n      }\n    }\n  }\n  createSourceBuffers(tracks) {\n    const {\n      sourceBuffer,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        const track = tracks[trackName];\n        if (!track) {\n          throw Error(`source buffer exists for track ${trackName}, however track does not`);\n        }\n        // use levelCodec as first priority\n        const codec = track.levelCodec || track.codec;\n        const mimeType = `${track.container};codecs=${codec}`;\n        logger.log(`[buffer-controller]: creating sourceBuffer(${mimeType})`);\n        try {\n          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          const sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n        } catch (err) {\n          logger.error(`[buffer-controller]: error while trying to add sourceBuffer: ${err.message}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n  }\n  _onSBUpdateStart(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onStart();\n  }\n  _onSBUpdateEnd(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  }\n  _onSBUpdateError(type, event) {\n    const error = new Error(`${type} SourceBuffer error`);\n    logger.error(`[buffer-controller]: ${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.operationQueue.current(type);\n    if (operation) {\n      operation.onError(event);\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource,\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!media || !mediaSource || !sb) {\n      logger.warn(`[buffer-controller]: Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && !sb.ending) {\n      sb.ended = false;\n      logger.log(`[buffer-controller]: Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const {\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!sb) {\n      logger.warn(`[buffer-controller]: Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    sb.ended = false;\n    sb.appendBuffer(data);\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n    if (!buffers.length) {\n      logger.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = buffers.map(type => operationQueue.appendBlocker(type));\n    Promise.all(blockingOperations).then(() => {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(type => {\n        const sb = this.sourceBuffer[type];\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!(sb != null && sb.updating)) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  }\n  getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  }\n  addBufferListener(type, event, fn) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    this.listeners[type].forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  }\n}\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nconst specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nconst getCharForByte = function getCharForByte(byte) {\n  let charCode = byte;\n  if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n    charCode = specialCea608CharsCodes[byte];\n  }\n  return String.fromCharCode(charCode);\n};\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nconst rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nconst rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nconst rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nconst backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nclass CaptionsLogger {\n  constructor() {\n    this.time = null;\n    this.verboseLevel = 0;\n  }\n  log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      const m = typeof msg === 'function' ? msg() : msg;\n      logger.log(`${this.time} [${severity}] ${m}`);\n    }\n  }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n  const hexArray = [];\n  for (let j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nclass PenState {\n  constructor(foreground, underline, italics, background, flash) {\n    this.foreground = void 0;\n    this.underline = void 0;\n    this.italics = void 0;\n    this.background = void 0;\n    this.flash = void 0;\n    this.foreground = foreground || 'white';\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || 'black';\n    this.flash = flash || false;\n  }\n  reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  setStyles(styles) {\n    const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (let i = 0; i < attribs.length; i++) {\n      const style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  }\n  isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  }\n  equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  }\n  copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  }\n  toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  }\n}\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nclass StyledUnicodeChar {\n  constructor(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = void 0;\n    this.penState = void 0;\n    this.uchar = uchar || ' '; // unicode character\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  }\n  reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  }\n  setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  }\n  setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  }\n  equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  }\n  copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  }\n  isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  }\n}\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nclass Row {\n  constructor(logger) {\n    this.chars = void 0;\n    this.pos = void 0;\n    this.currPenState = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chars = [];\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n    this.pos = 0;\n    this.currPenState = new PenState();\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(3, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(3, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(relPos) {\n    const newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (let i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  }\n  insertChar(byte) {\n    if (byte >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    const char = getCharForByte(byte);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n    this.chars[this.pos].setChar(char, this.currPenState);\n    this.moveCursor(1);\n  }\n  clearFromPos(startPos) {\n    let i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  }\n  clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const chars = [];\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      const char = this.chars[i].uchar;\n      if (char !== ' ') {\n        empty = false;\n      }\n      chars.push(char);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  }\n  setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    const currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  }\n}\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nclass CaptionScreen {\n  constructor(logger) {\n    this.rows = void 0;\n    this.currRow = void 0;\n    this.nrRollUpRows = void 0;\n    this.lastOutputScreen = void 0;\n    this.logger = void 0;\n    this.rows = [];\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    } // Note that we use zero-based numbering (0-14)\n\n    this.logger = logger;\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.reset();\n  }\n  reset() {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n  backSpace() {\n    const row = this.rows[this.currRow];\n    row.backSpace();\n  }\n  clearToEndOfRow() {\n    const row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(char) {\n    const row = this.rows[this.currRow];\n    row.insertChar(char);\n  }\n  setPen(styles) {\n    const row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  }\n  moveCursor(relPos) {\n    const row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  }\n  setCursor(absPos) {\n    this.logger.log(2, 'setCursor: ' + absPos);\n    const row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  }\n  setPAC(pacData) {\n    this.logger.log(2, () => 'pacData = ' + JSON.stringify(pacData));\n    let newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (let i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      const lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        const time = this.logger.time;\n        if (prevLineTime && time !== null && prevLineTime < time) {\n          for (let i = 0; i < this.nrRollUpRows; i++) {\n            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    const row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      const indent = pacData.indent;\n      const prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    const styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(bkgData) {\n    this.logger.log(2, () => 'bkgData = ' + JSON.stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  }\n\n  setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n\n    this.logger.log(1, () => this.getDisplayText());\n    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    const topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(2, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    const displayText = [];\n    let text = '';\n    let rowNr = -1;\n    for (let i = 0; i < NR_ROWS; i++) {\n      const rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nclass Cea608Channel {\n  constructor(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  }\n  setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  }\n  setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  }\n  setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(2, () => 'MODE=' + newMode);\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  }\n  insertChars(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  }\n  ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(2, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  }\n  ccBS() {\n    // BackSpace\n    this.logger.log(2, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  }\n  ccAOF() {\n    // Reserved (formerly Alarm Off)\n  }\n  ccAON() {\n    // Reserved (formerly Alarm On)\n  }\n  ccDER() {\n    // Delete to End of Row\n    this.logger.log(2, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  }\n  ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  }\n  ccFON() {\n    // Flash On\n    this.logger.log(2, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  }\n  ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(2, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  }\n  ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(2, 'TR');\n    this.setMode('MODE_TEXT');\n  }\n  ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(2, 'RTD');\n    this.setMode('MODE_TEXT');\n  }\n  ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(2, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  }\n  ccCR() {\n    // Carriage Return\n    this.logger.log(2, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  }\n  ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(2, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      const tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(true);\n  }\n  ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  }\n  ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    const styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      const colorIndex = Math.floor(secondByte / 2) - 0x10;\n      const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(2, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  }\n  outputDataUpdate(dispatch = false) {\n    const time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  }\n  cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  }\n}\n\n// Will be 1 or 2 when parsing captions\n\nclass Cea608Parser {\n  constructor(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = void 0;\n    this.logger = void 0;\n    const logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    this.cmdHistory = createCmdHistory();\n    this.logger = logger;\n  }\n  getHandler(channel) {\n    return this.channels[channel].getHandler();\n  }\n  setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(time, byteList) {\n    let cmdFound;\n    let a;\n    let b;\n    let charsFound = false;\n    this.logger.time = time;\n    for (let i = 0; i < byteList.length; i += 2) {\n      a = byteList[i] & 0x7f;\n      b = byteList[i + 1] & 0x7f;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(3, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      cmdFound = this.parseCmd(a, b);\n      if (!cmdFound) {\n        cmdFound = this.parseMidrow(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parsePAC(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parseBackgroundAttributes(a, b);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          const currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            const channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(2, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(2, \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(a, b) {\n    const {\n      cmdHistory\n    } = this;\n    const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      this.logger.log(3, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n      return true;\n    }\n    const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(a, b) {\n    let chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(0, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      const channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(3, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(a, b) {\n    let row;\n    const cmdHistory = this.cmdHistory;\n    const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      return true; // Repeated commands are dropped (once)\n    }\n\n    const chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    const channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(row, byte) {\n    let pacIndex;\n    const pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (byte > 0x5f) {\n      pacIndex = byte - 0x60;\n    } else {\n      pacIndex = byte - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(a, b) {\n    let channelNr;\n    let charCodes = null;\n    let charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      let oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(2, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      const hexCodes = numArrayToHexArray(charCodes);\n      this.logger.log(3, 'Char codes =  ' + hexCodes.join(','));\n      setLastCmd(a, b, this.cmdHistory);\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(a, b) {\n    const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    let index;\n    const bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    setLastCmd(a, b, this.cmdHistory);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let i = 0; i < Object.keys(this.channels).length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    this.cmdHistory = createCmdHistory();\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(t) {\n    for (let i = 0; i < this.channels.length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\nclass OutputFilter {\n  constructor(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  }\n  newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  }\n}\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar VTTCue = (function () {\n  if (typeof self !== 'undefined' && self.VTTCue) {\n    return self.VTTCue;\n  }\n  const AllowedDirections = ['', 'lr', 'rl'];\n  const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    const lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj, ...rest) {\n    let i = 1;\n    for (; i < arguments.length; i++) {\n      const cobj = arguments[i];\n      for (const p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    const cue = this;\n    const baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    let _id = '';\n    let _pauseOnExit = false;\n    let _startTime = startTime;\n    let _endTime = endTime;\n    let _text = text;\n    let _region = null;\n    let _vertical = '';\n    let _snapToLines = true;\n    let _line = 'auto';\n    let _lineAlign = 'start';\n    let _position = 50;\n    let _positionAlign = 'middle';\n    let _size = 50;\n    let _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function () {\n        return _id;\n      },\n      set: function (value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function () {\n        return _pauseOnExit;\n      },\n      set: function (value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function () {\n        return _startTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function () {\n        return _endTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function () {\n        return _text;\n      },\n      set: function (value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function () {\n        return _region;\n      },\n      set: function (value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function () {\n        return _vertical;\n      },\n      set: function (value) {\n        const setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function () {\n        return _snapToLines;\n      },\n      set: function (value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function () {\n        return _line;\n      },\n      set: function (value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function () {\n        return _lineAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function () {\n        return _position;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function () {\n        return _positionAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function () {\n        return _size;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function () {\n        return _align;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    const WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})();\n\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\nclass StringDecoder {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  }\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n  constructor() {\n    this.values = Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(k, v, a) {\n    for (let n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      const percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  const groups = groupDelim ? input.split(groupDelim) : [input];\n  for (const i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    const kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    const k = kv[0];\n    const v = kv[1];\n    callback(k, v);\n  }\n}\nconst defaults = new VTTCue(0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  const oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    const ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    const settings = new Settings();\n    parseOptions(input, function (k, v) {\n      let vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (let i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    let line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    let position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nclass VTTParser {\n  constructor() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  parse(data) {\n    const _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      let buffer = _this.buffer;\n      let pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      const line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n        if (!(m != null && m[0])) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      let alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new VTTCue(0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              const hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  }\n  flush() {\n    const _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  }\n}\n\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n  let ts = parseInt(timeString.slice(-3));\n  const secs = parseInt(timeString.slice(-6, -4));\n  const mins = parseInt(timeString.slice(-9, -7));\n  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// From https://github.com/darkskyapp/string-hash\nconst hash = function hash(text) {\n  let _hash = 5381;\n  let i = text.length;\n  while (i) {\n    _hash = _hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (_hash >>> 0).toString();\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  let currCC = vttCCs[cc];\n  let prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) != null && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  const parser = new VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  const cues = [];\n  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n  let cueTime = '00:00.000';\n  let timestampMapMPEGTS = 0;\n  let timestampMapLOCAL = 0;\n  let parsingError;\n  let inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    const currCC = vttCCs[cc];\n    let cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC != null && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      if (!initPTS) {\n        parsingError = new Error('Missing initPTS for VTT MPEGTS');\n        return;\n      }\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    const duration = cue.endTime - cue.startTime;\n    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    const text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(line => {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(timestamp => {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\nconst IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n  const results = findBox(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));\n  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n  try {\n    ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  const tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  const defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {\n    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n    return result;\n  }, {});\n  const trim = tt.getAttribute('xml:space') !== 'preserve';\n  const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  const cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, cueElement => {\n    const cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n    const region = regionElements[cueElement.getAttribute('region')];\n    const style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    const styles = getTtmlStyles(region, style, styleElements);\n    const {\n      textAlign\n    } = styles;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      const lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(cue => cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  const parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce((dict, element) => {\n    const id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce((str, node, i) => {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  const ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  let regionStyle = null;\n  const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n\n  const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce((styles, name) => {\n    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  let seconds = parseTimeStamp(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  const m = HMSF_REGEX.exec(timeAttributeValue);\n  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  const value = Number(m[1]);\n  const unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\nclass TimelineController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    if (this.config.enableCEA708Captions) {\n      const channel1 = new OutputFilter(this, 'textTrack1');\n      const channel2 = new OutputFilter(this, 'textTrack2');\n      const channel3 = new OutputFilter(this, 'textTrack3');\n      const channel4 = new OutputFilter(this, 'textTrack4');\n      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n    }\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;\n  }\n  addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    let merged = false;\n    for (let i = cueRanges.length; i--;) {\n      const cueRange = cueRanges[i];\n      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      const track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      const cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(Events.CUES_PARSED, {\n        type: 'captions',\n        cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    const {\n      unparsedVttFrags\n    } = this;\n    if (id === 'main') {\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(frag => {\n        this.onFragLoaded(Events.FRAG_LOADED, frag);\n      });\n    }\n  }\n  getExistingTrack(trackName) {\n    const {\n      media\n    } = this;\n    if (media) {\n      for (let i = 0; i < media.textTracks.length; i++) {\n        const textTrack = media.textTracks[i];\n        if (textTrack[trackName]) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  }\n  createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  }\n  createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    const {\n      captionsProperties,\n      captionsTracks,\n      media\n    } = this;\n    const {\n      label,\n      languageCode\n    } = captionsProperties[trackName];\n    // Enable reuse of existing text track.\n    const existingTrack = this.getExistingTrack(trackName);\n    if (!existingTrack) {\n      const textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      clearCurrentCues(captionsTracks[trackName]);\n      sendAddTrackEvent(captionsTracks[trackName], media);\n    }\n  }\n  createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    const trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    const label = trackProperties.label;\n    const track = {\n      _id: trackName,\n      label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  }\n  createTextTrack(kind, label, lang) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media;\n    this._cleanTracks();\n  }\n  onMediaDetaching() {\n    const {\n      captionsTracks\n    } = this;\n    Object.keys(captionsTracks).forEach(trackName => {\n      clearCurrentCues(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    this.lastSn = -1; // Detect discontinuity in fragment parsing\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = [];\n    this.initPTS = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  }\n  _cleanTracks() {\n    // clear outdated subtitles\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = media.textTracks;\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        clearCurrentCues(textTracks[i]);\n      }\n    }\n  }\n  onSubtitleTracksUpdated(event, data) {\n    const tracks = data.subtitleTracks || [];\n    const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n      if (listIsIdentical) {\n        this.tracks = tracks;\n        return;\n      }\n      this.textTracks = [];\n      this.tracks = tracks;\n      if (this.config.renderTextTracksNatively) {\n        const inUseTracks = this.media ? this.media.textTracks : null;\n        this.tracks.forEach((track, index) => {\n          let textTrack;\n          if (inUseTracks && index < inUseTracks.length) {\n            let inUseTrack = null;\n            for (let i = 0; i < inUseTracks.length; i++) {\n              if (canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                break;\n              }\n            }\n\n            // Reuse tracks with the same label, but do not reuse 608/708 tracks\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            clearCurrentCues(textTrack);\n          } else {\n            const textTrackKind = this._captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            textTrack.groupId = track.groupId;\n            this.textTracks.push(textTrack);\n          }\n        });\n      } else if (this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        const tracksList = this.tracks.map(track => {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  }\n  _captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.attrs.CHARACTERISTICS) {\n      const transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);\n      const describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);\n      if (transcribesSpokenDialog && describesMusicAndSound) {\n        return 'captions';\n      }\n    }\n    return 'subtitles';\n  }\n  onManifestLoaded(event, data) {\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(captionsTrack => {\n        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        const trackName = `textTrack${instreamIdMatch[1]}`;\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  }\n  closedCaptionsForLevel(frag) {\n    const level = this.hls.levels[frag.level];\n    return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  }\n  onFragLoading(event, data) {\n    const {\n      cea608Parser1,\n      cea608Parser2,\n      lastSn,\n      lastPartIndex\n    } = this;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (data.frag.type === PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      const sn = data.frag.sn;\n      const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {\n        cea608Parser1.reset();\n        cea608Parser2.reset();\n      }\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      payload\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        const decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        const decrypted = ('stats' in data);\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          const trackPlaylistMedia = this.tracks[frag.level];\n          const vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(data);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  }\n  _parseIMSC1(frag, payload) {\n    const hls = this.hls;\n    parseIMSC1(payload, this.initPTS[frag.cc], cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      logger.log(`Failed to parse IMSC1: ${error}`);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _parseVTTs(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      payload\n    } = data;\n    // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n    const {\n      initPTS,\n      unparsedVttFrags\n    } = this;\n    const maxAvCC = initPTS.length - 1;\n    if (!initPTS[frag.cc] && maxAvCC === -1) {\n      unparsedVttFrags.push(data);\n      return;\n    }\n    const hls = this.hls;\n    // Parse the WebVTT file contents.\n    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n      if (missingInitPTS) {\n        unparsedVttFrags.push(data);\n      } else {\n        this._fallbackToIMSC1(frag, payload);\n      }\n      // Something went wrong while parsing. Trigger event with success false.\n      logger.log(`Failed to parse VTT cue: ${error}`);\n      if (missingInitPTS && maxAvCC > frag.cc) {\n        return;\n      }\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _fallbackToIMSC1(frag, payload) {\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    const trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      parseIMSC1(payload, this.initPTS[frag.cc], () => {\n        trackPlaylistMedia.textCodec = IMSC1_CODEC;\n        this._parseIMSC1(frag, payload);\n      }, () => {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  }\n  _appendCues(cues, fragLevel) {\n    const hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(cue => addCueToTrack(textTrack, cue));\n    } else {\n      const currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues,\n        track\n      });\n    }\n  }\n  onFragDecrypted(event, data) {\n    const {\n      frag\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      this.onFragLoaded(Events.FRAG_LOADED, data);\n    }\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  }\n  onFragParsingUserdata(event, data) {\n    const {\n      cea608Parser1,\n      cea608Parser2\n    } = this;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    const {\n      frag,\n      samples\n    } = data;\n    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (let i = 0; i < samples.length; i++) {\n      const ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        const ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    endOffsetSubtitles,\n    type\n  }) {\n    const {\n      media\n    } = this;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      const {\n        captionsTracks\n      } = this;\n      Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        const {\n          textTracks\n        } = this;\n        Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n      }\n    }\n  }\n  extractCea608Data(byteArray) {\n    const actualCCBytes = [[], []];\n    const count = byteArray[0] & 0x1f;\n    let position = 2;\n    for (let j = 0; j < count; j++) {\n      const tmpByte = byteArray[position++];\n      const ccbyte1 = 0x7f & byteArray[position++];\n      const ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        const ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  }\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return !!inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\n/*\n * cap stream level to media size dimension controller\n */\n\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    this.unregisterListener();\n    if (this.hls.config.capLevelToPlayerSize) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n  }\n  detectPlayerSize() {\n    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return pixelRatio;\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\n\nclass FPSController {\n  // stream controller must be provided as a dependency!\n\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\n\nconst LOGGER_PREFIX = '[eme]';\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nclass EMEController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n    this.onWaitingForKey = this._onWaitingForKey.bind(this);\n    this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n    this.log = logger.log.bind(logger, LOGGER_PREFIX);\n    this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n    this.error = logger.error.bind(logger, LOGGER_PREFIX);\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.requestMediaKeySystemAccessFunc = null;\n    config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n    config.drmSystems = config.drmSystemOptions = {};\n    // @ts-ignore\n    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n    // @ts-ignore\n    this.config = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  getLicenseServerUrl(keySystem) {\n    const {\n      drmSystems,\n      widevineLicenseUrl\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n    throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n  }\n  getServerCertificateUrl(keySystem) {\n    const {\n      drmSystems\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n    }\n  }\n  attemptKeySystemAccess(keySystemsToAttempt) {\n    const levels = this.hls.levels;\n    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;\n    const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);\n    const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise((resolve, reject) => {\n      const attempt = keySystems => {\n        const keySystem = keySystems.shift();\n        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({\n          keySystem,\n          mediaKeys\n        })).catch(error => {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  }\n  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    const {\n      requestMediaKeySystemAccessFunc\n    } = this.config;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n      if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  }\n  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    // This can throw, but is caught in event handler callpath\n    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess\n      };\n      keySystemAccess.catch(error => {\n        this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n      });\n      return keySystemAccess.then(mediaKeySystemAccess => {\n        this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n        const certificateRequest = this.fetchServerCertificate(keySystem);\n        this.log(`Create media-keys for \"${keySystem}\"`);\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {\n          this.log(`Media-keys created for \"${keySystem}\"`);\n          return certificateRequest.then(certificate => {\n            if (certificate) {\n              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(error => {\n          this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata,\n    keySystem,\n    mediaKeys\n  }) {\n    this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n    const mediaKeysSession = mediaKeys.createSession();\n    const mediaKeySessionContext = {\n      decryptdata,\n      keySystem,\n      mediaKeys,\n      mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  }\n  renewKeySession(mediaKeySessionContext) {\n    const decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      const keyId = this.getKeyIdString(decryptdata);\n      const scheme = 'cenc';\n      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');\n    } else {\n      this.warn(`Could not renew expired session. Missing pssh initData.`);\n    }\n    this.removeSession(mediaKeySessionContext);\n  }\n  getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return Hex.hexDump(decryptdata.keyId);\n  }\n  updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    const keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n    return keySession.update(data);\n  }\n  selectKeySystemFormat(frag) {\n    const keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  }\n  getKeyFormatPromise(keyFormats) {\n    return new Promise((resolve, reject) => {\n      const keySystemsInConfig = getKeySystemsForConfig(this.config);\n      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n        keySystem\n      }) => {\n        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n        }\n      }).catch(reject);\n    });\n  }\n  loadKey(data) {\n    const decryptdata = data.keyInfo.decryptdata;\n    const keyId = this.getKeyIdString(decryptdata);\n    const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n    this.log(`Starting session for key ${keyDetails}`);\n    let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keySessionContextPromise) {\n      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        this.throwIfDestroyed();\n        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            keySystem,\n            mediaKeys,\n            decryptdata\n          });\n          const scheme = 'cenc';\n          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');\n        });\n      });\n      keySessionContextPromise.catch(error => this.handleError(error));\n    }\n    return keySessionContextPromise;\n  }\n  throwIfDestroyed(message = 'Invalid state') {\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  }\n  handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error,\n        fatal: true\n      });\n    }\n  }\n  getKeySystemForKeyPromise(decryptdata) {\n    const keyId = this.getKeyIdString(decryptdata);\n    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  }\n  getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = getKeySystemsForConfig(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, `Missing key-system license configuration options ${JSON.stringify({\n        drmSystems: this.config.drmSystems\n      })}`);\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  }\n  _onMediaEncrypted(event) {\n    const {\n      initDataType,\n      initData\n    } = event;\n    this.debug(`\"${event.type}\" event: init data type: \"${initDataType}\"`);\n\n    // Ignore event when initData is null\n    if (initData === null) {\n      return;\n    }\n    let keyId;\n    let keySystemDomain;\n    if (initDataType === 'sinf' && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n      // Match sinf keyId to playlist skd://keyId=\n      const json = bin2str(new Uint8Array(initData));\n      try {\n        const sinf = base64Decode(JSON.parse(json).sinf);\n        const tenc = parseSinf(new Uint8Array(sinf));\n        if (!tenc) {\n          return;\n        }\n        keyId = tenc.subarray(8, 24);\n        keySystemDomain = KeySystems.FAIRPLAY;\n      } catch (error) {\n        this.warn('Failed to parse sinf \"encrypted\" event message initData');\n        return;\n      }\n    } else {\n      // Support clear-lead key-session creation (otherwise depend on playlist keys)\n      const psshInfo = parsePssh(initData);\n      if (psshInfo === null) {\n        return;\n      }\n      if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {\n        keyId = psshInfo.data.subarray(8, 24);\n      }\n      keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n    }\n    if (!keySystemDomain || !keyId) {\n      return;\n    }\n    const keyIdHex = Hex.hexDump(keyId);\n    const {\n      keyIdToKeySessionPromise,\n      mediaKeySessions\n    } = this;\n    let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n    for (let i = 0; i < mediaKeySessions.length; i++) {\n      // Match playlist key\n      const keyContext = mediaKeySessions[i];\n      const decryptdata = keyContext.decryptdata;\n      if (decryptdata.pssh || !decryptdata.keyId) {\n        continue;\n      }\n      const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n        delete keyIdToKeySessionPromise[oldKeyIdHex];\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {\n          return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n        });\n        break;\n      }\n    }\n    if (!keySessionContextPromise) {\n      // Clear-lead key (not encountered in playlist)\n      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        var _keySystemToKeySystem;\n        this.throwIfDestroyed();\n        const decryptdata = new LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : '');\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            decryptdata,\n            keySystem,\n            mediaKeys\n          });\n          return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');\n        });\n      });\n    }\n    keySessionContextPromise.catch(error => this.handleError(error));\n  }\n  _onWaitingForKey(event) {\n    this.log(`\"${event.type}\" event`);\n  }\n  attemptSetMediaKeys(keySystem, mediaKeys) {\n    const queue = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${keySystem}\"`);\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    const setMediaKeysPromise = Promise.all(queue).then(() => {\n      if (!this.media) {\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return this.media.setMediaKeys(mediaKeys);\n    });\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(() => {\n      this.log(`Media-keys set for \"${keySystem}\"`);\n      queue.push(setMediaKeysPromise);\n      this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste, _this$config$drmSyste2;\n    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n      return Promise.resolve(context);\n    }\n    const keyId = this.getKeyIdString(context.decryptdata);\n    this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n    const licenseStatus = new EventEmitter();\n    context.mediaKeysSession.onmessage = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      const {\n        messageType,\n        message\n      } = event;\n      this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        this.renewLicense(context, message).catch(error => {\n          this.handleError(error);\n          licenseStatus.emit('error', error);\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === KeySystems.FAIRPLAY) {\n          this.updateKeySession(context, strToUtf8array('acknowledged'));\n          this.removeSession(context);\n        }\n      } else {\n        this.warn(`unhandled media key message type \"${messageType}\"`);\n      }\n    };\n    context.mediaKeysSession.onkeystatuseschange = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      this.onKeyStatusChange(context);\n      const keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        this.warn(`${context.keySystem} expired for key ${keyId}`);\n        this.renewKeySession(context);\n      }\n    };\n    const keyUsablePromise = new Promise((resolve, reject) => {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', keyStatus => {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, `key status changed to \"${keyStatus}\"`));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          this.warn(`unhandled key status change \"${keyStatus}\"`);\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {\n      var _context$mediaKeysSes;\n      this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n    }).catch(error => {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error,\n        fatal: false\n      }, `Error generating key-session request: ${error}`);\n    }).then(() => keyUsablePromise).catch(error => {\n      licenseStatus.removeAllListeners();\n      this.removeSession(context);\n      throw error;\n    }).then(() => {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  }\n  onKeyStatusChange(mediaKeySessionContext) {\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {\n      this.log(`key status change \"${status}\" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  }\n  fetchServerCertificate(keySystem) {\n    const config = this.config;\n    const Loader = config.loader;\n    const certLoader = new Loader(config);\n    const url = this.getServerCertificateUrl(keySystem);\n    if (!url) {\n      return Promise.resolve();\n    }\n    this.log(`Fetching serverCertificate for \"${keySystem}\"`);\n    return new Promise((resolve, reject) => {\n      const loaderContext = {\n        responseType: 'arraybuffer',\n        url\n      };\n      const loadPolicy = config.certLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          resolve(response.data);\n        },\n        onError: (response, contex, networkDetails, stats) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)\n          }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: {\n              url: loaderContext.url,\n              data: undefined\n            }\n          }, `\"${keySystem}\" certificate request timed out (${url})`));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          reject(new Error('aborted'));\n        }\n      };\n      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    return new Promise((resolve, reject) => {\n      mediaKeys.setServerCertificate(cert).then(success => {\n        this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n        resolve(mediaKeys);\n      }).catch(error => {\n        reject(new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  }\n  renewLicense(context, keyMessage) {\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {\n      return this.updateKeySession(context, new Uint8Array(data)).catch(error => {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  }\n  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    const licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr,\n        licenseChallenge\n      });\n    }\n    return Promise.resolve().then(() => {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(error => {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(licenseXhrSetupResult => {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  }\n  requestLicense(keySessionContext, licenseChallenge) {\n    const keyLoadPolicy = this.config.keyLoadPolicy.default;\n    return new Promise((resolve, reject) => {\n      const url = this.getLicenseServerUrl(keySessionContext.keySystem);\n      this.log(`Sending license request to URL: ${url}`);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = () => {\n        if (!this.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let data = xhr.response;\n            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n            const licenseResponseCallback = this.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                this.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            const retryConfig = keyLoadPolicy.errorRetry;\n            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n            this._requestLicenseFailureCount++;\n            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr,\n                response: {\n                  url,\n                  data: undefined,\n                  code: xhr.status,\n                  text: xhr.statusText\n                }\n              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n            } else {\n              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({\n        xhr,\n        licenseChallenge\n      }) => {\n        xhr.send(licenseChallenge);\n      });\n    });\n  }\n  onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    const media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    media.addEventListener('encrypted', this.onMediaEncrypted);\n    media.addEventListener('waitingforkey', this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const media = this.media;\n    const mediaKeysList = this.mediaKeySessions;\n    if (media) {\n      media.removeEventListener('encrypted', this.onMediaEncrypted);\n      media.removeEventListener('waitingforkey', this.onWaitingForKey);\n      this.media = null;\n    }\n    this._requestLicenseFailureCount = 0;\n    this.setMediaKeysQueue = [];\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    const keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch(error => {\n      this.log(`Could not clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);\n    }))).then(() => {\n      if (keySessionCount) {\n        this.log('finished closing key sessions and clearing media keys');\n        mediaKeysList.length = 0;\n      }\n    }).catch(error => {\n      this.log(`Could not close sessions and clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null;\n  }\n  onManifestLoaded(event, {\n    sessionKeys\n  }) {\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  }\n  removeSession(mediaKeySessionContext) {\n    const {\n      mediaKeysSession,\n      licenseXhr\n    } = mediaKeySessionContext;\n    if (mediaKeysSession) {\n      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n      mediaKeysSession.onmessage = null;\n      mediaKeysSession.onkeystatuseschange = null;\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      return mediaKeysSession.remove().catch(error => {\n        this.log(`Could not remove session: ${error}`);\n      }).then(() => {\n        return mediaKeysSession.close();\n      }).catch(error => {\n        this.log(`Could not close session: ${error}`);\n      });\n    }\n  }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n  constructor(data, message) {\n    super(message);\n    this.data = void 0;\n    data.error || (data.error = new Error(message));\n    this.data = data;\n    data.err = data.error;\n  }\n}\n\n/**\n * CMCD spec version\n */\nconst CMCDVersion = 1;\n\n/**\n * CMCD Object Type\n */\nvar CMCDObjectType = {\n  MANIFEST: \"m\",\n  AUDIO: \"a\",\n  VIDEO: \"v\",\n  MUXED: \"av\",\n  INIT: \"i\",\n  CAPTION: \"c\",\n  TIMED_TEXT: \"tt\",\n  KEY: \"k\",\n  OTHER: \"o\"\n};\n\n/**\n * CMCD Streaming Format\n */\nconst CMCDStreamingFormatHLS = 'h';\n\n/**\n * CMCD Streaming Type\n */\n\n/**\n * CMCD Headers\n */\n\n/**\n * CMCD\n */\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nclass CMCDController {\n  // eslint-disable-line no-restricted-globals\n  // eslint-disable-line no-restricted-globals\n\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n    this.onWaiting = () => {\n      if (this.initialized) {\n        this.starved = true;\n      }\n      this.buffering = true;\n    };\n    this.onPlaying = () => {\n      if (!this.initialized) {\n        this.initialized = true;\n      }\n      this.buffering = false;\n    };\n    /**\n     * Apply CMCD data to a manifest request.\n     */\n    this.applyPlaylistData = context => {\n      try {\n        this.apply(context, {\n          ot: CMCDObjectType.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (error) {\n        logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    /**\n     * Apply CMCD data to a segment request\n     */\n    this.applyFragmentData = context => {\n      try {\n        const fragment = context.frag;\n        const level = this.hls.levels[fragment.level];\n        const ot = this.getObjectType(fragment);\n        const data = {\n          d: fragment.duration * 1000,\n          ot\n        };\n        if (ot === CMCDObjectType.VIDEO || ot === CMCDObjectType.AUDIO || ot == CMCDObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = this.getTopBandwidth(ot) / 1000;\n          data.bl = this.getBufferLength(ot);\n        }\n        this.apply(context, data);\n      } catch (error) {\n        logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    const config = this.config = hls.config;\n    const {\n      cmcd\n    } = config;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || CMCDController.uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.registerListeners();\n    }\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  }\n  onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  }\n  onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var _this$media;\n    return {\n      v: CMCDVersion,\n      sf: CMCDStreamingFormatHLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(context, data = {}) {\n    // apply baseline data\n    _extends(data, this.createData());\n    const isVideo = data.ot === CMCDObjectType.INIT || data.ot === CMCDObjectType.VIDEO || data.ot === CMCDObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    if (this.useHeaders) {\n      const headers = CMCDController.toHeaders(data);\n      if (!Object.keys(headers).length) {\n        return;\n      }\n      if (!context.headers) {\n        context.headers = {};\n      }\n      _extends(context.headers, headers);\n    } else {\n      const query = CMCDController.toQuery(data);\n      if (!query) {\n        return;\n      }\n      context.url = CMCDController.appendQueryToUri(context.url, query);\n    }\n  }\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(fragment) {\n    const {\n      type\n    } = fragment;\n    if (type === 'subtitle') {\n      return CMCDObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return CMCDObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return CMCDObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return CMCDObjectType.MUXED;\n      }\n      return CMCDObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(type) {\n    let bitrate = 0;\n    let levels;\n    const hls = this.hls;\n    if (type === CMCDObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      const max = hls.maxAutoLevel;\n      const len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    for (const level of levels) {\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(type) {\n    const media = this.hls.media;\n    const buffer = type === CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader\n    } = this.config;\n    const apply = this.applyPlaylistData;\n    const Ctor = pLoader || this.config.loader;\n    return class CmcdPlaylistLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader\n    } = this.config;\n    const apply = this.applyFragmentData;\n    const Ctor = fLoader || this.config.loader;\n    return class CmcdFragmentLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Generate a random v4 UUI\n   *\n   * @returns {string}\n   */\n  static uuid() {\n    const url = URL.createObjectURL(new Blob());\n    const uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.slice(uuid.lastIndexOf('/') + 1);\n  }\n\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static serialize(data) {\n    const results = [];\n    const isValid = value => !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    const toRounded = value => Math.round(value);\n    const toHundred = value => toRounded(value / 100) * 100;\n    const toUrlSafe = value => encodeURIComponent(value);\n    const formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded\n    };\n    const keys = Object.keys(data || {}).sort();\n    for (const key of keys) {\n      let value = data[key];\n\n      // ignore invalid values\n      if (!isValid(value)) {\n        continue;\n      }\n\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        continue;\n      }\n\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        continue;\n      }\n\n      // Certain values require special formatting\n      const formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value);\n      }\n\n      // Serialize the key/value pair\n      const type = typeof value;\n      let result;\n      if (key === 'ot' || key === 'sf' || key === 'st') {\n        result = `${key}=${value}`;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'number') {\n        result = `${key}=${value}`;\n      } else {\n        result = `${key}=${JSON.stringify(value)}`;\n      }\n      results.push(result);\n    }\n    return results.join(',');\n  }\n\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static toHeaders(data) {\n    const keys = Object.keys(data);\n    const headers = {};\n    const headerNames = ['Object', 'Request', 'Session', 'Status'];\n    const headerGroups = [{}, {}, {}, {}];\n    const headerMap = {\n      br: 0,\n      d: 0,\n      ot: 0,\n      tb: 0,\n      bl: 1,\n      dl: 1,\n      mtp: 1,\n      nor: 1,\n      nrr: 1,\n      su: 1,\n      cid: 2,\n      pr: 2,\n      sf: 2,\n      sid: 2,\n      st: 2,\n      v: 2,\n      bs: 3,\n      rtp: 3\n    };\n    for (const key of keys) {\n      // Unmapped fields are mapped to the Request header\n      const index = headerMap[key] != null ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n    for (let i = 0; i < headerGroups.length; i++) {\n      const value = CMCDController.serialize(headerGroups[i]);\n      if (value) {\n        headers[`CMCD-${headerNames[i]}`] = value;\n      }\n    }\n    return headers;\n  }\n\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static toQuery(data) {\n    return `CMCD=${encodeURIComponent(CMCDController.serialize(data))}`;\n  }\n\n  /**\n   * Append query args to a uri.\n   */\n  static appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n    const separator = uri.includes('?') ? '&' : '?';\n    return `${uri}${separator}${query}`;\n  }\n}\n\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.log = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[content-steering]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  startLoad() {\n    this.started = true;\n    self.clearTimeout(this.reloadTimer);\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = Math.max(this.timeToLoad * 1000 - (performance.now() - this.updated), 0);\n        this.scheduleRefresh(this.uri, ttl);\n      } else {\n        this.loadSteeringManifest(this.uri);\n      }\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    self.clearTimeout(this.reloadTimer);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      let pathwayPriority = this.pathwayPriority;\n      const pathwayId = this.pathwayId;\n      if (!this.penalizedPathways[pathwayId]) {\n        this.penalizedPathways[pathwayId] = performance.now();\n      }\n      if (!pathwayPriority && this.levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = this.levels.reduce((pathways, level) => {\n          if (pathways.indexOf(level.pathwayId) === -1) {\n            pathways.push(level.pathwayId);\n          }\n          return pathways;\n        }, []);\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== pathwayId;\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n      return pathwayLevels;\n    }\n    return levels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this.pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (penalizedPathways[pathwayId]) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const levelParsed = _extends({}, baseLevel);\n        levelParsed.details = undefined;\n        levelParsed.url = performUriReplacement(baseLevel.uri, baseLevel.attrs['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        levelParsed.attrs = attributes;\n        const clonedLevel = new Level(levelParsed);\n        addGroupId(clonedLevel, 'audio', clonedAudioGroupId);\n        addGroupId(clonedLevel, 'text', clonedSubtitleGroupId);\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if (steeringData.VERSION !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    self.clearTimeout(this.reloadTimer);\n    this.reloadTimer = self.setTimeout(() => {\n      this.loadSteeringManifest(uri);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\n\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = void 0;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        this.callbacks.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = this.context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponse = xhr.responseType !== 'text';\n        if (status >= 200 && status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          const data = useResponse ? xhr.response : xhr.responseText;\n          const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n          stats.loaded = stats.total = len;\n          stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n          if (!this.callbacks) {\n            return;\n          }\n          const onProgress = this.callbacks.onProgress;\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n          if (!this.callbacks) {\n            return;\n          }\n          const response = {\n            url: xhr.responseURL,\n            data: data,\n            code: status\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          const retryConfig = config.loadPolicy.errorRetry;\n          const retryCount = stats.retry;\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          if (shouldRetry(retryConfig, retryCount, false, status)) {\n            this.retry(retryConfig);\n          } else {\n            logger.error(`${status} while loading ${context.url}`);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr, stats);\n          }\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    var _this$config;\n    const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      logger.warn(`timeout while loading ${this.context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config /* HlsConfig */) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = void 0;\n    this.response = void 0;\n    this.controller = void 0;\n    this.context = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = null;\n    this.abortInternal();\n  }\n  abortInternal() {\n    const response = this.response;\n    if (!(response != null && response.ok)) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const onProgress = callbacks.onProgress;\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      this.abortInternal();\n      callbacks.onTimeout(stats, context, this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(response => {\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        this.abortInternal();\n        callbacks.onTimeout(stats, context, this.response);\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      const {\n        response\n      } = this;\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      callbacks.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n  newCue(track, startTime, endTime, captionScreen) {\n    const result = [];\n    let row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    let cue;\n    let indenting;\n    let indent;\n    let text;\n    const Cue = self.VTTCue || self.TextTrackCue;\n    for (let r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        var _track$cues;\n        for (let c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        const cueText = fixLineBreaks(text.trim());\n        const id = generateCueId(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort((cueA, cueB) => {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(cue => addCueToTrack(track, cue));\n    }\n    return result;\n  }\n};\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: SubtitleStreamController ,\n  subtitleTrackController: SubtitleTrackController ,\n  timelineController: TimelineController ,\n  audioStreamController: AudioStreamController ,\n  audioTrackController: AudioTrackController ,\n  emeController: EMEController ,\n  cmcdController: CMCDController ,\n  contentSteeringController: ContentSteeringController \n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n   */\n\n  /**\n   * The configuration object provided on player instantiation.\n   */\n\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return \"1.4.10\";\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    this.config = void 0;\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = void 0;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    enableLogs(userConfig.debug || false, 'Hls instance');\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    this._autoLevelCapping = -1;\n    if (config.progressive) {\n      enableStreamingMode(config);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: ConfigAbrController,\n      bufferController: ConfigBufferController,\n      capLevelController: ConfigCapLevelController,\n      errorController: ConfigErrorController,\n      fpsController: ConfigFpsController\n    } = config;\n    const errorController = new ConfigErrorController(this);\n    const abrController = this.abrController = new ConfigAbrController(this);\n    const bufferController = this.bufferController = new ConfigBufferController(this);\n    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    const fpsController = new ConfigFpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const id3TrackController = new ID3TrackController(this);\n    const ConfigContentSteeringController = config.contentSteeringController;\n    // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (e) {\n        logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n        this.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERNAL_EXCEPTION,\n          fatal: false,\n          event: event,\n          error: e\n        });\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(media) {\n    logger.log('attachMedia');\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this.url;\n    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1) {\n    logger.log(`startLoad(${startPosition})`);\n    this.networkControllers.forEach(controller => {\n      controller.startLoad(startPosition);\n    });\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    logger.log('stopLoad');\n    this.networkControllers.forEach(controller => {\n      controller.stopLoad();\n    });\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    logger.log('recoverMediaError');\n    const media = this._media;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n    }\n  }\n  removeLevel(levelIndex, urlId = 0) {\n    this.levelController.removeLevel(levelIndex, urlId);\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    logger.log(`set currentLevel:${newLevel}`);\n    this.loadLevel = newLevel;\n    this.abrController.clearTimer();\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  get startLevel() {\n    return this.levelController.startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (HdcpLevels.indexOf(value) > -1) {\n      this._maxHdcpLevel = value;\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    // ensure next auto level is between  min and max auto level\n    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n}\nHls.defaultConfig = void 0;\n\n\n//# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9kaXN0L2hscy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUF1RixpQkFBaUI7QUFDeEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQSwrREFBK0QsOEJBQThCO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsc0JBQXNCLFNBQVM7QUFDdEYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksc0NBQXNDLGlCQUFpQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0Usb0NBQW9DO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsbUNBQW1DO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLDJCQUEyQjtBQUNwRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVLE1BQU07QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQixVQUFVLE1BQU07QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLFlBQVksR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLFlBQVksR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9CQUFvQixvQkFBb0Isd0JBQXdCLEtBQUssbUJBQW1CO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0ksYUFBYTtBQUM1SjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCLEtBQUssZ0RBQWdELFVBQVU7QUFDM0Y7QUFDQSxNQUFNO0FBQ04sMEdBQTBHLGNBQWM7QUFDeEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksS0FBSztBQUN4SSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrSkFBa0osT0FBTztBQUN6SjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxnQkFBZ0IsS0FBSyxVQUFVLE1BQU07QUFDekk7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiwrRUFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnRUFBZ0UsT0FBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHVFQUF1RSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWUsS0FBSzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsYUFBYSxXQUFXLGNBQWMsUUFBUSxXQUFXOztBQUU1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0YsWUFBWTs7QUFFaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IscUZBQXFGLHlCQUF5QixhQUFhO0FBQzFKO0FBQ0Esc0JBQXNCLGVBQWUsTUFBTSxXQUFXO0FBQ3RELE1BQU07QUFDTix5QkFBeUIsWUFBWSxhQUFhLGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBLE1BQU07QUFDTix5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnRkFBZ0YsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFLHlDQUF5QztBQUNySDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLHFDQUFxQyxHQUFHLFVBQVU7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxRQUFRLGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLEdBQUcsZ0JBQWdCLEtBQUssb0JBQW9CLFVBQVUsYUFBYTtBQUNuSTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRCw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJFQUEyRSxNQUFNO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sRUFBRSw4RkFBOEY7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNEJBQTRCLE1BQU0sYUFBYSxxQkFBcUIsWUFBWTtBQUMxSTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCLGtCQUFrQix3QkFBd0IsVUFBVSxhQUFhLFVBQVUsVUFBVSxVQUFVLEtBQUs7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU8sS0FBSyxzQ0FBc0M7QUFDekY7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNEJBQTRCLDRCQUE0QjtBQUN4RDs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlLEdBQUcseUJBQXlCLFNBQVMsYUFBYTtBQUNoSDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZSxHQUFHLHlCQUF5QixTQUFTLGFBQWEsT0FBTyxNQUFNO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVDQUF1QyxlQUFlO0FBQ3RELDBCQUEwQixzQkFBc0IsRUFBRSxvQkFBb0IsR0FBRyxXQUFXLEdBQUcsVUFBVSxHQUFHLE9BQU87QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZSxpQ0FBaUMsNkJBQTZCO0FBQ2xIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUyxFQUFFLCtDQUErQyxhQUFhLGVBQWUsRUFBRSxzREFBc0Q7QUFDakwsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpRkFBaUYsTUFBTTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCLEVBQUUscUpBQXFKLE1BQU0sMENBQTBDLE1BQU0sT0FBTyxHQUFHLHlCQUF5QixFQUFFLElBQUk7O0FBRTlTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsWUFBWTtBQUM3RTs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwwQkFBMEI7QUFDL0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQ0FBMkMsZUFBZSxFQUFFLGNBQWM7QUFDMUU7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQyxlQUFlLEVBQUUsY0FBYztBQUMxRTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILGdCQUFnQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkksbUJBQW1CO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9HQUFvRyxlQUFlLGNBQWMsY0FBYztBQUMvSTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFlBQVk7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCLGNBQWMsb0JBQW9CLEVBQUUsYUFBYTtBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEVBQTBFLFNBQVMsSUFBSSxZQUFZO0FBQ25HO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixpQkFBaUIsc0JBQXNCLEdBQUcsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BELDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQW1FLFdBQVcsTUFBTTtBQUNySDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRLEVBQUUsMkNBQTJDLFdBQVcsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsV0FBVyxXQUFXO0FBQ25FO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsTUFBTSxRQUFRLEVBQUUsb0NBQW9DLEtBQUssa0VBQWtFLEVBQUUsWUFBWSxTQUFTLDZFQUE2RSxHQUFHLHVFQUF1RSxhQUFhLDRFQUE0RTtBQUN0YTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlCQUF5QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxNQUFNLGdCQUFnQixHQUFHLGNBQWMsS0FBSyw4REFBOEQsRUFBRSxXQUFXO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTLEtBQUssWUFBWSxNQUFNLFNBQVMsZUFBZSxnQkFBZ0IsR0FBRyxjQUFjLGFBQWEsVUFBVSxHQUFHLG9CQUFvQixJQUFJLDZEQUE2RCxJQUFJLFdBQVcsWUFBWSx3Q0FBd0M7QUFDbFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTLE1BQU0sU0FBUyxFQUFFLHFFQUFxRSxFQUFFLDZEQUE2RCxJQUFJLFdBQVcsWUFBWSx3Q0FBd0M7QUFDbFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9FQUFvRSxJQUFJLFdBQVcsV0FBVztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFFBQVEsVUFBVSx3QkFBd0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYSw2QkFBNkIsUUFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw2QkFBNkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0IsNERBQTRELElBQUksMkJBQTJCLDRCQUE0QjtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0MsWUFBWSxpREFBaUQsSUFBSSxpQkFBaUIsV0FBVyx1Q0FBdUMsYUFBYSxPQUFPO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCLFdBQVcseURBQXlELG9DQUFvQyxjQUFjO0FBQzdLO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsRUFBRSxtQ0FBbUMsV0FBVyxZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVUsSUFBSSxrRkFBa0Y7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsS0FBSyxZQUFZLEVBQUUsWUFBWSxlQUFlLGFBQWEscUJBQXFCLGVBQWUsR0FBRyx5QkFBeUIsS0FBSyxNQUFNO0FBQzNLO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUJBQXVCLGNBQWMsaUNBQWlDLFdBQVc7QUFDakY7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYyxXQUFXLGdCQUFnQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsZUFBZTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxTQUFTLFdBQVcsWUFBWTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsWUFBWSxVQUFVO0FBQ3hFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLElBQUksVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTs7QUFFdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLGlCQUFpQixtQkFBbUIsS0FBSyxnQkFBZ0IsR0FBRyxpQ0FBaUMsUUFBUTtBQUMvSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVcsY0FBYyxlQUFlLGtCQUFrQixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVksU0FBUyxrQkFBa0IsYUFBYSxvQkFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQixHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtCQUErQixXQUFXLFFBQVEsT0FBTyx1QkFBdUIsWUFBWSxHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixXQUFXLFFBQVE7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0IsdUNBQXVDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixNQUFNO0FBQ04sZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBLFFBQVE7QUFDUjs7QUFFQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLHFCQUFxQixXQUFXLGdDQUFnQyxZQUFZO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLHVCQUF1QjtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixTQUFTLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsUUFBUTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsTUFBTSxNQUFNO0FBQzVFLFVBQVU7QUFDViw4QkFBOEIsbUNBQW1DLE1BQU0sTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0NBQW9DLEdBQUcsb0NBQW9DLFdBQVcsa0NBQWtDO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2REFBNkQsc0JBQXNCLHdCQUF3QixpQkFBaUIsd0JBQXdCO0FBQ3BKLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDLDZCQUE2QiwyQ0FBMkM7QUFDbko7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLGdCQUFnQixzQ0FBc0MsV0FBVywyQ0FBMkM7QUFDdkssMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGFBQWEsRUFBRSxvREFBb0QsV0FBVyxnQkFBZ0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxHQUFHO0FBQ2YsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksVUFBVTtBQUN0QixZQUFZLEdBQUc7QUFDZixZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkRBQTJELE9BQU87QUFDbEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdELGlFQUFpRTtBQUNqRSxxRUFBcUU7QUFDckUseUVBQXlFO0FBQ3pFO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksVUFBVTtBQUN0QixZQUFZLEdBQUc7QUFDZixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxHQUFHO0FBQ2YsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxVQUFVO0FBQ3RCLFlBQVksR0FBRztBQUNmLFlBQVksU0FBUztBQUNyQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUIsT0FBTyxHQUFHO0FBQzFFO0FBQ0EsWUFBWTtBQUNaLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsYUFBYTtBQUN6RjtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsMkNBQTJDLGNBQWMsS0FBSyxnQkFBZ0IsU0FBUyxpQkFBaUIsTUFBTTtBQUNuSyx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZLFVBQVUsNkJBQTZCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CLHFCQUFxQiwyQkFBMkI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxhQUFhLEtBQUssV0FBVztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixhQUFhLEtBQUssV0FBVztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhLEtBQUssV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sdUZBQXVGLGFBQWEsUUFBUSxzQkFBc0I7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMkJBQTJCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyxhQUFhLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZCQUE2QixTQUFTLFdBQVcsWUFBWTtBQUM3RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNDQUFzQztBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBLHNCQUFzQixZQUFZLFVBQVUsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLHNCQUFzQixHQUFHLHlCQUF5QixRQUFRLFFBQVEsbUJBQW1CLElBQUksaUJBQWlCLGFBQWEsU0FBUztBQUN2UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUZBQW1GLFNBQVMsV0FBVyxZQUFZO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUyxXQUFXLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLEVBQUUsaUNBQWlDLFdBQVcsWUFBWSw4Q0FBOEMsV0FBVztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWMsdUJBQXVCLFlBQVk7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsb0JBQW9CLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QixTQUFTLFdBQVc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQixtQ0FBbUMsaUJBQWlCLEdBQUcsOEJBQThCLEdBQUcsWUFBWTtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0IsMEJBQTBCLDhCQUE4QixHQUFHLFlBQVk7QUFDdEk7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUIsMEJBQTBCLGdDQUFnQyxHQUFHLGlCQUFpQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxFQUFFLG1DQUFtQyxXQUFXLFlBQVk7QUFDdEcsNkJBQTZCLGtDQUFrQztBQUMvRCxrREFBa0QsNEJBQTRCO0FBQzlFLHNEQUFzRCxxQ0FBcUM7QUFDM0YsdUJBQXVCO0FBQ3ZCLDZCQUE2Qix5RUFBeUU7QUFDdEcseUJBQXlCLG9EQUFvRDtBQUM3RSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFtRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQ0FBb0MsOENBQThDLHVDQUF1QztBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLEdBQUcsaUJBQWlCLGVBQWUscUNBQXFDLEdBQUcsdUJBQXVCLG1CQUFtQjtBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxxQkFBcUIsa0NBQWtDLGNBQWMsd0JBQXdCLG1CQUFtQiw2QkFBNkIsZ0JBQWdCLHlCQUF5QjtBQUMzTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLG1CQUFtQixRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLCtDQUErQyxRQUFRLHFDQUFxQyxrQkFBa0I7QUFDOUc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLE1BQU0sWUFBWSx3Q0FBd0MsZ0JBQWdCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBLHNCQUFzQixTQUFTLFVBQVUsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLHNCQUFzQixHQUFHLHlCQUF5QixRQUFRLFlBQVkseUJBQXlCO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseUZBQXlGLFNBQVMsV0FBVyxZQUFZO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUksTUFBTSxpQkFBaUIsR0FBRyxjQUFjLFVBQVUsUUFBUTtBQUMvRjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkMsUUFBUSxxREFBcUQsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxRQUFRO0FBQzNLO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsNEJBQTRCLFFBQVEsRUFBRSxpQ0FBaUMsV0FBVyxZQUFZLDhDQUE4QyxXQUFXLGlCQUFpQix5REFBeUQ7QUFDak87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQixvQkFBb0IsWUFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0VBQWdFLFNBQVMsK0NBQStDLFNBQVMsV0FBVyxhQUFhO0FBQ3pKO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUNBQWlDLElBQUksWUFBWSxTQUFTLDRCQUE0QiwyQkFBMkI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxHQUFHLHdCQUF3QixTQUFTLHlCQUF5QixRQUFRLFNBQVMsVUFBVSxnQkFBZ0IsR0FBRyxjQUFjO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CLDBCQUEwQixhQUFhO0FBQ3BHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLE9BQU8sR0FBRyxLQUFLLFNBQVMsWUFBWSxRQUFRLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0RUFBNEUsY0FBYyxlQUFlLG1CQUFtQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlGQUFpRixNQUFNO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJLEdBQUcsZ0JBQWdCLFNBQVMsaUJBQWlCLFFBQVEsUUFBUTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLHFCQUFxQixTQUFTLElBQUksWUFBWTtBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUsseUNBQXlDLE1BQU0sdUNBQXVDLE9BQU87QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJLFVBQVUsZ0JBQWdCLEdBQUcsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUIscUJBQXFCLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlGQUFpRixNQUFNO0FBQ3ZGO0FBQ0E7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sa0JBQWtCLFdBQVcsU0FBUyxZQUFZLFFBQVEsY0FBYztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwrRUFBK0UsWUFBWSxJQUFJLFVBQVU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTLG9CQUFvQjtBQUN4RTtBQUNBLCtEQUErRCxjQUFjLEtBQUssVUFBVTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNLHVCQUF1QixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csV0FBVyxVQUFVLE1BQU0sUUFBUSxRQUFRO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RCxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSw2RkFBNkYsTUFBTTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdDQUFnQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3BILE9BQU87QUFDUDtBQUNBLGtFQUFrRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3JIO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0ZBQXNGLFdBQVcsU0FBUyxZQUFZLE1BQU0sUUFBUTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esa0hBQWtILHVCQUF1QjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHlCQUF5QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLFNBQVMsTUFBTTtBQUM1RCxpRUFBaUUsU0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVGQUF1RixZQUFZO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZLEdBQUcsVUFBVSxhQUFhLE1BQU07QUFDL0Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4scURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLHlFQUF5RSxhQUFhLFNBQVM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxHQUFHLFNBQVMsSUFBSSxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLE1BQU0sRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsR0FBRyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUZBQW1GLGdDQUFnQztBQUNuSDtBQUNBLHNHQUFzRyxrQkFBa0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVLG1DQUFtQyxzQ0FBc0M7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVLEtBQUssTUFBTTtBQUNoRixPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLHlEQUF5RCxVQUFVLEVBQUUsSUFBSSxNQUFNO0FBQy9FLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2Q0FBNkMsVUFBVSxXQUFXLHFDQUFxQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLGNBQWM7QUFDekUsUUFBUSxnQkFBZ0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDBEQUEwRCxTQUFTLEVBQUUsVUFBVSxJQUFJLFdBQVcsZ0JBQWdCLHNCQUFzQjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0VBQW9FLFVBQVU7QUFDOUU7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sV0FBVyxzQkFBc0IsWUFBWSxvQkFBb0IsT0FBTyxnQkFBZ0I7QUFDakkseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQyxjQUFjLEVBQUUsZUFBZSxJQUFJLGlCQUFpQixZQUFZLFdBQVc7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzREFBc0Q7QUFDN0Q7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsV0FBVyw0QkFBNEIsYUFBYTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxLQUFLLE9BQU8sbUJBQW1CLGNBQWMsVUFBVSxzQ0FBc0M7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUJBQW1CLFlBQVksK0JBQStCLHFCQUFxQixrQkFBa0IsbUJBQW1CO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CLGtCQUFrQixNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEIsVUFBVTtBQUNqRCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Ysb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxxREFBcUQsc0dBQXNHLFdBQVcsTUFBTTtBQUM1SyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMkNBQTJDLE1BQU07QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPLDJCQUEyQiwySEFBMkgsaUJBQWlCLDZFQUE2RSxPQUFPLHVDQUF1QztBQUM5VTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxNQUFNLFVBQVUsZ0NBQWdDLElBQUksYUFBYSxlQUFlLEdBQUcsY0FBYztBQUM1RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sVUFBVSxtQ0FBbUMsSUFBSTtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4Q0FBOEMsR0FBRyx3Q0FBd0MsUUFBUSxVQUFVO0FBQ3BKO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFEQUFxRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQyxJQUFJLGFBQWEsWUFBWSxHQUFHLGVBQWU7QUFDL0YsY0FBYztBQUNkO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLGVBQWUsbUNBQW1DO0FBQ3RHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpRUFBaUUsTUFBTSxlQUFlLG1DQUFtQztBQUN6SCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLDZDQUE2QyxNQUFNO0FBQ25ELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLEdBQUcsTUFBTTtBQUNqQyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CLElBQUksR0FBRyxNQUFNO0FBQ2pDLFFBQVE7QUFDUixvQkFBb0IsSUFBSSxHQUFHLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLElBQUksSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBbUQ7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSxnQ0FBZ0MsVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUIsR0FBRyxlQUFlLHFCQUFxQixlQUFlO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUIsS0FBSyx5QkFBeUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCLFNBQVMsUUFBUTtBQUM1RixpRUFBaUUscUJBQXFCLFNBQVMsUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFEQUFxRCxZQUFZLEVBQUUsWUFBWSxHQUFHLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsUUFBUSxnQkFBZ0IsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQiw4Q0FBOEMsZ0JBQWdCLFlBQVksYUFBYSxZQUFZLEdBQUcseUJBQXlCLEtBQUssZ0JBQWdCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUssU0FBUyxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsb0JBQW9CLG9DQUFvQyxXQUFXLEtBQUssdUNBQXVDO0FBQ3BKO0FBQ0EsR0FBRztBQUNILHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzPzhiZDUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuXHQoZnVuY3Rpb24gKHJvb3QpIHtcblx0ICB2YXIgVVJMX1JFR0VYID1cblx0ICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG5cdCAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuXHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuXHQgIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG5cdCAgdmFyIFVSTFRvb2xraXQgPSB7XG5cdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuXHQgICAgLy8gRS5nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuXHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG5cdCAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuXHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG5cdCAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG5cdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuXHQgICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcblx0ICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG5cdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuXHQgICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG5cdCAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG5cdCAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcblx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuXHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0ICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdCAgICAgIGlmICghYmFzZVBhcnRzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcblx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2Ncblx0ICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcblx0ICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcblx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuXHQgICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuXHQgICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cblx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG5cdCAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcblx0ICAgICAgICBwYXRoOiBudWxsLFxuXHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG5cdCAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG5cdCAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcblx0ICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG5cdCAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuXHQgICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcblx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG5cdCAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuXHQgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcblx0ICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcblx0ICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcblx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG5cdCAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdCAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuXHQgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuXHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cblx0ICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuXHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuXHQgICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcblx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuXHQgICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuXHQgICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG5cdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG5cdCAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG5cdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcblx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuXHQgICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuXHQgICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG5cdCAgICB9LFxuXHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcblx0ICAgICAgaWYgKCFwYXJ0cykge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcblx0ICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuXHQgICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuXHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG5cdCAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuXHQgICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG5cdCAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcblx0ICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuXHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcblx0ICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuXHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG5cdCAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcblx0ICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG5cdCAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cblx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuXHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuXHQgICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG5cdCAgICAgIHdoaWxlIChcblx0ICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcblx0ICAgICAgKSB7fVxuXHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuXHQgICAgfSxcblx0ICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuXHQgICAgICAgIHBhcnRzLm5ldExvYyArXG5cdCAgICAgICAgcGFydHMucGF0aCArXG5cdCAgICAgICAgcGFydHMucGFyYW1zICtcblx0ICAgICAgICBwYXJ0cy5xdWVyeSArXG5cdCAgICAgICAgcGFydHMuZnJhZ21lbnRcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgfTtcblxuXHQgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcblx0fSkoKTsgXG59ICh1cmxUb29sa2l0KSk7XG5cbnZhciB1cmxUb29sa2l0RXhwb3J0cyA9IHVybFRvb2xraXQuZXhwb3J0cztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuY29uc3QgaXNGaW5pdGVOdW1iZXIgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbn07XG5cbmxldCBFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEV2ZW50cykge1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hJTkdcIl0gPSBcImhsc01lZGlhQXR0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0FUVEFDSEVEXCJdID0gXCJobHNNZWRpYUF0dGFjaGVkXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFEZXRhY2hpbmdcIjtcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNIRURcIl0gPSBcImhsc01lZGlhRGV0YWNoZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX1JFU0VUXCJdID0gXCJobHNCdWZmZXJSZXNldFwiO1xuICBFdmVudHNbXCJCVUZGRVJfQ09ERUNTXCJdID0gXCJobHNCdWZmZXJDb2RlY3NcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NSRUFURURcIl0gPSBcImhsc0J1ZmZlckNyZWF0ZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0FQUEVORElOR1wiXSA9IFwiaGxzQnVmZmVyQXBwZW5kaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRFRFwiXSA9IFwiaGxzQnVmZmVyQXBwZW5kZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0VPU1wiXSA9IFwiaGxzQnVmZmVyRW9zXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSElOR1wiXSA9IFwiaGxzQnVmZmVyRmx1c2hpbmdcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0ZMVVNIRURcIl0gPSBcImhsc0J1ZmZlckZsdXNoZWRcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BRElOR1wiXSA9IFwiaGxzTWFuaWZlc3RMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURFRFwiXSA9IFwiaGxzTWFuaWZlc3RMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfUEFSU0VEXCJdID0gXCJobHNNYW5pZmVzdFBhcnNlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hJTkdcIl0gPSBcImhsc0xldmVsU3dpdGNoaW5nXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1NXSVRDSEVEXCJdID0gXCJobHNMZXZlbFN3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX0xPQURJTkdcIl0gPSBcImhsc0xldmVsTG9hZGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FERURcIl0gPSBcImhsc0xldmVsTG9hZGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1VQREFURURcIl0gPSBcImhsc0xldmVsVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9QVFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxQdHNVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMU19VUERBVEVEXCJdID0gXCJobHNMZXZlbHNVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNBdWRpb1RyYWNrc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfU1dJVENISU5HXCJdID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSEVEXCJdID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BRElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BREVEXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19TV0lUQ0hcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfTE9BRElOR1wiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfTE9BREVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEXCJdID0gXCJobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWRcIjtcbiAgRXZlbnRzW1wiQ1VFU19QQVJTRURcIl0gPSBcImhsc0N1ZXNQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORFwiXSA9IFwiaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kXCI7XG4gIEV2ZW50c1tcIklOSVRfUFRTX0ZPVU5EXCJdID0gXCJobHNJbml0UHRzRm91bmRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FESU5HXCJdID0gXCJobHNGcmFnTG9hZGluZ1wiO1xuICBFdmVudHNbXCJGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURcIl0gPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiO1xuICBFdmVudHNbXCJGUkFHX0xPQURFRFwiXSA9IFwiaGxzRnJhZ0xvYWRlZFwiO1xuICBFdmVudHNbXCJGUkFHX0RFQ1JZUFRFRFwiXSA9IFwiaGxzRnJhZ0RlY3J5cHRlZFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UXCJdID0gXCJobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50XCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19VU0VSREFUQVwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YVwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfTUVUQURBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nTWV0YWRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTRURcIl0gPSBcImhsc0ZyYWdQYXJzZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19CVUZGRVJFRFwiXSA9IFwiaGxzRnJhZ0J1ZmZlcmVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQ0hBTkdFRFwiXSA9IFwiaGxzRnJhZ0NoYW5nZWRcIjtcbiAgRXZlbnRzW1wiRlBTX0RST1BcIl0gPSBcImhsc0Zwc0Ryb3BcIjtcbiAgRXZlbnRzW1wiRlBTX0RST1BfTEVWRUxfQ0FQUElOR1wiXSA9IFwiaGxzRnBzRHJvcExldmVsQ2FwcGluZ1wiO1xuICBFdmVudHNbXCJFUlJPUlwiXSA9IFwiaGxzRXJyb3JcIjtcbiAgRXZlbnRzW1wiREVTVFJPWUlOR1wiXSA9IFwiaGxzRGVzdHJveWluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BRElOR1wiXSA9IFwiaGxzS2V5TG9hZGluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNMaXZlQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgcmV0dXJuIEV2ZW50cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmluZXMgZWFjaCBFdmVudCB0eXBlIGFuZCBwYXlsb2FkIGJ5IEV2ZW50IG5hbWUuIFVzZWQgaW4ge0BsaW5rIGhscy5qcyNIbHNFdmVudEVtaXR0ZXJ9IHRvIHN0cm9uZ2x5IHR5cGUgdGhlIGV2ZW50IGxpc3RlbmVyIEFQSS5cbiAqL1xuXG5sZXQgRXJyb3JUeXBlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICBFcnJvclR5cGVzW1wiTkVUV09SS19FUlJPUlwiXSA9IFwibmV0d29ya0Vycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNRURJQV9FUlJPUlwiXSA9IFwibWVkaWFFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk1VWF9FUlJPUlwiXSA9IFwibXV4RXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk9USEVSX0VSUk9SXCJdID0gXCJvdGhlckVycm9yXCI7XG4gIHJldHVybiBFcnJvclR5cGVzO1xufSh7fSk7XG5sZXQgRXJyb3JEZXRhaWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFXCJdID0gXCJrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2Vzc2lvblVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRFwiXSA9IFwia2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUlwiXSA9IFwia2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX0VSUk9SXCJdID0gXCJtYW5pZmVzdExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX1RJTUVPVVRcIl0gPSBcIm1hbmlmZXN0TG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfVElNRU9VVFwiXSA9IFwibGV2ZWxMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9QQVJTSU5HX0VSUk9SXCJdID0gXCJsZXZlbFBhcnNpbmdFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9TV0lUQ0hfRVJST1JcIl0gPSBcImxldmVsU3dpdGNoRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUlwiXSA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfREVDUllQVF9FUlJPUlwiXSA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX1BBUlNJTkdfRVJST1JcIl0gPSBcImZyYWdQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19HQVBcIl0gPSBcImZyYWdHYXBcIjtcbiAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9FUlJPUlwiXSA9IFwia2V5TG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX1RJTUVPVVRcIl0gPSBcImtleUxvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BRERfQ09ERUNfRVJST1JcIl0gPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcImJ1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICByZXR1cm4gRXJyb3JEZXRhaWxzO1xufSh7fSk7XG5cbmNvbnN0IG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5sZXQgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgY29uc3QgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgYFske3R5cGV9XSA+YCk7XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWcsIGlkKSB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgaWYgKHNlbGYuY29uc29sZSAmJiBkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLFxuICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgLy8gJ3RyYWNlJyxcbiAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicpO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICB0cnkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKGBEZWJ1ZyBsb2dzIGVuYWJsZWQgZm9yIFwiJHtpZH1cIiBpbiBobHMuanMgdmVyc2lvbiAke1wiMS40LjEwXCJ9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5jb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCAyKSA9PT0gJ1gtJykge1xuICAgICAgICAgIHRoaXMuY2xpZW50QXR0cnMgPSB0aGlzLmNsaWVudEF0dHJzIHx8IFtdO1xuICAgICAgICAgIHRoaXMuY2xpZW50QXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTApO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gIH1cbiAgb3B0aW9uYWxGbG9hdChhdHRyTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG4gIGJvb2woYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV0gPT09ICdZRVMnO1xuICB9XG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChpbnB1dCkge1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGNvbnN0IHF1b3RlID0gJ1wiJztcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbMl07XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiYgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSB2YWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG4vLyBBdm9pZCBleHBvcnRpbmcgY29uc3QgZW51bSBzbyB0aGF0IHRoZXNlIHZhbHVlcyBjYW4gYmUgaW5saW5lZFxuXG5mdW5jdGlvbiBpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZShhdHRyTmFtZSkge1xuICByZXR1cm4gYXR0ck5hbWUgIT09IFwiSURcIiAmJiBhdHRyTmFtZSAhPT0gXCJDTEFTU1wiICYmIGF0dHJOYW1lICE9PSBcIlNUQVJULURBVEVcIiAmJiBhdHRyTmFtZSAhPT0gXCJEVVJBVElPTlwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRU5ELU9OLU5FWFRcIjtcbn1cbmZ1bmN0aW9uIGlzU0NURTM1QXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gIHJldHVybiBhdHRyTmFtZSA9PT0gXCJTQ1RFMzUtT1VUXCIgfHwgYXR0ck5hbWUgPT09IFwiU0NURTM1LUlOXCI7XG59XG5jbGFzcyBEYXRlUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgdGhpcy5hdHRyID0gdm9pZCAwO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkID0gdm9pZCAwO1xuICAgIGlmIChkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0F0dHIgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLmF0dHI7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2aW91c0F0dHIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRlUmFuZ2VBdHRyLCBrZXkpICYmIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV0pIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgREFURVJBTkdFIHRhZyBhdHRyaWJ1dGU6IFwiJHtrZXl9XCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXCIke2RhdGVSYW5nZUF0dHIuSUR9XCJgKTtcbiAgICAgICAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgRGF0ZVJhbmdlIHRhZ3Mgd2l0aCB0aGUgc2FtZSBJRFxuICAgICAgZGF0ZVJhbmdlQXR0ciA9IF9leHRlbmRzKG5ldyBBdHRyTGlzdCh7fSksIHByZXZpb3VzQXR0ciwgZGF0ZVJhbmdlQXR0cik7XG4gICAgfVxuICAgIHRoaXMuYXR0ciA9IGRhdGVSYW5nZUF0dHI7XG4gICAgdGhpcy5fc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZVJhbmdlQXR0cltcIlNUQVJULURBVEVcIl0pO1xuICAgIGlmIChcIkVORC1EQVRFXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUodGhpcy5hdHRyW1wiRU5ELURBVEVcIl0pO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aGlzLl9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuSUQ7XG4gIH1cbiAgZ2V0IGNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gIH1cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG4gIGdldCBlbmREYXRlKCkge1xuICAgIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5kRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgaWYgKFwiRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIik7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBwbGFubmVkRHVyYXRpb24oKSB7XG4gICAgaWYgKFwiUExBTk5FRC1EVVJBVElPTlwiIGluIHRoaXMuYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIlBMQU5ORUQtRFVSQVRJT05cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBlbmRPbk5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKFwiRU5ELU9OLU5FWFRcIik7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pZCAmJiAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKTtcbiAgfVxufVxuXG5jbGFzcyBMb2FkU3RhdHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy5yZXRyeSA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdGUgPSAwO1xuICAgIHRoaXMubG9hZGluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIHRoaXMucGFyc2luZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9XG59XG5cbnZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7XG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFZJREVPOiBcInZpZGVvXCIsXG4gIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG59O1xuY2xhc3MgQmFzZVNlZ21lbnQge1xuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG5cbiAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXG5cbiAgLy8gSG9sZHMgdGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBmcmFnbWVudCBzdXBwb3J0c1xuXG4gIGNvbnN0cnVjdG9yKGJhc2V1cmwpIHtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSB7XG4gICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXTogbnVsbCxcbiAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dOiBudWxsLFxuICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXTogbnVsbFxuICAgIH07XG4gICAgdGhpcy5iYXNldXJsID0gYmFzZXVybDtcbiAgfVxuXG4gIC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG4gIHNldEJ5dGVSYW5nZSh2YWx1ZSwgcHJldmlvdXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIGNvbnN0IGJ5dGVSYW5nZSA9IFtdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBieXRlUmFuZ2VbMF0gPSBwcmV2aW91cyA/IHByZXZpb3VzLmJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgfVxuICAgIGJ5dGVSYW5nZVsxXSA9IHBhcnNlSW50KHBhcmFtc1swXSkgKyBieXRlUmFuZ2VbMF07XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gYnl0ZVJhbmdlO1xuICB9XG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG5cbiAgLy8gc24gbm90YXRlcyB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBhIHNlZ21lbnQsIGFuZCBpZiBzZXQgdG8gYSBzdHJpbmcgY2FuIGJlICdpbml0U2VnbWVudCdcblxuICAvLyBsZXZlbGtleXMgYXJlIHRoZSBFWFQtWC1LRVkgdGFncyB0aGF0IGFwcGx5IHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUga2V5IGxvYWRlci4gU2V0IHdoaWxlIHRoZSBrZXkgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBrZXkgbG9hZGluZ1xuICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gU2V0IGJ5IGB1cGRhdGVGcmFnUFRTRFRTYCBpbiBsZXZlbC1oZWxwZXJcbiAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBtaW5pbXVtIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG4gIC8vICNFWFRJTkYgIHNlZ21lbnQgdGl0bGVcbiAgLy8gVGhlIE1lZGlhIEluaXRpYWxpemF0aW9uIFNlY3Rpb24gZm9yIHRoaXMgc2VnbWVudFxuICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgY29uc3RydWN0b3IodHlwZSwgYmFzZXVybCkge1xuICAgIHN1cGVyKGJhc2V1cmwpO1xuICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbnVsbDtcbiAgICB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIHRoaXMudGFnTGlzdCA9IFtdO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuc24gPSAwO1xuICAgIHRoaXMubGV2ZWxrZXlzID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICB0aGlzLmNjID0gMDtcbiAgICB0aGlzLnN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kUFRTID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnREVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmREVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIHRoaXMubWluRW5kUFRTID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy51cmxJZCA9IDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB0aGlzLnRpdGxlID0gbnVsbDtcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgdGhpcy5nYXAgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGVjcnlwdGRhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxrZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgbGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRSZXF1ZXN0cygpIHtcbiAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxuICBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gKi9cbmNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5mcmFnT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmdhcCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIHRoaXMuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBwYXJ0QXR0cnMuYm9vbCgnSU5ERVBFTkRFTlQnKTtcbiAgICB0aGlzLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9UQVJHRVRfRFVSQVRJT04gPSAxMDtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICovXG5jbGFzcyBMZXZlbERldGFpbHMge1xuICAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG5cbiAgY29uc3RydWN0b3IoYmFzZVVybCkge1xuICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0aGlzLmFsaWduZWRTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgdGhpcy5mcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0TGlzdCA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgIHRoaXMuYWR2YW5jZWREYXRlVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgdGhpcy5zdGFydFNOID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMubTN1OCA9ICcnO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5jYW5CbG9ja1JlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuU2tpcFVudGlsID0gMDtcbiAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5za2lwcGVkU2VnbWVudHMgPSAwO1xuICAgIHRoaXMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgdGhpcy5ob2xkQmFjayA9IDA7XG4gICAgdGhpcy5wYXJ0VGFyZ2V0ID0gMDtcbiAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGl0aW9uUmVwb3J0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnR1bmVJbkdvYWwgPSAwO1xuICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZCA9IDA7XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuICByZWxvYWRlZChwcmV2aW91cykge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydFNuRGlmZiA9IHRoaXMubGFzdFBhcnRTbiAtIHByZXZpb3VzLmxhc3RQYXJ0U247XG4gICAgY29uc3QgcGFydEluZGV4RGlmZiA9IHRoaXMubGFzdFBhcnRJbmRleCAtIHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZjtcbiAgICB0aGlzLmFkdmFuY2VkID0gdGhpcy5lbmRTTiA+IHByZXZpb3VzLmVuZFNOIHx8IHBhcnRTbkRpZmYgPiAwIHx8IHBhcnRTbkRpZmYgPT09IDAgJiYgcGFydEluZGV4RGlmZiA+IDA7XG4gICAgaWYgKHRoaXMudXBkYXRlZCB8fCB0aGlzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IE1hdGguZmxvb3IocHJldmlvdXMubWlzc2VzICogMC42KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5taXNzZXMgPSBwcmV2aW91cy5taXNzZXMgKyAxO1xuICAgIH1cbiAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gcHJldmlvdXMuYXZhaWxhYmlsaXR5RGVsYXk7XG4gIH1cbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSgpIHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0ucHJvZ3JhbURhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBsZXZlbFRhcmdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCB0aGlzLnRhcmdldGR1cmF0aW9uIHx8IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCBydW5UaW1lID0gdGhpcy5kcmlmdEVuZFRpbWUgLSB0aGlzLmRyaWZ0U3RhcnRUaW1lO1xuICAgIGlmIChydW5UaW1lID4gMCkge1xuICAgICAgY29uc3QgcnVuRHVyYXRpb24gPSB0aGlzLmRyaWZ0RW5kIC0gdGhpcy5kcmlmdFN0YXJ0O1xuICAgICAgcmV0dXJuIHJ1bkR1cmF0aW9uICogMTAwMCAvIHJ1blRpbWU7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG4gIGdldCBlZGdlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRFbmQgfHwgdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgcGFydEVuZCgpIHtcbiAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdCA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cbiAgZ2V0IGZyYWdtZW50RW5kKCkge1xuICAgIHZhciBfdGhpcyRmcmFnbWVudHM7XG4gICAgaWYgKChfdGhpcyRmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cykgIT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgYWdlKCkge1xuICAgIGlmICh0aGlzLmFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChEYXRlLm5vdygpIC0gdGhpcy5hZHZhbmNlZERhdGVUaW1lLCAwKSAvIDEwMDA7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBsYXN0UGFydEluZGV4KCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDI7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdDIgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0Mi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXQgbGFzdFBhcnRTbigpIHtcbiAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuICAgIGlmICgoX3RoaXMkcGFydExpc3QzID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdDMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmRTTjtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjREZWNvZGUoYmFzZTY0ZW5jb2RlZFN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0ZW5jb2RlZFN0ciksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5SWRCeXRlcyhzdHIpIHtcbiAgY29uc3Qga2V5SWRieXRlcyA9IHN0clRvVXRmOGFycmF5KHN0cikuc3ViYXJyYXkoMCwgMTYpO1xuICBjb25zdCBwYWRkZWRrZXlJZGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBwYWRkZWRrZXlJZGJ5dGVzLnNldChrZXlJZGJ5dGVzLCAxNiAtIGtleUlkYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIHBhZGRlZGtleUlkYnl0ZXM7XG59XG5mdW5jdGlvbiBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkKSB7XG4gIGNvbnN0IHN3YXAgPSBmdW5jdGlvbiBzd2FwKGFycmF5LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IGN1ciA9IGFycmF5W2Zyb21dO1xuICAgIGFycmF5W2Zyb21dID0gYXJyYXlbdG9dO1xuICAgIGFycmF5W3RvXSA9IGN1cjtcbiAgfTtcbiAgc3dhcChrZXlJZCwgMCwgMyk7XG4gIHN3YXAoa2V5SWQsIDEsIDIpO1xuICBzd2FwKGtleUlkLCA0LCA1KTtcbiAgc3dhcChrZXlJZCwgNiwgNyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh1cmkpIHtcbiAgLy8gZGF0YTpbPG1lZGlhIHR5cGVdWzthdHRyaWJ1dGU9dmFsdWVdWztiYXNlNjRdLDxkYXRhPlxuICBjb25zdCBjb2xvbnNwbGl0ID0gdXJpLnNwbGl0KCc6Jyk7XG4gIGxldCBrZXlkYXRhID0gbnVsbDtcbiAgaWYgKGNvbG9uc3BsaXRbMF0gPT09ICdkYXRhJyAmJiBjb2xvbnNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHNlbWljb2xvbnNwbGl0ID0gY29sb25zcGxpdFsxXS5zcGxpdCgnOycpO1xuICAgIGNvbnN0IGNvbW1hc3BsaXQgPSBzZW1pY29sb25zcGxpdFtzZW1pY29sb25zcGxpdC5sZW5ndGggLSAxXS5zcGxpdCgnLCcpO1xuICAgIGlmIChjb21tYXNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgaXNiYXNlNjQgPSBjb21tYXNwbGl0WzBdID09PSAnYmFzZTY0JztcbiAgICAgIGNvbnN0IGRhdGEgPSBjb21tYXNwbGl0WzFdO1xuICAgICAgaWYgKGlzYmFzZTY0KSB7XG4gICAgICAgIHNlbWljb2xvbnNwbGl0LnNwbGljZSgtMSwgMSk7IC8vIHJlbW92ZSBmcm9tIHByb2Nlc3NpbmdcbiAgICAgICAga2V5ZGF0YSA9IGJhc2U2NERlY29kZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleWRhdGEgPSBnZXRLZXlJZEJ5dGVzKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5ZGF0YTtcbn1cbmZ1bmN0aW9uIHN0clRvVXRmOGFycmF5KHN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAqL1xudmFyIEtleVN5c3RlbXMgPSB7XG4gIENMRUFSS0VZOiBcIm9yZy53My5jbGVhcmtleVwiLFxuICBGQUlSUExBWTogXCJjb20uYXBwbGUuZnBzXCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJjb20ud2lkZXZpbmUuYWxwaGFcIlxufTtcblxuLy8gUGxheWxpc3QgI0VYVC1YLUtFWSBLRVlGT1JNQVQgdmFsdWVzXG52YXIgS2V5U3lzdGVtRm9ybWF0cyA9IHtcbiAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gIEZBSVJQTEFZOiBcImNvbS5hcHBsZS5zdHJlYW1pbmdrZXlkZWxpdmVyeVwiLFxuICBQTEFZUkVBRFk6IFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIixcbiAgV0lERVZJTkU6IFwidXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkXCJcbn07XG5mdW5jdGlvbiBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihmb3JtYXQpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkNMRUFSS0VZO1xuICB9XG59XG5cbi8vIFN5c3RlbSBJRHMgZm9yIHdoaWNoIHdlIGNhbiBleHRyYWN0IGEga2V5IElEIGZyb20gXCJlbmNyeXB0ZWRcIiBldmVudCBQU1NIXG52YXIgS2V5U3lzdGVtSWRzID0ge1xuICBXSURFVklORTogXCJlZGVmOGJhOTc5ZDY0YWNlYTNjODI3ZGNkNTFkMjFlZFwiXG59O1xuZnVuY3Rpb24ga2V5U3lzdGVtSWRUb0tleVN5c3RlbURvbWFpbihzeXN0ZW1JZCkge1xuICBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5XSURFVklORSkge1xuICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgIC8vIH0gZWxzZSBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5QTEFZUkVBRFkpIHtcbiAgICAvLyAgIHJldHVybiBLZXlTeXN0ZW1zLlBMQVlSRUFEWTtcbiAgICAvLyB9IGVsc2UgaWYgKHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuQ0VOQyB8fCBzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLkNMRUFSS0VZKSB7XG4gICAgLy8gICByZXR1cm4gS2V5U3lzdGVtcy5DTEVBUktFWTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgZHJtU3lzdGVtcyxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgfSA9IGNvbmZpZztcbiAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihrZXlTeXN0ZW0gPT4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV0pIDogW107XG4gIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdFtLZXlTeXN0ZW1zLldJREVWSU5FXSAmJiB3aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gIH1cbiAgcmV0dXJuIGtleVN5c3RlbXNUb0F0dGVtcHQ7XG59XG5jb25zdCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5uYXZpZ2F0b3IgJiYgc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgcmV0dXJuIHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIGxldCBpbml0RGF0YVR5cGVzO1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAnc2luZiddO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXktc3lzdGVtOiAke2tleVN5c3RlbX1gKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgIHBlcnNpc3RlbnRTdGF0ZTogZHJtU3lzdGVtT3B0aW9ucy5wZXJzaXN0ZW50U3RhdGUgfHwgJ25vdC1hbGxvd2VkJyxcbiAgICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IGRybVN5c3RlbU9wdGlvbnMuZGlzdGluY3RpdmVJZGVudGlmaWVyIHx8ICdub3QtYWxsb3dlZCcsXG4gICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgYXVkaW9DYXBhYmlsaXRpZXM6IGF1ZGlvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGBhdWRpby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpLFxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiB2aWRlb0NvZGVjcy5tYXAoY29kZWMgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgdmlkZW8vbXA0OyBjb2RlY3M9XCIke2NvZGVjfVwiYCxcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnLFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy52aWRlb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgIH0pKVxuICB9O1xuICByZXR1cm4gW2Jhc2VDb25maWddO1xufVxuXG5mdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbn1cblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzSGVhZGVyJDIgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzRm9vdGVyID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm5zIHRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gKiBvciAqdW5kZWZpbmVkKiBpZiBubyBoZWFkZXIgaXMgZm91bmQgYXQgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICovXG5jb25zdCBnZXRJRDNEYXRhID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIHdoaWxlIChpc0hlYWRlciQyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgbGVuZ3RoICs9IDEwO1xuICAgIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICBpZiAoaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgfVxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZGF0YS5zdWJhcnJheShmcm9udCwgZnJvbnQgKyBsZW5ndGgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgcmVhZFNpemUgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIGxldCBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuY29uc3QgY2FuUGFyc2UkMiA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgcmV0dXJuIGlzSGVhZGVyJDIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAqIEBwYXJhbSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmNvbnN0IGdldFRpbWVTdGFtcCA9IGRhdGEgPT4ge1xuICBjb25zdCBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICovXG5jb25zdCBpc1RpbWVTdGFtcEZyYW1lID0gZnJhbWUgPT4ge1xuICByZXR1cm4gZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJztcbn07XG5jb25zdCBnZXRGcmFtZURhdGEgPSBkYXRhID0+IHtcbiAgLypcbiAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgKi9cbiAgY29uc3QgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTtcblxuICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgY29uc3Qgb2Zmc2V0ID0gMTA7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBzaXplLFxuICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICogQHBhcmFtIGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICovXG5jb25zdCBnZXRJRDNGcmFtZXMgPSBpZDNEYXRhID0+IHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZyYW1lcyA9IFtdO1xuICB3aGlsZSAoaXNIZWFkZXIkMihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgb2Zmc2V0ICs9IDEwO1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICBjb25zdCBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICB9XG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn07XG5jb25zdCBkZWNvZGVGcmFtZSA9IGZyYW1lID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuY29uc3QgZGVjb2RlUHJpdkZyYW1lID0gZnJhbWUgPT4ge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgb3duZXIgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogb3duZXIsXG4gICAgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyXG4gIH07XG59O1xuY29uc3QgZGVjb2RlVGV4dEZyYW1lID0gZnJhbWUgPT4ge1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cbiAgY29uc3QgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB0ZXh0XG4gIH07XG59O1xuY29uc3QgZGVjb2RlVVJMRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIGNvbnN0IHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn07XG5jb25zdCByZWFkVGltZVN0YW1wID0gdGltZVN0YW1wRnJhbWUgPT4ge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArIChkYXRhWzVdIDw8IDE1KSArIChkYXRhWzZdIDw8IDcpICsgZGF0YVs3XTtcbiAgICB0aW1lc3RhbXAgLz0gNDU7XG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5jb25zdCB1dGY4QXJyYXlUb1N0ciA9IChhcnJheSwgZXhpdE9uTnVsbCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xuICBpZiAoZGVjb2Rlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IGRlY29kZWQuc3Vic3RyaW5nKDAsIGlkeCkgOiBkZWNvZGVkO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgfVxuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIGxldCBjO1xuICBsZXQgY2hhcjI7XG4gIGxldCBjaGFyMztcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgYyA9IGFycmF5W2krK107XG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gMHh4eHh4eHhcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjpcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xubGV0IGRlY29kZXI7XG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cblxuLyoqXG4gKiAgaGV4IGR1bXAgaGVscGVyIGNsYXNzXG4gKi9cblxuY29uc3QgSGV4ID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGggPSBhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgfVxuICAgICAgc3RyICs9IGg7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG5cbmNvbnN0IFVJTlQzMl9NQVgkMSA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmNvbnN0IFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRTaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZmZlcltvZmZzZXRdIDw8IDI0IHwgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHwgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgM107XG59XG5mdW5jdGlvbiB3cml0ZVVpbnQzMihidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgYnVmZmVyW29mZnNldCArIDFdID0gdmFsdWUgPj4gMTYgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiA4ICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xufVxuXG4vLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbmZ1bmN0aW9uIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgY29uc3QgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDspIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICBjb25zdCB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIGNvbnN0IGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBjb25zdCBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzdWJyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gZW5kYm94O1xuICB9XG5cbiAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoc2lkeCkge1xuICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gIGNvbnN0IHZlcnNpb24gPSBzaWR4WzBdO1xuXG4gIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICBsZXQgaW5kZXggPSA4O1xuICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDtcblxuICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICBjb25zdCBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICBjb25zdCBmaXJzdE9mZnNldCA9IDA7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgaW5kZXggKz0gODtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCArPSAxNjtcbiAgfVxuXG4gIC8vIHNraXAgcmVzZXJ2ZWRcbiAgaW5kZXggKz0gMjtcbiAgbGV0IHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG4gIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcbiAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb24sXG4gICAgICAvLyB1bnNjYWxlZFxuICAgICAgaW5mbzoge1xuICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgdGltZXNjYWxlLFxuICAgIHZlcnNpb24sXG4gICAgcmVmZXJlbmNlc0NvdW50LFxuICAgIHJlZmVyZW5jZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJucyBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFrID0gdHJha3NbaV07XG4gICAgY29uc3QgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgIGlmICh0a2hkKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgICBsZXQgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIGluZGV4KTtcbiAgICAgIGNvbnN0IG1kaGQgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIobWRoZCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IGJpbjJzdHIoaGRsci5zdWJhcnJheSg4LCAxMikpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB7XG4gICAgICAgICAgICBzb3VuOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sXG4gICAgICAgICAgICB2aWRlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICAgICB9W2hkbHJUeXBlXTtcbiAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgLy8gUGFyc2UgY29kZWMgZGV0YWlsc1xuICAgICAgICAgICAgY29uc3Qgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuICAgICAgICAgICAgbGV0IGNvZGVjO1xuICAgICAgICAgICAgaWYgKHN0c2QpIHtcbiAgICAgICAgICAgICAgY29kZWMgPSBiaW4yc3RyKHN0c2Quc3ViYXJyYXkoMTIsIDE2KSk7XG4gICAgICAgICAgICAgIC8vIFRPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGUuXG4gICAgICAgICAgICAgIC8vIHN0c2Quc3RhcnQgKz0gODtcbiAgICAgICAgICAgICAgLy8gY29uc3QgY29kZWNCb3ggPSBmaW5kQm94KHN0c2QsIFtjb2RlY10pWzBdO1xuICAgICAgICAgICAgICAvLyBpZiAoY29kZWNCb3gpIHtcbiAgICAgICAgICAgICAgLy8gICBUT0RPOiBDb2RlYyBwYXJzaW5nIHN1cHBvcnQgZm9yIGF2YzEsIG1wNGEsIGhldmMsIGF2MDEuLi5cbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICAgICAgICBpZDogdHJhY2tJZCxcbiAgICAgICAgICAgICAgY29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyZXggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAnbXZleCcsICd0cmV4J10pO1xuICB0cmV4LmZvckVhY2godHJleCA9PiB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkge1xuICBpZiAoIWluaXRTZWdtZW50IHx8ICFkZWNyeXB0ZGF0YSkge1xuICAgIHJldHVybiBpbml0U2VnbWVudDtcbiAgfVxuICBjb25zdCBrZXlJZCA9IGRlY3J5cHRkYXRhLmtleUlkO1xuICBpZiAoa2V5SWQgJiYgZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uKSB7XG4gICAgY29uc3QgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgICB0cmFrcy5mb3JFYWNoKHRyYWsgPT4ge1xuICAgICAgY29uc3Qgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuXG4gICAgICAvLyBza2lwIHRoZSBzYW1wbGUgZW50cnkgY291bnRcbiAgICAgIGNvbnN0IHNhbXBsZUVudHJpZXMgPSBzdHNkLnN1YmFycmF5KDgpO1xuICAgICAgbGV0IGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY2EnXSk7XG4gICAgICBjb25zdCBpc0F1ZGlvID0gZW5jQm94ZXMubGVuZ3RoID4gMDtcbiAgICAgIGlmICghaXNBdWRpbykge1xuICAgICAgICBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmN2J10pO1xuICAgICAgfVxuICAgICAgZW5jQm94ZXMuZm9yRWFjaChlbmMgPT4ge1xuICAgICAgICBjb25zdCBlbmNCb3hDaGlsZHJlbiA9IGlzQXVkaW8gPyBlbmMuc3ViYXJyYXkoMjgpIDogZW5jLnN1YmFycmF5KDc4KTtcbiAgICAgICAgY29uc3Qgc2luZkJveGVzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgICAgICBzaW5mQm94ZXMuZm9yRWFjaChzaW5mID0+IHtcbiAgICAgICAgICBjb25zdCB0ZW5jID0gcGFyc2VTaW5mKHNpbmYpO1xuICAgICAgICAgIGlmICh0ZW5jKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBkZWZhdWx0IGtleSBpZCAoa2V5SUQgb2Zmc2V0IGlzIGFsd2F5cyA4IHdpdGhpbiB0aGUgdGVuYyBib3gpOlxuICAgICAgICAgICAgY29uc3QgdGVuY0tleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgICAgICBpZiAoIXRlbmNLZXlJZC5zb21lKGIgPT4gYiAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW2VtZV0gUGF0Y2hpbmcga2V5SWQgaW4gJ2VuYyR7aXNBdWRpbyA/ICdhJyA6ICd2J30+c2luZj4+dGVuYycgYm94OiAke0hleC5oZXhEdW1wKHRlbmNLZXlJZCl9IC0+ICR7SGV4LmhleER1bXAoa2V5SWQpfWApO1xuICAgICAgICAgICAgICB0ZW5jLnNldChrZXlJZCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbml0U2VnbWVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZihzaW5mKSB7XG4gIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgaWYgKHNjaG0pIHtcbiAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgcmV0dXJuIGZpbmRCb3goc2luZiwgWydzY2hpJywgJ3RlbmMnXSlbMF07XG4gICAgfVxuICB9XG4gIGxvZ2dlci5lcnJvcihgW2VtZV0gbWlzc2luZyAnc2NobScgYm94YCk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gaW5pdERhdGEgLSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gKiBAcGFyYW0gZm1wNCAtIHRoZSBieXRlcyBvZiB0aGUgbXA0IGZyYWdtZW50XG4gKiBAcmV0dXJucyB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG5mdW5jdGlvbiBnZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCkge1xuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgcmV0dXJuIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkucmVkdWNlKChyZXN1bHQsIHRyYWYpID0+IHtcbiAgICBjb25zdCB0ZmR0ID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSlbMF07XG4gICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgY29uc3Qgc3RhcnQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5yZWR1Y2UoKHJlc3VsdCwgdGZoZCkgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICBjb25zdCB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICBsZXQgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIHRvbyBsYXJnZSwgYXNzdW1lIHNpZ25lZCA2NC1iaXQuIE5lZ2F0aXZlIHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lcyBhcmUgaW52YWxpZCwgYnV0IHRoZXkgZXhpc3QgaW4gdGhlIHdpbGQuXG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBsYXJnZSB2YWx1ZXMgZnJvbSBiZWluZyB1c2VkIGZvciBpbml0UFRTLCB3aGljaCBjYW4gY2F1c2UgcGxheWxpc3Qgc3luYyBpc3N1ZXMuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzUzMDNcbiAgICAgICAgICBpZiAoYmFzZVRpbWUgPT09IFVJTlQzMl9NQVgkMSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtZGVtdXhlcl06IElnbm9yaW5nIGFzc3VtZWQgaW52YWxpZCBzaWduZWQgNjQtYml0IHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBiYXNlVGltZSAqPSBVSU5UMzJfTUFYJDEgKyAxO1xuICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBiYXNlVGltZSAvIHNjYWxlO1xuICAgICAgICBpZiAoaXNGaW5pdGUoc3RhcnRUaW1lKSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0VGltZSA8IHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIG51bGwpO1xuICAgIGlmIChzdGFydCAhPT0gbnVsbCAmJiBpc0Zpbml0ZShzdGFydCkgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCBzdGFydCA8IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgbnVsbCk7XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdGZoZOKAmSwgMCwgdGZfZmxhZ3Mpe1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICB0cmFja19JRDtcbiAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICB1bnNpZ25lZCBpbnQoNjQpICBiYXNlX2RhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9zaXplO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICB9XG4gKi9cbmZ1bmN0aW9uIGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKSB7XG4gIGxldCByYXdEdXJhdGlvbiA9IDA7XG4gIGxldCB2aWRlb0R1cmF0aW9uID0gMDtcbiAgbGV0IGF1ZGlvRHVyYXRpb24gPSAwO1xuICBjb25zdCB0cmFmcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJywgJ3RyYWYnXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFmID0gdHJhZnNbaV07XG4gICAgLy8gVGhlcmUgaXMgb25seSBvbmUgdGZoZCAmIHRydW4gcGVyIHRyYWZcbiAgICAvLyBUaGlzIGlzIHRydWUgZm9yIENNQUYgc3R5bGUgY29udGVudCwgYW5kIHdlIHNob3VsZCBwZXJoYXBzIGNoZWNrIHRoZSBmdHlwXG4gICAgLy8gYW5kIG9ubHkgbG9vayBmb3IgYSBzaW5nbGUgdHJ1biB0aGVuLCBidXQgZm9yIElTT0JNRkYgd2Ugc2hvdWxkIGNoZWNrXG4gICAgLy8gZm9yIG11bHRpcGxlIHRyYWNrIHJ1bnMuXG4gICAgY29uc3QgdGZoZCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pWzBdO1xuICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICBjb25zdCB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tEZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcbiAgICBjb25zdCB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApIHwgKHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmZsYWdzKTtcbiAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSB0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5kdXJhdGlvbjtcbiAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDgpIHtcbiAgICAgIC8vIDB4MDAwMDA4IGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGZpZWxkXG4gICAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDIpIHtcbiAgICAgICAgLy8gMHgwMDAwMDIgaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IGZpZWxkLCB3aGljaCBwcmVjZWRlcyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgICAvLyBJZiBwcmVzZW50LCB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZXhpc3RzIGF0IGJ5dGUgb2Zmc2V0IDEyXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCAxMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBkdXJhdGlvbiBpcyBhdCBieXRlIG9mZnNldCA4XG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCA4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICBjb25zdCB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICBjb25zdCB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJ1bnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJhd0R1cmF0aW9uID0gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bnNbal0pO1xuICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBzYW1wbGVEdXJhdGlvbikge1xuICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1bnNbal0sIDQpO1xuICAgICAgICByYXdEdXJhdGlvbiA9IHNhbXBsZUR1cmF0aW9uICogc2FtcGxlQ291bnQ7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgIHZpZGVvRHVyYXRpb24gKz0gcmF3RHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTykge1xuICAgICAgICBhdWRpb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlkZW9EdXJhdGlvbiA9PT0gMCAmJiBhdWRpb0R1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgbGV0IHNpZHhEdXJhdGlvbiA9IDA7XG4gICAgY29uc3Qgc2lkeHMgPSBmaW5kQm94KGRhdGEsIFsnc2lkeCddKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWR4ID0gcGFyc2VTZWdtZW50SW5kZXgoc2lkeHNbaV0pO1xuICAgICAgaWYgKHNpZHggIT0gbnVsbCAmJiBzaWR4LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgc2lkeER1cmF0aW9uICs9IHNpZHgucmVmZXJlbmNlcy5yZWR1Y2UoKGR1ciwgcmVmKSA9PiBkdXIgKyByZWYuaW5mby5kdXJhdGlvbiB8fCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpZHhEdXJhdGlvbjtcbiAgfVxuICBpZiAodmlkZW9EdXJhdGlvbikge1xuICAgIHJldHVybiB2aWRlb0R1cmF0aW9uO1xuICB9XG4gIHJldHVybiBhdWRpb0R1cmF0aW9uO1xufVxuXG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrUnVuQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0cnVu4oCZLCB2ZXJzaW9uLCB0cl9mbGFncykge1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfY291bnQ7XG4gICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICBzaWduZWQgaW50KDMyKSBkYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZmlyc3Rfc2FtcGxlX2ZsYWdzO1xuICAgICAvLyBhbGwgZmllbGRzIGluIHRoZSBmb2xsb3dpbmcgYXJyYXkgYXJlIG9wdGlvbmFsXG4gICAgIHtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2R1cmF0aW9uO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfc2l6ZTtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2ZsYWdzXG4gICAgICAgIGlmICh2ZXJzaW9uID09IDApXG4gICAgICAgICAgIHsgdW5zaWduZWQgaW50KDMyKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgIHsgc2lnbmVkIGludCgzMilcbiAgICAgfVsgc2FtcGxlX2NvdW50IF1cbiAgfVxuICovXG5mdW5jdGlvbiBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuKSB7XG4gIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKTtcbiAgLy8gRmxhZ3MgYXJlIGF0IG9mZnNldCAwLCBub24tb3B0aW9uYWwgc2FtcGxlX2NvdW50IGlzIGF0IG9mZnNldCA0LiBUaGVyZWZvcmUgd2Ugc3RhcnQgOCBieXRlcyBpbi5cbiAgLy8gRWFjaCBmaWVsZCBpcyBhbiBpbnQzMiwgd2hpY2ggaXMgNCBieXRlc1xuICBsZXQgb2Zmc2V0ID0gODtcbiAgLy8gZGF0YS1vZmZzZXQtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgLy8gZmlyc3Qtc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICBpZiAoZmxhZ3MgJiAweDAwMDAwNCkge1xuICAgIG9mZnNldCArPSA0O1xuICB9XG4gIGxldCBkdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMTAwKSB7XG4gICAgICBjb25zdCBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgb2Zmc2V0KTtcbiAgICAgIGR1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1zaXplLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMjAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwNDAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLWNvbXBvc2l0aW9uLXRpbWUtb2Zmc2V0cy1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDgwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBmbXA0LCB0aW1lT2Zmc2V0KSB7XG4gIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkuZm9yRWFjaCh0cmFmID0+IHtcbiAgICBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5mb3JFYWNoKHRmaGQgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICBjb25zdCB0cmFjayA9IGluaXREYXRhW2lkXTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGZpbmRCb3godHJhZiwgWyd0ZmR0J10pLmZvckVhY2godGZkdCA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICBsZXQgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICBjb25zdCB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgY29uc3QgbG93ZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCQxICsgMSkpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcbmZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGEpIHtcbiAgY29uc3Qgc2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgdmFsaWQ6IG51bGwsXG4gICAgcmVtYWluZGVyOiBudWxsXG4gIH07XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG4gIGlmICghbW9vZnMpIHtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH0gZWxzZSBpZiAobW9vZnMubGVuZ3RoIDwgMikge1xuICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTtcbiAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9IHNsaWNlVWludDgoZGF0YSwgMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IHNsaWNlVWludDgoZGF0YSwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKSB7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB0cmFjaykge1xuICBjb25zdCBzZWlTYW1wbGVzID0gW107XG4gIGNvbnN0IHZpZGVvRGF0YSA9IHRyYWNrLnNhbXBsZXM7XG4gIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgY29uc3QgdHJhY2tJZCA9IHRyYWNrLmlkO1xuICBsZXQgaXNIRVZDRmxhdm9yID0gZmFsc2U7XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveCh2aWRlb0RhdGEsIFsnbW9vZiddKTtcbiAgbW9vZnMubWFwKG1vb2YgPT4ge1xuICAgIGNvbnN0IG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgIGNvbnN0IHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKHRyYWYgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGNvbnN0IGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKHRmZHQgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKHRmaGQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgY29uc3QgYmFzZURhdGFPZmZzZXRQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgY29uc3Qgc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDIpICE9PSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDA4KSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICBsZXQgdGZoZE9mZnNldCA9IDg7XG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAodHJ1biA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldFByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgICBsZXQgZGF0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMTAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVTaXplUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMjAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDgwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgICAgICAgICAgbGV0IHRydW5PZmZzZXQgPSA4OyAvLyBwYXN0IHZlcnNpb24sIGZsYWdzLCBhbmQgc2FtcGxlIGNvdW50XG5cbiAgICAgICAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBzYW1wbGVDb3VudDsgaXgrKykge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IGRlZmF1bHRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IGRlZmF1bHRTYW1wbGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRTaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbHVUb3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuYWx1VG90YWxTaXplIDwgc2FtcGxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmFsdVNpemUgPSByZWFkVWludDMyKHZpZGVvRGF0YSwgc2FtcGxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIHZpZGVvRGF0YVtzYW1wbGVPZmZzZXRdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdmlkZW9EYXRhLnN1YmFycmF5KHNhbXBsZU9mZnNldCwgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShkYXRhLCBpc0hFVkNGbGF2b3IgPyAyIDogMSwgdGltZU9mZnNldCArIGNvbXBvc2l0aW9uT2Zmc2V0IC8gdGltZXNjYWxlLCBzZWlTYW1wbGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSBuYWx1U2l6ZTtcbiAgICAgICAgICAgICAgICAgIG5hbHVUb3RhbFNpemUgKz0gbmFsdVNpemUgKyA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0ICs9IHNhbXBsZUR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzZWlTYW1wbGVzO1xufVxuZnVuY3Rpb24gaXNIRVZDKGNvZGVjKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZGVsaW1pdCA9IGNvZGVjLmluZGV4T2YoJy4nKTtcbiAgY29uc3QgYmFzZUNvZGVjID0gZGVsaW1pdCA8IDAgPyBjb2RlYyA6IGNvZGVjLnN1YnN0cmluZygwLCBkZWxpbWl0KTtcbiAgcmV0dXJuIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8IGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8XG4gIC8vIERvbGJ5IFZpc2lvblxuICBiYXNlQ29kZWMgPT09ICdkdmgxJyB8fCBiYXNlQ29kZWMgPT09ICdkdmhlJztcbn1cbmZ1bmN0aW9uIGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIG5hbHVIZWFkZXIpIHtcbiAgaWYgKGlzSEVWQ0ZsYXZvcikge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciA+PiAxICYgMHgzZjtcbiAgICByZXR1cm4gbmFsdVR5cGUgPT09IDM5IHx8IG5hbHVUeXBlID09PSA0MDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuYWx1VHlwZSA9IG5hbHVIZWFkZXIgJiAweDFmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gNjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5lc2NhcGVkRGF0YSwgaGVhZGVyU2l6ZSwgcHRzLCBzYW1wbGVzKSB7XG4gIGNvbnN0IGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICBsZXQgc2VpUHRyID0gMDtcbiAgLy8gc2tpcCBuYWwgaGVhZGVyXG4gIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICBsZXQgcGF5bG9hZFR5cGUgPSAwO1xuICBsZXQgcGF5bG9hZFNpemUgPSAwO1xuICBsZXQgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICBsZXQgYiA9IDA7XG4gIHdoaWxlIChzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlaVB0ciA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG4gICAgY29uc3QgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcbiAgICBpZiAoIWVuZE9mQ2FwdGlvbnMgJiYgcGF5bG9hZFR5cGUgPT09IDQgJiYgc2VpUHRyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuICAgICAgY29uc3QgY291bnRyeUNvZGUgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyQ29kZSA9IHJlYWRVaW50MTYoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgc2VpUHRyICs9IDI7XG4gICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgY29uc3QgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgICBzZWlQdHIgKz0gNDtcbiAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgY29uc3QgdXNlckRhdGFUeXBlID0gZGF0YVtzZWlQdHIrK107XG5cbiAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQ0NzID0gMHgxZiAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgZW5hYmxlZCA9IDB4NDAgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBlbmFibGVkID8gMiArIHRvdGFsQ0NzICogMyA6IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W2ldID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdXNlckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIHB0cyxcbiAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUgJiYgcGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG4gICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xuICAgICAgICBjb25zdCB1dWlkU3RyQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgX2IgPSBkYXRhW3NlaVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goX2IubGVuZ3RoID09IDEgPyAnMCcgKyBfYiA6IF9iKTtcbiAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgY29uc3QgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzW2ldID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICBwdHMsXG4gICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgc2VpUHRyICs9IHBheWxvYWRTaXplO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gKi9cbmZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICBjb25zdCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IEVQQlBvc2l0aW9ucyA9IFtdO1xuICBsZXQgaSA9IDE7XG5cbiAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgLy8gYXJyYXlcbiAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gIGNvbnN0IG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICBsZXQgc291cmNlSW5kZXggPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgfVxuICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgfVxuICByZXR1cm4gbmV3RGF0YTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1zZyhkYXRhKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkYXRhWzBdO1xuICBsZXQgc2NoZW1lSWRVcmkgPSAnJztcbiAgbGV0IHZhbHVlID0gJyc7XG4gIGxldCB0aW1lU2NhbGUgPSAwO1xuICBsZXQgcHJlc2VudGF0aW9uVGltZURlbHRhID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICBsZXQgZXZlbnREdXJhdGlvbiA9IDA7XG4gIGxldCBpZCA9IDA7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IHJlYWRVaW50MzIoZGF0YSwgMTYpO1xuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIDIwKTtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgIG9mZnNldCA9IDI4O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbGVmdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHByZXNlbnRhdGlvblRpbWUgPSAyICoqIDMyICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwcmVzZW50YXRpb25UaW1lKSkge1xuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgbG9nZ2VyLndhcm4oJ1ByZXNlbnRhdGlvbiB0aW1lIGV4Y2VlZHMgc2FmZSBpbnRlZ2VyIGxpbWl0IGFuZCB3cmFwcGVkIHRvIG1heCBzYWZlIGludGVnZXIgaW4gcGFyc2luZyBlbXNnIGJveCcpO1xuICAgIH1cbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVJZFVyaSxcbiAgICB2YWx1ZSxcbiAgICB0aW1lU2NhbGUsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEsXG4gICAgZXZlbnREdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXlsb2FkXG4gIH07XG59XG5mdW5jdGlvbiBtcDRCb3godHlwZSwgLi4ucGF5bG9hZCkge1xuICBjb25zdCBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgbGV0IHNpemUgPSA4O1xuICBsZXQgaSA9IGxlbjtcbiAgd2hpbGUgKGktLSkge1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXA0cHNzaChzeXN0ZW1JZCwga2V5aWRzLCBkYXRhKSB7XG4gIGlmIChzeXN0ZW1JZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICB9XG4gIGxldCB2ZXJzaW9uO1xuICBsZXQga2lkcztcbiAgaWYgKGtleWlkcykge1xuICAgIHZlcnNpb24gPSAxO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheShrZXlpZHMubGVuZ3RoICogMTYpO1xuICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBrZXlpZHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICBjb25zdCBrID0ga2V5aWRzW2l4XTsgLy8gdWludDhhcnJheVxuICAgICAgaWYgKGsuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICB9XG4gICAgICBraWRzLnNldChrLCBpeCAqIDE2KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmVyc2lvbiA9IDA7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgbGV0IGtpZENvdW50O1xuICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGlmIChrZXlpZHMubGVuZ3RoID4gMCkge1xuICAgICAgbmV3IERhdGFWaWV3KGtpZENvdW50LmJ1ZmZlcikuc2V0VWludDMyKDAsIGtleWlkcy5sZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGNvbnN0IGRhdGFTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGlmIChkYXRhICYmIGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICBuZXcgRGF0YVZpZXcoZGF0YVNpemUuYnVmZmVyKS5zZXRVaW50MzIoMCwgZGF0YS5ieXRlTGVuZ3RoLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG1wNEJveChbMTEyLCAxMTUsIDExNSwgMTA0XSwgbmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb24sIDB4MDAsIDB4MDAsIDB4MDAgLy8gRmxhZ3NcbiAgXSksIHN5c3RlbUlkLFxuICAvLyAxNiBieXRlc1xuICBraWRDb3VudCwga2lkcywgZGF0YVNpemUsIGRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKSk7XG59XG5mdW5jdGlvbiBwYXJzZVBzc2goaW5pdERhdGEpIHtcbiAgaWYgKCEoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgaW5pdERhdGEuYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHZlcnNpb246IDAsXG4gICAgc3lzdGVtSWQ6ICcnLFxuICAgIGtpZHM6IG51bGwsXG4gICAgZGF0YTogbnVsbFxuICB9O1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluaXREYXRhKTtcbiAgY29uc3QgYm94U2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICBpZiAoaW5pdERhdGEuYnl0ZUxlbmd0aCAhPT0gYm94U2l6ZSAmJiBib3hTaXplID4gNDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0eXBlID0gdmlldy5nZXRVaW50MzIoNCk7XG4gIGlmICh0eXBlICE9PSAweDcwNzM3MzY4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnZlcnNpb24gPSB2aWV3LmdldFVpbnQzMig4KSA+Pj4gMjQ7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA+IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQuc3lzdGVtSWQgPSBIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMTIsIDE2KSk7XG4gIGNvbnN0IGRhdGFTaXplT3JLaWRDb3VudCA9IHZpZXcuZ2V0VWludDMyKDI4KTtcbiAgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAwKSB7XG4gICAgaWYgKGJveFNpemUgLSAzMiA8IGRhdGFTaXplT3JLaWRDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyLCBkYXRhU2l6ZU9yS2lkQ291bnQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAxKSB7XG4gICAgcmVzdWx0LmtpZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTaXplT3JLaWRDb3VudDsgaSsrKSB7XG4gICAgICByZXN1bHQua2lkcy5wdXNoKG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiArIGkgKiAxNiwgMTYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubGV0IGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbmNsYXNzIExldmVsS2V5IHtcbiAgc3RhdGljIGNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpIHtcbiAgICBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gIH1cbiAgY29uc3RydWN0b3IobWV0aG9kLCB1cmksIGZvcm1hdCwgZm9ybWF0dmVyc2lvbnMgPSBbMV0sIGl2ID0gbnVsbCkge1xuICAgIHRoaXMudXJpID0gdm9pZCAwO1xuICAgIHRoaXMubWV0aG9kID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmNyeXB0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5pdiA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMua2V5SWQgPSBudWxsO1xuICAgIHRoaXMucHNzaCA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgIHRoaXMuaXYgPSBpdjtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IG1ldGhvZCA/IG1ldGhvZCAhPT0gJ05PTkUnIDogZmFsc2U7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiBtZXRob2QgIT09ICdBRVMtMTI4JztcbiAgfVxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IHRoaXMubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgcmV0dXJuIFsnSVNPLTIzMDAxLTcnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnLCAnU0FNUExFLUFFUy1DVFInXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldERlY3J5cHREYXRhKHNuKSB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyAmJiB0aGlzLnVyaSAmJiAhdGhpcy5pdikge1xuICAgICAgaWYgKHR5cGVvZiBzbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gV2UgYXJlIGZldGNoaW5nIGRlY3J5cHRpb24gZGF0YSBmb3IgYSBpbml0aWFsaXphdGlvbiBzZWdtZW50XG4gICAgICAgIC8vIElmIHRoZSBzZWdtZW50IHdhcyBlbmNyeXB0ZWQgd2l0aCBBRVMtMTI4XG4gICAgICAgIC8vIEl0IG11c3QgaGF2ZSBhbiBJViBkZWZpbmVkLiBXZSBjYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgU2VnbWVudCBOdW1iZXIgaW4uXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmICF0aGlzLml2KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XCIke3RoaXMubWV0aG9kfVwiIC0gY29tcGxpYW5jZSBpc3N1ZWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICBzbiA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBpdiA9IGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNuKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgJ2lkZW50aXR5JywgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucywgaXYpO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUga2V5SWQgaWYgcG9zc2libGVcbiAgICBjb25zdCBrZXlCeXRlcyA9IGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHRoaXMudXJpKTtcbiAgICBpZiAoa2V5Qnl0ZXMpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIHRoaXMucHNzaCA9IGtleUJ5dGVzO1xuICAgICAgICAgIC8vIEluIGNhc2Ugb2Ygd2lkZXZpbmUga2V5SUQgaXMgZW1iZWRkZWQgaW4gUFNTSCBib3guIFJlYWQgS2V5IElELlxuICAgICAgICAgIGlmIChrZXlCeXRlcy5sZW5ndGggPj0gMjIpIHtcbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlCeXRlcy5zdWJhcnJheShrZXlCeXRlcy5sZW5ndGggLSAyMiwga2V5Qnl0ZXMubGVuZ3RoIC0gNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFBsYXlSZWFkeUtleVN5c3RlbVVVSUQgPSBuZXcgVWludDhBcnJheShbMHg5YSwgMHgwNCwgMHhmMCwgMHg3OSwgMHg5OCwgMHg0MCwgMHg0MiwgMHg4NiwgMHhhYiwgMHg5MiwgMHhlNiwgMHg1YiwgMHhlMCwgMHg4OCwgMHg1ZiwgMHg5NV0pO1xuICAgICAgICAgICAgdGhpcy5wc3NoID0gbXA0cHNzaChQbGF5UmVhZHlLZXlTeXN0ZW1VVUlELCBudWxsLCBrZXlCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBrZXlCeXRlc1V0ZjE2ID0gbmV3IFVpbnQxNkFycmF5KGtleUJ5dGVzLmJ1ZmZlciwga2V5Qnl0ZXMuYnl0ZU9mZnNldCwga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3Qga2V5Qnl0ZVN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgQXJyYXkuZnJvbShrZXlCeXRlc1V0ZjE2KSk7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIFBsYXlyZWFkeSBXUk1IZWFkZXIgWE1MXG4gICAgICAgICAgICBjb25zdCB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKGtleUJ5dGVTdHIuaW5kZXhPZignPCcpLCBrZXlCeXRlU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbEtleUJ5dGVzLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgIGNvbnN0IGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleURhdGEpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5SWQgPSBrZXlEYXRhLmNoaWxkTm9kZXNbMF0gPyBrZXlEYXRhLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlIDoga2V5RGF0YS5nZXRBdHRyaWJ1dGUoJ1ZBTFVFJyk7XG4gICAgICAgICAgICAgIGlmIChrZXlJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUlkQXJyYXkgPSBiYXNlNjREZWNvZGUoa2V5SWQpLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4gUFJPIGlzIGEgYmFzZTY0LWVuY29kZWQgbGl0dGxlIGVuZGlhbiBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4g4oCYdGVuY+KAmSBpcyBhIGJpZyBlbmRpYW4gVVVJRCBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgICBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkQXJyYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlJZEFycmF5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGtleWRhdGEgPSBrZXlCeXRlcy5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgcGFkZGVkLnNldChrZXlkYXRhLCAxNiAtIGtleWRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAga2V5ZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlkYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IGFzc2lnbiBhIG5ldyBrZXlJZCBmb3IgZWFjaCB1cmlcbiAgICBpZiAoIXRoaXMua2V5SWQgfHwgdGhpcy5rZXlJZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgbGV0IGtleUlkID0ga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV07XG4gICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBrZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgIGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldID0ga2V5SWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gdWludDhWaWV3O1xufVxuXG5jb25zdCBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHtcXCQoW2EtekEtWjAtOS1fXSspXFx9L2c7XG5mdW5jdGlvbiBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyKSB7XG4gIHJldHVybiBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWC50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0ciwgYXR0cmlidXRlTmFtZXMpIHtcbiAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgIGZvciAobGV0IGkgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cltuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBhdHRyW25hbWVdID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSkge1xuICBpZiAocGFyc2VkLnZhcmlhYmxlTGlzdCAhPT0gbnVsbCB8fCBwYXJzZWQuaGFzVmFyaWFibGVSZWZzKSB7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCwgdmFyaWFibGVSZWZlcmVuY2UgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdmFyaWFibGVSZWZlcmVuY2Uuc3Vic3RyaW5nKDIsIHZhcmlhYmxlUmVmZXJlbmNlLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgdmFyaWFibGVWYWx1ZSA9IHZhcmlhYmxlTGlzdCA9PSBudWxsID8gdm9pZCAwIDogdmFyaWFibGVMaXN0W3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFyaWFibGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIHByZWNlZGluZyBFWFQtWC1ERUZJTkUgdGFnIGZvciBWYXJpYWJsZSBSZWZlcmVuY2U6IFwiJHt2YXJpYWJsZU5hbWV9XCJgKSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHBhcmVudFVybCkge1xuICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICBwYXJzZWQudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0ID0ge307XG4gIH1cbiAgbGV0IE5BTUU7XG4gIGxldCBWQUxVRTtcbiAgaWYgKCdRVUVSWVBBUkFNJyBpbiBhdHRyKSB7XG4gICAgTkFNRSA9IGF0dHIuUVVFUllQQVJBTTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IHNlbGYuVVJMKHBhcmVudFVybCkuc2VhcmNoUGFyYW1zO1xuICAgICAgaWYgKHNlYXJjaFBhcmFtcy5oYXMoTkFNRSkpIHtcbiAgICAgICAgVkFMVUUgPSBzZWFyY2hQYXJhbXMuZ2V0KE5BTUUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7TkFNRX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgcXVlcnkgcGFyYW1ldGVyIGluIFVSSTogXCIke3BhcmVudFVybH1cImApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIFFVRVJZUEFSQU06ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIE5BTUUgPSBhdHRyLk5BTUU7XG4gICAgVkFMVUUgPSBhdHRyLlZBTFVFO1xuICB9XG4gIGlmIChOQU1FIGluIHZhcmlhYmxlTGlzdCkge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgZHVwbGljYXRlIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zOiBcIiR7TkFNRX1cImApKTtcbiAgfSBlbHNlIHtcbiAgICB2YXJpYWJsZUxpc3RbTkFNRV0gPSBWQUxVRSB8fCAnJztcbiAgfVxufVxuZnVuY3Rpb24gaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgc291cmNlVmFyaWFibGVMaXN0KSB7XG4gIGNvbnN0IElNUE9SVCA9IGF0dHIuSU1QT1JUO1xuICBpZiAoc291cmNlVmFyaWFibGVMaXN0ICYmIElNUE9SVCBpbiBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICBpZiAoIXZhcmlhYmxlTGlzdCkge1xuICAgICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICAgIH1cbiAgICB2YXJpYWJsZUxpc3RbSU1QT1JUXSA9IHNvdXJjZVZhcmlhYmxlTGlzdFtJTVBPUlRdO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgSU1QT1JUIGF0dHJpYnV0ZSBub3QgZm91bmQgaW4gTXVsdGl2YXJpYW50IFBsYXlsaXN0OiBcIiR7SU1QT1JUfVwiYCkpO1xuICB9XG59XG5cbi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZWxmLk1lZGlhU291cmNlIHx8IHNlbGYuV2ViS2l0TWVkaWFTb3VyY2U7XG59XG5cbi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxuY29uc3Qgc2FtcGxlRW50cnlDb2Rlc0lTTyA9IHtcbiAgYXVkaW86IHtcbiAgICBhM2RzOiB0cnVlLFxuICAgICdhYy0zJzogdHJ1ZSxcbiAgICAnYWMtNCc6IHRydWUsXG4gICAgYWxhYzogdHJ1ZSxcbiAgICBhbGF3OiB0cnVlLFxuICAgIGRyYTE6IHRydWUsXG4gICAgJ2R0cysnOiB0cnVlLFxuICAgICdkdHMtJzogdHJ1ZSxcbiAgICBkdHNjOiB0cnVlLFxuICAgIGR0c2U6IHRydWUsXG4gICAgZHRzaDogdHJ1ZSxcbiAgICAnZWMtMyc6IHRydWUsXG4gICAgZW5jYTogdHJ1ZSxcbiAgICBnNzE5OiB0cnVlLFxuICAgIGc3MjY6IHRydWUsXG4gICAgbTRhZTogdHJ1ZSxcbiAgICBtaGExOiB0cnVlLFxuICAgIG1oYTI6IHRydWUsXG4gICAgbWhtMTogdHJ1ZSxcbiAgICBtaG0yOiB0cnVlLFxuICAgIG1scGE6IHRydWUsXG4gICAgbXA0YTogdHJ1ZSxcbiAgICAncmF3ICc6IHRydWUsXG4gICAgT3B1czogdHJ1ZSxcbiAgICBvcHVzOiB0cnVlLFxuICAgIC8vIGJyb3dzZXJzIGV4cGVjdCB0aGlzIHRvIGJlIGxvd2VyY2FzZSBkZXNwaXRlIE1QNFJBIHNheXMgJ09wdXMnXG4gICAgc2FtcjogdHJ1ZSxcbiAgICBzYXdiOiB0cnVlLFxuICAgIHNhd3A6IHRydWUsXG4gICAgc2V2YzogdHJ1ZSxcbiAgICBzcWNwOiB0cnVlLFxuICAgIHNzbXY6IHRydWUsXG4gICAgdHdvczogdHJ1ZSxcbiAgICB1bGF3OiB0cnVlXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgYXZjMTogdHJ1ZSxcbiAgICBhdmMyOiB0cnVlLFxuICAgIGF2YzM6IHRydWUsXG4gICAgYXZjNDogdHJ1ZSxcbiAgICBhdmNwOiB0cnVlLFxuICAgIGF2MDE6IHRydWUsXG4gICAgZHJhYzogdHJ1ZSxcbiAgICBkdmExOiB0cnVlLFxuICAgIGR2YXY6IHRydWUsXG4gICAgZHZoMTogdHJ1ZSxcbiAgICBkdmhlOiB0cnVlLFxuICAgIGVuY3Y6IHRydWUsXG4gICAgaGV2MTogdHJ1ZSxcbiAgICBodmMxOiB0cnVlLFxuICAgIG1qcDI6IHRydWUsXG4gICAgbXA0djogdHJ1ZSxcbiAgICBtdmMxOiB0cnVlLFxuICAgIG12YzI6IHRydWUsXG4gICAgbXZjMzogdHJ1ZSxcbiAgICBtdmM0OiB0cnVlLFxuICAgIHJlc3Y6IHRydWUsXG4gICAgcnY2MDogdHJ1ZSxcbiAgICBzMjYzOiB0cnVlLFxuICAgIHN2YzE6IHRydWUsXG4gICAgc3ZjMjogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgdnAwODogdHJ1ZSxcbiAgICB2cDA5OiB0cnVlXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBzdHBwOiB0cnVlLFxuICAgIHd2dHQ6IHRydWVcbiAgfVxufTtcbmNvbnN0IE1lZGlhU291cmNlJDIgPSBnZXRNZWRpYVNvdXJjZSgpO1xuZnVuY3Rpb24gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpIHtcbiAgY29uc3QgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoY29kZWMsIHR5cGUpIHtcbiAgdmFyIF9NZWRpYVNvdXJjZSRpc1R5cGVTdTtcbiAgcmV0dXJuIChfTWVkaWFTb3VyY2UkaXNUeXBlU3UgPSBNZWRpYVNvdXJjZSQyID09IG51bGwgPyB2b2lkIDAgOiBNZWRpYVNvdXJjZSQyLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlIHx8ICd2aWRlbyd9L21wNDtjb2RlY3M9XCIke2NvZGVjfVwiYCkpICE9IG51bGwgPyBfTWVkaWFTb3VyY2UkaXNUeXBlU3UgOiBmYWxzZTtcbn1cblxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC0oU0VTU0lPTi1EQVRBfFNFU1NJT04tS0VZfERFRklORXxDT05URU5ULVNURUVSSU5HfFNUQVJUKTooW15cXHJcXG5dKilbXFxyXFxuXSsvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuY29uc3QgSVNfTUVESUFfUExBWUxJU1QgPSAvXiNFWFQoPzpJTkZ8LVgtVEFSR0VURFVSQVRJT04pOi9tOyAvLyBIYW5kbGUgZW1wdHkgTWVkaWEgUGxheWxpc3QgKGZpcnN0IEVYVElORiBub3Qgc2lnbmFsZWQsIGJ1dCBUQVJHRVREVVJBVElPTiBwcmVzZW50KVxuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUID0gbmV3IFJlZ0V4cChbLyNFWFRJTkY6XFxzKihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopXFxzKyk/Ly5zb3VyY2UsXG4vLyBkdXJhdGlvbiAoI0VYVElORjo8ZHVyYXRpb24+LDx0aXRsZT4pLCBncm91cCAxID0+IGR1cmF0aW9uLCBncm91cCAyID0+IHRpdGxlXG4vKD8hIykgKihcXFNbXFxTIF0qKS8uc291cmNlLFxuLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbi8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsXG4vLyBuZXh0IHNlZ21lbnQncyBieXRlcmFuZ2UsIGdyb3VwIDQgPT4gcmFuZ2Ugc3BlYyAoeEB5KVxuLyNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsXG4vLyBuZXh0IHNlZ21lbnQncyBwcm9ncmFtIGRhdGUvdGltZSBncm91cCA1ID0+IHRoZSBkYXRldGltZSBzcGVjXG4vIy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbignfCcpLCAnZycpO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IG5ldyBSZWdFeHAoWy8jKEVYVE0zVSkvLnNvdXJjZSwgLyNFWFQtWC0oREFURVJBTkdFfERFRklORXxLRVl8TUFQfFBBUlR8UEFSVC1JTkZ8UExBWUxJU1QtVFlQRXxQUkVMT0FELUhJTlR8UkVORElUSU9OLVJFUE9SVHxTRVJWRVItQ09OVFJPTHxTS0lQfFNUQVJUKTooLispLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEV8RElTQ09OVElOVUlUWS1TRVFVRU5DRXxNRURJQS1TRVFVRU5DRXxUQVJHRVREVVJBVElPTnxWRVJTSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShESVNDT05USU5VSVRZfEVORExJU1R8R0FQKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbignfCcpKTtcbmNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY29udmVydEFWQzFUb0FWQ09USShjb2RlYykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgY29uc3QgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgbGV0IHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjO1xuICB9XG4gIHN0YXRpYyByZXNvbHZlKHVybCwgYmFzZVVybCkge1xuICAgIHJldHVybiB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGlzTWVkaWFQbGF5bGlzdChzdHIpIHtcbiAgICByZXR1cm4gSVNfTUVESUFfUExBWUxJU1QudGVzdChzdHIpO1xuICB9XG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGNvbnN0IGhhc1ZhcmlhYmxlUmVmcyA9IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpIDtcbiAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICBsZXZlbHM6IFtdLFxuICAgICAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IG51bGwsXG4gICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgaGFzVmFyaWFibGVSZWZzXG4gICAgfTtcbiAgICBjb25zdCBsZXZlbHNXaXRoS25vd25Db2RlY3MgPSBbXTtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICB2YXIgX2xldmVsJHVua25vd25Db2RlY3M7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgICB7XG4gICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbJ0NPREVDUycsICdTVVBQTEVNRU5UQUwtQ09ERUNTJywgJ0FMTE9XRUQtQ1BDJywgJ1BBVEhXQVktSUQnLCAnU1RBQkxFLVZBUklBTlQtSUQnLCAnQVVESU8nLCAnVklERU8nLCAnU1VCVElUTEVTJywgJ0NMT1NFRC1DQVBUSU9OUycsICdOQU1FJ10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCByZXN1bHRbMl0pIDtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUsXG4gICAgICAgICAgdXJsOiBNM1U4UGFyc2VyLnJlc29sdmUodXJpLCBiYXNldXJsKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29kZWNzKChhdHRycy5DT0RFQ1MgfHwgJycpLnNwbGl0KC9bICxdKy8pLmZpbHRlcihjID0+IGMpLCBsZXZlbCk7XG4gICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjICYmIGxldmVsLnZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF9sZXZlbCR1bmtub3duQ29kZWNzID0gbGV2ZWwudW5rbm93bkNvZGVjcykgIT0gbnVsbCAmJiBfbGV2ZWwkdW5rbm93bkNvZGVjcy5sZW5ndGgpKSB7XG4gICAgICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICBjb25zdCB0YWcgPSByZXN1bHRbM107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByZXN1bHRbNF07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1EQVRBJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tREFUQVxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQXR0cnMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgc2Vzc2lvbkF0dHJzLCBbJ0RBVEEtSUQnLCAnTEFOR1VBR0UnLCAnVkFMVUUnLCAnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFJZCA9IHNlc3Npb25BdHRyc1snREFUQS1JRCddO1xuICAgICAgICAgICAgICBpZiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YVtkYXRhSWRdID0gc2Vzc2lvbkF0dHJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NFU1NJT04tS0VZJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tS0VZXG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBwYXJzZUtleShhdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpO1xuICAgICAgICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cy5wdXNoKHNlc3Npb25LZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1TRVNTSU9OLUtFWSB0YWc6IFwiJHthdHRyaWJ1dGVzfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLURFRklORVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFsnTkFNRScsICdWQUxVRScsICdRVUVSWVBBUkFNJ10pO1xuICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIHZhcmlhYmxlQXR0cmlidXRlcywgYmFzZXVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQ09OVEVOVC1TVEVFUklORyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1DT05URU5ULVNURUVSSU5HXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcywgWydTRVJWRVItVVJJJywgJ1BBVEhXQVktSUQnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IE0zVThQYXJzZXIucmVzb2x2ZShjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydTRVJWRVItVVJJJ10sIGJhc2V1cmwpLFxuICAgICAgICAgICAgICAgIHBhdGh3YXlJZDogY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snUEFUSFdBWS1JRCddIHx8ICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TVEFSVFxuICAgICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICBjb25zdCBzdHJpcFVua25vd25Db2RlY0xldmVscyA9IGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcbiAgICBwYXJzZWQubGV2ZWxzID0gc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPyBsZXZlbHNXaXRoS25vd25Db2RlY3MgOiBwYXJzZWQubGV2ZWxzO1xuICAgIGlmIChwYXJzZWQubGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgcGFyc2VkKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgY29uc3QgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICBjb25zdCBncm91cHNCeVR5cGUgPSB7XG4gICAgICBBVURJTzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICAgIH0pKSxcbiAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlY1xuICAgICAgfSkpLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IFtdXG4gICAgfTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBjb25zdCB0eXBlID0gYXR0cnMuVFlQRTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGdyb3Vwc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgY29uc3QgbWVkaWFzID0gcmVzdWx0c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAge1xuICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRycywgWydVUkknLCAnR1JPVVAtSUQnLCAnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnU1RBQkxFLVJFTkRJVElPTi1JRCcsICdOQU1FJywgJ0lOU1RSRUFNLUlEJywgJ0NIQVJBQ1RFUklTVElDUycsICdDSEFOTkVMUyddKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYSA9IHtcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGF0dHJzWydHUk9VUC1JRCddIHx8ICcnLFxuICAgICAgICAgIGluc3RyZWFtSWQ6IGF0dHJzWydJTlNUUkVBTS1JRCddLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UgfHwgJycsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZzogYXR0cnMuTEFOR1VBR0UsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChncm91cHMgIT0gbnVsbCAmJiBncm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGF1ZGlvIG9yIHRleHQgZ3JvdXBzIHNpZ25hbGxlZCBpbiB0aGUgbWFuaWZlc3QsIGxldCdzIGxvb2sgZm9yIGEgbWF0Y2hpbmcgY29kZWMgc3RyaW5nIGZvciB0aGlzIHRyYWNrXG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCB0aGUgdHJhY2sgc2lnbmFsbGVkLCBsZXRzIHVzZSB0aGUgZmlyc3QgYXVkaW8gZ3JvdXBzIGNvZGVjIHdlIGhhdmVcbiAgICAgICAgICAvLyBBY3RpbmcgYXMgYSBiZXN0IGd1ZXNzXG4gICAgICAgICAgY29uc3QgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGdyb3VwcywgbWVkaWEuZ3JvdXBJZCkgfHwgZ3JvdXBzWzBdO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAnYXVkaW9Db2RlYycpO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFzLnB1c2gobWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBzdGF0aWMgcGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgYmFzZXVybCwgaWQsIHR5cGUsIGxldmVsVXJsSWQsIG11bHRpdmFyaWFudFZhcmlhYmxlTGlzdCkge1xuICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsRGV0YWlscyhiYXNldXJsKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbC5mcmFnbWVudHM7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGluaXQgc2VnbWVudCBzZWVuIChhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzKVxuICAgIGxldCBjdXJyZW50SW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIGxldCBjdXJyZW50U04gPSAwO1xuICAgIGxldCBjdXJyZW50UGFydCA9IDA7XG4gICAgbGV0IHRvdGFsZHVyYXRpb24gPSAwO1xuICAgIGxldCBkaXNjb250aW51aXR5Q291bnRlciA9IDA7XG4gICAgbGV0IHByZXZGcmFnID0gbnVsbDtcbiAgICBsZXQgZnJhZyA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpO1xuICAgIGxldCBsZXZlbGtleXM7XG4gICAgbGV0IGZpcnN0UGR0SW5kZXggPSAtMTtcbiAgICBsZXQgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgbGV2ZWwubTN1OCA9IHN0cmluZztcbiAgICBsZXZlbC5oYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChjcmVhdGVOZXh0RnJhZykge1xuICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG4gICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgICAgZnJhZy51cmxJZCA9IGxldmVsVXJsSWQ7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGNvbnN0IHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhsZXZlbCwgdXJpKSA7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGN1cnJlbnRTTisrO1xuICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgIC8vIFgtQllURVJBTkdFXG4gICAgICAgIGNvbnN0IGRhdGEgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IScpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGFnID0gKCcgJyArIHJlc3VsdFtpXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gcmVzdWx0W2kgKyAyXSA/ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKSA6ICcnO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2tpcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBza2lwQXR0cnMsIFsnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IHNraXBBdHRycy5kZWNpbWFsSW50ZWdlcignU0tJUFBFRC1TRUdNRU5UUycpO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVzdWx0IGluIGZyYWdtZW50c1tdIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggd2Ugd2lsbCBmaWxsIGluIHdpdGggYG1lcmdlRGV0YWlsc2BcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSBza2lwQXR0cnMuZW51bWVyYXRlZFN0cmluZygnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnRhcmdldGR1cmF0aW9uID0gTWF0aC5tYXgocGFyc2VJbnQodmFsdWUxKSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRVhUTTNVJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBpZiAodmFsdWUxIHx8IHZhbHVlMikge1xuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh2YWx1ZTIgPyBbdmFsdWUxLCB2YWx1ZTJdIDogW3ZhbHVlMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlcisrO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdHQVAnOlxuICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZ10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQklUUkFURSc6XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RBVEVSQU5HRSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZUF0dHIgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIGRhdGVSYW5nZUF0dHIsIFsnSUQnLCAnQ0xBU1MnLCAnU1RBUlQtREFURScsICdFTkQtREFURScsICdTQ1RFMzUtQ01EJywgJ1NDVEUzNS1PVVQnLCAnU0NURTM1LUlOJ10pO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIGRhdGVSYW5nZUF0dHIsIGRhdGVSYW5nZUF0dHIuY2xpZW50QXR0cnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VBdHRyLklEXSk7XG4gICAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCB8fCBsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZS5pZF0gPSBkYXRlUmFuZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQgREFURVJBTkdFIHRhZzogXCIke3ZhbHVlMX1cImApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEFkZCB0byBmcmFnbWVudCB0YWcgbGlzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKDwgdjEuMi4wKVxuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0VYVC1YLURBVEVSQU5HRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBbJ05BTUUnLCAnVkFMVUUnLCAnSU1QT1JUJywgJ1FVRVJZUEFSQU0nXSk7XG4gICAgICAgICAgICAgICAgaWYgKCdJTVBPUlQnIGluIHZhcmlhYmxlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIG11bHRpdmFyaWFudFZhcmlhYmxlTGlzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBsZXZlbEtleSA9IHBhcnNlS2V5KHZhbHVlMSwgYmFzZXVybCwgbGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbEtleS5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSBfZXh0ZW5kcyh7fSwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0gPSBsZXZlbEtleTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtS0VZIHRhZzogXCIke3ZhbHVlMX1cImApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgbWFwQXR0cnMsIFsnQllURVJBTkdFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZnJhZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgICAgLy8gICAjRVhUSU5GOiA2LjBcbiAgICAgICAgICAgICAgICAvLyAgICNFWFQtWC1NQVA6VVJJPVwiaW5pdC5tcDRcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0ID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGluaXQsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBpbml0O1xuICAgICAgICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgJiYgIWZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYmVmb3JlIHNlZ21lbnQgZHVyYXRpb24gdGFnXG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NFUlZFUi1DT05UUk9MJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ29udHJvbEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLmNhbkJsb2NrUmVsb2FkID0gc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1CTE9DSy1SRUxPQUQnKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0NBTi1TS0lQLVVOVElMJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBEYXRlUmFuZ2VzID0gbGV2ZWwuY2FuU2tpcFVudGlsID4gMCAmJiBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLVNLSVAtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICBsZXZlbC5wYXJ0SG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnUEFSVC1IT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQtSU5GJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydEluZkF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRUYXJnZXQgPSBwYXJ0SW5mQXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1BBUlQtVEFSR0VUJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdDtcbiAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZyYWdtZW50UGFydCA9IGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRQYXJ0Kys7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcGFydEF0dHJzLCBbJ0JZVEVSQU5HRScsICdVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFydCA9IG5ldyBQYXJ0KHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzRnJhZ21lbnRQYXJ0KTtcbiAgICAgICAgICAgICAgcGFydExpc3QucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiArPSBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQUkVMT0FELUhJTlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkSGludEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwcmVsb2FkSGludEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXZlbC5wcmVsb2FkSGludCA9IHByZWxvYWRIaW50QXR0cnM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1JFTkRJVElPTi1SRVBPUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcmVuZGl0aW9uUmVwb3J0QXR0cnMsIFsnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMgPSBsZXZlbC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzLnB1c2gocmVuZGl0aW9uUmVwb3J0QXR0cnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldkZyYWcgJiYgIXByZXZGcmFnLnJlbHVybCkge1xuICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbiAtPSBwcmV2RnJhZy5kdXJhdGlvbjtcbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0RnJhZ21lbnQgPSBmcmFnbWVudHNbMF07XG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50TGVuZ3RoIC0gMV07XG4gICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5za2lwcGVkU2VnbWVudHMgKiBsZXZlbC50YXJnZXRkdXJhdGlvbjtcbiAgICBpZiAodG90YWxkdXJhdGlvbiA+IDAgJiYgZnJhZ21lbnRMZW5ndGggJiYgbGFzdEZyYWdtZW50KSB7XG4gICAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gZnJhZ21lbnRMZW5ndGg7XG4gICAgICBjb25zdCBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICBsZXZlbC5lbmRTTiA9IGxhc3RTbiAhPT0gJ2luaXRTZWdtZW50JyA/IGxhc3RTbiA6IDA7XG4gICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VLZXkoa2V5VGFnQXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKSB7XG4gIHZhciBfa2V5QXR0cnMkTUVUSE9ELCBfa2V5QXR0cnMkS0VZRk9STUFUO1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODIxNiNzZWN0aW9uLTQuMy4yLjRcbiAgY29uc3Qga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3Qoa2V5VGFnQXR0cmlidXRlcyk7XG4gIHtcbiAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwga2V5QXR0cnMsIFsnS0VZRk9STUFUJywgJ0tFWUZPUk1BVFZFUlNJT05TJywgJ1VSSScsICdJVicsICdVUkknXSk7XG4gIH1cbiAgY29uc3QgZGVjcnlwdG1ldGhvZCA9IChfa2V5QXR0cnMkTUVUSE9EID0ga2V5QXR0cnMuTUVUSE9EKSAhPSBudWxsID8gX2tleUF0dHJzJE1FVEhPRCA6ICcnO1xuICBjb25zdCBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJO1xuICBjb25zdCBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gIGNvbnN0IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA9IGtleUF0dHJzLktFWUZPUk1BVFZFUlNJT05TO1xuICAvLyBGcm9tIFJGQzogVGhpcyBhdHRyaWJ1dGUgaXMgT1BUSU9OQUw7IGl0cyBhYnNlbmNlIGluZGljYXRlcyBhbiBpbXBsaWNpdCB2YWx1ZSBvZiBcImlkZW50aXR5XCIuXG4gIGNvbnN0IGRlY3J5cHRrZXlmb3JtYXQgPSAoX2tleUF0dHJzJEtFWUZPUk1BVCA9IGtleUF0dHJzLktFWUZPUk1BVCkgIT0gbnVsbCA/IF9rZXlBdHRycyRLRVlGT1JNQVQgOiAnaWRlbnRpdHknO1xuICBpZiAoZGVjcnlwdHVyaSAmJiBrZXlBdHRycy5JViAmJiAhZGVjcnlwdGl2KSB7XG4gICAgbG9nZ2VyLmVycm9yKGBJbnZhbGlkIElWOiAke2tleUF0dHJzLklWfWApO1xuICB9XG4gIC8vIElmIGRlY3J5cHR1cmkgaXMgYSBVUkkgd2l0aCBhIHNjaGVtZSwgdGhlbiBiYXNldXJsIHdpbGwgYmUgaWdub3JlZFxuICAvLyBObyB1cmkgaXMgYWxsb3dlZCB3aGVuIE1FVEhPRCBpcyBOT05FXG4gIGNvbnN0IHJlc29sdmVkVXJpID0gZGVjcnlwdHVyaSA/IE0zVThQYXJzZXIucmVzb2x2ZShkZWNyeXB0dXJpLCBiYXNldXJsKSA6ICcnO1xuICBjb25zdCBrZXlGb3JtYXRWZXJzaW9ucyA9IChkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPyBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgOiAnMScpLnNwbGl0KCcvJykubWFwKE51bWJlcikuZmlsdGVyKE51bWJlci5pc0Zpbml0ZSk7XG4gIHJldHVybiBuZXcgTGV2ZWxLZXkoZGVjcnlwdG1ldGhvZCwgcmVzb2x2ZWRVcmksIGRlY3J5cHRrZXlmb3JtYXQsIGtleUZvcm1hdFZlcnNpb25zLCBkZWNyeXB0aXYpO1xufVxuZnVuY3Rpb24gcGFyc2VTdGFydFRpbWVPZmZzZXQoc3RhcnRBdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICByZXR1cm4gc3RhcnRUaW1lT2Zmc2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2V0Q29kZWNzKGNvZGVjcywgbGV2ZWwpIHtcbiAgWyd2aWRlbycsICdhdWRpbycsICd0ZXh0J10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpKTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoY29kZWMgPT4ge1xuICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgfSk7XG4gICAgICBsZXZlbFtgJHt0eXBlfUNvZGVjYF0gPSBwcmVmZXJyZWQubGVuZ3RoID4gMCA/IHByZWZlcnJlZFswXSA6IGZpbHRlcmVkWzBdO1xuXG4gICAgICAvLyByZW1vdmUgZnJvbSBsaXN0XG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGNvZGVjID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgfVxuICB9KTtcbiAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbn1cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgY29uc3QgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpIHtcbiAgbGV0IGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICBmb3IgKGxldCBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgLy8gRXhpdCBvbiBkZWx0YS1wbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgfSBlbHNlIGlmIChwcmV2RnJhZyAhPSBudWxsICYmIHByZXZGcmFnLnByb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICB9XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpIHtcbiAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG4gIGZyYWcubGV2ZWwgPSBpZDtcbiAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gIGlmIChsZXZlbGtleXMpIHtcbiAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgfVxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCkge1xuICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgY29uc3Qge1xuICAgIGVuY3J5cHRlZEZyYWdtZW50c1xuICB9ID0gbGV2ZWw7XG4gIGlmICgoIWVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggfHwgZW5jcnlwdGVkRnJhZ21lbnRzW2VuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggLSAxXS5sZXZlbGtleXMgIT09IGxldmVsa2V5cykgJiYgT2JqZWN0LmtleXMobGV2ZWxrZXlzKS5zb21lKGZvcm1hdCA9PiBsZXZlbGtleXNbZm9ybWF0XS5pc0NvbW1vbkVuY3J5cHRpb24pKSB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gIH1cbn1cblxudmFyIFBsYXlsaXN0Q29udGV4dFR5cGUgPSB7XG4gIE1BTklGRVNUOiBcIm1hbmlmZXN0XCIsXG4gIExFVkVMOiBcImxldmVsXCIsXG4gIEFVRElPX1RSQUNLOiBcImF1ZGlvVHJhY2tcIixcbiAgU1VCVElUTEVfVFJBQ0s6IFwic3VidGl0bGVUcmFja1wiXG59O1xudmFyIFBsYXlsaXN0TGV2ZWxUeXBlID0ge1xuICBNQUlOOiBcIm1haW5cIixcbiAgQVVESU86IFwiYXVkaW9cIixcbiAgU1VCVElUTEU6IFwic3VidGl0bGVcIlxufTtcblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGNvbnRleHQ7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCkge1xuICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuY2xhc3MgUGxheWxpc3RMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cbiAgZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfVxuICByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgZGVzdHJveUludGVybmFsTG9hZGVycygpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdXJsXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9XG4gIGxvYWQoY29udGV4dCkge1xuICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogTG9hZGluZyBwbGF5bGlzdCBvZiB0eXBlICR7Y29udGV4dC50eXBlfSwgbGV2ZWw6ICR7Y29udGV4dC5sZXZlbH0sIGlkOiAke2NvbnRleHQuaWR9YCk7XG5cbiAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgbGV0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsKSB7XG4gICAgICAgIC8vIHNhbWUgVVJMIGNhbid0IG92ZXJsYXBcbiAgICAgICAgbG9nZ2VyLnRyYWNlKCdbcGxheWxpc3QtbG9hZGVyXTogcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coYFtwbGF5bGlzdC1sb2FkZXJdOiBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6ICR7Y29udGV4dC50eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgLy8gY29udGV4dCAobWFuaWZlc3QsIGxldmVsLCBhdWRpby9zdWJzIHBsYXlsaXN0KVxuICAgIGxldCBsb2FkUG9saWN5O1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBjb25maWcubWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBfZXh0ZW5kcyh7fSwgY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICAgICAgZXJyb3JSZXRyeTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAvLyAodGhlIGRlZmF1bHQgb2YgMTAwMDBtcyBpcyBjb3VudGVyIHByb2R1Y3RpdmUgdG8gYmxvY2tpbmcgcGxheWxpc3QgcmVsb2FkIHJlcXVlc3RzKVxuICAgIGlmICgoX2NvbnRleHQkZGVsaXZlcnlEaXJlID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2NvbnRleHQkZGVsaXZlcnlEaXJlLnBhcnQpIHtcbiAgICAgIGxldCBsZXZlbERldGFpbHM7XG4gICAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMICYmIGNvbnRleHQubGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMubGV2ZWxzW2NvbnRleHQubGV2ZWxdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUYXJnZXQgPSBsZXZlbERldGFpbHMucGFydFRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIGlmIChwYXJ0VGFyZ2V0ICYmIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCA9IE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwO1xuICAgICAgICAgIGxvYWRQb2xpY3kgPSBfZXh0ZW5kcyh7fSwgbG9hZFBvbGljeSwge1xuICAgICAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IE1hdGgubWluKG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2gsIGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMpLFxuICAgICAgICAgICAgbWF4TG9hZFRpbWVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkgPSBsb2FkUG9saWN5LmVycm9yUmV0cnkgfHwgbG9hZFBvbGljeS50aW1lb3V0UmV0cnkgfHwge307XG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgbG9hZFBvbGljeSxcbiAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgIG1heFJldHJ5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMFxuICAgIH07XG4gICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldyBFcnJvcignbm8gRVhUTTNVIGRlbGltaXRlcicpLCBuZXR3b3JrRGV0YWlscyB8fCBudWxsLCBzdGF0cyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKE0zVThQYXJzZXIuaXNNZWRpYVBsYXlsaXN0KHN0cmluZykpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgfHwgbnVsbCwgbG9hZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSwgc3RhdHMpO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSwgdW5kZWZpbmVkLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cbiAgaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgaWYgKHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvcikge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgcGFyc2VkUmVzdWx0LnBsYXlsaXN0UGFyc2luZ0Vycm9yLCBuZXR3b3JrRGV0YWlscywgc3RhdHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICBsZXZlbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0XG4gICAgfSA9IHBhcnNlZFJlc3VsdDtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdDtcbiAgICBjb25zdCB7XG4gICAgICBBVURJTzogYXVkaW9UcmFja3MgPSBbXSxcbiAgICAgIFNVQlRJVExFUzogc3VidGl0bGVzLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IGNhcHRpb25zXG4gICAgfSA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCBwYXJzZWRSZXN1bHQpO1xuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgY29uc3QgZW1iZWRkZWRBdWRpb0ZvdW5kID0gYXVkaW9UcmFja3Muc29tZShhdWRpb1RyYWNrID0+ICFhdWRpb1RyYWNrLnVybCk7XG5cbiAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgIGlmICghZW1iZWRkZWRBdWRpb0ZvdW5kICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xuICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICAgIGdyb3VwSWQ6ICdtYWluJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBhdXRvc2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICBmb3JjZWQ6IGZhbHNlLFxuICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICBhdHRyczogbmV3IEF0dHJMaXN0KHt9KSxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIHVybDogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgY2FwdGlvbnMsXG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICB1cmwsXG4gICAgICBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdFxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICB0eXBlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsVXJsSWQgPSBpc0Zpbml0ZU51bWJlcihpZCkgPyBpZCA6IDA7XG4gICAgY29uc3QgbGV2ZWxJZCA9IGlzRmluaXRlTnVtYmVyKGxldmVsKSA/IGxldmVsIDogbGV2ZWxVcmxJZDtcbiAgICBjb25zdCBsZXZlbFR5cGUgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gTTNVOFBhcnNlci5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIGxldmVsVXJsSWQsIHRoaXMudmFyaWFibGVMaXN0KTtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsID0ge1xuICAgICAgICBhdHRyczogbmV3IEF0dHJMaXN0KHt9KSxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdXJsXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHNlc3Npb25EYXRhOiBudWxsLFxuICAgICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKTtcbiAgfVxuICBoYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgZXJyb3IsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQgPSBmYWxzZSwgcmVzcG9uc2UsIHN0YXRzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgQSBuZXR3b3JrICR7dGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcicgKyAocmVzcG9uc2UgPyAnIChzdGF0dXMgJyArIHJlc3BvbnNlLmNvZGUgKyAnKScgOiAnJyl9IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnR5cGV9YDtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICBtZXNzYWdlICs9IGA6ICR7Y29udGV4dC5sZXZlbH0gaWQ6ICR7Y29udGV4dC5pZH1gO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLIHx8IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSykge1xuICAgICAgbWVzc2FnZSArPSBgIGlkOiAke2NvbnRleHQuaWR9IGdyb3VwLWlkOiBcIiR7Y29udGV4dC5ncm91cElkfVwiYDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgbG9nZ2VyLndhcm4oYFtwbGF5bGlzdC1sb2FkZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgbGV0IGRldGFpbHMgPSBFcnJvckRldGFpbHMuVU5LTk9XTjtcbiAgICBsZXQgZmF0YWwgPSBmYWxzZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsLFxuICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgIGxvYWRlcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgY29uc3QgdXJsID0gKG5ldHdvcmtEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBuZXR3b3JrRGV0YWlscy51cmwpIHx8IGNvbnRleHQudXJsO1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgfSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgfVxuICBoYW5kbGVQbGF5bGlzdExvYWRlZChsZXZlbERldGFpbHMsIHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBsZXZlbCxcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnQgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IHR5cGVvZiBjb250ZXh0LmxldmVsID09PSAnbnVtYmVyJyAmJiBwYXJlbnQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBsZXZlbCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBfZXJyb3IgPSBuZXcgRXJyb3IoJ05vIFNlZ21lbnRzIGZvdW5kIGluIFBsYXlsaXN0Jyk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBlcnJvcjogX2Vycm9yLFxuICAgICAgICByZWFzb246IF9lcnJvci5tZXNzYWdlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgIGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTWlzc2luZyBUYXJnZXQgRHVyYXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3I7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgbG9hZGVyKSB7XG4gICAgICBpZiAobG9hZGVyLmdldENhY2hlQWdlKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSBsb2FkZXIuZ2V0Q2FjaGVBZ2UoKSB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKCFsb2FkZXIuZ2V0Q2FjaGVBZ2UgfHwgaXNOYU4obGV2ZWxEZXRhaWxzLmFnZUhlYWRlcikpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbEluZGV4IHx8IDAsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjaywgdmlkZW9FbCkge1xuICBsZXQgZXZlbnQ7XG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICBldmVudC50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKSB7XG4gIC8vIFNvbWV0aW1lcyB0aGVyZSBhcmUgY3VlIG92ZXJsYXBzIG9uIHNlZ21lbnRlZCB2dHRzIHNvIHRoZSBzYW1lXG4gIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXG4gIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgaWYgKCF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFkZEN1ZSBpcyBmYWlsZWQgZm9yOiAke2N1ZX1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgW3RleHR0cmFjay11dGlsc106ICR7ZXJyfWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGV4dFRyYWNrQ3VlID0gbmV3IHNlbGYuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgICAgdHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgW3RleHR0cmFjay11dGlsc106IExlZ2FjeSBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgZmFpbGVkOiAke2VycjJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2spIHtcbiAgLy8gV2hlbiB0cmFjay5tb2RlIGlzIGRpc2FibGVkLCB0cmFjay5jdWVzIHdpbGwgYmUgbnVsbC5cbiAgLy8gVG8gZ3VhcmFudGVlIHRoZSByZW1vdmFsIG9mIGN1ZXMsIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHlcbiAgLy8gY2hhbmdlIHRoZSBtb2RlIHRvIGhpZGRlblxuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gdHJhY2suY3Vlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UodHJhY2ssIHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgdHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VlcyA9IGdldEN1ZXNJblJhbmdlKHRyYWNrLmN1ZXMsIHN0YXJ0LCBlbmQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKGN1ZXNbaV0pKSB7XG4gICAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG4vLyBGaW5kIGZpcnN0IGN1ZSBzdGFydGluZyBhZnRlciBnaXZlbiB0aW1lLlxuLy8gTW9kaWZpZWQgdmVyc2lvbiBvZiBiaW5hcnkgc2VhcmNoIE8obG9nKG4pKS5cbmZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3VlcywgdGltZSkge1xuICAvLyBJZiBmaXJzdCBjdWUgc3RhcnRzIGFmdGVyIHRpbWUsIHN0YXJ0IHRoZXJlXG4gIGlmICh0aW1lIDwgY3Vlc1swXS5zdGFydFRpbWUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBJZiB0aGUgbGFzdCBjdWUgZW5kcyBiZWZvcmUgdGltZSB0aGVyZSBpcyBubyBvdmVybGFwXG4gIGNvbnN0IGxlbiA9IGN1ZXMubGVuZ3RoIC0gMTtcbiAgaWYgKHRpbWUgPiBjdWVzW2xlbl0uZW5kVGltZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGxlbjtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMik7XG4gICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIGlmICh0aW1lID4gY3Vlc1ttaWRdLnN0YXJ0VGltZSAmJiBsZWZ0IDwgbGVuKSB7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBub3QgbG93ZXIgb3IgaGlnaGVyLCBpdCBtdXN0IGJlIGVxdWFsLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCwgbGVmdCBhbmQgcmlnaHQgaGF2ZSBzd2FwcGVkLlxuICAvLyBObyBkaXJlY3QgbWF0Y2ggd2FzIGZvdW5kLCBsZWZ0IG9yIHJpZ2h0IGVsZW1lbnQgbXVzdCBiZSB0aGUgY2xvc2VzdC4gQ2hlY2sgd2hpY2ggb25lIGhhcyB0aGUgc21hbGxlc3QgZGlmZi5cbiAgcmV0dXJuIGN1ZXNbbGVmdF0uc3RhcnRUaW1lIC0gdGltZSA8IHRpbWUgLSBjdWVzW3JpZ2h0XS5zdGFydFRpbWUgPyBsZWZ0IDogcmlnaHQ7XG59XG5mdW5jdGlvbiBnZXRDdWVzSW5SYW5nZShjdWVzLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGN1ZXNGb3VuZCA9IFtdO1xuICBjb25zdCBmaXJzdEN1ZUluUmFuZ2UgPSBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKGN1ZXMsIHN0YXJ0KTtcbiAgaWYgKGZpcnN0Q3VlSW5SYW5nZSA+IC0xKSB7XG4gICAgZm9yIChsZXQgaSA9IGZpcnN0Q3VlSW5SYW5nZSwgbGVuID0gY3Vlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY3VlID0gY3Vlc1tpXTtcbiAgICAgIGlmIChjdWUuc3RhcnRUaW1lID49IHN0YXJ0ICYmIGN1ZS5lbmRUaW1lIDw9IGVuZCkge1xuICAgICAgICBjdWVzRm91bmQucHVzaChjdWUpO1xuICAgICAgfSBlbHNlIGlmIChjdWUuc3RhcnRUaW1lID4gZW5kKSB7XG4gICAgICAgIHJldHVybiBjdWVzRm91bmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjdWVzRm91bmQ7XG59XG5cbnZhciBNZXRhZGF0YVNjaGVtYSA9IHtcbiAgYXVkaW9JZDM6IFwib3JnLmlkM1wiLFxuICBkYXRlUmFuZ2U6IFwiY29tLmFwcGxlLnF1aWNrdGltZS5ITFNcIixcbiAgZW1zZzogXCJodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzXCJcbn07XG5cbmNvbnN0IE1JTl9DVUVfRFVSQVRJT04gPSAwLjI1O1xuZnVuY3Rpb24gZ2V0Q3VlQ2xhc3MoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gQXR0ZW1wdCB0byByZWNyZWF0ZSBTYWZhcmkgZnVuY3Rpb25hbGl0eSBieSBjcmVhdGluZ1xuICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gIC8vIElEMyBkYXRhIGluIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgY3VlXG4gIHJldHVybiBzZWxmLldlYktpdERhdGFDdWUgfHwgc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG59XG5cbi8vIFZUVEN1ZSBsYXRlc3QgZHJhZnQgYWxsb3dzIGFuIGluZmluaXRlIGR1cmF0aW9uLCBmYWxsYmFja1xuLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuY29uc3QgTUFYX0NVRV9FTkRUSU1FID0gKCgpID0+IHtcbiAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn0pKCk7XG5mdW5jdGlvbiBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDAgLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBoZXhUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHN0ci5yZXBsYWNlKC9eMHgvLCAnJykucmVwbGFjZSgvKFtcXGRhLWZBLUZdezJ9KSA/L2csICcweCQxICcpLnJlcGxhY2UoLyArJC8sICcnKS5zcGxpdCgnICcpKS5idWZmZXI7XG59XG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG4gIGNyZWF0ZVRyYWNrKG1lZGlhKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cbiAgZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICBpZiAodGV4dFRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScgJiYgdGV4dFRyYWNrLmxhYmVsID09PSAnaWQzJykge1xuICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAvLyBzYW1lIGFzIHdoYXQgd2UgZG8gZm9yIGNhcHRpb25zXG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH1cbiAgb25GcmFnUGFyc2luZ01ldGFkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGhsczoge1xuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3Vlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlbmFibGVFbXNnTWV0YWRhdGFDdWVzICYmICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2FtcGxlc1xuICAgIH0gPSBkYXRhO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG4gICAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzYW1wbGVzW2ldLnR5cGU7XG4gICAgICBpZiAodHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhbWVzID0gZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZSArIHNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgIGlmIChlbmRUaW1lID4gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgaWYgKCFpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICAgICAgLy8gYWRkIGEgYm91bmRzIHRvIGFueSB1bmJvdW5kZWQgY3Vlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICBjdWUudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSkge1xuICAgIHZhciBfdGhpcyRpZDNUcmFjaztcbiAgICBjb25zdCBjdWVzID0gKF90aGlzJGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGlkM1RyYWNrLmN1ZXM7XG4gICAgaWYgKGN1ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgICBpZiAoY3VlLnR5cGUgPT09IHR5cGUgJiYgY3VlLnN0YXJ0VGltZSA8IHN0YXJ0VGltZSAmJiBjdWUuZW5kVGltZSA9PT0gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgY3VlLmVuZFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwge1xuICAgIHN0YXJ0T2Zmc2V0LFxuICAgIGVuZE9mZnNldCxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDNUcmFjayxcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXNcbiAgICAgIH1cbiAgICB9ID0gaGxzO1xuICAgIGlmIChpZDNUcmFjayAmJiAoZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMpKSB7XG4gICAgICBsZXQgcHJlZGljYXRlO1xuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB8fCBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ3Vlc0luUmFuZ2UoaWQzVHJhY2ssIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhIHx8ICFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhdGhpcy5obHMuY29uZmlnLmVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQsXG4gICAgICBpZDNUcmFja1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGVSYW5nZXNcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgICAvLyBSZW1vdmUgY3VlcyBmcm9tIHRyYWNrIG5vdCBmb3VuZCBpbiBkZXRhaWxzLmRhdGVSYW5nZXNcbiAgICBpZiAoaWQzVHJhY2spIHtcbiAgICAgIGNvbnN0IGlkc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkKS5maWx0ZXIoaWQgPT4gIWlkcy5pbmNsdWRlcyhpZCkpO1xuICAgICAgZm9yIChsZXQgaSA9IGlkc1RvUmVtb3ZlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBpZCA9IGlkc1RvUmVtb3ZlW2ldO1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBpZDNUcmFjay5yZW1vdmVDdWUoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXS5jdWVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpZHMubGVuZ3RoID09PSAwIHx8ICFpc0Zpbml0ZU51bWJlcihsYXN0RnJhZ21lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RGcmFnbWVudC5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGVUaW1lT2Zmc2V0ID0gbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSAvIDEwMDAgLSBsYXN0RnJhZ21lbnQuc3RhcnQ7XG4gICAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBjb25zdCBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIGNvbnN0IGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICBjb25zdCBjdWVzID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmN1ZXMpIHx8IHt9O1xuICAgICAgbGV0IGR1cmF0aW9uS25vd24gPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikgfHwgZmFsc2U7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZVJhbmdlLnN0YXJ0RGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgbGV0IGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICBjb25zdCBlbmREYXRlID0gZGF0ZVJhbmdlLmVuZERhdGU7XG4gICAgICBpZiAoZW5kRGF0ZSkge1xuICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGVuZERhdGUsIGRhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRhdGVSYW5nZS5lbmRPbk5leHQgJiYgIWR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MgPSBpZHMucmVkdWNlKChmaWx0ZXJNYXBBcnJheSwgaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlLmNsYXNzID09PSBkYXRlUmFuZ2UuY2xhc3MgJiYgY2FuZGlkYXRlLmlkICE9PSBpZCAmJiBjYW5kaWRhdGUuc3RhcnREYXRlID4gZGF0ZVJhbmdlLnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgZmlsdGVyTWFwQXJyYXkucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmlsdGVyTWFwQXJyYXk7XG4gICAgICAgIH0sIFtdKS5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBiLnN0YXJ0RGF0ZS5nZXRUaW1lKCkpWzBdO1xuICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzLnN0YXJ0RGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlLmF0dHIpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdWUgPSBjdWVzW2tleV07XG4gICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICBpZiAoZHVyYXRpb25Lbm93biAmJiAhYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBkYXRlUmFuZ2UuYXR0cltrZXldO1xuICAgICAgICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBoZXhUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdWUudmFsdWUgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdWUudHlwZSA9IE1ldGFkYXRhU2NoZW1hLmRhdGVSYW5nZTtcbiAgICAgICAgICBjdWUuaWQgPSBpZDtcbiAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIGN1ZXNba2V5XSA9IGN1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSA9IHtcbiAgICAgICAgY3VlcyxcbiAgICAgICAgZGF0ZVJhbmdlLFxuICAgICAgICBkdXJhdGlvbktub3duXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBMYXRlbmN5Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSAoKSA9PiB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXRlbmN5IHx8IDA7XG4gIH1cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICB9XG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBob2xkQmFjayxcbiAgICAgIHBhcnRIb2xkQmFjayxcbiAgICAgIHRhcmdldGR1cmF0aW9uXG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsaXZlU3luY0R1cmF0aW9uLFxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50LFxuICAgICAgbG93TGF0ZW5jeU1vZGVcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgIGlmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gMCkge1xuICAgICAgdGFyZ2V0TGF0ZW5jeSA9IGxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGxpdmVTeW5jRHVyYXRpb24gOiBsaXZlU3luY0R1cmF0aW9uQ291bnQgKiB0YXJnZXRkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSB0YXJnZXRkdXJhdGlvbjtcbiAgICBjb25zdCBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IDEuMDtcbiAgICByZXR1cm4gdGFyZ2V0TGF0ZW5jeSArIE1hdGgubWluKHRoaXMuc3RhbGxDb3VudCAqIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlLCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSk7XG4gIH1cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBjb25zdCB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCB8fCB0YXJnZXRMYXRlbmN5ID09PSBudWxsIHx8IGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2UgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCBzeW5jUG9zaXRpb24gPSBsaXZlRWRnZSAtIHRhcmdldExhdGVuY3kgLSB0aGlzLmVkZ2VTdGFsbGVkO1xuICAgIGNvbnN0IG1pbiA9IGVkZ2UgLSBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtYXggPSBlZGdlIC0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgfVxuICBnZXQgZHJpZnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZHJpZnQ7XG4gIH1cbiAgZ2V0IGVkZ2VTdGFsbGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBtYXhMZXZlbFVwZGF0ZUFnZSA9ICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICByZXR1cm4gTWF0aC5tYXgobGV2ZWxEZXRhaWxzLmFnZSAtIG1heExldmVsVXBkYXRlQWdlLCAwKTtcbiAgfVxuICBnZXQgZm9yd2FyZEJ1ZmZlckxlbmd0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkUmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQubGVuZ3RoO1xuICAgIHJldHVybiAoYnVmZmVyZWRSYW5nZXMgPyBtZWRpYS5idWZmZXJlZC5lbmQoYnVmZmVyZWRSYW5nZXMgLSAxKSA6IGxldmVsRGV0YWlscy5lZGdlKSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfVxuICAgIGlmICghZGV0YWlscy5saXZlICYmIHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGxldmVsRGV0YWlscztcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgaWYgKChfdGhpcyRsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5Jyk7XG4gICAgfVxuICB9XG4gIHRpbWV1cGRhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7XG5cbiAgICAvLyBBZGFwdCBwbGF5YmFja1JhdGUgdG8gbWVldCB0YXJnZXQgbGF0ZW5jeSBpbiBsb3ctbGF0ZW5jeSBtb2RlXG4gICAgY29uc3Qge1xuICAgICAgbG93TGF0ZW5jeU1vZGUsXG4gICAgICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7XG4gICAgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG4gICAgY29uc3QgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgY29uc3QgaW5MaXZlUmFuZ2UgPSBkaXN0YW5jZUZyb21UYXJnZXQgPCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uO1xuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBpbkxpdmVSYW5nZSAmJiBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKDIsIE1hdGgubWF4KDEuMCwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUpKTtcbiAgICAgIGNvbnN0IHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9XG4gIGVzdGltYXRlTGl2ZUVkZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH1cbiAgY29tcHV0ZUxhdGVuY3koKSB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmNvbnN0IEhkY3BMZXZlbHMgPSBbJ05PTkUnLCAnVFlQRS0wJywgJ1RZUEUtMScsIG51bGxdO1xudmFyIEhsc1NraXAgPSB7XG4gIE5vOiBcIlwiLFxuICBZZXM6IFwiWUVTXCIsXG4gIHYyOiBcInYyXCJcbn07XG5mdW5jdGlvbiBnZXRTa2lwVmFsdWUoZGV0YWlscywgbXNuKSB7XG4gIGNvbnN0IHtcbiAgICBjYW5Ta2lwVW50aWwsXG4gICAgY2FuU2tpcERhdGVSYW5nZXMsXG4gICAgZW5kU05cbiAgfSA9IGRldGFpbHM7XG4gIGNvbnN0IHNuQ2hhbmdlR29hbCA9IG1zbiAhPT0gdW5kZWZpbmVkID8gbXNuIC0gZW5kU04gOiAwO1xuICBpZiAoY2FuU2tpcFVudGlsICYmIHNuQ2hhbmdlR29hbCA8IGNhblNraXBVbnRpbCkge1xuICAgIGlmIChjYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuICByZXR1cm4gSGxzU2tpcC5Obztcbn1cbmNsYXNzIEhsc1VybFBhcmFtZXRlcnMge1xuICBjb25zdHJ1Y3Rvcihtc24sIHBhcnQsIHNraXApIHtcbiAgICB0aGlzLm1zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5za2lwID0gdm9pZCAwO1xuICAgIHRoaXMubXNuID0gbXNuO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5za2lwID0gc2tpcDtcbiAgfVxuICBhZGREaXJlY3RpdmVzKHVyaSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19za2lwJywgdGhpcy5za2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9XG59XG5jbGFzcyBMZXZlbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9hdHRycyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRyYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZWNTZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy51bmtub3duQ29kZWNzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Hcm91cElkcyA9IHZvaWQgMDtcbiAgICB0aGlzLmRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRFcnJvciA9IDA7XG4gICAgdGhpcy5sb2FkZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFsQml0cmF0ZSA9IDA7XG4gICAgdGhpcy50ZXh0R3JvdXBJZHMgPSB2b2lkIDA7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5fdXJsSWQgPSAwO1xuICAgIHRoaXMudXJsID0gW2RhdGEudXJsXTtcbiAgICB0aGlzLl9hdHRycyA9IFtkYXRhLmF0dHJzXTtcbiAgICB0aGlzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGU7XG4gICAgaWYgKGRhdGEuZGV0YWlscykge1xuICAgICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIH1cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBkYXRhLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gZGF0YS52aWRlb0NvZGVjO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IGRhdGEudW5rbm93bkNvZGVjcztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXS5maWx0ZXIoYyA9PiBjKS5qb2luKCcsJykucmVwbGFjZSgvXFwuW14uLF0rL2csICcnKTtcbiAgfVxuICBnZXQgbWF4Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgfVxuICBnZXQgYXR0cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzW3RoaXMuX3VybElkXTtcbiAgfVxuICBnZXQgcGF0aHdheUlkKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydQQVRIV0FZLUlEJ10gfHwgJy4nO1xuICB9XG4gIGdldCB1cmkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsW3RoaXMuX3VybElkXSB8fCAnJztcbiAgfVxuICBnZXQgdXJsSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybElkO1xuICB9XG4gIHNldCB1cmxJZCh2YWx1ZSkge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgJSB0aGlzLnVybC5sZW5ndGg7XG4gICAgaWYgKHRoaXMuX3VybElkICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3VybElkID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBhdWRpb0dyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJGF1ZGlvR3JvdXBJZHM7XG4gICAgcmV0dXJuIChfdGhpcyRhdWRpb0dyb3VwSWRzID0gdGhpcy5hdWRpb0dyb3VwSWRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXVkaW9Hcm91cElkc1t0aGlzLnVybElkXTtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJHRleHRHcm91cElkcztcbiAgICByZXR1cm4gKF90aGlzJHRleHRHcm91cElkcyA9IHRoaXMudGV4dEdyb3VwSWRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGV4dEdyb3VwSWRzW3RoaXMudXJsSWRdO1xuICB9XG4gIGFkZEZhbGxiYWNrKGRhdGEpIHtcbiAgICB0aGlzLnVybC5wdXNoKGRhdGEudXJsKTtcbiAgICB0aGlzLl9hdHRycy5wdXNoKGRhdGEuYXR0cnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gIGNvbnN0IGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgbGV0IGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZnJhZztcbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH1cbiAgICBpZiAoZnJhZy5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGZyYWcuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICB9IGVsc2UgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgY29uc3QgY29udGlndW91cyA9IGZyYWdGcm9tLmNjID09PSBmcmFnVG8uY2M7XG4gICAgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuICAgIGlmIChjb250aWd1b3VzICYmIGZyYWdGcm9tLm1pbkVuZFBUUykge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyAoZnJhZ0Zyb20ubWluRW5kUFRTIC0gZnJhZ0Zyb20uc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUykge1xuICBjb25zdCBwYXJzZWRNZWRpYUR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gIGlmIChwYXJzZWRNZWRpYUR1cmF0aW9uIDw9IDApIHtcbiAgICBsb2dnZXIud2FybignRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvbicsIGZyYWcpO1xuICAgIGVuZFBUUyA9IHN0YXJ0UFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgICBlbmREVFMgPSBzdGFydERUUyArIGZyYWcuZHVyYXRpb247XG4gIH1cbiAgbGV0IG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGxldCBtaW5FbmRQVFMgPSBlbmRQVFM7XG4gIGNvbnN0IGZyYWdTdGFydFB0cyA9IGZyYWcuc3RhcnRQVFM7XG4gIGNvbnN0IGZyYWdFbmRQdHMgPSBmcmFnLmVuZFBUUztcbiAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdTdGFydFB0cykpIHtcbiAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICBjb25zdCBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWdTdGFydFB0cyAtIHN0YXJ0UFRTKTtcbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGZyYWcuZGVsdGFQVFMpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgfVxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICBtaW5FbmRQVFMgPSBNYXRoLm1pbihlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gIH1cbiAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGlmIChmcmFnLnN0YXJ0ICE9PSAwKSB7XG4gICAgZnJhZy5zdGFydCA9IHN0YXJ0UFRTO1xuICB9XG4gIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBmcmFnLnN0YXJ0O1xuICBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5taW5FbmRQVFMgPSBtaW5FbmRQVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICBjb25zdCBzbiA9IGZyYWcuc247IC8vICdpbml0U2VnbWVudCdcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBpO1xuICBjb25zdCBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7XG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpIC0gMV0pO1xuICB9XG5cbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSArIDFdKTtcbiAgfVxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSwgZGV0YWlscy5mcmFnbWVudEhpbnQpO1xuICB9XG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgLy8gVHJhY2sgdGhlIGxhc3QgaW5pdFNlZ21lbnQgcHJvY2Vzc2VkLiBJbml0aWFsaXplIGl0IHRvIHRoZSBsYXN0IG9uZSBvbiB0aGUgdGltZWxpbmUuXG4gIGxldCBjdXJyZW50SW5pdFNlZ21lbnQgPSBudWxsO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG4gICAgaWYgKG9sZEluaXQpIHtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEluaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH1cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnKSA9PiB7XG4gICAgaWYgKG9sZEZyYWcucmVsdXJsKSB7XG4gICAgICAvLyBEbyBub3QgY29tcGFyZSBDQyBpZiB0aGUgb2xkIGZyYWdtZW50IGhhcyBubyB1cmwuIFRoaXMgaXMgYSBsZXZlbC5mcmFnbWVudEhpbnQgdXNlZCBieSBMTC1ITFMgcGFydHMuXG4gICAgICAvLyBJdCBtYXliZSBiZSBvZmYgYnkgMSBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgYW55IHBhcnRzIG9yIGRpc2NvbnRpbnVpdHkgdGFncyB3ZXJlIGFwcGVuZGVkIHRvIHRoZSBlbmRcbiAgICAgIC8vIG9mIHRoZSBwbGF5bGlzdC5cbiAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihvbGRGcmFnLnN0YXJ0UFRTKSAmJiBpc0Zpbml0ZU51bWJlcihvbGRGcmFnLmVuZFBUUykpIHtcbiAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgIG5ld0ZyYWcuc3RhcnREVFMgPSBvbGRGcmFnLnN0YXJ0RFRTO1xuICAgICAgbmV3RnJhZy5tYXhTdGFydFBUUyA9IG9sZEZyYWcubWF4U3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5lbmREVFMgPSBvbGRGcmFnLmVuZERUUztcbiAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICB9XG5cbiAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgfVxuICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld0ZyYWcubG9hZGVyID0gb2xkRnJhZy5sb2FkZXI7XG4gICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgbmV3RnJhZy51cmxJZCA9IG9sZEZyYWcudXJsSWQ7XG4gICAgaWYgKG9sZEZyYWcuaW5pdFNlZ21lbnQpIHtcbiAgICAgIG5ld0ZyYWcuaW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzVG9DaGVjayA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZyYWdtZW50c1RvQ2hlY2suZm9yRWFjaChmcmFnID0+IHtcbiAgICAgIHZhciBfY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgaWYgKCFmcmFnLmluaXRTZWdtZW50IHx8IGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSAoKF9jdXJyZW50SW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudEluaXRTZWdtZW50LnJlbHVybCkpIHtcbiAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RGV0YWlscy5mcmFnbWVudHMuc29tZShmcmFnID0+ICFmcmFnKTtcbiAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCcpO1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpLS07KSB7XG4gICAgICAgIG5ld0RldGFpbHMuZnJhZ21lbnRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0U04gPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zbjtcbiAgICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5jYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgbmV3RGV0YWlscy5kYXRlUmFuZ2VzID0gbWVyZ2VEYXRlUmFuZ2VzKG9sZERldGFpbHMuZGF0ZVJhbmdlcywgbmV3RGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgbG9nZ2VyLndhcm4oJ2Rpc2NvbnRpbnVpdHkgc2xpZGluZyBmcm9tIHBsYXlsaXN0LCB0YWtlIGRyaWZ0IGludG8gYWNjb3VudCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdGcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgfVxuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICB9XG5cbiAgLy8gTWVyZ2UgcGFydHNcbiAgbWFwUGFydEludGVyc2VjdGlvbihvbGREZXRhaWxzLnBhcnRMaXN0LCBuZXdEZXRhaWxzLnBhcnRMaXN0LCAob2xkUGFydCwgbmV3UGFydCkgPT4ge1xuICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICB9KTtcblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnQ7XG4gIGNvbnN0IGFkdmFuY2VkRGF0ZVRpbWUgPSBuZXdEZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWU7XG4gIGlmIChuZXdEZXRhaWxzLmFkdmFuY2VkICYmIGFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICBjb25zdCBlZGdlID0gbmV3RGV0YWlscy5lZGdlO1xuICAgIGlmICghbmV3RGV0YWlscy5kcmlmdFN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IGVkZ2U7XG4gICAgfVxuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gZWRnZTtcbiAgfSBlbHNlIHtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kVGltZSA9IG9sZERldGFpbHMuZHJpZnRFbmRUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBvbGREZXRhaWxzLmRyaWZ0RW5kO1xuICAgIG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IG9sZERldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VEYXRlUmFuZ2VzKG9sZERhdGVSYW5nZXMsIGRlbHRhRGF0ZVJhbmdlcywgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICBjb25zdCBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuZm9yRWFjaChpZCA9PiB7XG4gICAgICBkZWxldGUgZGF0ZVJhbmdlc1tpZF07XG4gICAgfSk7XG4gIH1cbiAgT2JqZWN0LmtleXMoZGVsdGFEYXRlUmFuZ2VzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0ciwgZGF0ZVJhbmdlc1tpZF0pO1xuICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCkge1xuICAgICAgZGF0ZVJhbmdlc1tpZF0gPSBkYXRlUmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKGBJZ25vcmluZyBpbnZhbGlkIFBsYXlsaXN0IERlbHRhIFVwZGF0ZSBEQVRFUkFOR0UgdGFnOiBcIiR7SlNPTi5zdHJpbmdpZnkoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyKX1cImApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRlUmFuZ2VzO1xufVxuZnVuY3Rpb24gbWFwUGFydEludGVyc2VjdGlvbihvbGRQYXJ0cywgbmV3UGFydHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIGlmIChvbGRQYXJ0cyAmJiBuZXdQYXJ0cykge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9sZFBhcnRzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgY29uc3Qgb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgY29uc3QgbmV3UGFydCA9IG5ld1BhcnRzW2kgKyBkZWx0YV07XG4gICAgICBpZiAob2xkUGFydCAmJiBuZXdQYXJ0ICYmIG9sZFBhcnQuaW5kZXggPT09IG5ld1BhcnQuaW5kZXggJiYgb2xkUGFydC5mcmFnbWVudC5zbiA9PT0gbmV3UGFydC5mcmFnbWVudC5zbikge1xuICAgICAgICBpbnRlcnNlY3Rpb25GbihvbGRQYXJ0LCBuZXdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhLS07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICBjb25zdCBza2lwcGVkU2VnbWVudHMgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cztcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3Qgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgbGV0IG5ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICBpZiAoc2tpcHBlZFNlZ21lbnRzICYmICFuZXdGcmFnICYmIGkgPCBza2lwcGVkU2VnbWVudHMpIHtcbiAgICAgIC8vIEZpbGwgaW4gc2tpcHBlZCBzZWdtZW50cyBpbiBkZWx0YSBwbGF5bGlzdFxuICAgICAgbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gb2xkRnJhZztcbiAgICB9XG4gICAgaWYgKG9sZEZyYWcgJiYgbmV3RnJhZykge1xuICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgY29uc3QgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gKyBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmIChkZWx0YSA8IDAgfHwgZGVsdGEgPj0gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQpO1xufVxuZnVuY3Rpb24gYWRkU2xpZGluZyhkZXRhaWxzLCBzdGFydCkge1xuICBpZiAoc3RhcnQpIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKGxldCBpID0gZGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWdtZW50c1tpXS5zdGFydCArPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICBkZXRhaWxzLmZyYWdtZW50SGludC5zdGFydCArPSBzdGFydDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWxvYWRJbnRlcnZhbChuZXdEZXRhaWxzLCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9IEluZmluaXR5KSB7XG4gIGxldCByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICBpZiAobmV3RGV0YWlscy51cGRhdGVkKSB7XG4gICAgLy8gVXNlIGxhc3Qgc2VnbWVudCBkdXJhdGlvbiB3aGVuIHNob3J0ZXIgdGhhbiB0YXJnZXQgZHVyYXRpb24gYW5kIG5lYXIgbGl2ZSBlZGdlXG4gICAgY29uc3QgZnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPSA0O1xuICAgIGlmIChmcmFnbWVudHMubGVuZ3RoICYmIHJlbG9hZEludGVydmFsICogbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPiBkaXN0YW5jZVRvTGl2ZUVkZ2VNcykge1xuICAgICAgY29uc3QgbGFzdFNlZ21lbnREdXJhdGlvbiA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZHVyYXRpb24gKiAxMDAwO1xuICAgICAgaWYgKGxhc3RTZWdtZW50RHVyYXRpb24gPCByZWxvYWRJbnRlcnZhbCkge1xuICAgICAgICByZWxvYWRJbnRlcnZhbCA9IGxhc3RTZWdtZW50RHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGVzdGltYXRlID0gJ21pc3MgaGFsZiBhdmVyYWdlJztcbiAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgcmVsb2FkSW50ZXJ2YWwgLz0gMjtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbCwgc24sIGZyYWdDdXJyZW50KSB7XG4gIGlmICghKGxldmVsICE9IG51bGwgJiYgbGV2ZWwuZGV0YWlscykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICBsZXQgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW3NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICBpZiAoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGlmIChzbiA8IGxldmVsRGV0YWlscy5zdGFydFNOICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnQ3VycmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSB7XG4gIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgaWYgKCEobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5kZXRhaWxzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBmaW5kUGFydCgoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMucGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gZmluZFBhcnQocGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgaWYgKHBhcnRMaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IHBhcnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaWYgKHBhcnQuaW5kZXggPT09IHBhcnRJbmRleCAmJiBwYXJ0LmZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVGltZW91dEVycm9yKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5Q29uZmlnKGxvYWRQb2xpY3ksIGVycm9yKSB7XG4gIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yKTtcbiAgcmV0dXJuIGxvYWRQb2xpY3kuZGVmYXVsdFtgJHtpc1RpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InfVJldHJ5YF07XG59XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KSB7XG4gIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSBkZWxheVxuICBjb25zdCBiYWNrb2ZmRmFjdG9yID0gcmV0cnlDb25maWcuYmFja29mZiA9PT0gJ2xpbmVhcicgPyAxIDogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gIHJldHVybiBNYXRoLm1pbihiYWNrb2ZmRmFjdG9yICogcmV0cnlDb25maWcucmV0cnlEZWxheU1zLCByZXRyeUNvbmZpZy5tYXhSZXRyeURlbGF5TXMpO1xufVxuZnVuY3Rpb24gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhsb2RlckNvbmZpZykge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGxvZGVyQ29uZmlnKSwge1xuICAgIGVycm9yUmV0cnk6IG51bGwsXG4gICAgdGltZW91dFJldHJ5OiBudWxsXG4gIH0pO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dCwgaHR0cFN0YXR1cykge1xuICByZXR1cm4gISFyZXRyeUNvbmZpZyAmJiByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgJiYgKHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWlzVGltZW91dCk7XG59XG5mdW5jdGlvbiByZXRyeUZvckh0dHBTdGF0dXMoaHR0cFN0YXR1cykge1xuICAvLyBEbyBub3QgcmV0cnkgb24gc3RhdHVzIDR4eCwgc3RhdHVzIDAgKENPUlMgZXJyb3IpLCBvciB1bmRlZmluZWQgKGRlY3J5cHQvZ2FwL3BhcnNlIGVycm9yKVxuICByZXR1cm4gaHR0cFN0YXR1cyA9PT0gMCAmJiBuYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSB8fCAhIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSk7XG59XG5cbmNvbnN0IEJpbmFyeVNlYXJjaCA9IHtcbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0gY29tcGFyaXNvbkZuXG4gICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICogICAgICBTaG91bGQgcmV0dXJuOlxuICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBvYmplY3QgaWYgZm91bmQsIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gKGxpc3QsIGNvbXBhcmlzb25Gbikge1xuICAgIGxldCBtaW5JbmRleCA9IDA7XG4gICAgbGV0IG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgIGxldCBjdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG4gICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIFBEVFZhbHVlIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoUERUVmFsdWUgPT09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhaXNGaW5pdGVOdW1iZXIoUERUVmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBpZiBsZXNzIHRoYW4gc3RhcnRcbiAgY29uc3Qgc3RhcnRQRFQgPSBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPCAoc3RhcnRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbmRQRFQgPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgaWYgKFBEVFZhbHVlID49IChlbmRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuICBmb3IgKGxldCBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBTTiBvZiB0aGUgcHJldmlvdXMgZnJhZ21lbnQ7IG9yIGJhc2VkIG9uIHRoZSBuZWVkcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gKiBAcGFyYW0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgYSBtYXRjaGluZyBmcmFnbWVudCBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQgPSAwLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMCkge1xuICBsZXQgZnJhZ05leHQgPSBudWxsO1xuICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gfHwgbnVsbDtcbiAgfSBlbHNlIGlmIChidWZmZXJFbmQgPT09IDAgJiYgZnJhZ21lbnRzWzBdLnN0YXJ0ID09PSAwKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbMF07XG4gIH1cbiAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICBpZiAoZnJhZ05leHQgJiYgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PSAwKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIC8vIFdlIG1pZ2h0IGJlIHNlZWtpbmcgcGFzdCB0aGUgdG9sZXJhbmNlIHNvIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgY29uc3QgZm91bmRGcmFnbWVudCA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcbiAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gIH1cbiAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQgPSAwLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMCwgY2FuZGlkYXRlKSB7XG4gIC8vIGVhZ2VybHkgYWNjZXB0IGFuIGFjY3VyYXRlIG1hdGNoIChubyB0b2xlcmFuY2UpXG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgPD0gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiA+IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0gcGR0QnVmZmVyRW5kIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QocGR0QnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUpIHtcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKSAqIDEwMDA7XG5cbiAgLy8gZW5kUHJvZ3JhbURhdGVUaW1lIGNhbiBiZSBudWxsLCBkZWZhdWx0IHRvIHplcm9cbiAgY29uc3QgZW5kUHJvZ3JhbURhdGVUaW1lID0gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSB8fCAwO1xuICByZXR1cm4gZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGNhbmRpZGF0ZSA9PiB7XG4gICAgaWYgKGNhbmRpZGF0ZS5jYyA8IGNjKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IGNjKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IFJFTkRJVElPTl9QRU5BTFRZX0RVUkFUSU9OX01TID0gMzAwMDAwO1xudmFyIE5ldHdvcmtFcnJvckFjdGlvbiA9IHtcbiAgRG9Ob3RoaW5nOiAwLFxuICBTZW5kRW5kQ2FsbGJhY2s6IDEsXG4gIFNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6IDIsXG4gIFJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5OiAzLFxuICBJbnNlcnREaXNjb250aW51aXR5OiA0LFxuICBSZXRyeVJlcXVlc3Q6IDVcbn07XG52YXIgRXJyb3JBY3Rpb25GbGFncyA9IHtcbiAgTm9uZTogMCxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q6IDEsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQOiAyLFxuICBTd2l0Y2hUb1NEUjogNFxufTsgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2VcbmNsYXNzIEVycm9yQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgW2luZm9dOmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgW3dhcm5pbmddOmApO1xuICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIGBbZXJyb3JdOmApO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3JPdXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cbiAgc3RvcExvYWQoKSB7fVxuICBnZXRWYXJpYW50TGV2ZWxJbmRleChmcmFnKSB7XG4gICAgcmV0dXJuIChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZnJhZy5sZXZlbCA6IHRoaXMuaGxzLmxvYWRMZXZlbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRmcmFnLCBfZGF0YSRsZXZlbDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBjb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHNlZ21lbnQgZXJyb3JzIG1hcmtlZCBhcyBnYXBcbiAgICAgICAgaWYgKChfZGF0YSRmcmFnID0gZGF0YS5mcmFnKSAhPSBudWxsICYmIF9kYXRhJGZyYWcuZ2FwKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggbGV2ZWwgaWYgcG9zc2libGUsIG90aGVyd2lzZSBhbGxvdyByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2RhdGEkY29udGV4dCwgX2RhdGEkY29udGV4dCRsZXZlbERlO1xuICAgICAgICAgIC8vIE9ubHkgcmV0cnkgd2hlbiBlbXB0eSBhbmQgbGl2ZVxuICAgICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEubGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUiAmJiAhISgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCAmJiAoX2RhdGEkY29udGV4dCRsZXZlbERlID0gX2RhdGEkY29udGV4dC5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgX2RhdGEkY29udGV4dCRsZXZlbERlLmxpdmUpKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVzY2FsYXRlIHRvIGZhdGFsIGlmIG5vdCByZXRyeWluZyBvciBzd2l0Y2hpbmdcbiAgICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQubGV2ZWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBjb250ZXh0LmxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgaWYgKGxldmVsICYmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgY29udGV4dC5ncm91cElkID09PSBsZXZlbC5hdWRpb0dyb3VwSWQgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGNvbnRleHQuZ3JvdXBJZCA9PT0gbGV2ZWwudGV4dEdyb3VwSWQpKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIFBhdGh3YXkgc3dpdGNoIG9yIFJlZHVuZGFudCBmYWlsb3ZlciBpZiBwb3NzaWJsZSBmb3IgZmFzdGVzdCByZWNvdmVyeVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFsbG93IHBsYXlsaXN0IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgaGxzLmxvYWRMZXZlbCk7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmFjdGlvbiA9IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5mbGFncyA9IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW2hscy5sb2FkTGV2ZWxdO1xuICAgICAgICAgIGNvbnN0IHJlc3RyaWN0ZWRIZGNwTGV2ZWwgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgICBpZiAocmVzdHJpY3RlZEhkY3BMZXZlbCkge1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AsXG4gICAgICAgICAgICAgIGhkY3BMZXZlbDogcmVzdHJpY3RlZEhkY3BMZXZlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCAoX2RhdGEkbGV2ZWwgPSBkYXRhLmxldmVsKSAhPSBudWxsID8gX2RhdGEkbGV2ZWwgOiBobHMubG9hZExldmVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SKSB7XG4gICAgICBjb25zdCBsZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgICAgLy8gRG8gbm90IHJldHJ5IGxldmVsLiBFc2NhbGF0ZSB0byBmYXRhbCBpZiBzd2l0Y2hpbmcgbGV2ZWxzIGZhaWxzLlxuICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICB2YXIgX2RhdGEkcmVzcG9uc2U7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhobHMuY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeSwgZGF0YSk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMucGxheWxpc3RFcnJvcisrO1xuICAgIGNvbnN0IGh0dHBTdGF0dXMgPSAoX2RhdGEkcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkcmVzcG9uc2UuY29kZTtcbiAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgaHR0cFN0YXR1cyk7XG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICByZXRyeUNvdW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IHJldHJ5Q291bnQ7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgfVxuICBnZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gU2hhcmUgZnJhZ21lbnQgZXJyb3IgY291bnQgYWNjcm9zcyBtZWRpYSBvcHRpb25zIChtYWluLCBhdWRpbywgc3VicylcbiAgICAvLyBUaGlzIGFsbG93cyBmb3IgbGV2ZWwgYmFzZWQgcmVuZGl0aW9uIHN3aXRjaGluZyB3aGVuIG1lZGlhIG9wdGlvbiBhc3NldHMgZmFpbFxuICAgIGNvbnN0IHZhcmlhbnRMZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1t2YXJpYW50TGV2ZWxJbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0xvYWRQb2xpY3ksXG4gICAgICBrZXlMb2FkUG9saWN5XG4gICAgfSA9IGhscy5jb25maWc7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhkYXRhLmRldGFpbHMuc3RhcnRzV2l0aCgna2V5JykgPyBrZXlMb2FkUG9saWN5IDogZnJhZ0xvYWRQb2xpY3ksIGRhdGEpO1xuICAgIGNvbnN0IGZyYWdtZW50RXJyb3JzID0gaGxzLmxldmVscy5yZWR1Y2UoKGFjYywgbGV2ZWwpID0+IGFjYyArIGxldmVsLmZyYWdtZW50RXJyb3IsIDApO1xuICAgIC8vIFN3aXRjaCBsZXZlbHMgd2hlbiBvdXQgb2YgcmV0cmllZCBvciBsZXZlbCBpbmRleCBvdXQgb2YgYm91bmRzXG4gICAgaWYgKGxldmVsKSB7XG4gICAgICB2YXIgX2RhdGEkcmVzcG9uc2UyO1xuICAgICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh0dHBTdGF0dXMgPSAoX2RhdGEkcmVzcG9uc2UyID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHJlc3BvbnNlMi5jb2RlO1xuICAgICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgZnJhZ21lbnRFcnJvcnMsIGlzVGltZW91dEVycm9yKGRhdGEpLCBodHRwU3RhdHVzKTtcbiAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICAgIHJldHJ5Q291bnQ6IGZyYWdtZW50RXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlYWNoIG1heCByZXRyeSBjb3VudCwgb3IgTWlzc2luZyBsZXZlbCByZWZlcmVuY2VcbiAgICAvLyBTd2l0Y2ggdG8gdmFsaWQgaW5kZXhcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgdmFyaWFudExldmVsSW5kZXgpO1xuICAgIC8vIEFkZCByZXRyeSBkZXRhaWxzIHRvIGFsbG93IHNraXBwaW5nIG9mIEZSQUdfUEFSU0lOR19FUlJPUlxuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSBmcmFnbWVudEVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG4gIGdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAobGV2ZWxJbmRleCA9PT0gbnVsbCB8fCBsZXZlbEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldmVsSW5kZXggPSBobHMubG9hZExldmVsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgICAgaWYgKGhscy5hdXRvTGV2ZWxFbmFibGVkKSB7XG4gICAgICAgIHZhciBfZGF0YSRmcmFnMiwgX2RhdGEkY29udGV4dDI7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgbmV4dCBsZXZlbCB0byByZXRyeVxuICAgICAgICBsZXQgbmV4dExldmVsID0gLTE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgbG9hZExldmVsLFxuICAgICAgICAgIG1pbkF1dG9MZXZlbCxcbiAgICAgICAgICBtYXhBdXRvTGV2ZWxcbiAgICAgICAgfSA9IGhscztcbiAgICAgICAgY29uc3QgZnJhZ0Vycm9yVHlwZSA9IChfZGF0YSRmcmFnMiA9IGRhdGEuZnJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGZyYWcyLnR5cGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlOiBwbGF5bGlzdEVycm9yVHlwZSxcbiAgICAgICAgICBncm91cElkOiBwbGF5bGlzdEVycm9yR3JvdXBJZFxuICAgICAgICB9ID0gKF9kYXRhJGNvbnRleHQyID0gZGF0YS5jb250ZXh0KSAhPSBudWxsID8gX2RhdGEkY29udGV4dDIgOiB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxldmVscy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSAoaSArIGxvYWRMZXZlbCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgIT09IGxvYWRMZXZlbCAmJiBjYW5kaWRhdGUgPj0gbWluQXV0b0xldmVsICYmIGNhbmRpZGF0ZSA8PSBtYXhBdXRvTGV2ZWwgJiYgbGV2ZWxzW2NhbmRpZGF0ZV0ubG9hZEVycm9yID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbENhbmRpZGF0ZSA9IGxldmVsc1tjYW5kaWRhdGVdO1xuICAgICAgICAgICAgLy8gU2tpcCBsZXZlbCBzd2l0Y2ggaWYgR0FQIHRhZyBpcyBmb3VuZCBpbiBuZXh0IGxldmVsIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCAmJiBkYXRhLmZyYWcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxzW2NhbmRpZGF0ZV0uZGV0YWlscztcbiAgICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdDYW5kaWRhdGUgPSBmaW5kRnJhZ21lbnRCeVBUUyhkYXRhLmZyYWcsIGxldmVsRGV0YWlscy5mcmFnbWVudHMsIGRhdGEuZnJhZy5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdDYW5kaWRhdGUgIT0gbnVsbCAmJiBmcmFnQ2FuZGlkYXRlLmdhcCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIHBsYXlsaXN0RXJyb3JHcm91cElkID09PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0dyb3VwSWQgfHwgcGxheWxpc3RFcnJvclR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgcGxheWxpc3RFcnJvckdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBhdWRpby9zdWJzIHBsYXlsaXN0IGVycm9ycyBmaW5kIGFub3RoZXIgZ3JvdXAgSUQgb3IgZmFsbHRocm91Z2ggdG8gcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgbGV2ZWwuYXVkaW9Hcm91cElkID09PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0dyb3VwSWQgfHwgZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUgJiYgbGV2ZWwudGV4dEdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBhdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0TGV2ZWwgPiAtMSAmJiBobHMubG9hZExldmVsICE9PSBuZXh0TGV2ZWwpIHtcbiAgICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgICAgbmV4dEF1dG9MZXZlbDogbmV4dExldmVsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsZXZlbHMgdG8gc3dpdGNoIC8gTWFudWFsIGxldmVsIHNlbGVjdGlvbiAvIExldmVsIG5vdCBmb3VuZFxuICAgIC8vIFJlc29sdmUgd2l0aCBQYXRod2F5IHN3aXRjaCwgUmVkdW5kYW50IGZhaWwtb3Zlciwgb3Igc3RheSBvbiBsb3dlc3QgTGV2ZWxcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0XG4gICAgfTtcbiAgfVxuICBvbkVycm9yT3V0KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgIHN3aXRjaCAoKF9kYXRhJGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGVycm9yQWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6XG4gICAgICAgIHRoaXMuc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLmhscy5zdG9wTG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBzZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb247XG4gICAgaWYgKCFlcnJvckFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmbGFncyxcbiAgICAgIGhkY3BMZXZlbCxcbiAgICAgIG5leHRBdXRvTGV2ZWxcbiAgICB9ID0gZXJyb3JBY3Rpb247XG4gICAgc3dpdGNoIChmbGFncykge1xuICAgICAgY2FzZSBFcnJvckFjdGlvbkZsYWdzLk5vbmU6XG4gICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSGFuZGxlIFJlZHVuZGFudCBMZXZlbHMgaGVyZS4gUGF0aHdheSBzd2l0Y2hpbmcgaXMgaGFuZGxlZCBieSBjb250ZW50LXN0ZWVyaW5nLWNvbnRyb2xsZXJcbiAgICAgICAgICBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRoaXMucmVkdW5kYW50RmFpbG92ZXIoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQOlxuICAgICAgICBpZiAoaGRjcExldmVsKSB7XG4gICAgICAgICAgaGxzLm1heEhkY3BMZXZlbCA9IEhkY3BMZXZlbHNbSGRjcExldmVscy5pbmRleE9mKGhkY3BMZXZlbCkgLSAxXTtcbiAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKGBSZXN0cmljdGluZyBwbGF5YmFjayB0byBIRENQLUxFVkVMIG9mIFwiJHtobHMubWF4SGRjcExldmVsfVwiIG9yIGxvd2VyYCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBJZiBub3QgcmVzb2x2ZWQgYnkgcHJldmlvdXMgYWN0aW9ucyB0cnkgdG8gc3dpdGNoIHRvIG5leHQgbGV2ZWxcbiAgICBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgIH1cbiAgfVxuICBzd2l0Y2hMZXZlbChkYXRhLCBsZXZlbEluZGV4KSB7XG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhLmVycm9yQWN0aW9uKSB7XG4gICAgICB0aGlzLndhcm4oYHN3aXRjaGluZyB0byBsZXZlbCAke2xldmVsSW5kZXh9IGFmdGVyICR7ZGF0YS5kZXRhaWxzfWApO1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgICBkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIC8vIFN0cmVhbSBjb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGlzIGJ1dCB3b24ndCBzd2l0Y2ggb24gZmFsc2Ugc3RhcnRcbiAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgIH1cbiAgfVxuICByZWR1bmRhbnRGYWlsb3ZlcihkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgcGVuYWxpemVkUmVuZGl0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEubGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBjb25zdCByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuICAgIGNvbnN0IGVycm9yVXJsSWQgPSBkYXRhLmZyYWcgPyBkYXRhLmZyYWcudXJsSWQgOiBsZXZlbC51cmxJZDtcbiAgICBpZiAobGV2ZWwudXJsSWQgPT09IGVycm9yVXJsSWQgJiYgKCFkYXRhLmZyYWcgfHwgbGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMucGVuYWxpemVSZW5kaXRpb24obGV2ZWwsIGRhdGEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlZHVuZGFudExldmVsczsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdVcmxJZCA9IChlcnJvclVybElkICsgaSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICBjb25zdCBwZW5hbGl6ZWRSZW5kaXRpb24gPSBwZW5hbGl6ZWRSZW5kaXRpb25zW25ld1VybElkXTtcbiAgICAgIC8vIENoZWNrIGlmIHJlbmRpdGlvbiBpcyBwZW5hbGl6ZWQgYW5kIHNraXAgaWYgaXQgaXMgYSBiYWQgZml0IGZvciBmYWlsb3ZlclxuICAgICAgaWYgKCFwZW5hbGl6ZWRSZW5kaXRpb24gfHwgY2hlY2tFeHBpcmVkKHBlbmFsaXplZFJlbmRpdGlvbiwgZGF0YSwgcGVuYWxpemVkUmVuZGl0aW9uc1tlcnJvclVybElkXSkpIHtcbiAgICAgICAgLy8gZGVsZXRlIHBlbmFsaXplZFJlbmRpdGlvbnNbbmV3VXJsSWRdO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHVybCBpZCBvZiBhbGwgbGV2ZWxzIHNvIHRoYXQgd2Ugc3RheSBvbiB0aGUgc2FtZSBzZXQgb2YgdmFyaWFudHMgd2hlbiBsZXZlbCBzd2l0Y2hpbmdcbiAgICAgICAgdGhpcy53YXJuKGBTd2l0Y2hpbmcgdG8gUmVkdW5kYW50IFN0cmVhbSAke25ld1VybElkICsgMX0vJHtyZWR1bmRhbnRMZXZlbHN9OiBcIiR7bGV2ZWwudXJsW25ld1VybElkXX1cIiBhZnRlciAke2RhdGEuZGV0YWlsc31gKTtcbiAgICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgICAgaGxzLmxldmVscy5mb3JFYWNoKGx2ID0+IHtcbiAgICAgICAgICBsdi51cmxJZCA9IG5ld1VybElkO1xuICAgICAgICB9KTtcbiAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBlbmFsaXplUmVuZGl0aW9uKGxldmVsLCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGVuYWxpemVkUmVuZGl0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBlbmFsaXplZFJlbmRpdGlvbiA9IHBlbmFsaXplZFJlbmRpdGlvbnNbbGV2ZWwudXJsSWRdIHx8IHtcbiAgICAgIGxhc3RFcnJvclBlcmZNczogMCxcbiAgICAgIGVycm9yczogW10sXG4gICAgICBkZXRhaWxzOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHBlbmFsaXplZFJlbmRpdGlvbi5sYXN0RXJyb3JQZXJmTXMgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBwZW5hbGl6ZWRSZW5kaXRpb24uZXJyb3JzLnB1c2goZGF0YSk7XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uLmRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIHBlbmFsaXplZFJlbmRpdGlvbnNbbGV2ZWwudXJsSWRdID0gcGVuYWxpemVkUmVuZGl0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0V4cGlyZWQocGVuYWxpemVkUmVuZGl0aW9uLCBkYXRhLCBjdXJyZW50UGVuYWx0eVN0YXRlKSB7XG4gIC8vIEV4cGlyZSBwZW5hbHR5IGZvciBzd2l0Y2hpbmcgYmFjayB0byByZW5kaXRpb24gYWZ0ZXIgUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVNcbiAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gcGVuYWxpemVkUmVuZGl0aW9uLmxhc3RFcnJvclBlcmZNcyA+IFJFTkRJVElPTl9QRU5BTFRZX0RVUkFUSU9OX01TKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gRXhwaXJlIHBlbmFsdHkgb24gR0FQIHRhZyBlcnJvciBpZiByZW5kaXRpb24gaGFzIG5vIEdBUCBhdCBwb3NpdGlvbiAoZG9lcyBub3QgY292ZXIgbWVkaWEgdHJhY2tzKVxuICBjb25zdCBsYXN0RXJyb3JEZXRhaWxzID0gcGVuYWxpemVkUmVuZGl0aW9uLmRldGFpbHM7XG4gIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCAmJiBsYXN0RXJyb3JEZXRhaWxzICYmIGRhdGEuZnJhZykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZGF0YS5mcmFnLnN0YXJ0O1xuICAgIGNvbnN0IGNhbmRpZGF0ZUZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBsYXN0RXJyb3JEZXRhaWxzLmZyYWdtZW50cywgcG9zaXRpb24pO1xuICAgIGlmIChjYW5kaWRhdGVGcmFnICYmICFjYW5kaWRhdGVGcmFnLmdhcCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIC8vIEV4cGlyZSBwZW5hbHR5IGlmIHRoZXJlIGFyZSBtb3JlIGVycm9ycyBpbiBjdXJyZW50TGV2ZWwgdGhhbiBpbiBwZW5hbGl6ZWRSZW5kaXRpb25cbiAgaWYgKGN1cnJlbnRQZW5hbHR5U3RhdGUgJiYgcGVuYWxpemVkUmVuZGl0aW9uLmVycm9ycy5sZW5ndGggPCBjdXJyZW50UGVuYWx0eVN0YXRlLmVycm9ycy5sZW5ndGgpIHtcbiAgICBjb25zdCBsYXN0Q2FuZGlkYXRlRXJyb3IgPSBwZW5hbGl6ZWRSZW5kaXRpb24uZXJyb3JzW3BlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RFcnJvckRldGFpbHMgJiYgbGFzdENhbmRpZGF0ZUVycm9yLmZyYWcgJiYgZGF0YS5mcmFnICYmIE1hdGguYWJzKGxhc3RDYW5kaWRhdGVFcnJvci5mcmFnLnN0YXJ0IC0gZGF0YS5mcmFnLnN0YXJ0KSA+IGxhc3RFcnJvckRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBsb2dQcmVmaXgpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gbnVsbDtcbiAgfVxuICBjbGVhclRpbWVyKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gLTE7XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzKSB7XG4gICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICBsZXQgdXJpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgZm9yIFJlbmRpdGlvbiBSZXBvcnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgdXJpID0gYXR0ci5VUkkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGV4YWN0IG1hdGNoLiBPdGhlcndpc2UsIHRoZSBsYXN0IHBhcnRpYWwgbWF0Y2gsIGlmIGFueSwgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIChQbGF5bGlzdCBVUkkgaW5jbHVkZXMgYSBxdWVyeSBzdHJpbmcgdGhhdCB0aGUgUmVuZGl0aW9uIFJlcG9ydCBkb2VzIG5vdClcbiAgICAgICAgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpLnN1YnN0cmluZygwLCB1cmkubGVuZ3RoKSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHJlbmRpdGlvblJlcG9ydHNbZm91bmRJbmRleF07XG4gICAgICAgIGNvbnN0IG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pIHx8IChwcmV2aW91cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXMubGFzdFBhcnRTbik7XG4gICAgICAgIGxldCBwYXJ0ID0gcGFyc2VJbnQoYXR0clsnTEFTVC1QQVJUJ10pIHx8IChwcmV2aW91cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXMubGFzdFBhcnRJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50R29hbCA9IE1hdGgubWluKHByZXZpb3VzLmFnZSAtIHByZXZpb3VzLnBhcnRUYXJnZXQsIHByZXZpb3VzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgcGFydCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0ID49IDAgPyBwYXJ0IDogdW5kZWZpbmVkLCBIbHNTa2lwLk5vKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgLy8gTG9hZGluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJjbGFzc2VzXG4gIH1cblxuICBzaG91bGRMb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmICEhcGxheWxpc3QgJiYgISFwbGF5bGlzdC51cmwgJiYgKCFwbGF5bGlzdC5kZXRhaWxzIHx8IHBsYXlsaXN0LmRldGFpbHMubGl2ZSk7XG4gIH1cbiAgc2hvdWxkUmVsb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lciA9PT0gLTEgJiYgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSAmJiB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdCk7XG4gIH1cbiAgcGxheWxpc3RMb2FkZWQoaW5kZXgsIGRhdGEsIHByZXZpb3VzRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0gPSBkYXRhO1xuXG4gICAgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gTWF0aC5tYXgoMCwgbm93IC0gc3RhdHMubG9hZGluZy5maXJzdCkgOiAwO1xuICAgIGRldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IERhdGUubm93KCkgLSBlbGFwc2VkO1xuXG4gICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgcHJldmlvdXNEZXRhaWxzICE9IG51bGwgJiYgcHJldmlvdXNEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2coYGxpdmUgcGxheWxpc3QgJHtpbmRleH0gJHtkZXRhaWxzLmFkdmFuY2VkID8gJ1JFRlJFU0hFRCAnICsgZGV0YWlscy5sYXN0UGFydFNuICsgJy0nICsgZGV0YWlscy5sYXN0UGFydEluZGV4IDogJ01JU1NFRCd9YCk7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYW5Mb2FkIHx8ICFkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICAgIGxldCBtc24gPSB1bmRlZmluZWQ7XG4gICAgICBsZXQgcGFydCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMuZW5kU04gJiYgZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgY29uc3QgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgIGNvbnN0IGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgY29uc3QgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCB3ZSdsbCBza2lwIHBhcnQgcmVxdWVzdHMgb25jZSB0aGUgbGFzdCBwYXJ0IGluZGV4IGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICBjb25zdCBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgY29uc3QgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBjdXJyZW50R29hbCA9IE1hdGgubWluKGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEuNSk7XG4gICAgICAgIGlmIChjdXJyZW50R29hbCA+IDApIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGF0dGVtcHRlZCB0byBnZXQgdGhlIG5leHQgb3IgbGF0ZXN0IHBsYXlsaXN0IHVwZGF0ZSwgYnV0IGN1cnJlbnRHb2FsIGluY3JlYXNlZCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZWl0aGVyIGNhbid0IGNhdGNodXAsIG9yIHRoZSBcImFnZVwiIGhlYWRlciBjYW5ub3QgYmUgdHJ1c3RlZC5cbiAgICAgICAgICAgIHRoaXMud2FybihgQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogJHtwcmV2aW91c0RldGFpbHMudHVuZUluR29hbH0gdG86ICR7Y3VycmVudEdvYWx9IHdpdGggcGxheWxpc3QgYWdlOiAke2RldGFpbHMuYWdlfWApO1xuICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IE1hdGguZmxvb3IoY3VycmVudEdvYWwgLyBkZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG1zbiArPSBzZWdtZW50cztcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBNYXRoLnJvdW5kKGN1cnJlbnRHb2FsICUgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAvIGRldGFpbHMucGFydFRhcmdldCk7XG4gICAgICAgICAgICAgIHBhcnQgKz0gcGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhgQ0ROIFR1bmUtaW4gYWdlOiAke2RldGFpbHMuYWdlSGVhZGVyfXMgbGFzdCBhZHZhbmNlZCAke2xhc3RBZHZhbmNlZC50b0ZpeGVkKDIpfXMgZ29hbDogJHtjdXJyZW50R29hbH0gc2tpcCBzbiAke3NlZ21lbnRzfSB0byBwYXJ0ICR7cGFydH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID0gY3VycmVudEdvYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhbGFzdFBhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIC0gYnVmZmVySW5mby5sZW4gOiAwO1xuICAgICAgY29uc3QgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSAoZGV0YWlscy5lZGdlIC0gcG9zaXRpb24pICogMTAwMDtcbiAgICAgIGNvbnN0IHJlbG9hZEludGVydmFsID0gY29tcHV0ZVJlbG9hZEludGVydmFsKGRldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKTtcbiAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgbm93ID4gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgKyByZWxvYWRJbnRlcnZhbCAtIChkZXRhaWxzLnBhcnRUYXJnZXQgKiAxMDAwIHx8IDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xIHx8IHRoaXMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsIDwgbm93KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IG5vdztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93IDw9IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICs9IHJlbG9hZEludGVydmFsO1xuICAgICAgfVxuICAgICAgbGV0IGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IHRoaXMucmVxdWVzdFNjaGVkdWxlZCAtIG5vdztcbiAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IE1hdGgubWF4KDAsIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSk7XG4gICAgICB0aGlzLmxvZyhgcmVsb2FkIGxpdmUgcGxheWxpc3QgJHtpbmRleH0gaW4gJHtNYXRoLnJvdW5kKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSl9IG1zYCk7XG4gICAgICAvLyB0aGlzLmxvZyhcbiAgICAgIC8vICAgYGxpdmUgcmVsb2FkICR7ZGV0YWlscy51cGRhdGVkID8gJ1JFRlJFU0hFRCcgOiAnTUlTU0VEJ31cbiAgICAgIC8vIHJlbG9hZCBpbiAke2VzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSAvIDEwMDB9XG4gICAgICAvLyByb3VuZCB0cmlwICR7KHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCkgLyAxMDAwfVxuICAgICAgLy8gZGlmZiAke1xuICAgICAgLy8gICAocmVsb2FkSW50ZXJ2YWwgLVxuICAgICAgLy8gICAgIChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgK1xuICAgICAgLy8gICAgICAgc3RhdHMubG9hZGluZy5lbmQgLVxuICAgICAgLy8gICAgICAgc3RhdHMubG9hZGluZy5zdGFydCkpIC9cbiAgICAgIC8vICAgMTAwMFxuICAgICAgLy8gfVxuICAgICAgLy8gcmVsb2FkIGludGVydmFsICR7cmVsb2FkSW50ZXJ2YWwgLyAxMDAwfVxuICAgICAgLy8gdGFyZ2V0IGR1cmF0aW9uICR7ZGV0YWlscy50YXJnZXRkdXJhdGlvbn1cbiAgICAgIC8vIGRpc3RhbmNlIHRvIGVkZ2UgJHtkaXN0YW5jZVRvTGl2ZUVkZ2VNcyAvIDEwMDB9YFxuICAgICAgLy8gKTtcblxuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpIHtcbiAgICBsZXQgc2tpcCA9IGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPSBudWxsICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gSGxzU2tpcC5ObztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gIH1cbiAgY2hlY2tSZXRyeShlcnJvckV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yRXZlbnQpO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZXJyb3JFdmVudC5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICByZXRyeUNvdW50ID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHJldHJ5ID0gISFlcnJvckFjdGlvbiAmJiAhIXJldHJ5Q29uZmlnICYmIChhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgfHwgIWVycm9yQWN0aW9uLnJlc29sdmVkICYmIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIGlmIChyZXRyeUNvdW50ID49IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RpbWVvdXQgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgLy8gVGhlIExMLUhMUyByZXF1ZXN0IGFscmVhZHkgdGltZWQgb3V0IHNvIHJldHJ5IGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2ApO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkUGxheWxpc3QoKSwgZGVsYXkpO1xuICAgICAgICB0aGlzLndhcm4oYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiBpbiAke2RlbGF5fW1zYCk7XG4gICAgICB9XG4gICAgICAvLyBgbGV2ZWxSZXRyeSA9IHRydWVgIHVzZWQgdG8gaW5mb3JtIG90aGVyIGNvbnRyb2xsZXJzIHRoYXQgYSByZXRyeSBpcyBoYXBwZW5pbmdcbiAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXRyeTtcbiAgfVxufVxuXG5sZXQgY2hyb21lT3JGaXJlZm94O1xuY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcikge1xuICAgIHN1cGVyKGhscywgJ1tsZXZlbC1jb250cm9sbGVyXScpO1xuICAgIHRoaXMuX2xldmVscyA9IFtdO1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9zdGFydExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5zdGVlcmluZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGVlcmluZyA9IGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIH0pO1xuICAgIHN1cGVyLnN0YXJ0TG9hZCgpO1xuICB9XG4gIHJlc2V0TGV2ZWxzKCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gW107XG4gICAgY29uc3QgbGV2ZWxTZXQgPSB7fTtcbiAgICBsZXQgbGV2ZWxGcm9tU2V0O1xuXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbFBhcnNlZCA9PiB7XG4gICAgICB2YXIgX2xldmVsUGFyc2VkJGF1ZGlvQ29kO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGxldmVsUGFyc2VkLmF0dHJzO1xuXG4gICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgIGlmICgoKF9sZXZlbFBhcnNlZCRhdWRpb0NvZCA9IGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWxQYXJzZWQkYXVkaW9Db2QuaW5kZXhPZignbXA0YS40MC4zNCcpKSAhPT0gLTEpIHtcbiAgICAgICAgY2hyb21lT3JGaXJlZm94IHx8IChjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcbiAgICAgICAgaWYgKGNocm9tZU9yRmlyZWZveCkge1xuICAgICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQVVESU8sXG4gICAgICAgIENPREVDUyxcbiAgICAgICAgJ0ZSQU1FLVJBVEUnOiBGUkFNRVJBVEUsXG4gICAgICAgICdQQVRIV0FZLUlEJzogUEFUSFdBWSxcbiAgICAgICAgUkVTT0xVVElPTixcbiAgICAgICAgU1VCVElUTEVTXG4gICAgICB9ID0gYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ1ByZWZpeCA9IGAke1BBVEhXQVkgfHwgJy4nfS1gIDtcbiAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7Y29udGVudFN0ZWVyaW5nUHJlZml4fSR7bGV2ZWxQYXJzZWQuYml0cmF0ZX0tJHtSRVNPTFVUSU9OfS0ke0ZSQU1FUkFURX0tJHtDT0RFQ1N9YDtcbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsS2V5XTtcbiAgICAgIGlmICghbGV2ZWxGcm9tU2V0KSB7XG4gICAgICAgIGxldmVsRnJvbVNldCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgIGxldmVsU2V0W2xldmVsS2V5XSA9IGxldmVsRnJvbVNldDtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWxGcm9tU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsRnJvbVNldC5hZGRGYWxsYmFjayhsZXZlbFBhcnNlZCk7XG4gICAgICB9XG4gICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCwgJ2F1ZGlvJywgQVVESU8pO1xuICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQsICd0ZXh0JywgU1VCVElUTEVTKTtcbiAgICB9KTtcbiAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobGV2ZWxzLCBkYXRhKTtcbiAgfVxuICBmaWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKHVuZmlsdGVyZWRMZXZlbHMsIGRhdGEpIHtcbiAgICBsZXQgYXVkaW9UcmFja3MgPSBbXTtcbiAgICBsZXQgc3VidGl0bGVUcmFja3MgPSBbXTtcbiAgICBsZXQgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgbGV0IHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIGxldCBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcblxuICAgIC8vIG9ubHkga2VlcCBsZXZlbHMgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV0IGxldmVscyA9IHVuZmlsdGVyZWRMZXZlbHMuZmlsdGVyKCh7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdW5rbm93bkNvZGVjc1xuICAgIH0pID0+IHtcbiAgICAgIHJlc29sdXRpb25Gb3VuZCB8fCAocmVzb2x1dGlvbkZvdW5kID0gISEod2lkdGggJiYgaGVpZ2h0KSk7XG4gICAgICB2aWRlb0NvZGVjRm91bmQgfHwgKHZpZGVvQ29kZWNGb3VuZCA9ICEhdmlkZW9Db2RlYyk7XG4gICAgICBhdWRpb0NvZGVjRm91bmQgfHwgKGF1ZGlvQ29kZWNGb3VuZCA9ICEhYXVkaW9Db2RlYyk7XG4gICAgICByZXR1cm4gISh1bmtub3duQ29kZWNzICE9IG51bGwgJiYgdW5rbm93bkNvZGVjcy5sZW5ndGgpICYmICghYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodmlkZW9Db2RlYywgJ3ZpZGVvJykpO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgbGV2ZWwgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIHZpZGVvIGNvZGVjcyBvciBSRVNPTFVUSU9OIHNpZ25hbGxlZFxuICAgIGlmICgocmVzb2x1dGlvbkZvdW5kIHx8IHZpZGVvQ29kZWNGb3VuZCkgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7XG4gICAgICAgIHZpZGVvQ29kZWMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0pID0+ICEhdmlkZW9Db2RlYyB8fCAhISh3aWR0aCAmJiBoZWlnaHQpKTtcbiAgICB9XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIERpc3BhdGNoIGVycm9yIGFmdGVyIE1BTklGRVNUX0xPQURFRCBpcyBkb25lIHByb3BhZ2F0aW5nXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKHRyYWNrID0+ICF0cmFjay5hdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh0cmFjay5hdWRpb0NvZGVjLCAnYXVkaW8nKSk7XG4gICAgICAvLyBBc3NpZ24gaWRzIGFmdGVyIGZpbHRlcmluZyBhcyBhcnJheSBpbmRpY2VzIGJ5IGdyb3VwLWlkXG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdWJ0aXRsZXMpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZXM7XG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoc3VidGl0bGVUcmFja3MpO1xuICAgIH1cbiAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgIGNvbnN0IHVuc29ydGVkTGV2ZWxzID0gbGV2ZWxzLnNsaWNlKDApO1xuICAgIC8vIHNvcnQgbGV2ZWxzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3RcbiAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSAhPT0gYi5hdHRyc1snSERDUC1MRVZFTCddKSB7XG4gICAgICAgIHJldHVybiAoYS5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA+IChiLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID8gMSA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGEuYml0cmF0ZSAhPT0gYi5iaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYS5hdHRyc1snRlJBTUUtUkFURSddICE9PSBiLmF0dHJzWydGUkFNRS1SQVRFJ10pIHtcbiAgICAgICAgcmV0dXJuIGEuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0ZSQU1FLVJBVEUnKSAtIGIuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0ZSQU1FLVJBVEUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmF0dHJzLlNDT1JFICE9PSBiLmF0dHJzLlNDT1JFKSB7XG4gICAgICAgIHJldHVybiBhLmF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdTQ09SRScpIC0gYi5hdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnU0NPUkUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHV0aW9uRm91bmQgJiYgYS5oZWlnaHQgIT09IGIuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBhLmhlaWdodCAtIGIuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgbGV0IGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbMF07XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIGxldmVscyA9IHRoaXMuc3RlZXJpbmcuZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscyk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCAhPT0gdW5zb3J0ZWRMZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5zb3J0ZWRMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodW5zb3J0ZWRMZXZlbHNbaV0ucGF0aHdheUlkID09PSBsZXZlbHNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgICBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcblxuICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldID09PSBmaXJzdExldmVsSW5QbGF5bGlzdCkge1xuICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgdGhpcy5sb2coYG1hbmlmZXN0IGxvYWRlZCwgJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTogJHtmaXJzdExldmVsSW5QbGF5bGlzdC5iaXRyYXRlfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdWRpbyBpcyBvbmx5IGFsdGVybmF0ZSBpZiBtYW5pZmVzdCBpbmNsdWRlIGEgVVJJIGFsb25nIHdpdGggdGhlIGF1ZGlvIGdyb3VwIHRhZyxcbiAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuICAgIGNvbnN0IGF1ZGlvT25seSA9IGF1ZGlvQ29kZWNGb3VuZCAmJiAhdmlkZW9Db2RlY0ZvdW5kO1xuICAgIGNvbnN0IGVkYXRhID0ge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZVRyYWNrcyxcbiAgICAgIHNlc3Npb25EYXRhOiBkYXRhLnNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXM6IGRhdGEuc2Vzc2lvbktleXMsXG4gICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgIGFsdEF1ZGlvOiAhYXVkaW9Pbmx5ICYmIGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCBlZGF0YSk7XG5cbiAgICAvLyBJbml0aWF0ZSBsb2FkaW5nIGFmdGVyIGFsbCBjb250cm9sbGVycyBoYXZlIHJlY2VpdmVkIE1BTklGRVNUX1BBUlNFRFxuICAgIGlmICh0aGlzLmhscy5jb25maWcuYXV0b1N0YXJ0TG9hZCB8fCB0aGlzLmhscy5mb3JjZVN0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxldmVscygpIHtcbiAgICBpZiAodGhpcy5fbGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG4gIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgY29uc3QgZmF0YWwgPSBuZXdMZXZlbCA8IDA7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCBsYXN0UGF0aHdheUlkID0gbGFzdExldmVsID8gbGFzdExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgaWYgKGxhc3RMZXZlbEluZGV4ID09PSBuZXdMZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxhc3RMZXZlbCAmJiBsYXN0UGF0aHdheUlkID09PSBwYXRod2F5SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfSR7cGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSBmcm9tIGxldmVsICR7bGFzdExldmVsSW5kZXh9JHtsYXN0UGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIGxhc3RQYXRod2F5SWQgOiAnJ31gKTtcbiAgICBjb25zdCBsZXZlbFN3aXRjaGluZ0RhdGEgPSBfZXh0ZW5kcyh7fSwgbGV2ZWwsIHtcbiAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICBhdHRyczogbGV2ZWwuYXR0cnMsXG4gICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgIHVybElkOiBsZXZlbC51cmxJZFxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBkZWxldGUgbGV2ZWxTd2l0Y2hpbmdEYXRhLl9hdHRycztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVsZXRlIGxldmVsU3dpdGNoaW5nRGF0YS5fdXJsSWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGFzdExldmVsLmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgIH1cbiAgfVxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIHtcbiAgICBmcmFnXG4gIH0pIHtcbiAgICBpZiAoZnJhZyAhPT0gdW5kZWZpbmVkICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTI7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWwsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuICAgIGlmICghY3VyTGV2ZWwpIHtcbiAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGk7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgbGV2ZWwgaW5kZXggJHtsZXZlbH1gKTtcbiAgICAgIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgICBpZiAoY3VyTGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChsZXZlbCwgZGF0YSwgY3VyTGV2ZWwuZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIuc2tpcCkge1xuICAgICAgLy8gcmVjZWl2ZWQgYSBkZWx0YSBwbGF5bGlzdCB1cGRhdGUgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkXG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBpZiAoIWN1cnJlbnRMZXZlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcyAmJiBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgIGxldCB1cmxJZCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHNbaV0gPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIHVybElkID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVybElkICE9PSAtMSAmJiB1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICBpZiAodGhpcy5jYW5Mb2FkKSB7XG4gICAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBpZiAoY3VycmVudExldmVsICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgIGNvbnN0IGlkID0gY3VycmVudExldmVsLnVybElkO1xuICAgICAgbGV0IHVybCA9IGN1cnJlbnRMZXZlbC51cmk7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgICAgdGhpcy5sb2coYExvYWRpbmcgbGV2ZWwgaW5kZXggJHtjdXJyZW50TGV2ZWxJbmRleH0keyhobHNVcmxQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBobHNVcmxQYXJhbWV0ZXJzLm1zbikgIT09IHVuZGVmaW5lZCA/ICcgYXQgc24gJyArIGhsc1VybFBhcmFtZXRlcnMubXNuICsgJyBwYXJ0ICcgKyBobHNVcmxQYXJhbWV0ZXJzLnBhcnQgOiAnJ30gd2l0aCR7cGF0aHdheUlkID8gJyBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ30gVVJJICR7aWQgKyAxfS8ke2N1cnJlbnRMZXZlbC51cmwubGVuZ3RofSAke3VybH1gKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWxPYmplY3QuYXR0cnMuQVVESU8sIGxldmVsKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BRElORywge1xuICAgICAgICB1cmwsXG4gICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWxJbmRleCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgIH1cbiAgfVxuICBzZXQgbmV4dExvYWRMZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgIH1cbiAgfVxuICByZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCkge1xuICAgIGNvbnN0IGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXggPSAodXJsLCBpZCkgPT4gaWQgIT09IHVybElkO1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsLnVybC5sZW5ndGggPiAxICYmIHVybElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwudXJsID0gbGV2ZWwudXJsLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcbiAgICAgICAgaWYgKGxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gbGV2ZWwuYXVkaW9Hcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IGxldmVsLnRleHRHcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RlZXJpbmcucmVtb3ZlTGV2ZWwobGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICBsZXZlbHNcbiAgICB9KTtcbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIHtcbiAgICBsZXZlbHNcbiAgfSkge1xuICAgIGxldmVscy5mb3JFYWNoKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGV0YWlsc1xuICAgICAgfSA9IGxldmVsO1xuICAgICAgaWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLmZyYWdtZW50cykge1xuICAgICAgICBkZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICBmcmFnbWVudC5sZXZlbCA9IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEdyb3VwSWQobGV2ZWwsIHR5cGUsIGlkKSB7XG4gIGlmICghaWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBbXTtcbiAgICB9XG4gICAgbGV2ZWwuYXVkaW9Hcm91cElkc1tsZXZlbC51cmwubGVuZ3RoIC0gMV0gPSBpZDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICBpZiAoIWxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLnRleHRHcm91cElkc1tsZXZlbC51cmwubGVuZ3RoIC0gMV0gPSBpZDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICBjb25zdCBncm91cHMgPSB7fTtcbiAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgIGNvbnN0IGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgZ3JvdXBzW2dyb3VwSWRdKys7XG4gIH0pO1xufVxuXG52YXIgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgTk9UX0xPQURFRDogXCJOT1RfTE9BREVEXCIsXG4gIEFQUEVORElORzogXCJBUFBFTkRJTkdcIixcbiAgUEFSVElBTDogXCJQQVJUSUFMXCIsXG4gIE9LOiBcIk9LXCJcbn07XG5jbGFzcyBGcmFnbWVudFRyYWNrZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZnJhZ21lbnRzID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSB0aGlzLnRpbWVSYW5nZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IG9yIFBhcnQgd2l0aCBhbiBhcHBlbmRlZCByYW5nZSB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGVcbiAgICogT3RoZXJ3aXNlLCByZXR1cm4gbnVsbFxuICAgKi9cbiAgZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlUGFydHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVBhcnQgPSBhY3RpdmVQYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVQYXJ0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwZW5kZWRQVFMgPSBhY3RpdmVQYXJ0LmVuZDtcbiAgICAgICAgaWYgKGFjdGl2ZVBhcnQuc3RhcnQgPD0gcG9zaXRpb24gJiYgYXBwZW5kZWRQVFMgIT09IG51bGwgJiYgcG9zaXRpb24gPD0gYXBwZW5kZWRQVFMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICBpZiAoKGZyYWdtZW50RW50aXR5ID09IG51bGwgPyB2b2lkIDAgOiBmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUpID09PSBsZXZlbFR5cGUgJiYgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICovXG4gIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIGFwcGVuZGVkUGFydCkge1xuICAgIGlmICh0aGlzLnRpbWVSYW5nZXMpIHtcbiAgICAgIHRoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXSA9IHRpbWVSYW5nZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIC8vIGV4Y2x1ZGluZyBhbnl0aGluZyBuZXdlciB0aGFuIGFwcGVuZGVkUGFydFNuXG4gICAgY29uc3QgYXBwZW5kZWRQYXJ0U24gPSAoYXBwZW5kZWRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZFBhcnQuZnJhZ21lbnQuc24pIHx8IC0xO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSBmcmFnbWVudEVudGl0eS5ib2R5LnNuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFlc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNEYXRhLnRpbWUuc29tZSh0aW1lID0+IHtcbiAgICAgICAgY29uc3QgaXNOb3RCdWZmZXJlZCA9ICF0aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTm90QnVmZmVyZWQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCF0aW1lUmFuZ2VzIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSB8fCBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiBmcmFnLmdhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0ZyYWdIaW50ID0gIWZyYWcucmVsdXJsO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgY29uc3QgcGFydGlhbCA9IGlzRnJhZ0hpbnQgfHwgc3RyZWFtSW5mby5wYXJ0aWFsID09PSB0cnVlO1xuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSB0aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZywgcGFydCwgcGFydGlhbCwgdGltZVJhbmdlKTtcbiAgICB9KTtcbiAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgIGlmIChPYmplY3Qua2V5cyhmcmFnbWVudEVudGl0eS5yYW5nZSkubGVuZ3RoKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRMaXN0KSB7XG4gICAgICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tmcmFnbWVudEVudGl0eS5ib2R5LnR5cGVdID0gZnJhZ21lbnRFbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9sZGVyIGZyYWdtZW50IHBhcnRzIGZyb20gbG9va3VwIGFmdGVyIGZyYWcgaXMgdHJhY2tlZCBhcyBidWZmZXJlZFxuICAgICAgICB0aGlzLnJlbW92ZVBhcnRzKGZyYWcuc24gLSAxLCBmcmFnLnR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgZnJhZ21lbnQgaWYgbm90aGluZyB3YXMgYXBwZW5kZWRcbiAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVBhcnRzKHNuVG9LZWVwLCBsZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydC5mcmFnbWVudC5zbiA+PSBzblRvS2VlcCk7XG4gIH1cbiAgZnJhZ0J1ZmZlcmVkKGZyYWcsIGZvcmNlKSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmICghZnJhZ21lbnRFbnRpdHkgJiYgZm9yY2UpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICAgIGJvZHk6IGZyYWcsXG4gICAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgICBsb2FkZWQ6IG51bGwsXG4gICAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgdGhpcy5oYXNHYXBzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpIHtcbiAgICBjb25zdCBidWZmZXJlZCA9IHtcbiAgICAgIHRpbWU6IFtdLFxuICAgICAgcGFydGlhbFxuICAgIH07XG4gICAgY29uc3Qgc3RhcnRQVFMgPSBmcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBlbmRQVFMgPSBmcmFnbWVudC5lbmQ7XG4gICAgY29uc3QgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICBjb25zdCBtYXhTdGFydFBUUyA9IGZyYWdtZW50Lm1heFN0YXJ0UFRTIHx8IHN0YXJ0UFRTO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBjb25zdCBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciB0aW1lUmFuZ2UgdGltZXMgc2luY2UgaXQncyBjb21wbGV0ZWx5IHBsYXlhYmxlXG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UFRTIDwgZW5kVGltZSAmJiBlbmRQVFMgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgYnVmZmVyZWQucGFydGlhbCA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgLy8gR2V0IHBsYXlhYmxlIHNlY3Rpb25zIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIGdldFBhcnRpYWxGcmFnbWVudCh0aW1lKSB7XG4gICAgbGV0IGJlc3RGcmFnbWVudCA9IG51bGw7XG4gICAgbGV0IHRpbWVQYWRkaW5nO1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgbGV0IGJlc3RPdmVybGFwID0gMDtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJQYWRkaW5nLFxuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuICBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgY29uc3QgbGFzdEZyYWdtZW50RW50aXR5ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW3R5cGVdO1xuICAgIHJldHVybiBsYXN0RnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCAmJiAobGFzdEZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IGlzUGFydGlhbChsYXN0RnJhZ21lbnRFbnRpdHkpKTtcbiAgfVxuICBnZXRTdGF0ZShmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgfVxuICBpc1RpbWVCdWZmZXJlZChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcmFnbWVudCBlbnRpdHkgYGxvYWRlZGAgRnJhZ0xvYWRlZERhdGEgaXMgbnVsbCB3aGVuIGxvYWRpbmcgcGFydHNcbiAgICBjb25zdCBsb2FkZWQgPSBwYXJ0ID8gbnVsbCA6IGRhdGE7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHRpbWVSYW5nZXNcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIGxldCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV07XG4gICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV0gPSBhY3RpdmVQYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xuICAgICAgY29uc3QgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgcGFydCk7XG4gICAgfSk7XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH1cbiAgaGFzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9XG4gIGhhc1BhcnRzKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkYWN0aXZlUGFydExpc3RzO1xuICAgIHJldHVybiAhISgoX3RoaXMkYWN0aXZlUGFydExpc3RzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkYWN0aXZlUGFydExpc3RzLmxlbmd0aCk7XG4gIH1cbiAgcmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydCwgZW5kLCBwbGF5bGlzdFR5cGUsIHdpdGhHYXBPbmx5LCB1bmJ1ZmZlcmVkT25seSkge1xuICAgIGlmICh3aXRoR2FwT25seSAmJiAhdGhpcy5oYXNHYXBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gcGxheWxpc3RUeXBlIHx8IHdpdGhHYXBPbmx5ICYmICFmcmFnLmdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5zdGFydCA8IGVuZCAmJiBmcmFnLmVuZCA+IHN0YXJ0ICYmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCB1bmJ1ZmZlcmVkT25seSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQuc3RhdHMubG9hZGVkID0gMDtcbiAgICBmcmFnbWVudC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGNvbnN0IHNuVG9SZW1vdmUgPSBmcmFnbWVudC5zbjtcbiAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydC5mcmFnbWVudC5zbiAhPT0gc25Ub1JlbW92ZSk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnQuZW5kTGlzdCkge1xuICAgICAgZGVsZXRlIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tmcmFnbWVudC50eXBlXTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gIHZhciBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UsIF9mcmFnbWVudEVudGl0eSRyYW5nZTIsIF9mcmFnbWVudEVudGl0eSRyYW5nZTM7XG4gIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoZnJhZ21lbnRFbnRpdHkuYm9keS5nYXAgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPSBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZS5wYXJ0aWFsKSB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPSBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTIucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW92aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTMucGFydGlhbCkpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpIHtcbiAgcmV0dXJuIGAke2ZyYWdtZW50LnR5cGV9XyR7ZnJhZ21lbnQubGV2ZWx9XyR7ZnJhZ21lbnQudXJsSWR9XyR7ZnJhZ21lbnQuc259YDtcbn1cblxuY29uc3QgTUlOX0NIVU5LX1NJWkUgPSBNYXRoLnBvdygyLCAxNyk7IC8vIDEyOGtiXG5cbmNsYXNzIEZyYWdtZW50TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMucGFydExvYWRUaW1lb3V0ID0gLTE7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZChmcmFnLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgdXJsID0gZnJhZy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSAke3VybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCd9YCksXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgaWYgKGZyYWcudGFnTGlzdC5zb21lKHRhZ3MgPT4gdGFnc1swXSA9PT0gJ0dBUCcpKSB7XG4gICAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc2V0IHRlbXBvcmFyeSB0cmVhdG1lbnQgYXMgR0FQIHRhZ1xuICAgICAgICAgIGZyYWcuZ2FwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyID0gZnJhZy5sb2FkZXIgPSBGcmFnbWVudElMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcpO1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnID8gSW5maW5pdHkgOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzZXRJViAmJiBmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgICBmcmFnLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5zbGljZSgwLCAxNikpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBsb2FkUGFydChmcmFnLCBwYXJ0LCBvblByb2dyZXNzKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCB8fCBwYXJ0LmdhcCkge1xuICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICAvLyBTaG91bGQgd2UgZGVmaW5lIGFub3RoZXIgbG9hZCBwb2xpY3kgZm9yIHBhcnRzP1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIHBhcnQuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCk7XG4gICAgICAgICAgY29uc3QgcGFydExvYWRlZERhdGEgPSB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH07XG4gICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgIGNvbnN0IGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgY29uc3QgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICBjb25zdCBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuICAgIGlmIChwYXJ0VG90YWwpIHtcbiAgICAgIGNvbnN0IGVzdFRvdGFsUGFydHMgPSBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gLyBwYXJ0LmR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSwgZXN0VG90YWxQYXJ0cyk7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdQYXJ0cyA9IGVzdFRvdGFsUGFydHMgLSBlc3RMb2FkZWRQYXJ0cztcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ0J5dGVzID0gZXN0UmVtYWluaW5nUGFydHMgKiBNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBlc3RMb2FkZWRQYXJ0cyk7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IE1hdGgubWF4KGZyYWdTdGF0cy5sb2FkZWQsIGZyYWdTdGF0cy50b3RhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgY29uc3QgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICBpZiAoZnJhZ0xvYWRpbmcuc3RhcnQpIHtcbiAgICAgIC8vIGFkZCB0byBmcmFnbWVudCBsb2FkZXIgbGF0ZW5jeVxuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ0xvYWRpbmcuc3RhcnQgPSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgfVxuICAgIGZyYWdMb2FkaW5nLmVuZCA9IHBhcnRMb2FkaW5nLmVuZDtcbiAgfVxuICByZXNldExvYWRlcihmcmFnLCBsb2FkZXIpIHtcbiAgICBmcmFnLmxvYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMubG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0ID0gbnVsbCkge1xuICBjb25zdCBzZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICBjb25zdCBsb2FkZXJDb250ZXh0ID0ge1xuICAgIGZyYWcsXG4gICAgcGFydCxcbiAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgdXJsOiBzZWdtZW50LnVybCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICByYW5nZVN0YXJ0OiAwLFxuICAgIHJhbmdlRW5kOiAwXG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgY29uc3QgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydCkgJiYgaXNGaW5pdGVOdW1iZXIoZW5kKSkge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YTtcbiAgICBsZXQgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYnl0ZVJhbmdlRW5kID0gZW5kO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnICYmICgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckZGVjcnlwdGRhdGEubWV0aG9kKSA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAvLyBoYXMgdGhlIHVuZW5jcnlwdGVkIHNpemUgc3BlY2lmaWVkIGluIHRoZSByYW5nZS5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0wOCNzZWN0aW9uLTYuMy42XG4gICAgICBjb25zdCBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gZnJhZ21lbnRMZW4gJSAxNik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yZXNldElWID0gdHJ1ZTtcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydCAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBieXRlUmFuZ2VTdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICB9XG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxuZnVuY3Rpb24gY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEdBUCAke2ZyYWcuZ2FwID8gJ3RhZycgOiAnYXR0cmlidXRlJ30gZm91bmRgKTtcbiAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfR0FQLFxuICAgIGZhdGFsOiBmYWxzZSxcbiAgICBmcmFnLFxuICAgIGVycm9yLFxuICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gIH07XG4gIGlmIChwYXJ0KSB7XG4gICAgZXJyb3JEYXRhLnBhcnQgPSBwYXJ0O1xuICB9XG4gIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICByZXR1cm4gbmV3IExvYWRFcnJvcihlcnJvckRhdGEpO1xufVxuY2xhc3MgTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG5jbGFzcyBLZXlMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgYWJvcnQodHlwZSkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gbG9hZGVyLmNvbnRleHQuZnJhZy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXRhY2goKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgLy8gUmVtb3ZlIGNhY2hlZCBFTUUga2V5cyBvbiBkZXRhY2hcbiAgICAgIGlmIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gIH1cbiAgY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIGRldGFpbHMgPSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gbmV3IExvYWRFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIGxvYWRDbGVhcihsb2FkaW5nRnJhZywgZW5jcnlwdGVkRnJhZ21lbnRzKSB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBhY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FpZG5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICBjb25zdCB7XG4gICAgICAgIHNuLFxuICAgICAgICBjY1xuICAgICAgfSA9IGxvYWRpbmdGcmFnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGVuY3J5cHRlZEZyYWdtZW50c1tpXTtcbiAgICAgICAgaWYgKGNjIDw9IGZyYWcuY2MgJiYgKHNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgc24gPCBmcmFnLnNuKSkge1xuICAgICAgICAgIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkKGZyYWcpIHtcbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5lbmNyeXB0ZWQgJiYgdGhpcy5lbWVDb250cm9sbGVyKSB7XG4gICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZyk7XG4gIH1cbiAgbG9hZEludGVybmFsKGZyYWcsIGtleVN5c3RlbUZvcm1hdCkge1xuICAgIHZhciBfa2V5SW5mbywgX2tleUluZm8yO1xuICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihrZXlTeXN0ZW1Gb3JtYXQgPyBgRXhwZWN0ZWQgZnJhZy5kZWNyeXB0ZGF0YSB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHRpbmcgZm9ybWF0ICR7a2V5U3lzdGVtRm9ybWF0fWAgOiAnTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvcikpO1xuICAgIH1cbiAgICBjb25zdCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgSW52YWxpZCBrZXkgVVJJOiBcIiR7dXJpfVwiYCkpKTtcbiAgICB9XG4gICAgbGV0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmICgoX2tleUluZm8gPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvLmRlY3J5cHRkYXRhLmtleSkge1xuICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAga2V5SW5mb1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBrZXkgbG9hZCBwcm9taXNlIGFzIGxvbmcgYXMgaXQgZG9lcyBub3QgaGF2ZSBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1bnVzYWJsZSBrZXkgc3RhdHVzXG4gICAgaWYgKChfa2V5SW5mbzIgPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvMi5rZXlMb2FkUHJvbWlzZSkge1xuICAgICAgdmFyIF9rZXlJbmZvJG1lZGlhS2V5U2VzcztcbiAgICAgIHN3aXRjaCAoKF9rZXlJbmZvJG1lZGlhS2V5U2VzcyA9IGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rZXlJbmZvJG1lZGlhS2V5U2Vzcy5rZXlTdGF0dXMpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ3N0YXR1cy1wZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndXNhYmxlJzpcbiAgICAgICAgY2FzZSAndXNhYmxlLWluLWZ1dHVyZSc6XG4gICAgICAgICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGtleUluZm9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEga2V5IHNlc3Npb24gYW5kIHN0YXR1cyBhbmQgaXQgaXMgbm90IHBlbmRpbmcgb3IgdXNhYmxlLCBjb250aW51ZVxuICAgICAgLy8gVGhpcyB3aWxsIGdvIGJhY2sgdG8gdGhlIGVtZS1jb250cm9sbGVyIGZvciBleHBpcmVkIGtleXMgdG8gZ2V0IGEgbmV3IGtleUxvYWRQcm9taXNlXG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUga2V5IG9yIHJldHVybiB0aGUgbG9hZGluZyBwcm9taXNlXG4gICAga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0gPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChkZWNyeXB0ZGF0YS5tZXRob2QpIHtcbiAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DRU5DJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIGxvYWRLZXlIVFRQIGhhbmRsZXMgaHR0cChzKSBhbmQgZGF0YSBVUkxzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgS2V5IHN1cHBsaWVkIHdpdGggdW5zdXBwb3J0ZWQgTUVUSE9EOiBcIiR7ZGVjcnlwdGRhdGEubWV0aG9kfVwiYCkpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3Qga2V5TG9hZGVkRGF0YSA9IHtcbiAgICAgIGZyYWcsXG4gICAgICBrZXlJbmZvXG4gICAgfTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihrZXlTZXNzaW9uQ29udGV4dCA9PiB7XG4gICAgICAgICAga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0ID0ga2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfVxuICBsb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgZnJhZy5rZXlMb2FkZXIgPSBrZXlJbmZvLmxvYWRlciA9IGtleUxvYWRlcjtcbiAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIGtleUluZm8sXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsOiBrZXlJbmZvLmRlY3J5cHRkYXRhLnVyaVxuICAgICAgfTtcblxuICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mbyxcbiAgICAgICAgICAgIHVybDogdXJpXG4gICAgICAgICAgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhIHx8IGtleUluZm8gIT09IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCBvciBjaGFuZ2VkJyksIG5ldHdvcmtEZXRhaWxzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleUluZm8uZGVjcnlwdGRhdGEua2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcblxuICAgICAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBrZXkgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gbG9hZGluZyBrZXkgJHtyZXNwb25zZS50ZXh0fWApLCBuZXR3b3JrRGV0YWlscywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sIHJlc3BvbnNlKSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgbmV3IEVycm9yKCdrZXkgbG9hZGluZyB0aW1lZCBvdXQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGtleUxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICByZXNldExvYWRlcihjb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm8sXG4gICAgICB1cmw6IHVyaVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgIGlmIChmcmFnLmtleUxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbmNsYXNzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge31cbiAgaGFzSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG4gIGhhc05leHRUaWNrKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbWlsbGlzIC0gSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEBldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuICB0aWNrSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRvVGljaygpIHt9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG5jb25zdCBub29wQnVmZmVyZWQgPSB7XG4gIGxlbmd0aDogMCxcbiAgc3RhcnQ6ICgpID0+IDAsXG4gIGVuZDogKCkgPT4gMFxufTtcbmNsYXNzIEJ1ZmZlckhlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGJ1ZmZlckluZm8obWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBjb25zdCB2YnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBjb25zdCBidWZmZXJlZCA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSxcbiAgICAgICAgICAgIGVuZDogdmJ1ZmZlcmVkLmVuZChpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiAwLFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zLFxuICAgICAgbmV4dFN0YXJ0OiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgcG9zID0gTWF0aC5tYXgoMCwgcG9zKTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgY29uc3QgZGlmZiA9IGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYnVmZmVyZWQyID0gW107XG4gICAgaWYgKG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIGNvbnN0IGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgfVxuICAgIGxldCBidWZmZXJMZW4gPSAwO1xuXG4gICAgLy8gYnVmZmVyU3RhcnROZXh0IGNhbiBwb3NzaWJseSBiZSB1bmRlZmluZWQgYmFzZWQgb24gdGhlIGNvbmRpdGlvbmFsIGxvZ2ljIGJlbG93XG4gICAgbGV0IGJ1ZmZlclN0YXJ0TmV4dDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgbGV0IGJ1ZmZlclN0YXJ0ID0gcG9zO1xuICAgIGxldCBidWZmZXJFbmQgPSBwb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gYnVmZmVyZWQyW2ldLnN0YXJ0O1xuICAgICAgY29uc3QgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiBidWZmZXJMZW4sXG4gICAgICBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCxcbiAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICBuZXh0U3RhcnQ6IGJ1ZmZlclN0YXJ0TmV4dFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgKi9cbiAgc3RhdGljIGdldEJ1ZmZlcmVkKG1lZGlhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZWRpYS5idWZmZXJlZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDaHVua01ldGFkYXRhIHtcbiAgY29uc3RydWN0b3IobGV2ZWwsIHNuLCBpZCwgc2l6ZSA9IDAsIHBhcnQgPSAtMSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgdGhpcy5sZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLnNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGluZyA9IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gICAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBhdWRpbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgICAgYXVkaW92aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKVxuICAgIH07XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuc24gPSBzbjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIHRoaXMucGFydGlhbCA9IHBhcnRpYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgbGV0IGZpcnN0RnJhZyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICBpZiAoY3VycmVudEZyYWcgJiYgY3VycmVudEZyYWcuY2MgPT09IGNjKSB7XG4gICAgICBmaXJzdEZyYWcgPSBjdXJyZW50RnJhZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlyc3RGcmFnO1xufVxuZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGlmIChsYXN0TGV2ZWwuZGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5mdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcocHJldkRldGFpbHMsIGN1ckRldGFpbHMsIHJlZmVyZW5jZUluZGV4ID0gMCkge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgcHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWcsIHNsaWRpbmcpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICBjb25zdCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gIC8vIFVwZGF0ZSBzZWdtZW50c1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZ21lbnRzW2ldLCBzbGlkaW5nKTtcbiAgfVxuICAvLyBVcGRhdGUgTEwtSExTIHBhcnRzIGF0IHRoZSBlbmQgb2YgdGhlIHBsYXlsaXN0XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZGV0YWlscy5mcmFnbWVudEhpbnQsIHNsaWRpbmcpO1xuICB9XG4gIGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVzaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsYXN0IGxldmVsLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIFBUUycgb2YgdGhlIG5ldyBmcmFnbWVudHMgc28gdGhhdCB0aGV5IGZvcm0gYVxuICogY29udGlndW91cyBzdHJlYW0gd2l0aCB0aGUgbGFzdCBmcmFnbWVudHMuXG4gKiBUaGUgUFRTIG9mIGEgZnJhZ21lbnQgbGV0cyBIbHMuanMga25vdyB3aGVyZSBpdCBmaXRzIGludG8gYSBzdHJlYW0gLSBieSBrbm93aW5nIGV2ZXJ5IFBUUywgd2Uga25vdyB3aGljaCBmcmFnbWVudCB0b1xuICogZG93bmxvYWQgYXQgYW55IGdpdmVuIHRpbWUuIFBUUyBpcyBub3JtYWxseSBjb21wdXRlZCB3aGVuIHRoZSBmcmFnbWVudCBpcyBkZW11eGVkLCBzbyB0YWtpbmcgdGhpcyBzdGVwIHNhdmVzIHVzIHRpbWVcbiAqIGFuZCBhbiBleHRyYSBkb3dubG9hZC5cbiAqIEBwYXJhbSBsYXN0RnJhZ1xuICogQHBhcmFtIGxhc3RMZXZlbFxuICogQHBhcmFtIGRldGFpbHNcbiAqL1xuZnVuY3Rpb24gYWxpZ25TdHJlYW0obGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBpZiAoIWxhc3RMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGxhc3RMZXZlbC5kZXRhaWxzKSB7XG4gICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgIGFsaWduUERUKGRldGFpbHMsIGxhc3RMZXZlbC5kZXRhaWxzKTtcbiAgfVxuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMgJiYgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgLy8gVHJ5IHRvIGFsaWduIG9uIHNuIHNvIHRoYXQgd2UgcGljayBhIGJldHRlciBzdGFydCBmcmFnbWVudC5cbiAgICAvLyBEbyBub3QgcGVyZm9ybSB0aGlzIG9uIHBsYXlsaXN0cyB3aXRoIGRlbHRhIHVwZGF0ZXMgYXMgdGhpcyBpcyBvbmx5IHRvIGFsaWduIGxldmVscyBvbiBzd2l0Y2hcbiAgICAvLyBhbmQgYWRqdXN0U2xpZGluZyBvbmx5IGFkanVzdHMgZnJhZ21lbnRzIGFmdGVyIHNraXBwZWRTZWdtZW50cy5cbiAgICBhZGp1c3RTbGlkaW5nKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCkge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgIGNvbnN0IHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICAgIGlmIChyZWZlcmVuY2VGcmFnICYmIGlzRmluaXRlTnVtYmVyKHJlZmVyZW5jZUZyYWcuc3RhcnQpKSB7XG4gICAgICBsb2dnZXIubG9nKGBBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsICR7ZGV0YWlscy51cmx9YCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBvZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgZGlmZmVyZW5jZSBpbiBQcm9ncmFtIERhdGUgVGltZSBmcm9tIHRoZSBsYXN0IGxldmVsLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKiBAcGFyYW0gbGFzdERldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25QRFQoZGV0YWlscywgbGFzdERldGFpbHMpIHtcbiAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB0aGUgdW5zYWZlIFwiIVwiIHVzYWdlIGJlbG93IGZvciBudWxsIHByb2dyYW0gZGF0ZSB0aW1lIGFjY2Vzcy5cbiAgaWYgKCFsYXN0RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIHx8ICFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhbGFzdERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIGxhc3QgbGV2ZWwgc2xpZGluZyBpcyAxMDAwIGFuZCBpdHMgZmlyc3QgZnJhZyBQUk9HUkFNLURBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDAgQU1cbiAgLy8gYW5kIGlmIG5ldyBkZXRhaWxzIGZpcnN0IGZyYWcgUFJPR1JBTSBEQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjA4IEFNXG4gIC8vIHRoZW4gd2UgY2FuIGRlZHVjZSB0aGF0IHBsYXlsaXN0IEIgc2xpZGluZyBpcyAxMDAwKzggPSAxMDA4c1xuICBjb25zdCBsYXN0UERUID0gbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTsgLy8gaGFzUHJvZ3JhbURhdGVUaW1lIGNoZWNrIGFib3ZlIG1ha2VzIHRoaXMgc2FmZS5cbiAgY29uc3QgbmV3UERUID0gZGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICAvLyBkYXRlIGRpZmYgaXMgaW4gbXMuIGZyYWcuc3RhcnQgaXMgaW4gc2Vjb25kc1xuICBjb25zdCBzbGlkaW5nID0gKG5ld1BEVCAtIGxhc3RQRFQpIC8gMTAwMCArIGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgaWYgKHNsaWRpbmcgJiYgaXNGaW5pdGVOdW1iZXIoc2xpZGluZykpIHtcbiAgICBsb2dnZXIubG9nKGBBZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSAke25ld1BEVCAtIGxhc3RQRFR9bXMsIHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9ICR7ZGV0YWlscy51cmx9IGApO1xuICAgIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC4gVW5saWtlIGBhbGlnblBEVGAsIHdoaWNoIGFkanVzdHNcbiAqIHRoZSB0aW1lbGluZSBiYXNlZCBvbiB0aGUgZGVsdGEgYmV0d2VlbiBQRFRzIG9mIHRoZSAwdGggZnJhZ21lbnQgb2YgdHdvIHBsYXlsaXN0cy9gTGV2ZWxEZXRhaWxzYCxcbiAqIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUcyxcbiAqIGFuZCB1c2VzIHRoZSBcIndhbGxjbG9ja1wiL1BEVCB0aW1lbGluZSBhcyBhIGNyb3NzLXJlZmVyZW5jZSB0byBgZGV0YWlsc2AsIGFkanVzdGluZyB0aGUgcHJlc2VudGF0aW9uXG4gKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICogdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVuc3VyZSB0aGUgXCJsb2NhbCB0aW1lbGluZXNcIiBvZiBhdWRpby9zdWJ0aXRsZSB0cmFja3NcbiAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZW5kaXRpb24geW91J2QgbGlrZSB0byB0aW1lLWFsaWduIChlLmcuIGFuIGF1ZGlvIHJlbmRpdGlvbikuXG4gKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChkZXRhaWxzLCByZWZEZXRhaWxzKSB7XG4gIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXJlZkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICBjb25zdCBtaWRkbGVGcmFnID0gTWF0aC5yb3VuZChyZWZGcmFnbWVudHMubGVuZ3RoIC8gMikgLSAxO1xuICBjb25zdCByZWZGcmFnID0gcmVmRnJhZ21lbnRzW21pZGRsZUZyYWddO1xuICBjb25zdCBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHJlZkZyYWcuY2MpIHx8IGZyYWdtZW50c1tNYXRoLnJvdW5kKGZyYWdtZW50cy5sZW5ndGggLyAyKSAtIDFdO1xuICBjb25zdCByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgY29uc3QgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChyZWZQRFQgPT09IG51bGwgfHwgdGFyZ2V0UERUID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlbHRhID0gKHRhcmdldFBEVCAtIHJlZlBEVCkgLyAxMDAwIC0gKGZyYWcuc3RhcnQgLSByZWZGcmFnLnN0YXJ0KTtcbiAgYWRqdXN0U2xpZGluZ1N0YXJ0KGRlbHRhLCBkZXRhaWxzKTtcbn1cblxuY2xhc3MgQUVTQ3J5cHRvIHtcbiAgY29uc3RydWN0b3Ioc3VidGxlLCBpdikge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMuYWVzSVYgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG4gIGRlY3J5cHQoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoe1xuICAgICAgbmFtZTogJ0FFUy1DQkMnLFxuICAgICAgaXY6IHRoaXMuYWVzSVZcbiAgICB9LCBrZXksIGRhdGEpO1xuICB9XG59XG5cbmNsYXNzIEZhc3RBRVNLZXkge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsIGtleSkge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICB9XG4gIGV4cGFuZEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge1xuICAgICAgbmFtZTogJ0FFUy1DQkMnXG4gICAgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICB9XG59XG5cbi8vIFBLQ1M3XG5mdW5jdGlvbiByZW1vdmVQYWRkaW5nKGFycmF5KSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgY29uc3QgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBzbGljZVVpbnQ4KGFycmF5LCAwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuICBpbml0VGFibGUoKSB7XG4gICAgY29uc3Qgc0JveCA9IHRoaXMuc0JveDtcbiAgICBjb25zdCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGNvbnN0IHN1Yk1peCA9IHRoaXMuc3ViTWl4O1xuICAgIGNvbnN0IHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgY29uc3Qgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICBjb25zdCBzdWJNaXgyID0gc3ViTWl4WzJdO1xuICAgIGNvbnN0IHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBjb25zdCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB4aSA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDEgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICBzeCA9IHN4ID4+PiA4IF4gc3ggJiAweGZmIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgY29uc3QgeDIgPSBkW3hdO1xuICAgICAgY29uc3QgeDQgPSBkW3gyXTtcbiAgICAgIGNvbnN0IHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICBsZXQgdCA9IGRbc3hdICogMHgxMDEgXiBzeCAqIDB4MTAxMDEwMDtcbiAgICAgIHN1Yk1peDBbeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgIHN1Yk1peDFbeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBzdWJNaXgyW3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICBjb25zdCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgY29uc3Qga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG4gICAgY29uc3Qga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcbiAgICBjb25zdCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBjb25zdCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBjb25zdCBzYm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IHJjb24gPSB0aGlzLnJjb247XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBsZXQgcHJldjtcbiAgICBsZXQgdDtcbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IHByZXY7XG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSB0IDw8IDggfCB0ID4+PiAyNDtcblxuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uW2tzUm93IC8ga2V5U2l6ZSB8IDBdIDw8IDI0O1xuICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPDwgMjQgfCAod29yZCAmIDB4ZmYwMCkgPDwgOCB8ICh3b3JkICYgMHhmZjAwMDApID4+IDggfCB3b3JkID4+PiAyNDtcbiAgfVxuICBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYpIHtcbiAgICBjb25zdCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICBjb25zdCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgY29uc3QgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGNvbnN0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcbiAgICBjb25zdCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgY29uc3Qgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG4gICAgbGV0IGtzUm93LCBpO1xuICAgIGNvbnN0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMiA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMyA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbczMgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczAgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9IGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczIgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczMgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG5cbiAgICAgIC8vIFdyaXRlXG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHN3YXBXb3JkKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMl0gPSBzd2FwV29yZCh0MiBeIGluaXRWZWN0b3IyKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH1cbn1cblxuY29uc3QgQ0hVTktfU0laRSA9IDE2OyAvLyAxNiBieXRlcywgMTI4IGJpdHNcblxuY2xhc3MgRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCB7XG4gICAgcmVtb3ZlUEtDUzdQYWRkaW5nID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IHNlbGYuY3J5cHRvO1xuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3VidGxlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgfVxuICBpc1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlU29mdHdhcmU7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFJlc3VsdCxcbiAgICAgIHJlbWFpbmRlckRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWN1cnJlbnRSZXN1bHQgfHwgcmVtYWluZGVyRGF0YSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShjdXJyZW50UmVzdWx0KTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgaWYgKHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlUGFkZGluZyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBpZiAodGhpcy5zb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIGlmICh0aGlzLnVzZVNvZnR3YXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShkZWNyeXB0UmVzdWx0LmJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndlYkNyeXB0b0RlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICB9XG5cbiAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50SVYsXG4gICAgICBjdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAvLyBUaGUgb3V0cHV0IGlzIHN0YWdnZXJlZCBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGFyc2luZyAtIHRoZSBjdXJyZW50IHJlc3VsdCBpcyBjYWNoZWQsIGFuZCBlbWl0dGVkIG9uIHRoZSBuZXh0IGNhbGxcbiAgICAvLyBUaGlzIGlzIGRvbmUgaW4gb3JkZXIgdG8gc3RyaXAgUEtDUzcgcGFkZGluZywgd2hpY2ggaXMgZm91bmQgYXQgdGhlIGVuZCBvZiBlYWNoIHNlZ21lbnQuIFdlIG9ubHkga25vdyB3ZSd2ZSByZWFjaGVkXG4gICAgLy8gdGhlIGVuZCBvbiBmbHVzaCgpLCBidXQgYnkgdGhhdCB0aW1lIHdlIGhhdmUgYWxyZWFkeSByZWNlaXZlZCBhbGwgYnl0ZXMgZm9yIHRoZSBzZWdtZW50LlxuICAgIC8vIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gZG9lcyBub3Qgd29yayB3aXRoIFdlYkNyeXB0b1xuXG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYgKEFFUy0xMjggPSAxMjggYml0IGJsb2NrcyA9IDE2IGJ5dGVzKVxuICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0VmFsaWRDaHVuayhkYXRhKTtcbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudElWKSB7XG4gICAgICBpdiA9IGN1cnJlbnRJVjtcbiAgICB9XG4gICAgbGV0IHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlcjtcbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XG4gICAgfVxuICAgIHNvZnR3YXJlRGVjcnlwdGVyLmV4cGFuZEtleShrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gc29mdHdhcmVEZWNyeXB0ZXIuZGVjcnlwdChjdXJyZW50Q2h1bmsuYnVmZmVyLCAwLCBpdik7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBzbGljZVVpbnQ4KGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIGNvbnN0IHN1YnRsZSA9IHRoaXMuc3VidGxlO1xuICAgIGlmICh0aGlzLmtleSAhPT0ga2V5IHx8ICF0aGlzLmZhc3RBZXNLZXkpIHtcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oYWVzS2V5ID0+IHtcbiAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgaWYgKCFzdWJ0bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignd2ViIGNyeXB0byBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ09uY2UoJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgY29uc3QgY3J5cHRvID0gbmV3IEFFU0NyeXB0byhzdWJ0bGUsIG5ldyBVaW50OEFycmF5KGl2KSk7XG4gICAgICByZXR1cm4gY3J5cHRvLmRlY3J5cHQoZGF0YS5idWZmZXIsIGFlc0tleSk7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGxvZ2dlci53YXJuKGBbZGVjcnlwdGVyXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEksICR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHRoaXMub25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2KTtcbiAgICB9KTtcbiAgfVxuICBvbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpIHtcbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gdHJ1ZTtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpO1xuICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgIHJldHVybiBkZWNyeXB0UmVzdWx0LmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJDcnlwdG8gYW5kIHNvZnR3YXJlRGVjcnlwdDogZmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpO1xuICB9XG4gIGdldFZhbGlkQ2h1bmsoZGF0YSkge1xuICAgIGxldCBjdXJyZW50Q2h1bmsgPSBkYXRhO1xuICAgIGNvbnN0IHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcbiAgICBpZiAoc3BsaXRQb2ludCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnRDaHVuayA9IHNsaWNlVWludDgoZGF0YSwgMCwgc3BsaXRQb2ludCk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzbGljZVVpbnQ4KGRhdGEsIHNwbGl0UG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENodW5rO1xuICB9XG4gIGxvZ09uY2UobXNnKSB7XG4gICAgaWYgKCF0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZyhgW2RlY3J5cHRlcl06ICR7bXNnfWApO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNvbnN0IFRpbWVSYW5nZXMgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAocikge1xuICAgIGxldCBsb2cgPSAnJztcbiAgICBjb25zdCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gYFske3Iuc3RhcnQoaSkudG9GaXhlZCgzKX0tJHtyLmVuZChpKS50b0ZpeGVkKDMpfV1gO1xuICAgIH1cbiAgICByZXR1cm4gbG9nO1xuICB9XG59O1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICBJRExFOiAnSURMRScsXG4gIEtFWV9MT0FESU5HOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19UUkFDSzogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HOiAnUEFSU0lORycsXG4gIFBBUlNFRDogJ1BBUlNFRCcsXG4gIEVOREVEOiAnRU5ERUQnLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgV0FJVElOR19JTklUX1BUUzogJ1dBSVRJTkdfSU5JVF9QVFMnLFxuICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCdcbn07XG5jbGFzcyBCYXNlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgbG9nUHJlZml4LCBwbGF5bGlzdFR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLnBsYXlsaXN0VHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMucmV0cnlEYXRlID0gMDtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUxvYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSBudWxsO1xuICAgIHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIHRoaXMubG9nUHJlZml4ID0gJyc7XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gcGxheWxpc3RUeXBlO1xuICAgIHRoaXMubG9nUHJlZml4ID0gbG9nUHJlZml4O1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgYCR7bG9nUHJlZml4fTpgKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKGhscy5jb25maWcpO1xuICAgIHRoaXMua2V5TG9hZGVyID0ga2V5TG9hZGVyO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoaGxzLmNvbmZpZyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuYWJvcnQodGhpcy5wbGF5bGlzdFR5cGUpO1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnICE9IG51bGwgJiYgZnJhZy5sb2FkZXIpIHtcbiAgICAgIGZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG4gIF9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAvLyBJZiBwbGF5bGlzdCBpcyBsaXZlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIHRoZSBjdXJyZW50IHJhbmdlLCBub3RoaW5nIGJ1ZmZlcmVkLCBtZWRpYSBpcyBkZXRhY2hlZCxcbiAgICAvLyBvZiBub3RoaW5nIGxvYWRpbmcvbG9hZGVkIHJldHVybiBmYWxzZVxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSB8fCBidWZmZXJJbmZvLm5leHRTdGFydCB8fCAhYnVmZmVySW5mby5lbmQgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7XG4gICAgLy8gU2luY2UgdGhlIGxhc3QgcGFydCBpc24ndCBndWFyYW50ZWVkIHRvIGNvcnJlc3BvbmQgdG8gdGhlIGxhc3QgcGxheWxpc3Qgc2VnbWVudCBmb3IgTG93LUxhdGVuY3kgSExTLFxuICAgIC8vIGNoZWNrIGluc3RlYWQgaWYgdGhlIGxhc3QgcGFydCBpcyBidWZmZXJlZC5cbiAgICBpZiAocGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICBjb25zdCBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgbGFzdFBhcnQuc3RhcnQgKyBsYXN0UGFydC5kdXJhdGlvbiAvIDIpO1xuICAgICAgcmV0dXJuIGxhc3RQYXJ0QnVmZmVyZWQ7XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXS50eXBlO1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChwbGF5bGlzdFR5cGUpO1xuICB9XG4gIGdldExldmVsRGV0YWlscygpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbHMkdGhpcyRsZXY7XG4gICAgICByZXR1cm4gKF90aGlzJGxldmVscyR0aGlzJGxldiA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVscyR0aGlzJGxldi5kZXRhaWxzO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnNlZWtpbmcgJiYgdGhpcy5vbnZlbmRlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYUJ1ZmZlcixcbiAgICAgIHN0YXRlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogMDtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgPyBtZWRpYUJ1ZmZlciA6IG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMubG9nKGBtZWRpYSBzZWVraW5nIHRvICR7aXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpID8gY3VycmVudFRpbWUudG9GaXhlZCgzKSA6IGN1cnJlbnRUaW1lfSwgc3RhdGU6ICR7c3RhdGV9YCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgLy8gU2Vla2luZyB3aGlsZSBmcmFnIGxvYWQgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgaWYgKCFidWZmZXJJbmZvLmxlbiB8fCBmcmFnRW5kT2Zmc2V0IDwgYnVmZmVySW5mby5zdGFydCB8fCBmcmFnU3RhcnRPZmZzZXQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgICBjb25zdCBwYXN0RnJhZ21lbnQgPSBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQ7XG4gICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBSZW1vdmUgZ2FwIGZyYWdtZW50c1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShjdXJyZW50VGltZSwgSW5maW5pdHksIHRoaXMucGxheWxpc3RUeXBlLCB0cnVlKTtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBBc3luYyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IGRhdGEuc3RhcnRUaW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgaWYgKHRoaXMuZnJhZ21lbnRMb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSB0aGlzLmRlY3J5cHRlciA9IHRoaXMua2V5TG9hZGVyID0gdGhpcy5mcmFnbWVudExvYWRlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB0aGlzLl9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBfbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke2RhdGEucGFydCA/ICcgcDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5gKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGRhdGEgPT4ge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUgd2UgcHJvYmFibHkgbmVlZGVkIHRvIGJhY2t0cmFjayBvciBhcmUgd2FpdGluZyBmb3IgbW9yZSBwYXJ0c1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH1gKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIHdob2xlIHBheWxvYWQ7IGNvbnRyb2xsZXJzIG5vdCBpbXBsZW1lbnRpbmcgcHJvZ3Jlc3NpdmUgbG9hZGluZyByZWNlaXZlIGRhdGEgZnJvbSB0aGlzIGNhbGxiYWNrXG4gICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFCdWZmZXI7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XG4gICAgICAvLyBMb3dlciB0aGUgYnVmZmVyIHNpemUgYW5kIHRyeSBhZ2FpblxuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICBjb25zdCBtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJhZy5kdXJhdGlvbiwgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICBpZiAodGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluRm9yd2FyZEJ1ZmZlckxlbmd0aCkpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKChfdGhpcyRtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYUJ1ZmZlci5idWZmZXJlZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAvLyBTdG9wIGdhcCBmb3IgYmFkIHRyYWNrZXIgLyBidWZmZXIgZmx1c2ggYmVoYXZpb3JcbiAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhmcmFnLnR5cGUpKSB7XG4gICAgICAvLyBJbiBsb3cgbGF0ZW5jeSBtb2RlLCByZW1vdmUgZnJhZ21lbnRzIGZvciB3aGljaCBvbmx5IHNvbWUgcGFydHMgd2VyZSBidWZmZXJlZFxuICAgICAgZnJhZ21lbnRUcmFja2VyLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoe1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBzdGF0czogZnJhZy5zdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfSk7XG4gICAgICBpZiAoZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSA9IG51bGwpIHtcbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIGNvbnN0IGZsdXNoU2NvcGUgPSB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cbiAgX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCkge1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyBkZWNyeXB0IGluaXQgc2VnbWVudCBkYXRhXG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnQ3VycmVudCxcbiAgICAgICAgaGxzLFxuICAgICAgICBsZXZlbHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICBmcmFnLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLnBheWxvYWQpO1xuICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaWxlbmNlIEZSQUdfQlVGRkVSRUQgZXZlbnQgaWYgZnJhZ0N1cnJlbnQgaXMgbnVsbFxuICAgICAgaWYgKGRhdGEuZnJhZyA9PT0gZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnQ3VycmVudCxcbiAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH0pO1xuICB9XG4gIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsIHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcudXJsSWQgIT09IGZyYWdDdXJyZW50LnVybElkO1xuICB9XG4gIGZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpIHtcbiAgICB2YXIgX2ZyYWckc3RhcnRQVFMsIF9mcmFnJGVuZFBUUywgX3RoaXMkZnJhZ0N1cnJlbnQsIF90aGlzJGZyYWdQcmV2aW91cztcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLmxvZyhgQnVmZmVyZWQgJHtmcmFnLnR5cGV9IHNuOiAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiAke3RoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayd9ICR7ZnJhZy5sZXZlbH0gKGZyYWc6WyR7KChfZnJhZyRzdGFydFBUUyA9IGZyYWcuc3RhcnRQVFMpICE9IG51bGwgPyBfZnJhZyRzdGFydFBUUyA6IE5hTikudG9GaXhlZCgzKX0tJHsoKF9mcmFnJGVuZFBUUyA9IGZyYWcuZW5kUFRTKSAhPSBudWxsID8gX2ZyYWckZW5kUFRTIDogTmFOKS50b0ZpeGVkKDMpfV0gPiBidWZmZXI6JHttZWRpYSA/IFRpbWVSYW5nZXMudG9TdHJpbmcoQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKSkgOiAnKGRldGFjaGVkKSd9KWApO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGZyYWcudHlwZSA9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCAmJiAoKF90aGlzJGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdDdXJyZW50LnNuKSA9PT0gKChfdGhpcyRmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdQcmV2aW91cy5zbikpIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5zZWVrVG9TdGFydFBvcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBzZWVrVG9TdGFydFBvcygpIHt9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXJ0c0xvYWRlZFxuICAgIH0gPSBmcmFnTG9hZGVkRW5kRGF0YTtcbiAgICAvLyBJZiB3ZSBkaWQgbm90IGxvYWQgcGFydHMsIG9yIGxvYWRlZCBhbGwgcGFydHMsIHdlIGhhdmUgY29tcGxldGUgKG5vdCBwYXJ0aWFsKSBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgY29tcGxldGUgPSAhcGFydHNMb2FkZWQgfHwgcGFydHNMb2FkZWQubGVuZ3RoID09PSAwIHx8IHBhcnRzTG9hZGVkLnNvbWUoZnJhZ0xvYWRlZCA9PiAhZnJhZ0xvYWRlZCk7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgcGFydCA/IHBhcnQuaW5kZXggOiAtMSwgIWNvbXBsZXRlKTtcbiAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhmcmFnKSB7fVxuICBfZG9GcmFnTG9hZChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSA9IG51bGwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghdGhpcy5sZXZlbHMgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWwke2RldGFpbHMgPyAnJyA6ICcgZGV0YWlsJ31zYCk7XG4gICAgfVxuICAgIGxldCBrZXlMb2FkaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKGZyYWcuZW5jcnlwdGVkICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgIT0gbnVsbCAmJiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXkpKSB7XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSwgJHt0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjayd9ICR7ZnJhZy5sZXZlbH1gKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLktFWV9MT0FERUQsIGtleUxvYWRlZERhdGEpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXlMb2FkZWREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLktFWV9MT0FESU5HLCB7XG4gICAgICAgIGZyYWdcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gS0VZX0xPQURJTkdgKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZnJhZy5lbmNyeXB0ZWQgJiYgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5sb2FkQ2xlYXIoZnJhZywgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMpO1xuICAgIH1cbiAgICB0YXJnZXRCdWZmZXJUaW1lID0gTWF0aC5tYXgoZnJhZy5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSB8fCAwKTtcbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcGFydExpc3QgPSBkZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgaWYgKHBhcnRMaXN0ICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPiBmcmFnLmVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgIGZyYWcgPSBkZXRhaWxzLmZyYWdtZW50SGludDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0SW5kZXggPSB0aGlzLmdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgdGhpcy5sb2coYExvYWRpbmcgcGFydCBzbjogJHtmcmFnLnNufSBwOiAke3BhcnQuaW5kZXh9IGNjOiAke2ZyYWcuY2N9IG9mIHBsYXlsaXN0IFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV0gcGFydHMgWzAtJHtwYXJ0SW5kZXh9LSR7cGFydExpc3QubGVuZ3RoIC0gMX1dICR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtmcmFnLmxldmVsfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIGxldCBfcmVzdWx0O1xuICAgICAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgX3Jlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0ID0gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElORyBwYXJ0c2ApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2coYExvYWRpbmcgZnJhZ21lbnQgJHtmcmFnLnNufSBjYzogJHtmcmFnLmNjfSAke2RldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnfSR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtmcmFnLmxldmVsfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5zbikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChkYXRhT25Qcm9ncmVzcyAmJiBrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgdW5lbmNyeXB0ZWQgZnJhZ21lbnQgZGF0YSB3aXRoIHByb2dyZXNzIGV2ZW50LFxuICAgICAgLy8gb3IgaGFuZGxlIGZyYWdtZW50IHJlc3VsdCBhZnRlciBrZXkgYW5kIGZyYWdtZW50IGFyZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICByZXN1bHQgPSBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbigoW2ZyYWdMb2FkZWREYXRhXSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGFPblByb2dyZXNzICYmIGZyYWdMb2FkZWREYXRhICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ0xvYWRlZERhdGE7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICBmcmFnLFxuICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElOR2ApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkb0ZyYWdQYXJ0c0xvYWQoZnJhZywgZnJvbVBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIGNvbnN0IHBhcnRzTG9hZGVkID0gW107XG4gICAgICBjb25zdCBpbml0aWFsUGFydExpc3QgPSAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMucGFydExpc3Q7XG4gICAgICBjb25zdCBsb2FkUGFydCA9IHBhcnQgPT4ge1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4ocGFydExvYWRlZERhdGEgPT4ge1xuICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgY29uc3QgbG9hZGVkUGFydCA9IHBhcnRMb2FkZWREYXRhLnBhcnQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICBjb25zdCBuZXh0UGFydCA9IGdldFBhcnRXaXRoKGxldmVsLCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSkgfHwgZmluZFBhcnQoaW5pdGlhbFBhcnRMaXN0LCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHRQYXJ0KSB7XG4gICAgICAgICAgICBsb2FkUGFydChuZXh0UGFydCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgcGFydHNMb2FkZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH07XG4gICAgICBsb2FkUGFydChmcm9tUGFydCk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikge1xuICAgIGlmICgnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgaWYgKGVycm9yLmRhdGEgJiYgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9oYW5kbGVUcmFuc211eGVyRmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZyYWcuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgfVxuICBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgc24sXG4gICAgICBwYXJ0OiBwYXJ0SW5kZXhcbiAgICB9ID0gY2h1bmtNZXRhO1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbEluZGV4XSkpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7c259IG9mIGxldmVsICR7bGV2ZWxJbmRleH0uIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/IGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgY29uc3QgZnJhZyA9IHBhcnQgPyBwYXJ0LmZyYWdtZW50IDogZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50ICE9PSBmcmFnKSB7XG4gICAgICBmcmFnLnN0YXRzID0gZnJhZ0N1cnJlbnQuc3RhdHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfTtcbiAgfVxuICBidWZmZXJGcmFnbWVudERhdGEoZGF0YSwgZnJhZywgcGFydCwgY2h1bmtNZXRhLCBub0JhY2t0cmFja2luZykge1xuICAgIHZhciBfYnVmZmVyO1xuICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGExLFxuICAgICAgZGF0YTJcbiAgICB9ID0gZGF0YTtcbiAgICBsZXQgYnVmZmVyID0gZGF0YTE7XG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpO1xuICAgIH1cbiAgICBpZiAoISgoX2J1ZmZlciA9IGJ1ZmZlcikgIT0gbnVsbCAmJiBfYnVmZmVyLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudCA9IHtcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICBkYXRhOiBidWZmZXJcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuICAgIGlmIChkYXRhLmRyb3BwZWQgJiYgZGF0YS5pbmRlcGVuZGVudCAmJiAhcGFydCkge1xuICAgICAgaWYgKG5vQmFja3RyYWNraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9XG4gIGZsdXNoQnVmZmVyR2FwKGZyYWcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBjdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGNsZWFyIHRoZSBiYWNrIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBiYWNrdHJhY2sgYXMgbXVjaCBhcyBuZWVkZWRcbiAgICBpZiAoIUJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWcuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYmFjay1idWZmZXIgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2sgdG8gYWxsb3cgYmFjayB0cmFja2luZ1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3QgZnJhZ0R1cmF0aW9uID0gZnJhZy5kdXJhdGlvbjtcbiAgICBjb25zdCBzZWdtZW50RnJhY3Rpb24gPSBNYXRoLm1pbih0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICogMiwgZnJhZ0R1cmF0aW9uICogMC4yNSk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChNYXRoLm1pbihmcmFnLnN0YXJ0IC0gc2VnbWVudEZyYWN0aW9uLCBidWZmZXJJbmZvLmVuZCAtIHNlZ21lbnRGcmFjdGlvbiksIGN1cnJlbnRUaW1lICsgc2VnbWVudEZyYWN0aW9uKTtcbiAgICBpZiAoZnJhZy5zdGFydCAtIHN0YXJ0ID4gc2VnbWVudEZyYWN0aW9uKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydCwgZnJhZy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgdHlwZSkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSk7XG4gIH1cbiAgZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBtYXhCdWZmZXJIb2xlXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgbWF4QnVmZmVySG9sZSk7XG4gICAgLy8gV29ya2Fyb3VuZCBmbGF3IGluIGdldHRpbmcgZm9yd2FyZCBidWZmZXIgd2hlbiBtYXhCdWZmZXJIb2xlIGlzIHNtYWxsZXIgdGhhbiBnYXAgYXQgY3VycmVudCBwb3NcbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnQXRQb3MgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zLCB0eXBlKTtcbiAgICAgIGlmIChidWZmZXJlZEZyYWdBdFBvcyAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBNYXRoLm1heChidWZmZXJJbmZvLm5leHRTdGFydCwgbWF4QnVmZmVySG9sZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVySW5mbztcbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxCaXRyYXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1heEJ1ZkxlbjtcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfVxuICByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gdGhyZXNob2xkIHx8IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIHRoaXMud2FybihgUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgcGxheWxpc3RUeXBlID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgIGNvbnN0IGZyYWdPclBhcnQgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIGlmIChmcmFnT3JQYXJ0ICYmICdmcmFnbWVudCcgaW4gZnJhZ09yUGFydCkge1xuICAgICAgcmV0dXJuIGZyYWdPclBhcnQuZnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnT3JQYXJ0O1xuICB9XG4gIGdldE5leHRGcmFnbWVudChwb3MsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCBmcmFnO1xuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSBjb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgIHRoaXMud2FybihgTm90IGVub3VnaCBmcmFnbWVudHMgdG8gc3RhcnQgcGxheWJhY2sgKGhhdmU6ICR7ZnJhZ0xlbn0sIG5lZWQ6ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9KWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgLy8gRG8gbm90IGxvYWQgdXNpbmcgbGl2ZSBsb2dpYyBpZiB0aGUgc3RhcnRpbmcgZnJhZyBpcyByZXF1ZXN0ZWQgLSB3ZSB3YW50IHRvIHVzZSBnZXRGcmFnbWVudEF0UG9zaXRpb24oKSBzbyB0aGF0XG4gICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuICAgICAgaWYgKCFsZXZlbERldGFpbHMuUFRTS25vd24gJiYgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmIHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IGZyYWcgPyB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IGZyYWcuc3RhcnQgOiBwb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gc3RhcnQpIHtcbiAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgbG9hZFBvc2l0aW9uIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJ1biBpbnRvIGFueSBzcGVjaWFsIGNhc2VzIGFscmVhZHksIGp1c3QgbG9hZCB0aGUgZnJhZ21lbnQgbW9zdCBjbG9zZWx5IG1hdGNoaW5nIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKHBvcywgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpO1xuICB9XG4gIGlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHRyYWNrZXJTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHJldHVybiAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmICEhZnJhZy5nYXApICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWU7XG4gIH1cbiAgZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgbGV2ZWxEZXRhaWxzLCBidWZmZXJJbmZvLCBwbGF5bGlzdFR5cGUsIG1heEJ1Zkxlbikge1xuICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgY29uc3QgbmV4dEZyYWdtZW50ID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGhpcy5uZXh0TG9hZFBvc2l0aW9uLCBsZXZlbERldGFpbHMpO1xuICAgIGlmIChuZXh0RnJhZ21lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gICAgfVxuICAgIGZyYWcgPSBuZXh0RnJhZ21lbnQ7XG4gICAgaWYgKGdhcFN0YXJ0ICYmIGZyYWcgJiYgIWZyYWcuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAvLyBNZWRpYSBidWZmZXJlZCBhZnRlciBHQVAgdGFncyBzaG91bGQgbm90IG1ha2UgdGhlIG5leHQgYnVmZmVyIHRpbWVyYW5nZSBleGNlZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoXG4gICAgICBjb25zdCBuZXh0YnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgYnVmZmVySW5mby5uZXh0U3RhcnQsIHBsYXlsaXN0VHlwZSk7XG4gICAgICBpZiAobmV4dGJ1ZmZlckluZm8gIT09IG51bGwgJiYgYnVmZmVySW5mby5sZW4gKyBuZXh0YnVmZmVySW5mby5sZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICB0aGlzLmxvZyhgYnVmZmVyIGZ1bGwgYWZ0ZXIgZ2FwcyBpbiBcIiR7cGxheWxpc3RUeXBlfVwiIHBsYXlsaXN0IHN0YXJ0aW5nIGF0IHNuOiAke2ZyYWcuc259YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpIHtcbiAgICAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmluaXRTZWdtZW50ICYmICEoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQuZGF0YSkgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBnZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGxldCBuZXh0UGFydCA9IC0xO1xuICAgIGxldCBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgbGV0IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgJiYgIXBhcnQuaW5kZXBlbmRlbnQ7XG4gICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgfSBlbHNlIGlmICgoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQYXJ0O1xuICB9XG4gIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBsYXN0UGFydCAmJiB0YXJnZXRCdWZmZXJUaW1lID4gbGFzdFBhcnQuc3RhcnQgJiYgbGFzdFBhcnQubG9hZGVkO1xuICB9XG5cbiAgLypcbiAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgZmluZCB0aGUgYmVzdCBtYXRjaGluZyBmaXJzdCBmcmFnbWVudCBmb3IgYSBsaXZlIHBsYXlsaXN0LiBUaGlzIGZyYWdtZW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgXCJzbGlkaW5nXCIgb2YgdGhlIHBsYXlsaXN0LCB3aGljaCBpcyBpdHMgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHBsYXliYWNrLiBBZnRlciBzbGlkaW5nIHdlIGNhbiBjb21wdXRlIHRoZSByZWFsXG4gICBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIGZyYWdtZW50IGluIHRoZSBwbGF5bGlzdCAoYWZ0ZXIgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQpLlxuICAqL1xuICBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKSB7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgbGV0IGZyYWcgPSBudWxsO1xuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiAke2ZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWV9YCk7XG4gICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8vIFNOIGRvZXMgbm90IG5lZWQgdG8gYmUgYWNjdXJhdGUgYmV0d2VlbiByZW5kaXRpb25zLCBidXQgZGVwZW5kaW5nIG9uIHRoZSBwYWNrYWdpbmcgaXQgbWF5IGJlIHNvLlxuICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBzdGF5aW5nIHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSwgc2luY2UgUFRTIHJlc2V0cyB1cG9uIGEgbmV3IHJhbmdlXG4gICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuY2MpO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgY29uc3QgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGxpdmVTdGFydCwgdGhpcy5iaXRyYXRlVGVzdCA/IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZCA6IGxldmVsRGV0YWlscy5lZGdlLCBsZXZlbERldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIC8qXG4gIFRoaXMgbWV0aG9kIGZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGdpdmVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbi5cbiAgICovXG4gIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIGZyYWdQcmV2aW91c1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICBmcmFnbWVudHMsXG4gICAgICBlbmRTTlxuICAgIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRIaW50XG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICBjb25zdCBsb2FkaW5nUGFydHMgPSAhIShjb25maWcubG93TGF0ZW5jeU1vZGUgJiYgcGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGggJiYgZnJhZ21lbnRIaW50KTtcbiAgICBpZiAobG9hZGluZ1BhcnRzICYmIGZyYWdtZW50SGludCAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgLy8gSW5jbHVkZSBpbmNvbXBsZXRlIGZyYWdtZW50IHdpdGggcGFydHMgYXQgZW5kXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbjtcbiAgICB9XG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAvLyBNb3ZlIGZyYWdQcmV2aW91cyBmb3J3YXJkIHRvIHN1cHBvcnQgZm9yY2luZyB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkXG4gICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgZnJhZy5nYXApIHtcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbikpIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGNvbnN0IHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgZW5kU04gJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUobmV4dEZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHdpdGhpblNsaWRpbmdXaW5kb3cgPSBjdXJyZW50VGltZSA+PSBzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICYmIGN1cnJlbnRUaW1lIDw9IGVuZDtcbiAgICAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcbiAgICBpZiAobGl2ZVN5bmNQb3NpdGlvbiAhPT0gbnVsbCAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24gJiYgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdykpIHtcbiAgICAgIC8vIENvbnRpbnVlIGlmIGJ1ZmZlciBpcyBzdGFydmluZyBvciBpZiBjdXJyZW50IHRpbWUgaXMgYmVoaW5kIG1heCBsYXRlbmN5XG4gICAgICBjb25zdCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIGlmICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCB8fCBjdXJyZW50VGltZSA8IGVuZCAtIG1heExhdGVuY3kpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYFBsYXliYWNrOiAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2VuZH0sIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFsaWduUGxheWxpc3RzKGRldGFpbHMsIHByZXZpb3VzRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGxldmVsTGFzdExvYWRlZCxcbiAgICAgIGZyYWdQcmV2aW91c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxhc3RMZXZlbCA9IGxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCA/IGxldmVsc1tsZXZlbExhc3RMb2FkZWRdIDogbnVsbDtcblxuICAgIC8vIEZJWE1FOiBJZiBub3QgZm9yIGBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzYCByZXF1aXJpbmcgZnJhZ1ByZXZpb3VzLmNjLFxuICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBsZXZlbC1oZWxwZXIgbWVyZ2VEZXRhaWxzKClcbiAgICBjb25zdCBsZW5ndGggPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBjb25zdCBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG4gICAgY29uc3QgYWxpZ25lZCA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgaXNGaW5pdGVOdW1iZXIoc2xpZGluZ1N0YXJ0KTtcbiAgICBpZiAoZmlyc3RMZXZlbExvYWQgfHwgIWFsaWduZWQgJiYgIXNsaWRpbmdTdGFydCkge1xuICAgICAgYWxpZ25TdHJlYW0oZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIGRldGFpbHMpO1xuICAgICAgY29uc3QgYWxpZ25lZFNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3Qgc2xpZGluZzogJHthbGlnbmVkU2xpZGluZ1N0YXJ0LnRvRml4ZWQoMil9IHN0YXJ0LXNuOiAke3ByZXZpb3VzRGV0YWlscyA/IHByZXZpb3VzRGV0YWlscy5zdGFydFNOIDogJ25hJ30tPiR7ZGV0YWlscy5zdGFydFNOfSBwcmV2LXNuOiAke2ZyYWdQcmV2aW91cyA/IGZyYWdQcmV2aW91cy5zbiA6ICduYSd9IGZyYWdtZW50czogJHtsZW5ndGh9YCk7XG4gICAgICByZXR1cm4gYWxpZ25lZFNsaWRpbmdTdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRpbmdTdGFydDtcbiAgfVxuICB3YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIGNvbnN0IGFkdmFuY2VQYXJ0TGltaXQgPSAzO1xuICAgIHJldHVybiBkZXRhaWxzLmxpdmUgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLnBhcnRUYXJnZXQgJiYgZGV0YWlscy50dW5lSW5Hb2FsID4gTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpO1xuICB9XG4gIHNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgc2xpZGluZykge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBzbGlkaW5nKSB7XG4gICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgfVxuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcbiAgICAgIC8vIFVzZSBQbGF5bGlzdCBFWFQtWC1TVEFSVDpUSU1FLU9GRlNFVCB3aGVuIHNldFxuICAgICAgLy8gUHJpb3JpdGl6ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3Qgb2Zmc2V0IHNvIHRoYXQgbWFpbiwgYXVkaW8sIGFuZCBzdWJ0aXRsZSBzdHJlYW0tY29udHJvbGxlciBzdGFydCB0aW1lcyBtYXRjaFxuICAgICAgY29uc3Qgb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA9IHRoaXMuc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lT2Zmc2V0ID0gb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA/IHRoaXMuc3RhcnRUaW1lT2Zmc2V0IDogZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsICYmIGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRpbmcsIHN0YXJ0UG9zaXRpb24pLCBzbGlkaW5nICsgZGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2coYFN0YXJ0IHRpbWUgb2Zmc2V0ICR7c3RhcnRUaW1lT2Zmc2V0fSBmb3VuZCBpbiAke29mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYSd9IHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAvLyBub3QgYmVlbiBzcGVjaWZpZWQgdmlhIHRoZSBjb25maWcgb3IgYW4gYXMgYW4gYXJndW1lbnQgdG8gc3RhcnRMb2FkICgjMzczNikuXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IHNsaWRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgfVxuICBnZXRMb2FkUG9zaXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgbWVkaWEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGZyYWcsIHBhcnQpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgZnJhZy5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQgJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3YXMgYWJvcnRlZGApO1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZykge1xuICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCB8fCAhdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICBvbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoZmlsdGVyVHlwZSwgZGF0YSkge1xuICAgIGlmIChkYXRhLmNodW5rTWV0YSAmJiAhZGF0YS5mcmFnKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChkYXRhLmNodW5rTWV0YSk7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBkYXRhLmZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gSGFuZGxlIGZyYWcgZXJyb3IgcmVsYXRlZCB0byBjYWxsZXIncyBmaWx0ZXJUeXBlXG4gICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gZmlsdGVyVHlwZSB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB2YXIgX3RoaXMkZnJhZ0N1cnJlbnQyO1xuICAgICAgdGhpcy53YXJuKGBGcmFnIGxvYWQgZXJyb3IgbXVzdCBtYXRjaCBjdXJyZW50IGZyYWcgdG8gcmV0cnkgJHtmcmFnLnVybH0gPiAkeyhfdGhpcyRmcmFnQ3VycmVudDIgPSB0aGlzLmZyYWdDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQyLnVybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2FwVGFnRW5jb3VudGVyZWQgPSBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUDtcbiAgICBpZiAoZ2FwVGFnRW5jb3VudGVyZWQpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICB9XG4gICAgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIHJldHJ5Q291bnQgPSAwLFxuICAgICAgcmV0cnlDb25maWdcbiAgICB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgaWYgKGVycm9yQWN0aW9uICYmIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCAmJiByZXRyeUNvbmZpZykge1xuICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSAhPSBudWxsID8gX3RoaXMkbGV2ZWxMYXN0TG9hZGVkIDogZnJhZy5sZXZlbCk7XG4gICAgICBjb25zdCBkZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpO1xuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259IG9mICR7ZmlsdGVyVHlwZX0gJHtmcmFnLmxldmVsfSBlcnJvcmVkIHdpdGggJHtkYXRhLmRldGFpbHN9LCByZXRyeWluZyBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGluICR7ZGVsYXl9bXNgKTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmV0cnlEYXRlID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgIH0gZWxzZSBpZiAocmV0cnlDb25maWcgJiYgZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKTtcbiAgICAgIGlmIChyZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgLy8gTmV0d29yayByZXRyeSBpcyBza2lwcGVkIHdoZW4gbGV2ZWwgc3dpdGNoIGlzIHByZWZlcnJlZFxuICAgICAgICBpZiAoIWdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgJHtkYXRhLmRldGFpbHN9IHJlYWNoZWQgb3IgZXhjZWVkZWQgbWF4IHJldHJ5ICgke3JldHJ5Q291bnR9KWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGVycm9yQWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckFjdGlvbi5hY3Rpb24pID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICB9XG4gICAgLy8gUGVyZm9ybSBuZXh0IGFzeW5jIHRpY2sgc29vbmVyIHRvIHNwZWVkIHVwIGVycm9yIGFjdGlvbiByZXNvbHV0aW9uXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgcmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkge1xuICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZGF0YS5wYXJlbnQ7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjU7XG4gICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoYnVmZmVyZWRJbmZvLmxlbik7XG4gICAgICB9XG4gICAgICBjb25zdCBmbHVzaEJ1ZmZlciA9ICFidWZmZXJlZDtcbiAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgdGhpcy53YXJuKGBCdWZmZXIgZnVsbCBlcnJvciB3aGlsZSBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoICR7cGxheWxpc3RUeXBlfSBidWZmZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZGF0YS5mcmFnKTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5mcmFnLnN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGZsdXNoQnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKSB7XG4gICAgaWYgKGZpbHRlclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICAvLyBSZXNldCBjdXJyZW50IGZyYWdtZW50IHNpbmNlIGF1ZGlvIHRyYWNrIGF1ZGlvIGlzIGVzc2VudGlhbCBhbmQgbWF5IG5vdCBoYXZlIGEgZmFpbC1vdmVyIHRyYWNrXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRnJhZ21lbnQgZXJyb3JzIHRoYXQgcmVzdWx0IGluIGEgbGV2ZWwgc3dpdGNoIG9yIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAvLyBzaG91bGQgcmVzZXQgdGhlIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRvIGlkbGVcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCBidWZmZXJUeXBlLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAvLyAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhidWZmZXJUeXBlLCBidWZmZXJlZFRpbWVSYW5nZXMsIHBsYXlsaXN0VHlwZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9XG4gIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIHRoaXMubG9nKCdSZXNldCBsb2FkaW5nIHN0YXRlJyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIHJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGxldmVsKSB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzW2xldmVsXS5kZXRhaWxzIDogbnVsbDtcbiAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQyO1xuICAgIHRoaXMud2FybihgVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke2NodW5rTWV0YS5zbn0gb2YgbGV2ZWwgJHtjaHVua01ldGEubGV2ZWx9LiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkMiA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSAhPSBudWxsID8gX3RoaXMkbGV2ZWxMYXN0TG9hZGVkMiA6IGNodW5rTWV0YS5sZXZlbCk7XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydCA9IDApIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0LCBJbmZpbml0eSwgdGhpcy5wbGF5bGlzdFR5cGUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgcGFydGlhbCkge1xuICAgIHZhciBfdGhpcyR0cmFuc211eGVyO1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdsZXZlbC5kZXRhaWxzIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoKHJlc3VsdCwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgaW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBjb25zdCBwYXJzZWREdXJhdGlvbiA9IGluZm8uZW5kUFRTIC0gaW5mby5zdGFydFBUUztcbiAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgJHtmcmFnLnNufSAke3R5cGV9IGR1cmF0aW9uIHJlbGlhYmx5ICgke3BhcnNlZER1cmF0aW9ufSlgKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyaWZ0ID0gcGFydGlhbCA/IDAgOiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIGluZm8uc3RhcnRQVFMsIGluZm8uZW5kUFRTLCBpbmZvLnN0YXJ0RFRTLCBpbmZvLmVuZERUUyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBkcmlmdCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZhbHNlKTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICB9IGVsc2UgaWYgKCgoX3RoaXMkdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYW5zbXV4ZXIuZXJyb3IpID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRm91bmQgbm8gbWVkaWEgaW4gZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ2ApO1xuICAgICAgaWYgKGxldmVsLmZyYWdtZW50RXJyb3IgPT09IDApIHtcbiAgICAgICAgLy8gTWFyayBhbmQgdHJhY2sgdGhlIG9kZCBlbXB0eSBzZWdtZW50IGFzIGEgZ2FwIHRvIGF2b2lkIHJlbG9hZGluZ1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlYXNvbjogYEZvdW5kIG5vIG1lZGlhIGluIG1zbiAke2ZyYWcuc259IG9mIGxldmVsIFwiJHtsZXZlbC51cmx9XCJgXG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIC8vIEZvciB0aGlzIGVycm9yIGZhbGx0aHJvdWdoLiBNYXJraW5nIHBhcnNlZCB3aWxsIGFsbG93IGFkdmFuY2luZyB0byBuZXh0IGZyYWdtZW50LlxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTRUQsIHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRUcmFuc211eGVyKCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZWNvdmVyV29ya2VyRXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmV2ZW50ID09PSAnZGVtdXhlcldvcmtlcicpIHtcbiAgICAgIHZhciBfcmVmLCBfdGhpcyRsZXZlbExhc3RMb2FkZWQzLCBfdGhpcyRmcmFnQ3VycmVudDM7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKChfcmVmID0gKF90aGlzJGxldmVsTGFzdExvYWRlZDMgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgIT0gbnVsbCA/IF90aGlzJGxldmVsTGFzdExvYWRlZDMgOiAoX3RoaXMkZnJhZ0N1cnJlbnQzID0gdGhpcy5mcmFnQ3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdDdXJyZW50My5sZXZlbCkgIT0gbnVsbCA/IF9yZWYgOiAwKTtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHRoaXMubG9nKGAke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXIoKSB7XG4gIHJldHVybiBzZWxmLlNvdXJjZUJ1ZmZlciB8fCBzZWxmLldlYktpdFNvdXJjZUJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBjb25zdCBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIGNvbnN0IGlzVHlwZVN1cHBvcnRlZCA9IG1lZGlhU291cmNlICYmIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiYgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fCBzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiAhIWlzVHlwZVN1cHBvcnRlZCAmJiAhIXNvdXJjZUJ1ZmZlclZhbGlkQVBJO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpIHtcbiAgdmFyIF9zb3VyY2VCdWZmZXIkcHJvdG90eTtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiB0eXBlb2YgKHNvdXJjZUJ1ZmZlciA9PSBudWxsID8gdm9pZCAwIDogKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfc291cmNlQnVmZmVyJHByb3RvdHkuY2hhbmdlVHlwZSkgPT09ICdmdW5jdGlvbic7XG59XG5cbi8vIGVuc3VyZSB0aGUgd29ya2VyIGVuZHMgdXAgaW4gdGhlIGJ1bmRsZVxuLy8gSWYgdGhlIHdvcmtlciBzaG91bGQgbm90IGJlIGluY2x1ZGVkIHRoaXMgZ2V0cyBhbGlhc2VkIHRvIGVtcHR5LmpzXG5mdW5jdGlvbiBoYXNVTURXb3JrZXIoKSB7XG4gIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaW5qZWN0V29ya2VyKCkge1xuICBjb25zdCBibG9iID0gbmV3IHNlbGYuQmxvYihbYHZhciBleHBvcnRzPXt9O3ZhciBtb2R1bGU9e2V4cG9ydHM6ZXhwb3J0c307ZnVuY3Rpb24gZGVmaW5lKGYpe2YoKX07ZGVmaW5lLmFtZD10cnVlOygke19fSExTX1dPUktFUl9CVU5ETEVfXy50b1N0cmluZygpfSkodHJ1ZSk7YF0sIHtcbiAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICB9KTtcbiAgY29uc3Qgb2JqZWN0VVJMID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIob2JqZWN0VVJMKTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXIsXG4gICAgb2JqZWN0VVJMXG4gIH07XG59XG5mdW5jdGlvbiBsb2FkV29ya2VyKHBhdGgpIHtcbiAgY29uc3Qgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG4gIHJldHVybiB7XG4gICAgd29ya2VyLFxuICAgIHNjcmlwdFVSTFxuICB9O1xufVxuXG5mdW5jdGlvbiBkdW1teVRyYWNrKHR5cGUgPSAnJywgaW5wdXRUaW1lU2NhbGUgPSA5MDAwMCkge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGUsXG4gICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgIHNhbXBsZXM6IFtdLFxuICAgIGRyb3BwZWQ6IDBcbiAgfTtcbn1cblxuY2xhc3MgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlYXVsdFRpbWVzdGFtcDtcbiAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge31cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIGxldCBsYXN0RGF0YUluZGV4O1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGlkM0RhdGEgPyBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgdGhpcy5iYXNlUFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgdGhpcy5pbml0UFRTKTtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cblxuICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0pO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhblBhcnNlJDIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAvLyBhZnRlciBhIElEMy5jYW5QYXJzZSwgYSBjYWxsIHRvIElEMy5nZXRJRDNEYXRhICpzaG91bGQqIGFsd2F5cyByZXR1cm5zIHNvbWUgZGF0YVxuICAgICAgICBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGggJiYgbGFzdERhdGFJbmRleCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxEYXRhID0gc2xpY2VVaW50OChkYXRhLCBsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBwYXJ0aWFsRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gcGFydGlhbERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFske3RoaXN9XSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25gKSk7XG4gIH1cbiAgZmx1c2godGltZU9mZnNldCkge1xuICAgIC8vIFBhcnNlIGNhY2hlIGluIGNhc2Ugb2YgcmVtYWluaW5nIGZyYW1lcy5cbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kZW11eChjYWNoZWREYXRhLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xuY29uc3QgaW5pdFBUU0ZuID0gKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgaW5pdFBUUykgPT4ge1xuICBpZiAoaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAgKiA5MDtcbiAgfVxuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTID8gaW5pdFBUUy5iYXNlVGltZSAqIDkwMDAwIC8gaW5pdFBUUy50aW1lc2NhbGUgOiAwO1xuICByZXR1cm4gdGltZU9mZnNldCAqIDkwMDAwICsgaW5pdDkwa0h6O1xufTtcblxuLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgbGV0IGFkdHNPYmplY3RUeXBlO1xuICBsZXQgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg7XG4gIGxldCBhZHRzQ2hhbm5lbENvbmZpZztcbiAgbGV0IGNvbmZpZztcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYztcbiAgY29uc3QgYWR0c1NhbXBsaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhjMCkgPj4+IDYpICsgMTtcbiAgY29uc3QgYWR0c1NhbXBsaW5nSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M2MpID4+PiAyO1xuICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPiBhZHRzU2FtcGxpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IHRydWUsXG4gICAgICByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkdHNDaGFubmVsQ29uZmlnID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyO1xuICAvLyBieXRlIDNcbiAgYWR0c0NoYW5uZWxDb25maWcgfD0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweGMwKSA+Pj4gNjtcbiAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSwgQURUUyB0eXBlOiR7YWR0c09iamVjdFR5cGV9LCBzYW1wbGluZ0luZGV4OiR7YWR0c1NhbXBsaW5nSW5kZXh9YCk7XG4gIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH1cbiAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgfSBlbHNlIHtcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgKi9cbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgIGlmIChhdWRpb0NvZGVjICYmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEgfHwgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGluZ0luZGV4ID49IDYpIHtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxIHx8IC92aXZhbGRpL2kudGVzdCh1c2VyQWdlbnQpKSB8fCAhYXVkaW9Db2RlYyAmJiBhZHRzQ2hhbm5lbENvbmZpZyA9PT0gMSkge1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIH1cbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICB9XG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAwOiBOdWxsXG4gICAgMTogQUFDIE1haW5cbiAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICA2OiBBQUMgU2NhbGFibGVcbiAgIHNhbXBsaW5nIGZyZXFcbiAgICAwOiA5NjAwMCBIelxuICAgIDE6IDg4MjAwIEh6XG4gICAgMjogNjQwMDAgSHpcbiAgICAzOiA0ODAwMCBIelxuICAgIDQ6IDQ0MTAwIEh6XG4gICAgNTogMzIwMDAgSHpcbiAgICA2OiAyNDAwMCBIelxuICAgIDc6IDIyMDUwIEh6XG4gICAgODogMTYwMDAgSHpcbiAgICA5OiAxMjAwMCBIelxuICAgIDEwOiAxMTAyNSBIelxuICAgIDExOiA4MDAwIEh6XG4gICAgMTI6IDczNTAgSHpcbiAgICAxMzogUmVzZXJ2ZWRcbiAgICAxNDogUmVzZXJ2ZWRcbiAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgKi9cbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbm5lbENvbmZpZyA8PCAzO1xuICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleFxuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgLy8gYWR0c09iamVjdFR5cGUgKGZvcmNlIHRvIDIsIGNocm9tZSBpcyBjaGVja2luZyB0aGF0IG9iamVjdCB0eXBlIGlzIGxlc3MgdGhhbiA1ID8/P1xuICAgIC8vICAgIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL21lZGlhL2Zvcm1hdHMvbXA0L2FhYy5jY1xuICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgY29uZmlnWzNdID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICBzYW1wbGVyYXRlOiBhZHRzU2FtcGxpbmdSYXRlc1thZHRzU2FtcGxpbmdJbmRleF0sXG4gICAgY2hhbm5lbENvdW50OiBhZHRzQ2hhbm5lbENvbmZpZyxcbiAgICBjb2RlYzogJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlLFxuICAgIG1hbmlmZXN0Q29kZWNcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xufVxuZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDU7XG59XG5mdW5jdGlvbiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGNhblBhcnNlJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZSQxKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgQURUUyBmcmFtZSBmb2xsb3dzIGxhc3QgQURUUyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAoZnJhbWVMZW5ndGggPD0gaGVhZGVyTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyJDEoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbml0VHJhY2tDb25maWcodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LCByYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LCBjaGFubmVsczoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24oc2FtcGxlcmF0ZSkge1xuICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlckxlbmd0aCxcbiAgICAgICAgZnJhbWVMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICBjb25zdCBmcmFtZUR1cmF0aW9uID0gZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBsZXQgdW5pdDtcbiAgaWYgKGhlYWRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYW1lTGVuZ3RoLFxuICAgICAgaGVhZGVyTGVuZ3RoXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBfbGVuZ3RoID0gaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGg7XG4gICAgY29uc3QgbWlzc2luZyA9IE1hdGgubWF4KDAsIG9mZnNldCArIF9sZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShfbGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKTtcbiAgICAgIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBkYXRhLmxlbmd0aCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0ID0gZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIF9sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBfc2FtcGxlID0ge1xuICAgICAgdW5pdCxcbiAgICAgIHB0czogc3RhbXBcbiAgICB9O1xuICAgIGlmICghbWlzc2luZykge1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKF9zYW1wbGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlOiBfc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBfbGVuZ3RoLFxuICAgICAgbWlzc2luZ1xuICAgIH07XG4gIH1cbiAgLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgY29uc3Qgc2FtcGxlID0ge1xuICAgIHVuaXQsXG4gICAgcHRzOiBzdGFtcFxuICB9O1xuICByZXR1cm4ge1xuICAgIHNhbXBsZSxcbiAgICBsZW5ndGgsXG4gICAgbWlzc2luZzogLTFcbiAgfTtcbn1cblxuLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG5jbGFzcyBBQUNEZW11eGVyIGV4dGVuZHMgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICBzdXBlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6ICdhYWMnLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8vIFNvdXJjZSBmb3IgcHJvYmUgaW5mbyAtIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBBRFRTIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIGNvbnN0IGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKHByb2JlJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNhblBhcnNlJDEoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgIGNvbnN0IGZyYW1lID0gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLm1pc3NpbmcgPT09IDApIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1zZ1NjaGVtZVBhdHRlcm4gPSAvXFwvZW1zZ1stL11JRDMvaTtcbmNsYXNzIE1QNERlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLnR4dFRyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge31cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2sgPSBkdW1teVRyYWNrKCd2aWRlbycsIDEpO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLmF1ZGlvVHJhY2sgPSBkdW1teVRyYWNrKCdhdWRpbycsIDEpO1xuICAgIGNvbnN0IGNhcHRpb25UcmFjayA9IHRoaXMudHh0VHJhY2sgPSBkdW1teVRyYWNrKCd0ZXh0JywgMSk7XG4gICAgdGhpcy5pZDNUcmFjayA9IGR1bW15VHJhY2soJ2lkMycsIDEpO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICBjb2RlY1xuICAgICAgfSA9IGluaXREYXRhLnZpZGVvO1xuICAgICAgdmlkZW9UcmFjay5pZCA9IGlkO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgdmlkZW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgY29kZWNcbiAgICAgIH0gPSBpbml0RGF0YS5hdWRpbztcbiAgICAgIGF1ZGlvVHJhY2suaWQgPSBpZDtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBjYXB0aW9uVHJhY2suaWQgPSBSZW11eGVyVHJhY2tJZENvbmZpZy50ZXh0O1xuICAgIHZpZGVvVHJhY2suc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIC8vIGVuc3VyZSB3ZSBmaW5kIGEgbW9vZiBib3ggaW4gdGhlIGZpcnN0IDE2IGtCXG4gICAgZGF0YSA9IGRhdGEubGVuZ3RoID4gMTYzODQgPyBkYXRhLnN1YmFycmF5KDAsIDE2Mzg0KSA6IGRhdGE7XG4gICAgcmV0dXJuIGZpbmRCb3goZGF0YSwgWydtb29mJ10pLmxlbmd0aCA+IDA7XG4gIH1cbiAgZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgLy8gTG9hZCBhbGwgZGF0YSBpbnRvIHRoZSBhdmMgdHJhY2suIFRoZSBDTUFGIHJlbXV4ZXIgd2lsbCBsb29rIGZvciB0aGUgZGF0YSBpbiB0aGUgc2FtcGxlcyBvYmplY3Q7IHRoZSByZXN0IG9mIHRoZSBmaWVsZHMgZG8gbm90IG1hdHRlclxuICAgIGxldCB2aWRlb1NhbXBsZXMgPSBkYXRhO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICBpZiAodGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgIC8vIFNwbGl0IHRoZSBieXRlc3RyZWFtIGludG8gdHdvIHJhbmdlczogb25lIGVuY29tcGFzc2luZyBhbGwgZGF0YSB1cCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbW9vZiwgYW5kIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBndWFyYW50ZWUgdGhhdCB3ZSdyZSBzZW5kaW5nIHZhbGlkIGRhdGEgdG8gTVNFIC0gd2hlbiBkZW11eGluZyBwcm9ncmVzc2l2ZWx5LCB3ZSBoYXZlIG5vIGd1YXJhbnRlZVxuICAgICAgLy8gdGhhdCB0aGUgZmV0Y2ggbG9hZGVyIGdpdmVzIHVzIGZsdXNoIG1vb2YrbWRhdCBwYWlycy4gSWYgd2UgcHVzaCBqYWdnZWQgZGF0YSB0byBNU0UsIGl0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgICB2aWRlb1NhbXBsZXMgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWdtZW50ZWREYXRhID0gc2VnbWVudFZhbGlkUmFuZ2UodmlkZW9TYW1wbGVzKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNlZ21lbnRlZERhdGEucmVtYWluZGVyO1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gc2VnbWVudGVkRGF0YS52YWxpZCB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1NhbXBsZXM7XG4gICAgfVxuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBwYXJzZVNhbXBsZXModGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGhpcy50eHRUcmFja1xuICAgIH07XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgdGltZU9mZnNldCA9IHRoaXMudGltZU9mZnNldDtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRoaXMudGltZU9mZnNldCk7XG4gICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBwYXJzZVNhbXBsZXModGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgfTtcbiAgfVxuICBleHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaztcbiAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZW1zZ3MgPSBmaW5kQm94KHZpZGVvVHJhY2suc2FtcGxlcywgWydlbXNnJ10pO1xuICAgICAgaWYgKGVtc2dzKSB7XG4gICAgICAgIGVtc2dzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICAgICAgY29uc3QgZW1zZ0luZm8gPSBwYXJzZUVtc2coZGF0YSk7XG4gICAgICAgICAgaWYgKGVtc2dTY2hlbWVQYXR0ZXJuLnRlc3QoZW1zZ0luZm8uc2NoZW1lSWRVcmkpKSB7XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBpc0Zpbml0ZU51bWJlcihlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lKSA/IGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUgLyBlbXNnSW5mby50aW1lU2NhbGUgOiB0aW1lT2Zmc2V0ICsgZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZURlbHRhIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gZW1zZ0luZm8uZXZlbnREdXJhdGlvbiA9PT0gMHhmZmZmZmZmZiA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICAvLyBTYWZhcmkgdGFrZXMgYW55dGhpbmcgPD0gMC4wMDEgc2Vjb25kcyBhbmQgbWFwcyBpdCB0byBJbmZpbml0eVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAuMDAxKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5lbXNnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZDNUcmFjaztcbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICB9XG4gIGRlc3Ryb3koKSB7fVxufVxuXG4vKipcbiAqICBNUEVHIHBhcnNlciBoZWxwZXJcbiAqL1xuXG5sZXQgY2hyb21lVmVyc2lvbiQxID0gbnVsbDtcbmNvbnN0IEJpdHJhdGVzTWFwID0gWzMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF07XG5jb25zdCBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcbmNvbnN0IFNhbXBsZXNDb2VmZmljaWVudHMgPSBbXG4vLyBNUEVHIDIuNVxuWzAsXG4vLyBSZXNlcnZlZFxuNzIsXG4vLyBMYXllcjNcbjE0NCxcbi8vIExheWVyMlxuMTIgLy8gTGF5ZXIxXG5dLFxuLy8gUmVzZXJ2ZWRcblswLFxuLy8gUmVzZXJ2ZWRcbjAsXG4vLyBMYXllcjNcbjAsXG4vLyBMYXllcjJcbjAgLy8gTGF5ZXIxXG5dLFxuLy8gTVBFRyAyXG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDFcblswLFxuLy8gUmVzZXJ2ZWRcbjE0NCxcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl1dO1xuXG5jb25zdCBCeXRlc0luU2xvdCA9IFswLFxuLy8gUmVzZXJ2ZWRcbjEsXG4vLyBMYXllcjNcbjEsXG4vLyBMYXllcjJcbjQgLy8gTGF5ZXIxXG5dO1xuXG5mdW5jdGlvbiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICBjb25zdCBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIGNvbnN0IG1wZWdWZXJzaW9uID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAzICYgMztcbiAgY29uc3QgbXBlZ0xheWVyID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAxICYgMztcbiAgY29uc3QgYml0UmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiA0ICYgMTU7XG4gIGNvbnN0IHNhbXBsZVJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMiAmIDM7XG4gIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICBjb25zdCBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICBjb25zdCBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICBjb25zdCBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgY29uc3QgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICBjb25zdCBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICBjb25zdCBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgY29uc3Qgc2FtcGxlQ29lZmZpY2llbnQgPSBTYW1wbGVzQ29lZmZpY2llbnRzW21wZWdWZXJzaW9uXVttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICBjb25zdCBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IE1hdGguZmxvb3Ioc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmdCaXQpICogYnl0ZXNJblNsb3Q7XG4gICAgaWYgKGNocm9tZVZlcnNpb24kMSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiQxID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24kMSAmJiBjaHJvbWVWZXJzaW9uJDEgPD0gODc7XG4gICAgaWYgKG5lZWRDaHJvbWVGaXggJiYgbXBlZ0xheWVyID09PSAyICYmIGJpdFJhdGUgPj0gMjI0MDAwICYmIGNoYW5uZWxNb2RlID09PSAwKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gQ2hyb21pdW0gYnkgc2V0dGluZyBjaGFubmVsTW9kZSB0byBkdWFsLWNoYW5uZWwgKDAxKSBpbnN0ZWFkIG9mIHN0ZXJlbyAoMDApXG4gICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGVSYXRlLFxuICAgICAgY2hhbm5lbENvdW50LFxuICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICBzYW1wbGVzUGVyRnJhbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgY29uc3QgaGVhZGVyU2l6ZSA9IDQ7XG4gIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICBpZiAoaGVhZGVyICE9IG51bGwgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gKi9cblxuY2xhc3MgRXhwR29sb21iIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMud29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGU7XG4gICAgY29uc3Qgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50KSB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMuYnl0ZXNBdmFpbGFibGUgKiA4ICsgdGhpcy5iaXRzQXZhaWxhYmxlKTtcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPDwgMztcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZSkge1xuICAgIGxldCBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICBjb25zdCB2YWx1ID0gdGhpcy53b3JkID4+PiAzMiAtIGJpdHM7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYml0cyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgcmVhZFVFRygpIHtcbiAgICBjb25zdCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKSB7XG4gICAgY29uc3QgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgbGV0IGxhc3RTY2FsZSA9IDg7XG4gICAgbGV0IG5leHRTY2FsZSA9IDg7XG4gICAgbGV0IGRlbHRhU2NhbGU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpIHtcbiAgICBsZXQgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICBsZXQgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIGxldCBzY2FsaW5nTGlzdENvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG4gICAgcmVhZFVCeXRlKCk7XG4gICAgY29uc3QgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgY29uc3QgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGNvbnN0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG5cbiAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcbiAgICBjb25zdCBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGNvbnN0IHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgY29uc3QgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBza2lwQml0cygxKTtcbiAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcblxuICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgIC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICB9XG4gICAgbGV0IHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTgsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE1LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYwLCA5OV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0LCAzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMiwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSxcbiAgICAgIGhlaWdodDogKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfVxuICByZWFkU2xpY2VUeXBlKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICovXG5cbmNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIGtleURhdGEpIHtcbiAgICB0aGlzLmtleURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlEYXRhID0ga2V5RGF0YTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIpO1xuICB9XG5cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gMTYpIHtcbiAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgIC8vIGVuY3J5cHRlZCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSExTX1NhbXBsZV9FbmNyeXB0aW9uL0VuY3J5cHRpb24vRW5jcnlwdGlvbi5odG1sKSxcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlcikudGhlbihkZWNyeXB0ZWRCdWZmZXIgPT4ge1xuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gIGdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgbGV0IG91dHB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH1cbiAgZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IHVpbnQ4RGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgIGxldCBpbnB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KHVpbnQ4RGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuICBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0KSB7XG4gICAgY29uc3QgZGVjb2RlZERhdGEgPSBkaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyKS50aGVuKGRlY3J5cHRlZEJ1ZmZlciA9PiB7XG4gICAgICBjdXJVbml0LmRhdGEgPSB0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGlmIChzYW1wbGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICBpZiAoY3VyVW5pdC5kYXRhLmxlbmd0aCA8PSA0OCB8fCBjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0KTtcbiAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBQQUNLRVRfTEVOR1RIID0gMTg4O1xuY2xhc3MgVFNEZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fYXZjVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl90eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKTtcbiAgICBpZiAoc3luY09mZnNldCA+IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNPZmZzZXQgIT09IC0xO1xuICB9XG4gIHN0YXRpYyBzeW5jT2Zmc2V0KGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgc2NhbndpbmRvdyA9IE1hdGgubWluKFBBQ0tFVF9MRU5HVEggKiA1LCBkYXRhLmxlbmd0aCAtIFBBQ0tFVF9MRU5HVEgpICsgMTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAvLyBhIFRTIGluaXQgc2VnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAyIFRTIHBhY2tldHM6IFBBVCBhbmQgUE1ULCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgICAgbGV0IGZvdW5kUGF0ID0gZmFsc2U7XG4gICAgICBsZXQgcGFja2V0U3RhcnQgPSAtMTtcbiAgICAgIGxldCB0c1BhY2tldHMgPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBsZW5ndGg7IGogKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICBpZiAoZGF0YVtqXSA9PT0gMHg0Nykge1xuICAgICAgICAgIHRzUGFja2V0cysrO1xuICAgICAgICAgIGlmIChwYWNrZXRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhY2tldFN0YXJ0ID0gajtcbiAgICAgICAgICAgIC8vIEZpcnN0IHN5bmMgd29yZCBmb3VuZCBhdCBvZmZzZXQsIGluY3JlYXNlIHNjYW4gbGVuZ3RoICgjNTI1MSlcbiAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBzY2Fud2luZG93ID0gTWF0aC5taW4ocGFja2V0U3RhcnQgKyBQQUNLRVRfTEVOR1RIICogOTksIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICBmb3VuZFBhdCA9IHBhcnNlUElEKGRhdGEsIGopID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICBpZiAoZm91bmRQYXQgJiYgdHNQYWNrZXRzID4gMSAmJiAocGFja2V0U3RhcnQgPT09IDAgJiYgdHNQYWNrZXRzID4gMiB8fCBqICsgUEFDS0VUX0xFTkdUSCA+IHNjYW53aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRzUGFja2V0cykge1xuICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHMgKCM1NTAxKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRyYWNrKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjogdHlwZSA9PT0gJ3ZpZGVvJyB8fCB0eXBlID09PSAnYXVkaW8nID8gJ3ZpZGVvL21wMnQnIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZSxcbiAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqL1xuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0Jyk7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge31cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9hdWRpb1RyYWNrLFxuICAgICAgX2F2Y1RyYWNrLFxuICAgICAgX2lkM1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICBfYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9hdmNUcmFjaykge1xuICAgICAgX2F2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGlzU2FtcGxlQWVzID0gZmFsc2UsIGZsdXNoID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuICAgIGxldCBwZXM7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMuX2F2Y1RyYWNrO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5fdHh0VHJhY2s7XG4gICAgbGV0IGF2Y0lkID0gdmlkZW9UcmFjay5waWQ7XG4gICAgbGV0IGF2Y0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICBsZXQgaWQzSWQgPSBpZDNUcmFjay5waWQ7XG4gICAgbGV0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IHVua25vd25QSUQgPSBudWxsO1xuICAgIGxldCBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZDtcbiAgICBsZXQgcG10SWQgPSB0aGlzLl9wbXRJZDtcbiAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3luY09mZnNldCA9IE1hdGgubWF4KDAsIFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpKTtcbiAgICBsZW4gLT0gKGxlbiAtIHN5bmNPZmZzZXQpICUgUEFDS0VUX0xFTkdUSDtcbiAgICBpZiAobGVuIDwgZGF0YS5ieXRlTGVuZ3RoICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGxlbiwgZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCAtIGxlbik7XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBsZXQgdHNQYWNrZXRFcnJvcnMgPSAwO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBjb25zdCBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgY29uc3QgcGlkID0gcGFyc2VQSUQoZGF0YSwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcblxuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgaWYgKGF0ZiA+IDEpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBVkNQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdmNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkM0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcyk7XG5cbiAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgICAgICBpZiAoYXZjSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50Q29kZWM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1bmtub3duUElEICE9PSBudWxsICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgTVBFRy1UUyBQTVQgZm91bmQgYXQgJHtzdGFydH0gYWZ0ZXIgdW5rbm93biBQSUQgJyR7dW5rbm93blBJRH0nLiBCYWNrdHJhY2tpbmcgdG8gc3luYyBieXRlIEAke3N5bmNPZmZzZXR9IHRvIHBhcnNlIGFsbCBUUyBwYWNrZXRzLmApO1xuICAgICAgICAgICAgICAgIHVua25vd25QSUQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN5bmNPZmZzZXQgLSAxODg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDB4MTE6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRCA9IHBpZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c1BhY2tldEVycm9ycysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHNQYWNrZXRFcnJvcnMgPiAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRm91bmQgJHt0c1BhY2tldEVycm9yc30gVFMgcGFja2V0L3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCAweDQ3YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlkZW9UcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfTtcbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5kZW11eChyZW1haW5kZXJEYXRhLCAtMSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHZpZGVvVHJhY2s6IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2tcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMocmVzdWx0KTtcbiAgICBpZiAodGhpcy5zYW1wbGVBZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQocmVzdWx0LCB0aGlzLnNhbXBsZUFlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IGF2Y0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgbGV0IHBlcztcbiAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCB0cnVlKTtcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgfVxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICE9IG51bGwgJiYgYXVkaW9EYXRhLnNpemUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICB9XG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIGNvbnN0IGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCB0cnVlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIGNvbnN0IHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywga2V5RGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKTtcbiAgfVxuICBkZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2tcbiAgICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsICgpID0+IHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG4gIHBhcnNlQVZDUEVTKHRyYWNrLCB0ZXh0VHJhY2ssIHBlcywgbGFzdCkge1xuICAgIGNvbnN0IHVuaXRzID0gdGhpcy5wYXJzZUFWQ05BTHUodHJhY2ssIHBlcy5kYXRhKTtcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGU7XG4gICAgbGV0IHB1c2g7XG4gICAgbGV0IHNwc2ZvdW5kID0gZmFsc2U7XG4gICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgcGVzLmRhdGEgPSBudWxsO1xuXG4gICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICBpZiAoYXZjU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHZhciBfYXZjU2FtcGxlMjtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgIC8vIE5EUlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGlza2V5ID0gZmFsc2U7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpY2VUeXBlID0gbmV3IEV4cEdvbG9tYihkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBpc2tleSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc2tleSkge1xuICAgICAgICAgICAgICB2YXIgX2F2Y1NhbXBsZTtcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBub24ta2V5ZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUgYXMgYSBrZXlmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICAgIGlmICgoX2F2Y1NhbXBsZSA9IGF2Y1NhbXBsZSkgIT0gbnVsbCAmJiBfYXZjU2FtcGxlLmZyYW1lICYmICFhdmNTYW1wbGUua2V5KSB7XG4gICAgICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IGlza2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBub24ta2V5ZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUgYXMgYSBrZXlmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgaWYgKChfYXZjU2FtcGxlMiA9IGF2Y1NhbXBsZSkgIT0gbnVsbCAmJiBfYXZjU2FtcGxlMi5mcmFtZSAmJiAhYXZjU2FtcGxlLmtleSkge1xuICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bml0LmRhdGEsIDEsIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gU1BTXG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwcyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHNwcyk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtzcHNdO1xuICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjYXJyYXkgPSBzcHMuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICBsZXQgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUFBTXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYXZjU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXRMYXN0TmFsVW5pdChzYW1wbGVzKSB7XG4gICAgdmFyIF9hdmNTYW1wbGUzO1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICBsZXQgbGFzdFVuaXQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKChfYXZjU2FtcGxlMyA9IGF2Y1NhbXBsZSkgIT0gbnVsbCAmJiBfYXZjU2FtcGxlMy51bml0cykge1xuICAgICAgY29uc3QgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFVuaXQ7XG4gIH1cbiAgcGFyc2VBVkNOQUx1KHRyYWNrLCBhcnJheSkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdW5pdHMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBvdmVyZmxvdztcbiAgICBsZXQgdW5pdFR5cGU7XG4gICAgbGV0IGxhc3RVbml0U3RhcnQgPSAtMTtcbiAgICBsZXQgbGFzdFVuaXRUeXBlID0gMDtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgdW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLFxuICAgICAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgaSA8PSA0IC0gbGFzdFN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5zdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLFxuICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgdG1wLnNldChhcnJheSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG4gIHBhcnNlQUFDUEVTKHRyYWNrLCBwZXMpIHtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdztcbiAgICBsZXQgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFtZU1pc3NpbmdCeXRlcyA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHtzYW1wbGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBpZiAoZnJhbWVNaXNzaW5nQnl0ZXMgPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KHNhbXBsZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQsIDApO1xuICAgICAgICB0bXAuc2V0KGRhdGEsIHNhbXBsZUxlbmd0aCk7XG4gICAgICAgIGRhdGEgPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLCBmcmFtZU92ZXJmbG93Qnl0ZXMpO1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjT3ZlckZsb3cuc2FtcGxlKTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgaWYgKG9mZnNldCAhPT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgIGxldCByZWFzb247XG4gICAgICBjb25zdCByZWNvdmVyYWJsZSA9IG9mZnNldCA8IGxlbiAtIDE7XG4gICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ05vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiAke3JlYXNvbn1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGxldmVsUmV0cnk6IHJlY292ZXJhYmxlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICBsZXQgcHRzO1xuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgcHRzID0gYWFjT3ZlckZsb3cuc2FtcGxlLnB0cyArIGZyYW1lRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlTVBFR1BFUyh0cmFjaywgcGVzKSB7XG4gICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBwdHMgPSBwZXMucHRzO1xuICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcykge1xuICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogSUQzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZDNTYW1wbGUgPSBfZXh0ZW5kcyh7fSwgcGVzLCB7XG4gICAgICB0eXBlOiB0aGlzLl9hdmNUcmFjayA/IE1ldGFkYXRhU2NoZW1hLmVtc2cgOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICB9KTtcbiAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goaWQzU2FtcGxlKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQVZDU2FtcGxlKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIGZyYW1lOiBmYWxzZSxcbiAgICBwdHMsXG4gICAgZHRzLFxuICAgIHVuaXRzOiBbXSxcbiAgICBkZWJ1ZyxcbiAgICBsZW5ndGg6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUElEKGRhdGEsIG9mZnNldCkge1xuICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG59XG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xufVxuZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXVkaW86IC0xLFxuICAgIGF2YzogLTEsXG4gICAgaWQzOiAtMSxcbiAgICBzZWdtZW50Q29kZWM6ICdhYWMnXG4gIH07XG4gIGNvbnN0IHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICBjb25zdCB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gIGNvbnN0IHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBvZmZzZXQpO1xuICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ0guMjY0IHdpdGggQUVTLTEyOC1DQkMgc2xpY2UgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDFiOlxuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAweDAzOlxuICAgICAgY2FzZSAweDA0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcgIT09IHRydWUgJiYgdHlwZVN1cHBvcnRlZC5tcDMgIT09IHRydWUpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LnNlZ21lbnRDb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDI0OlxuICAgICAgICBsb2dnZXIud2FybignVW5zdXBwb3J0ZWQgSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCcpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtKSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IGZyYWc7XG4gIGxldCBwZXNMZW47XG4gIGxldCBwZXNIZHJMZW47XG4gIGxldCBwZXNQdHM7XG4gIGxldCBwZXNEdHM7XG4gIGNvbnN0IGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgLy8gc2FmZXR5IGNoZWNrXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICB9XG4gIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICBmcmFnID0gZGF0YVswXTtcbiAgY29uc3QgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xuICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgIC8vIDEgPDwgMjlcbiAgICAgIChmcmFnWzEwXSAmIDB4ZmYpICogNDE5NDMwNCArXG4gICAgICAvLyAxIDw8IDIyXG4gICAgICAoZnJhZ1sxMV0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgIC8vIDEgPDwgMTRcbiAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICtcbiAgICAgIC8vIDEgPDwgN1xuICAgICAgKGZyYWdbMTNdICYgMHhmZSkgLyAyO1xuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAgIC8vIDEgPDwgMjlcbiAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgICAgLy8gMSA8PCAyMlxuICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgICAgLy8gMSA8PCAxNFxuICAgICAgICAoZnJhZ1sxN10gJiAweGZmKSAqIDEyOCArXG4gICAgICAgIC8vIDEgPDwgN1xuICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYCR7TWF0aC5yb3VuZCgocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gKTtcbiAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICBsZXQgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcbiAgICBpZiAoc3RyZWFtLnNpemUgPD0gcGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgIGNvbnN0IHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICBsZXQgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0IC09IGxlbjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgaSArPSBsZW47XG4gICAgfVxuICAgIGlmIChwZXNMZW4pIHtcbiAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiArIDM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBwZXNEYXRhLFxuICAgICAgcHRzOiBwZXNQdHMsXG4gICAgICBkdHM6IHBlc0R0cyxcbiAgICAgIGxlbjogcGVzTGVuXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgYXZjVHJhY2spIHtcbiAgaWYgKGF2Y1NhbXBsZS51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XG4gICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgaWYgKGF2Y1NhbXBsZS5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICBjb25zdCBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgIGF2Y1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgYXZjU2FtcGxlLmR0cyA9IGxhc3RTYW1wbGUuZHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJvcHBpbmcgc2FtcGxlcywgbm8gdGltZXN0YW1wIGZvdW5kXG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBhdmNUcmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgfVxuICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xuICB9XG59XG5cbi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuY2xhc3MgTVAzRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNvZGVjLCBjaGFubmVsQ291bnQpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSxcbiAgICAgIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXVxuICAgIH07XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbaS5jaGFyQ29kZUF0KDApLCBpLmNoYXJDb2RlQXQoMSksIGkuY2hhckNvZGVBdCgyKSwgaS5jaGFyQ29kZUF0KDMpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgY29uc3QgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSwgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICB2aWRlbzogdmlkZW9IZGxyLFxuICAgICAgYXVkaW86IGF1ZGlvSGRsclxuICAgIH07XG4gICAgY29uc3QgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGVudHJ5X2NvdW50XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYyxcbiAgICAvLyBlbnRyeV9zaXplXG4gICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCxcbiAgICAvLyAndXJsJyB0eXBlXG4gICAgMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG5cbiAgICBjb25zdCBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG5cbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHNhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGdyYXBoaWNzbW9kZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuXG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gYmFsYW5jZVxuICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsgLy8gZW50cnlfY291bnRcblxuICAgIGNvbnN0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBjb25zdCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG4gIHN0YXRpYyBib3godHlwZSwgLi4ucGF5bG9hZCkge1xuICAgIGxldCBzaXplID0gODtcbiAgICBsZXQgaSA9IHBheWxvYWQubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IGk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4NTUsIDB4YzQsXG4gICAgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAweDAwLCAweDAwXSkpO1xuICB9XG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1pbmYodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4gIHN0YXRpYyBtb292KHRyYWNrcykge1xuICAgIGxldCBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH1cbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXgsIC4uLmJveGVzXSk7XG4gIH1cbiAgc3RhdGljIG12aGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgLy8gMS4wIHJhdGVcbiAgICAweDAxLCAweDAwLFxuICAgIC8vIDEuMCB2b2x1bWVcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgXSk7XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgbGV0IHNwcyA9IFtdO1xuICAgIGxldCBwcHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgbGVuO1xuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgc3BzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBzcHMucHVzaChsZW4gJiAweGZmKTtcblxuICAgICAgLy8gU1BTXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uXG4gICAgc3BzWzNdLFxuICAgIC8vIHByb2ZpbGVcbiAgICBzcHNbNF0sXG4gICAgLy8gcHJvZmlsZSBjb21wYXRcbiAgICBzcHNbNV0sXG4gICAgLy8gbGV2ZWxcbiAgICAweGZjIHwgMyxcbiAgICAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgIDB4ZTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFt0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocHBzKSkpOyAvLyBcIlBQU1wiXG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdO1xuICAgIGNvbnN0IHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgLy8gaGVpZ2h0XG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLFxuICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAweDAwLCAweDE4LFxuICAgIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksXG4gICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksXG4gICAgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAvLyBoU3BhY2luZ1xuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9XG4gIHN0YXRpYyBlc2RzKHRyYWNrKSB7XG4gICAgY29uc3QgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuXG4gICAgMHgwMyxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDE3ICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZXNfaWRcbiAgICAweDAwLFxuICAgIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgMHgwNCxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDBmICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4NDAsXG4gICAgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsXG4gICAgLy8gc3RyZWFtX3R5cGVcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBhdmdCaXRyYXRlXG5cbiAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfVxuXG4gIHN0YXRpYyBtcDRhKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgIC8vIGNoYW5uZWxjb3VudFxuICAgIDB4MDAsIDB4MTAsXG4gICAgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgIC8vXG4gICAgMHgwMCwgMHgwMF0pLCBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgfVxuICBzdGF0aWMgbXAzKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgIC8vIGNoYW5uZWxjb3VudFxuICAgIDB4MDAsIDB4MTAsXG4gICAgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgIC8vXG4gICAgMHgwMCwgMHgwMF0pKTtcbiAgfVxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRraGQodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGU7XG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDcsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgaWQgPj4gMjQgJiAweGZmLCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gbGF5ZXJcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCAweDAwLCAweDAwLFxuICAgIC8vIHdpZHRoXG4gICAgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgY29uc3Qgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spO1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYgLy8gdHJhY2tfSURcbiAgICBdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArXG4gICAgLy8gdGZoZFxuICAgIDIwICtcbiAgICAvLyB0ZmR0XG4gICAgOCArXG4gICAgLy8gdHJhZiBoZWFkZXJcbiAgICAxNiArXG4gICAgLy8gbWZoZFxuICAgIDggK1xuICAgIC8vIG1vb2YgaGVhZGVyXG4gICAgOCksXG4gICAgLy8gbWRhdCBoZWFkZXJcbiAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgbGVuID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pO1xuICAgIGxldCBpO1xuICAgIGxldCBzYW1wbGU7XG4gICAgbGV0IGR1cmF0aW9uO1xuICAgIGxldCBzaXplO1xuICAgIGxldCBmbGFncztcbiAgICBsZXQgY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFt0cmFjay50eXBlID09PSAndmlkZW8nID8gMHgwMSA6IDB4MDAsXG4gICAgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgMHgwMCwgMHgwZiwgMHgwMSxcbiAgICAvLyBmbGFnc1xuICAgIGxlbiA+Pj4gMjQgJiAweGZmLCBsZW4gPj4+IDE2ICYgMHhmZiwgbGVuID4+PiA4ICYgMHhmZiwgbGVuICYgMHhmZixcbiAgICAvLyBzYW1wbGVfY291bnRcbiAgICBvZmZzZXQgPj4+IDI0ICYgMHhmZiwgb2Zmc2V0ID4+PiAxNiAmIDB4ZmYsIG9mZnNldCA+Pj4gOCAmIDB4ZmYsIG9mZnNldCAmIDB4ZmYgLy8gZGF0YV9vZmZzZXRcbiAgICBdLCAwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbZHVyYXRpb24gPj4+IDI0ICYgMHhmZiwgZHVyYXRpb24gPj4+IDE2ICYgMHhmZiwgZHVyYXRpb24gPj4+IDggJiAweGZmLCBkdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgIHNpemUgPj4+IDI0ICYgMHhmZiwgc2l6ZSA+Pj4gMTYgJiAweGZmLCBzaXplID4+PiA4ICYgMHhmZiwgc2l6ZSAmIDB4ZmYsXG4gICAgICAvLyBzYW1wbGVfc2l6ZVxuICAgICAgZmxhZ3MuaXNMZWFkaW5nIDw8IDIgfCBmbGFncy5kZXBlbmRzT24sIGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2IHwgZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0IHwgZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEgfCBmbGFncy5pc05vblN5bmMsIGZsYWdzLmRlZ3JhZFByaW8gJiAweGYwIDw8IDgsIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBmLFxuICAgICAgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICBjdHMgPj4+IDI0ICYgMHhmZiwgY3RzID4+PiAxNiAmIDB4ZmYsIGN0cyA+Pj4gOCAmIDB4ZmYsIGN0cyAmIDB4ZmYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cbiAgICBjb25zdCBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbk1QNC50eXBlcyA9IHZvaWQgMDtcbk1QNC5IRExSX1RZUEVTID0gdm9pZCAwO1xuTVA0LlNUVFMgPSB2b2lkIDA7XG5NUDQuU1RTQyA9IHZvaWQgMDtcbk1QNC5TVENPID0gdm9pZCAwO1xuTVA0LlNUU1ogPSB2b2lkIDA7XG5NUDQuVk1IRCA9IHZvaWQgMDtcbk1QNC5TTUhEID0gdm9pZCAwO1xuTVA0LlNUU0QgPSB2b2lkIDA7XG5NUDQuRlRZUCA9IHZvaWQgMDtcbk1QNC5ESU5GID0gdm9pZCAwO1xuXG5jb25zdCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjQmFzZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gYmFzZVRpbWUgKiBkZXN0U2NhbGUgKiBzcmNCYXNlOyAvLyBlcXVpdmFsZW50IHRvIGAodmFsdWUgKiBzY2FsZSkgLyAoMSAvIGJhc2UpYFxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZShiYXNlVGltZSwgZGVzdFNjYWxlLCBzcmNTY2FsZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKGJhc2VUaW1lLCByb3VuZCA9IGZhbHNlKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShiYXNlVGltZSwgc3JjU2NhbGUgPSAxKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIDEgLyBzcmNTY2FsZSk7XG59XG5cbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcbmNvbnN0IEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG5jb25zdCBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xubGV0IGNocm9tZVZlcnNpb24gPSBudWxsO1xubGV0IHNhZmFyaVdlYmtpdFZlcnNpb24gPSBudWxsO1xuY2xhc3MgTVA0UmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvciA9ICcnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRQVFMgPSBudWxsO1xuICAgIHRoaXMuX2luaXREVFMgPSBudWxsO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG51bGw7XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBudWxsO1xuICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHt9XG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBpbml0UFRTICYgaW5pdERUUyByZXNldCcpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuICByZXNldE5leHRUaW1lc3RhbXAoKSB7XG4gICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogcmVzZXQgbmV4dCB0aW1lc3RhbXAnKTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogSVNHZW5lcmF0ZWQgZmxhZyByZXNldCcpO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIGxldCByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKChtaW5QVFMsIHNhbXBsZSkgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUHRzKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBUUztcbiAgfVxuICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZsdXNoLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBsZXQgdmlkZW87XG4gICAgbGV0IGF1ZGlvO1xuICAgIGxldCBpbml0U2VnbWVudDtcbiAgICBsZXQgdGV4dDtcbiAgICBsZXQgaWQzO1xuICAgIGxldCBpbmRlcGVuZGVudDtcbiAgICBsZXQgYXVkaW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICBsZXQgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcblxuICAgIC8vIElmIHdlJ3JlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBwcm9ncmVzc2l2ZWx5LCB3YWl0IHVudGlsIHdlJ3ZlIHJlY2VpdmVkIGVub3VnaCBzYW1wbGVzIGZvciBlYWNoIHRyYWNrIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byBzeW5jaHJvbml6ZSB0aGUgYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXMuIFdlIGtub3cgaWYgdGhlIGN1cnJlbnQgc2VnbWVudCB3aWxsIGhhdmUgc2FtcGxlcyBpZiB0aGUgXCJwaWRcIlxuICAgIC8vIHBhcmFtZXRlciBpcyBncmVhdGVyIHRoYW4gLTEuIFRoZSBwaWQgaXMgc2V0IHdoZW4gdGhlIFBNVCBpcyBwYXJzZWQsIHdoaWNoIGNvbnRhaW5zIHRoZSB0cmFja3MgbGlzdC5cbiAgICAvLyBIb3dldmVyLCBpZiB0aGUgaW5pdFNlZ21lbnQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQsIG9yIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBhIHNlZ21lbnQgKGZsdXNoKSxcbiAgICAvLyB0aGVuIHdlIGNhbiByZW11eCBvbmUgdHJhY2sgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb3RoZXIuXG4gICAgY29uc3QgaGFzQXVkaW8gPSBhdWRpb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gdmlkZW9UcmFjay5waWQgPiAtMTtcbiAgICBjb25zdCBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGVub3VnaEF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGVub3VnaFZpZGVvU2FtcGxlcyA9IGZsdXNoICYmIGxlbmd0aCA+IDAgfHwgbGVuZ3RoID4gMTtcbiAgICBjb25zdCBjYW5SZW11eEF2YyA9ICghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJiAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykgfHwgdGhpcy5JU0dlbmVyYXRlZCB8fCBmbHVzaDtcbiAgICBpZiAoY2FuUmVtdXhBdmMpIHtcbiAgICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWaWRlb0NvbnRpZ3VvdXMgPSB0aGlzLmlzVmlkZW9Db250aWd1b3VzO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVJbmRleCA9IC0xO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgIGZpcnN0S2V5RnJhbWVJbmRleCA9IGZpbmRLZXlmcmFtZUluZGV4KHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgIGlmICghaXNWaWRlb0NvbnRpZ3VvdXMgJiYgdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSkge1xuICAgICAgICAgIGluZGVwZW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtcmVtdXhlcl06IERyb3BwZWQgJHtmaXJzdEtleUZyYW1lSW5kZXh9IG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lYCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9ICh2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gc3RhcnRQVFMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1yZW11eGVyXTogTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzYCk7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHRzRGVsdGEgPSBub3JtYWxpemVQdHMoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cywgc3RhcnRQVFMpIC0gc3RhcnRQVFM7XG4gICAgICAgICAgY29uc3QgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgYXVkaW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXVkaW8gPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCB0aGlzLmlzQXVkaW9Db250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcyB8fCBwbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPID8gdmlkZW9UaW1lT2Zmc2V0IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW8gPyBhdWRpby5lbmRQVFMgLSBhdWRpby5zdGFydFBUUyA6IDA7XG4gICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGZpcnN0S2V5RnJhbWVJbmRleCAhPT0gLTE7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA9IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUykge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudCxcbiAgICAgIHRleHQsXG4gICAgICBpZDNcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGNvbnN0IF9pbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgbGV0IGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIGxldCBpbml0UFRTO1xuICAgIGxldCBpbml0RFRTO1xuICAgIGxldCB0aW1lc2NhbGU7XG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHN0YXJ0UFRTIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0RFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0RFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0UFRTID0gdGltZXNjYWxlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2tzLFxuICAgICAgICBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgIGxldCBvZmZzZXQgPSA4O1xuICAgIGxldCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZmlyc3REVFM7XG4gICAgbGV0IGxhc3REVFM7XG4gICAgbGV0IG1pblBUUyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4UFRTID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBzb3J0U2FtcGxlcyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXZjRHRzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgY29uc3QgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTtcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgIG5leHRBdmNEdHMgPSBwdHMgLSBjdHM7XG4gICAgfVxuXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICBjb25zdCBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0VGltZSwgbmV4dEF2Y0R0cyk7XG4gICAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0VGltZSwgbmV4dEF2Y0R0cyk7XG4gICAgICBpZiAoc2FtcGxlLmR0cyA8IGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzKSB7XG4gICAgICAgIHNvcnRTYW1wbGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICBpZiAoc29ydFNhbXBsZXMpIHtcbiAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcbiAgICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgICByZXR1cm4gZGVsdGFkdHMgfHwgZGVsdGFwdHM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgZmlyc3QvbGFzdCBEVFNcbiAgICBmaXJzdERUUyA9IGlucHV0U2FtcGxlc1swXS5kdHM7XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV0uZHRzO1xuXG4gICAgLy8gU2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXG4gICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICBjb25zdCBpbnB1dER1cmF0aW9uID0gbGFzdERUUyAtIGZpcnN0RFRTO1xuICAgIGNvbnN0IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA9IGlucHV0RHVyYXRpb24gPyBNYXRoLnJvdW5kKGlucHV0RHVyYXRpb24gLyAobmJTYW1wbGVzIC0gMSkpIDogbXA0U2FtcGxlRHVyYXRpb24gfHwgdHJhY2suaW5wdXRUaW1lU2NhbGUgLyAzMDtcblxuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIGNvbnN0IGRlbHRhID0gZmlyc3REVFMgLSBuZXh0QXZjRHRzO1xuICAgICAgY29uc3QgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICBjb25zdCBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuICAgICAgaWYgKGZvdW5kSG9sZSB8fCBmb3VuZE92ZXJsYXApIHtcbiAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBVkM6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zICgke2RlbHRhfWR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBVkM6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jaygtZGVsdGEsIHRydWUpfSBtcyAoJHtkZWx0YX1kdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZE92ZXJsYXAgfHwgbmV4dEF2Y0R0cyA+PSBpbnB1dFNhbXBsZXNbMF0ucHRzKSB7XG4gICAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UFRTID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGRlbHRhO1xuICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgVmlkZW86IEZpcnN0IFBUUy9EVFMgYWRqdXN0ZWQ6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdFBUUywgdHJ1ZSl9LyR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdERUUywgdHJ1ZSl9LCBkZWx0YTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICBsZXQgbmJOYWx1ID0gMDtcbiAgICBsZXQgbmFsdUxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCB1bml0cyA9IHNhbXBsZS51bml0cztcbiAgICAgIGNvbnN0IG5iVW5pdHMgPSB1bml0cy5sZW5ndGg7XG4gICAgICBsZXQgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuXG4gICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgIHNhbXBsZS5kdHMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCBmaXJzdERUUyk7XG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihzYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgbWF4UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgY29uc3QgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgbGV0IG1kYXQ7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgbGV0IHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgIGxldCBtaW5EdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heER0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxldCBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgY29uc3QgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW2pdO1xuICAgICAgICBjb25zdCB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgY29uc3QgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgIGxldCBwdHNEZWx0YTtcbiAgICAgIGlmIChpIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cyAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbGFzdEZyYW1lRHVyYXRpb24gPSBpID4gMCA/IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLmR0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcHRzRGVsdGEgPSBpID4gMCA/IGF2Y1NhbXBsZS5wdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrICYmIHRoaXMubmV4dEF1ZGlvUHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgIGNvbnN0IGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoY29uZmlnLm1heEJ1ZmZlckhvbGUgKiB0aW1lU2NhbGUpO1xuICAgICAgICAgIGNvbnN0IGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZXRjaGVkTGFzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coYFttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQgLyA5MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbiAvIDkwfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xuICAgICAgbWluRHRzRGVsdGEgPSBNYXRoLm1pbihtaW5EdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWF4RHRzRGVsdGEgPSBNYXRoLm1heChtYXhEdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWluUHRzRGVsdGEgPSBNYXRoLm1pbihtaW5QdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgbWF4UHRzRGVsdGEgPSBNYXRoLm1heChtYXhQdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUoYXZjU2FtcGxlLmtleSwgbXA0U2FtcGxlRHVyYXRpb24sIG1wNFNhbXBsZUxlbmd0aCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgaWYgKGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24gPCA3MCkge1xuICAgICAgICAgIC8vIENocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgKGtleWZyYW1lKSB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICAgIGNvbnN0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbikge1xuICAgICAgICAvLyBGaXggZm9yIFwiQ05OIHNwZWNpYWwgcmVwb3J0LCB3aXRoIENDXCIgaW4gdGVzdC1zdHJlYW1zIChTYWZhcmkgYnJvd3NlciBvbmx5KVxuICAgICAgICAvLyBJZ25vcmUgRFRTIHdoZW4gZnJhbWUgZHVyYXRpb25zIGFyZSBpcnJlZ3VsYXIuIFNhZmFyaSBNU0UgZG9lcyBub3QgaGFuZGxlIHRoaXMgbGVhZGluZyB0byBnYXBzLlxuICAgICAgICBpZiAobWF4UHRzRGVsdGEgLSBtaW5QdHNEZWx0YSA8IG1heER0c0RlbHRhIC0gbWluRHRzRGVsdGEgJiYgYXZlcmFnZVNhbXBsZUR1cmF0aW9uIC8gbWF4RHRzRGVsdGEgPCAwLjAyNSAmJiBvdXRwdXRTYW1wbGVzWzBdLmN0cyA9PT0gMCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdGb3VuZCBpcnJlZ3VsYXIgZ2FwcyBpbiBzYW1wbGUgZHVyYXRpb24uIFVzaW5nIFBUUyBpbnN0ZWFkIG9mIERUUyB0byBkZXRlcm1pbmUgTVA0IHNhbXBsZSBkdXJhdGlvbi4nKTtcbiAgICAgICAgICBsZXQgZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG91dHB1dFNhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHREdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tpXS5jdHM7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFB0cyA9IG5leHREdHMgKyBvdXRwdXRTYW1wbGVzW2kgKyAxXS5jdHM7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb24gPSBuZXh0UHRzIC0gcHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IGkgPyBvdXRwdXRTYW1wbGVzW2kgLSAxXS5kdXJhdGlvbiA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uY3RzID0gMDtcbiAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gc3RyZXRjaGVkTGFzdEZyYW1lIHx8ICFtcDRTYW1wbGVEdXJhdGlvbiA/IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA6IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgY29uc3QgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG4gICAgY29uc3QgdHlwZSA9ICd2aWRlbyc7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogbWluUFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobWF4UFRTICsgbXA0U2FtcGxlRHVyYXRpb24pIC8gdGltZVNjYWxlLFxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kRFRTOiBuZXh0QXZjRHRzIC8gdGltZVNjYWxlLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiBmYWxzZSxcbiAgICAgIGhhc1ZpZGVvOiB0cnVlLFxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgZHJvcHBlZDogdHJhY2suZHJvcHBlZFxuICAgIH07XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdmlkZW9UaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnID8gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FIDogTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IHJhd01QRUcgPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGlnbmVkV2l0aFZpZGVvID0gdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgbGV0IG9mZnNldCA9IHJhd01QRUcgPyAwIDogODtcbiAgICBsZXQgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMgfHwgLTE7XG5cbiAgICAvLyB3aW5kb3cuYXVkaW9TYW1wbGVzID8gd2luZG93LmF1ZGlvU2FtcGxlcy5wdXNoKGlucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cykpIDogKHdpbmRvdy5hdWRpb1NhbXBsZXMgPSBbaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKV0pO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuICAgIGNvbnN0IHRpbWVPZmZzZXRNcGVnVFMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5pdFRpbWUgPSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9IGNvbnRpZ3VvdXMgfHwgaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgPiAwICYmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldE1wZWdUUyAtIG5leHRBdWRpb1B0cykgPCA5MDAwIHx8IE1hdGguYWJzKG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0ucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpIC0gbmV4dEF1ZGlvUHRzKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgIH0pO1xuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXVkaW9QdHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihzYW1wbGUgPT4gc2FtcGxlLnB0cyA+PSAwKTtcblxuICAgICAgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcbiAgICAgIGlmICghaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gMCB0byBtYXRjaCB2aWRlbyBzbyB0aGF0IHN0YXJ0IGdhcHMgbGFyZ2VyIHRoYW4gaW5wdXRTYW1wbGVEdXJhdGlvbiBhcmUgZmlsbGVkIHdpdGggc2lsZW5jZVxuICAgICAgICBuZXh0QXVkaW9QdHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gTWF0aC5tYXgoMCwgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBmcmFncyBhcmUgbm90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IGlucHV0U2FtcGxlc1swXS5wdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBjb25zdCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIFdoZW4gcmVtdXhpbmcgd2l0aCB2aWRlbywgaWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGUgdG8gc3RheSBpbiBzeW5jXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW8gZnJhbWUgQCAkeyhwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIG92ZXJsYXBzIG5leHRBdWRpb1B0cyBieSAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcy5gKTtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAvLyA0OiByZW11eGluZyB3aXRoIHZpZGVvICh2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICBsZXQgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cbiAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaWYgKG5leHRQdHMgPCAwKSB7XG4gICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci53YXJuKGBbbXA0LXJlbXV4ZXJdOiBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YW1wID0gTWF0aC5tYXgobmV4dFB0cywgMCk7XG4gICAgICAgICAgICBsZXQgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgIHB0czogbmV3U3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmlyc3RQVFMgPSBudWxsO1xuICAgIGxldCBsYXN0UFRTID0gbnVsbDtcbiAgICBsZXQgbWRhdDtcbiAgICBsZXQgbWRhdFNpemUgPSAwO1xuICAgIGxldCBzYW1wbGVMZW5ndGggPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIHdoaWxlIChzYW1wbGVMZW5ndGgtLSkge1xuICAgICAgbWRhdFNpemUgKz0gaW5wdXRTYW1wbGVzW3NhbXBsZUxlbmd0aF0udW5pdC5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMCwgX25iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBfbmJTYW1wbGVzOyBqKyspIHtcbiAgICAgIGNvbnN0IGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgY29uc3QgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XG4gICAgICBsZXQgcHRzID0gYXVkaW9TYW1wbGUucHRzO1xuICAgICAgaWYgKGxhc3RQVFMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgc2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgc2FtcGxlIHRvIHRoZSBcInJlYWxcIiBkdXJhdGlvbjsgdGhlIFBUUyBkaWZmIHdpdGhcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgICBjb25zdCBwcmV2U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tqIC0gMV07XG4gICAgICAgIHByZXZTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChwdHMgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgIGZpcnN0UFRTID0gcHRzO1xuICAgICAgICBpZiAobWRhdFNpemUgPiAwKSB7XG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgbWRhdFNpemUgKz0gb2Zmc2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgY29uc3QgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuXG4gICAgLy8gV2UgY291bGQgZW5kIHVwIHdpdGggbm8gYXVkaW8gc2FtcGxlcyBpZiBhbGwgaW5wdXQgc2FtcGxlcyB3ZXJlIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByZXZpb3VzbHkgcmVtdXhlZCBvbmVzXG4gICAgY29uc3QgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlLmR1cmF0aW9uO1xuXG4gICAgLy8gU2V0IHRoZSB0cmFjayBzYW1wbGVzIGZyb20gaW5wdXRTYW1wbGVzIHRvIG91dHB1dFNhbXBsZXMgYmVmb3JlIHJlbXV4aW5nXG4gICAgY29uc3QgbW9vZiA9IHJhd01QRUcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcblxuICAgIC8vIENsZWFyIHRoZSB0cmFjayBzYW1wbGVzLiBUaGlzIGFsc28gY2xlYXJzIHRoZSBzYW1wbGVzIGFycmF5IGluIHRoZSBkZW11eGVyLCBzaW5jZSB0aGUgcmVmZXJlbmNlIGlzIHNoYXJlZFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgdHlwZSA9ICdhdWRpbyc7XG4gICAgY29uc3QgYXVkaW9EYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgIGVuZFBUUzogZW5kLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICBuYjogbmJTYW1wbGVzXG4gICAgfTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICByZXR1cm4gYXVkaW9EYXRhO1xuICB9XG4gIHJlbXV4RW1wdHlBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XG4gICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgY29uc3QgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG4gICAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdERUUy5iYXNlVGltZSAqIDkwMDAwIC8gaW5pdERUUy50aW1lc2NhbGU7XG4gICAgY29uc3Qgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSBudWxsID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgaW5pdDkwa0h6O1xuICAgIGNvbnN0IGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIGluaXQ5MGtIejtcbiAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgIGNvbnN0IG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbik7XG4gICAgLy8gc2lsZW50IGZyYW1lXG4gICAgY29uc3Qgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIGxvZ2dlci50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhbXBsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICB1bml0OiBzaWxlbnRGcmFtZSxcbiAgICAgICAgcHRzOiBzdGFtcCxcbiAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHJldHVybiB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUHRzKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdERUUykge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0RFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0RFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIHRyYWNrLnNhbXBsZXMuc29ydCgoYSwgYikgPT4gYS5wdHMgLSBiLnB0cyk7XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuY2xhc3MgTXA0U2FtcGxlIHtcbiAgY29uc3RydWN0b3IoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuY3RzID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jdHMgPSBjdHM7XG4gICAgdGhpcy5mbGFncyA9IG5ldyBNcDRTYW1wbGVGbGFncyhpc0tleWZyYW1lKTtcbiAgfVxufVxuY2xhc3MgTXA0U2FtcGxlRmxhZ3Mge1xuICBjb25zdHJ1Y3Rvcihpc0tleWZyYW1lKSB7XG4gICAgdGhpcy5pc0xlYWRpbmcgPSAwO1xuICAgIHRoaXMuaXNEZXBlbmRlZE9uID0gMDtcbiAgICB0aGlzLmhhc1JlZHVuZGFuY3kgPSAwO1xuICAgIHRoaXMuZGVncmFkUHJpbyA9IDA7XG4gICAgdGhpcy5kZXBlbmRzT24gPSAxO1xuICAgIHRoaXMuaXNOb25TeW5jID0gMTtcbiAgICB0aGlzLmRlcGVuZHNPbiA9IGlzS2V5ZnJhbWUgPyAyIDogMTtcbiAgICB0aGlzLmlzTm9uU3luYyA9IGlzS2V5ZnJhbWUgPyAwIDogMTtcbiAgfVxufVxuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRQVFMgPSBudWxsO1xuICAgIHRoaXMuaW5pdFRyYWNrcyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge31cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpIHtcbiAgICB0aGlzLmluaXRQVFMgPSBkZWZhdWx0SW5pdFBUUztcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuICByZXNldE5leHRUaW1lc3RhbXAoKSB7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KHBhdGNoRW5jeXB0aW9uRGF0YShpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpKTtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IHRydWU7XG4gIH1cbiAgZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIGxldCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlY1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkpIHtcbiAgICAgIHRoaXMuaW5pdFRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW5pdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuXG4gICAgLy8gR2V0IGNvZGVjIGZyb20gaW5pdFNlZ21lbnQgb3IgZmFsbGJhY2sgdG8gZGVmYXVsdFxuICAgIGlmICghYXVkaW9Db2RlYykge1xuICAgICAgYXVkaW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoaW5pdERhdGEuYXVkaW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgfVxuICAgIGlmICghdmlkZW9Db2RlYykge1xuICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoaW5pdERhdGEudmlkZW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXI6ICdhdWRpby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnYXVkaW8nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBpbml0U2VnbWVudCBkb2VzIG5vdCBjb250YWluIG1vb3Ygb3IgdHJhayBib3hlcy4nKTtcbiAgICB9XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdHJhY2tzO1xuICB9XG4gIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIHZhciBfaW5pdERhdGEsIF9pbml0RGF0YTI7XG4gICAgbGV0IHtcbiAgICAgIGluaXRQVFMsXG4gICAgICBsYXN0RW5kVGltZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICB2aWRlbzogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGV4dFRyYWNrLFxuICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgIGluaXRTZWdtZW50OiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgIC8vIGxhc3RFbmREVFMgb3ZlciB0aW1lT2Zmc2V0IHdoZW5ldmVyIHBvc3NpYmxlOyBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGxheWJhY2ssIHRoZSBtZWRpYSBzb3VyY2Ugd2lsbCBub3QgdXBkYXRlXG4gICAgLy8gdGhlIG1lZGlhIGR1cmF0aW9uICh3aGljaCBpcyB3aGF0IHRpbWVPZmZzZXQgaXMgcHJvdmlkZWQgYXMpIGJlZm9yZSB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5leHQgY2h1bmsuXG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihsYXN0RW5kVGltZSkpIHtcbiAgICAgIGxhc3RFbmRUaW1lID0gdGhpcy5sYXN0RW5kVGltZSA9IHRpbWVPZmZzZXQgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgYmluYXJ5IHNlZ21lbnQgZGF0YSBpcyBhZGRlZCB0byB0aGUgdmlkZW9UcmFjayBpbiB0aGUgbXA0ZGVtdXhlci4gV2UgZG9uJ3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBkYXRhIGlzIG9ubHlcbiAgICAvLyBhdWRpbyBvciB2aWRlbyAob3IgYm90aCk7IGFkZGluZyBpdCB0byB2aWRlbyB3YXMgYW4gYXJiaXRyYXJ5IGNob2ljZS5cbiAgICBjb25zdCBkYXRhID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGlmICghKGRhdGEgIT0gbnVsbCAmJiBkYXRhLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGluaXRTZWdtZW50ID0ge1xuICAgICAgaW5pdFBUUzogdW5kZWZpbmVkLFxuICAgICAgdGltZXNjYWxlOiAxXG4gICAgfTtcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIGlmICghKChfaW5pdERhdGEgPSBpbml0RGF0YSkgIT0gbnVsbCAmJiBfaW5pdERhdGEubGVuZ3RoKSkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KGRhdGEpO1xuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIH1cbiAgICBpZiAoISgoX2luaXREYXRhMiA9IGluaXREYXRhKSAhPSBudWxsICYmIF9pbml0RGF0YTIubGVuZ3RoKSkge1xuICAgICAgLy8gV2UgY2FuJ3QgcmVtdXggaWYgdGhlIGluaXRTZWdtZW50IGNvdWxkIG5vdCBiZSBnZW5lcmF0ZWRcbiAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IEZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzO1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBnZXREdXJhdGlvbihkYXRhLCBpbml0RGF0YSk7XG4gICAgY29uc3Qgc3RhcnREVFMgPSBnZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgY29uc3QgZGVjb2RlVGltZSA9IHN0YXJ0RFRTID09PSBudWxsID8gdGltZU9mZnNldCA6IHN0YXJ0RFRTO1xuICAgIGlmIChpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIGRlY29kZVRpbWUsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB8fCBpbml0U2VnbWVudC50aW1lc2NhbGUgIT09IGluaXRQVFMudGltZXNjYWxlICYmIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGRlY29kZVRpbWUgLSB0aW1lT2Zmc2V0O1xuICAgICAgaWYgKGluaXRQVFMgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IDEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYEFkanVzdGluZyBpbml0UFRTIGJ5ICR7aW5pdFNlZ21lbnQuaW5pdFBUUyAtIGluaXRQVFMuYmFzZVRpbWV9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFNlZ21lbnQuaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlOiAxXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBhdWRpb1RyYWNrID8gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSA6IGxhc3RFbmRUaW1lO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICBvZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSwgaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlKTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmxhc3RFbmRUaW1lID0gZW5kVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0F1ZGlvID0gISFpbml0RGF0YS5hdWRpbztcbiAgICBjb25zdCBoYXNWaWRlbyA9ICEhaW5pdERhdGEudmlkZW87XG4gICAgbGV0IHR5cGUgPSAnJztcbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG4gICAgaWYgKGhhc1ZpZGVvKSB7XG4gICAgICB0eXBlICs9ICd2aWRlbyc7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICBzdGFydFBUUzogc3RhcnRUaW1lLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgIGVuZERUUzogZW5kVGltZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbyxcbiAgICAgIGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gdHJhY2sudHlwZSAhPT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC5pbml0U2VnbWVudCA9IGluaXRTZWdtZW50O1xuICAgIHJlc3VsdC5pZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdFBUUyk7XG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIHN0YXJ0RFRTLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikge1xuICBpZiAoaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEluaXRQVFMgaXMgaW52YWxpZCB3aGVuIGRpc3RhbmNlIGZyb20gcHJvZ3JhbSB3b3VsZCBiZSBtb3JlIHRoYW4gc2VnbWVudCBkdXJhdGlvbiBvciBhIG1pbmltdW0gb2Ygb25lIHNlY29uZFxuICBjb25zdCBtaW5EdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCAxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnREVFMgLSBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gIHJldHVybiBNYXRoLmFicyhzdGFydFRpbWUgLSB0aW1lT2Zmc2V0KSA+IG1pbkR1cmF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0UGFyc2VkVHJhY2tDb2RlYyh0cmFjaywgdHlwZSkge1xuICBjb25zdCBwYXJzZWRDb2RlYyA9IHRyYWNrID09IG51bGwgPyB2b2lkIDAgOiB0cmFjay5jb2RlYztcbiAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjLmxlbmd0aCA+IDQpIHtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gIH1cbiAgLy8gU2luY2UgbXA0LXRvb2xzIGNhbm5vdCBwYXJzZSBmdWxsIGNvZGVjIHN0cmluZyAoc2VlICdUT0RPOiBQYXJzZSBjb2RlYyBkZXRhaWxzJy4uLiBpbiBtcDQtdG9vbHMpXG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLjYuTDEyMC45MCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG4gIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2F2YzEnIHx8IHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgIHJldHVybiAnYXZjMS40MmUwMWUnO1xuICB9XG4gIHJldHVybiAnbXA0YS40MC41Jztcbn1cblxubGV0IG5vdztcbi8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxudHJ5IHtcbiAgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKTtcbn0gY2F0Y2ggKGVycikge1xuICBsb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgbm93ID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuRGF0ZS5ub3c7XG59XG5jb25zdCBtdXhDb25maWcgPSBbe1xuICBkZW11eDogTVA0RGVtdXhlcixcbiAgcmVtdXg6IFBhc3NUaHJvdWdoUmVtdXhlclxufSwge1xuICBkZW11eDogVFNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufSwge1xuICBkZW11eDogQUFDRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IE1QM0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59XTtcbmNsYXNzIFRyYW5zbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKSB7XG4gICAgdGhpcy5hc3luYyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudmVuZG9yID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2JlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbiAgY29uZmlndXJlKHRyYW5zbXV4Q29uZmlnKSB7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHRyYW5zbXV4Q29uZmlnO1xuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuICAgIGxldCB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgdHJhbnNtdXhDb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGlndW91cyxcbiAgICAgIGRpc2NvbnRpbnVpdHksXG4gICAgICB0cmFja1N3aXRjaCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBpbml0U2VnbWVudENoYW5nZVxuICAgIH0gPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlZmF1bHRJbml0UHRzLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBpbml0U2VnbWVudERhdGFcbiAgICB9ID0gdHJhbnNtdXhDb25maWc7XG4gICAgY29uc3Qga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgY29uc3QgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTtcbiAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgc3luY2hyb25vdXM7IHdlYkNyeXB0byBpcyBub3RcbiAgICAgIGlmIChkZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAgICAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgICAgICAgbGV0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuc29mdHdhcmVEZWNyeXB0KHVpbnREYXRhLCBrZXlEYXRhLmtleS5idWZmZXIsIGtleURhdGEuaXYuYnVmZmVyKTtcbiAgICAgICAgLy8gRm9yIExvdy1MYXRlbmN5IEhMUyBQYXJ0cywgZGVjcnlwdCBpbiBwbGFjZSwgc2luY2UgcGFydCBwYXJzaW5nIGlzIGV4cGVjdGVkIG9uIHB1c2ggcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcikudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHB1c2ggaGVyZSBpcyBpbXBvcnRhbnQ7IGlmIGZsdXNoKCkgaXMgY2FsbGVkIHdoaWxlIHRoaXMgaXMgc3RpbGwgcmVzb2x2aW5nLCB0aGlzIGVuc3VyZXMgdGhhdFxuICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSk7XG4gICAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRpb25Qcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNldE11eGVycyA9IHRoaXMubmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKTtcbiAgICBpZiAocmVzZXRNdXhlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jb25maWd1cmVUcmFuc211eGVyKHVpbnREYXRhKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihgW3RyYW5zbXV4ZXJdICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoIHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJhbnNtdXgodWludERhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGN1cnJlbnRTdGF0ZS5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgZGVjcnlwdGVyLFxuICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICBkZWNyeXB0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChkZWNyeXB0aW9uUHJvbWlzZSkge1xuICAgICAgLy8gVXBvbiByZXNvbHV0aW9uLCB0aGUgZGVjcnlwdGlvbiBwcm9taXNlIGNhbGxzIHB1c2goKSBhbmQgcmV0dXJucyBpdHMgVHJhbnNtdXhlclJlc3VsdCB1cCB0aGUgc3RhY2suIFRoZXJlZm9yZVxuICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgcmV0dXJuIGRlY3J5cHRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mbHVzaChjaHVua01ldGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2godGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIHRoZW4gSGxzLmpzIGhhcyBiZWVuIGdpdmVuIGNvbnRlbnQgaXRzIG5vdCBhYmxlIHRvIGhhbmRsZVxuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICB9XG4gICAgY29uc3QgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuICAgIGlmIChpc1Byb21pc2UoZGVtdXhSZXN1bHRPclByb21pc2UpKSB7XG4gICAgICAvLyBEZWNyeXB0IGZpbmFsIFNBTVBMRS1BRVMgc2FtcGxlc1xuICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0T3JQcm9taXNlLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdE9yUHJvbWlzZSwgY2h1bmtNZXRhKTtcbiAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICB9XG4gIGZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFja1xuICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0XG4gICAgfSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgbG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSR7Y2h1bmtNZXRhLnBhcnQgPiAtMSA/ICcgcDogJyArIGNodW5rTWV0YS5wYXJ0IDogJyd9IG9mIGxldmVsICR7Y2h1bmtNZXRhLmxldmVsfWApO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJ1ZSwgdGhpcy5pZCk7XG4gICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9KTtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICB9XG4gIHJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIHJlbXV4ZXIucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24sIGRlY3J5cHRkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgdHJhbnNtdXgoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IHRoaXMuZGVtdXhlci5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9O1xuICB9XG4gIHRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoZGVtdXhSZXN1bHQuYXVkaW9UcmFjaywgZGVtdXhSZXN1bHQudmlkZW9UcmFjaywgZGVtdXhSZXN1bHQuaWQzVHJhY2ssIGRlbXV4UmVzdWx0LnRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgdHlwZVN1cHBvcnRlZCxcbiAgICAgIHZlbmRvclxuICAgIH0gPSB0aGlzO1xuICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICBsZXQgbXV4O1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChtdXhDb25maWdbaV0uZGVtdXgucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBjb25zdCBSZW11eGVyID0gbXV4LnJlbXV4O1xuICAgIGNvbnN0IERlbXV4ZXIgPSBtdXguZGVtdXg7XG4gICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgUmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpO1xuICAgIH1cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfVxuICB9XG4gIG5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICB9XG4gIGdldERlY3J5cHRlcigpIHtcbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNyeXB0ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25UeXBlKGRhdGEsIGRlY3J5cHREYXRhKSB7XG4gIGxldCBlbmNyeXB0aW9uVHlwZSA9IG51bGw7XG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICE9IG51bGwgJiYgZGVjcnlwdERhdGEuaXYgIT09IG51bGwgJiYgZGVjcnlwdERhdGEubWV0aG9kICE9IG51bGwpIHtcbiAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhO1xuICB9XG4gIHJldHVybiBlbmNyeXB0aW9uVHlwZTtcbn1cbmNvbnN0IGVtcHR5UmVzdWx0ID0gY2h1bmtNZXRhID0+ICh7XG4gIHJlbXV4UmVzdWx0OiB7fSxcbiAgY2h1bmtNZXRhXG59KTtcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAndGhlbicgaW4gcCAmJiBwLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmNsYXNzIFRyYW5zbXV4Q29uZmlnIHtcbiAgY29uc3RydWN0b3IoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQdHMpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSBpbml0U2VnbWVudERhdGE7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cyB8fCBudWxsO1xuICB9XG59XG5jbGFzcyBUcmFuc211eFN0YXRlIHtcbiAgY29uc3RydWN0b3IoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbiAgfVxufVxuXG52YXIgZXZlbnRlbWl0dGVyMyA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblx0ICAsIHByZWZpeCA9ICd+JztcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cblx0ICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gRXZlbnRzKCkge31cblxuXHQvL1xuXHQvLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuXHQvLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cblx0Ly8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcblx0Ly8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG5cdC8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuXHQvL1xuXHRpZiAoT2JqZWN0LmNyZWF0ZSkge1xuXHQgIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdCAgLy9cblx0ICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuXHQgIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG5cdCAgLy9cblx0ICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICB0aGlzLmZuID0gZm47XG5cdCAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0ICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG5cdCAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0ICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuXHQgIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG5cdCAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG5cdCAgcmV0dXJuIGVtaXR0ZXI7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG5cdCAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcblx0ICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG5cdCAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0ICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdCAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG5cdCAqIGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuXHQgIHZhciBuYW1lcyA9IFtdXG5cdCAgICAsIGV2ZW50c1xuXHQgICAgLCBuYW1lO1xuXG5cdCAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cblx0ICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcblx0ICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcblx0ICB9XG5cblx0ICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHQgICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuXHQgIH1cblxuXHQgIHJldHVybiBuYW1lcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuXHQgICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdCAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuXHQgIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcblx0ICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuXHQgICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHQgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcblx0ICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcblx0ICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHQgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuXHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuXHQgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG5cdCAgICAsIGFyZ3Ncblx0ICAgICwgaTtcblxuXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHtcblx0ICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdCAgICBzd2l0Y2ggKGxlbikge1xuXHQgICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG5cdCAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG5cdCAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuXHQgICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG5cdCAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG5cdCAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgIH1cblxuXHQgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcblx0ICAgICAgLCBqO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0ICAgICAgc3dpdGNoIChsZW4pIHtcblx0ICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKCFmbikge1xuXHQgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdCAgaWYgKGxpc3RlbmVycy5mbikge1xuXHQgICAgaWYgKFxuXHQgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG5cdCAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcblx0ICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuXHQgICAgKSB7XG5cdCAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcblx0ICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG5cdCAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG5cdCAgICAgICkge1xuXHQgICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy9cblx0ICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cblx0ICAgIC8vXG5cdCAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuXHQgICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuXHQgIHZhciBldnQ7XG5cblx0ICBpZiAoZXZlbnQpIHtcblx0ICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cdCAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHQgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vXG5cdC8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBwcmVmaXguXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuXHQvL1xuXHQvLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuXHQvL1xuXHRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuXHQvL1xuXHR7XG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cdH0gXG59IChldmVudGVtaXR0ZXIzKSk7XG5cbnZhciBldmVudGVtaXR0ZXIzRXhwb3J0cyA9IGV2ZW50ZW1pdHRlcjMuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZXZlbnRlbWl0dGVyM0V4cG9ydHMpO1xuXG5jb25zdCBNZWRpYVNvdXJjZSQxID0gZ2V0TWVkaWFTb3VyY2UoKSB8fCB7XG4gIGlzVHlwZVN1cHBvcnRlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBUcmFuc211eGVySW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoaGxzLCBpZCwgb25UcmFuc211eENvbXBsZXRlLCBvbkZsdXNoKSB7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmtlckNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMub253bXNnID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkZsdXNoID0gdm9pZCAwO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudXNlV29ya2VyID0gISFjb25maWcuZW5hYmxlV29ya2VyO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgIHRoaXMub25GbHVzaCA9IG9uRmx1c2g7XG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoZXYgPT09IEV2ZW50cy5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlJDEuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcbiAgICAgIG1wZWc6IE1lZGlhU291cmNlJDEuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlJDEuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9O1xuICAgIC8vIG5hdmlnYXRvci52ZW5kb3IgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gV2ViIFdvcmtlclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcbiAgICBjb25zdCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yO1xuICAgIGlmICh0aGlzLnVzZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgY2FuQ3JlYXRlV29ya2VyID0gY29uZmlnLndvcmtlclBhdGggfHwgaGFzVU1EV29ya2VyKCk7XG4gICAgICBpZiAoY2FuQ3JlYXRlV29ya2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJQYXRoKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIFdlYiBXb3JrZXIgJHtjb25maWcud29ya2VyUGF0aH0gZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbG9hZFdvcmtlcihjb25maWcud29ya2VyUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGluamVjdGluZyBXZWIgV29ya2VyIGZvciBcIiR7aWR9XCJgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IGluamVjdFdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9ud21zZyA9IGV2ID0+IHRoaXMub25Xb3JrZXJNZXNzYWdlKGV2KTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB3b3JrZXJcbiAgICAgICAgICB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgIHdvcmtlci5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7ZXZlbnQubWVzc2FnZX0gICgke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub30pYCk7XG4gICAgICAgICAgICBjb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgaW4gXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgICAgICB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLFxuICAgICAgICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEVycm9yIHNldHRpbmcgdXAgXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWAsIGVycik7XG4gICAgICAgICAgdGhpcy5yZXNldFdvcmtlcigpO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpO1xuICB9XG4gIHJlc2V0V29ya2VyKCkge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBvYmplY3RVUkxcbiAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICB9XG4gICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHdvcmtlci5vbmVycm9yID0gbnVsbDtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdvcmtlcigpO1xuICAgICAgdGhpcy5vbndtc2cgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICB0cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsIF9sYXN0RnJhZyRpbml0U2VnbWVudDtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIC8vIFRPRE86IHB1c2ggXCJjbGVhci1sZWFkXCIgZGVjcnlwdCBkYXRhIGZvciB1bmVuY3J5cHRlZCBmcmFnbWVudHMgaW4gc3RyZWFtcyB3aXRoIGVuY3J5cHRlZCBvbmVzXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIGNvbnN0IGRpc2NvbnRpbnVpdHkgPSAhKGxhc3RGcmFnICYmIGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgY2h1bmtNZXRhLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCk7XG4gICAgY29uc3Qgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIGNvbnN0IHBhcnREaWZmID0gdGhpcy5wYXJ0ID8gY2h1bmtNZXRhLnBhcnQgLSB0aGlzLnBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwcm9ncmVzc2l2ZSA9IHNuRGlmZiA9PT0gMCAmJiBjaHVua01ldGEuaWQgPiAxICYmIGNodW5rTWV0YS5pZCA9PT0gKGxhc3RGcmFnID09IG51bGwgPyB2b2lkIDAgOiBsYXN0RnJhZy5zdGF0cy5jaHVua0NvdW50KTtcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIChzbkRpZmYgPT09IDEgfHwgc25EaWZmID09PSAwICYmIChwYXJ0RGlmZiA9PT0gMSB8fCBwcm9ncmVzc2l2ZSAmJiBwYXJ0RGlmZiA8PSAwKSk7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICBpZiAocGFydCAmJiAocGFydERpZmYgfHwgIWNvbnRpZ3VvdXMpKSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGluaXRTZWdtZW50Q2hhbmdlID0gIShsYXN0RnJhZyAmJiAoKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LnVybCkgPT09ICgoX2xhc3RGcmFnJGluaXRTZWdtZW50ID0gbGFzdEZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgVHJhbnNtdXhTdGF0ZShkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIGxvZ2dlci5sb2coYFt0cmFuc211eGVyLWludGVyZmFjZSwgJHtmcmFnLnR5cGV9XTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiAke2NodW5rTWV0YS5zbn0gcDogJHtjaHVua01ldGEucGFydH0gbGV2ZWw6ICR7Y2h1bmtNZXRhLmxldmVsfSBpZDogJHtjaHVua01ldGEuaWR9XG4gICAgICAgIGRpc2NvbnRpbnVpdHk6ICR7ZGlzY29udGludWl0eX1cbiAgICAgICAgdHJhY2tTd2l0Y2g6ICR7dHJhY2tTd2l0Y2h9XG4gICAgICAgIGNvbnRpZ3VvdXM6ICR7Y29udGlndW91c31cbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiAke2FjY3VyYXRlVGltZU9mZnNldH1cbiAgICAgICAgdGltZU9mZnNldDogJHt0aW1lT2Zmc2V0fVxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogJHtpbml0U2VnbWVudENoYW5nZX1gKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBUcmFuc211eENvbmZpZyhhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuXG4gICAgLy8gRnJhZ3Mgd2l0aCBzbiBvZiAnaW5pdFNlZ21lbnQnIGFyZSBub3QgdHJhbnNtdXhlZFxuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICBzdGF0ZVxuICAgICAgfSwgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gW2RhdGFdIDogW10pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgY29uc3QgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpO1xuICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIHB1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc211eGVyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdmbHVzaCcsXG4gICAgICAgIGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBsZXQgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICBjb25zdCBhc3luY0ZsdXNoID0gaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIGlmIChhc3luY0ZsdXNoIHx8IHRyYW5zbXV4ZXIuYXN5bmMpIHtcbiAgICAgICAgaWYgKCFpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChkYXRhLCBjaHVua01ldGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdCh0cmFuc211eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNtdXhlckVycm9yKGVycm9yLCBjaHVua01ldGEsIHJlYXNvbikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIHJlYXNvblxuICAgIH0pO1xuICB9XG4gIGhhbmRsZUZsdXNoUmVzdWx0KHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gIH1cbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XG4gICAgY29uc3QgZGF0YSA9IGV2LmRhdGE7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyR3b3JrZXJDb250ZXh0O1xuICAgICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IChfdGhpcyR3b3JrZXJDb250ZXh0ID0gdGhpcy53b3JrZXJDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkd29ya2VyQ29udGV4dC5vYmplY3RVUkw7XG4gICAgICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgIGlmIChsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKSB7XG4gICAgICAgICAgbG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXShkYXRhLmRhdGEubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KSB7XG4gICAgcmVzdWx0LmNodW5rTWV0YS50cmFuc211eGluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gIH1cbn1cblxuY29uc3QgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbmNvbnN0IE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbmNvbnN0IFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xuY29uc3QgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuY2xhc3MgR2FwQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICpcbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZSAtIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgKi9cbiAgcG9sbChsYXN0Q3VycmVudFRpbWUsIGFjdGl2ZUZyYWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBtZWRpYSxcbiAgICAgIHN0YWxsZWRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBzZWVraW5nXG4gICAgfSA9IG1lZGlhO1xuICAgIGNvbnN0IHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICBjb25zdCBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG4gICAgdGhpcy5zZWVraW5nID0gc2Vla2luZztcblxuICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcsIG5vLW9wXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgaWYgKHN0YWxsZWQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICAgIGlmICh0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICBjb25zdCBfc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKF9zdGFsbGVkRHVyYXRpb24pfW1zYCk7XG4gICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuICAgIGlmIChiZWdpblNlZWsgfHwgc2Vla2VkKSB7XG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBwbGF5aGVhZCBzaG91bGQgbm90IGJlIG1vdmluZ1xuICAgIGlmIChtZWRpYS5wYXVzZWQgJiYgIXNlZWtpbmcgfHwgbWVkaWEuZW5kZWQgfHwgbWVkaWEucGxheWJhY2tSYXRlID09PSAwIHx8ICFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICBjb25zdCBpc0J1ZmZlcmVkID0gYnVmZmVySW5mby5sZW4gPiAwO1xuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDA7XG5cbiAgICAvLyBUaGVyZSBpcyBubyBwbGF5YWJsZSBidWZmZXIgKHNlZWtlZCwgd2FpdGluZyBmb3IgYnVmZmVyKVxuICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICAvLyBXYWl0aW5nIGZvciBzZWVraW5nIGluIGEgYnVmZmVyZWQgcmFuZ2UgdG8gY29tcGxldGVcbiAgICAgIGNvbnN0IGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgLy8gTmV4dCBidWZmZXJlZCByYW5nZSBpcyB0b28gZmFyIGFoZWFkIHRvIGp1bXAgdG8gd2hpbGUgc3RpbGwgc2Vla2luZ1xuICAgICAgY29uc3Qgbm9CdWZmZXJHYXAgPSAhbmV4dFN0YXJ0IHx8IGFjdGl2ZUZyYWcgJiYgYWN0aXZlRnJhZy5zdGFydCA8PSBjdXJyZW50VGltZSB8fCBuZXh0U3RhcnQgLSBjdXJyZW50VGltZSA+IE1BWF9TVEFSVF9HQVBfSlVNUCAmJiAhdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgIC8vIFRoZSBhZGRpdGlvbiBwb2xsIGdpdmVzIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGp1bXAgdGhlIGdhcCBmb3IgdXNcbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG4gICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICBjb25zdCBzdGFydEp1bXAgPSBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTtcblxuICAgICAgLy8gV2hlbiBqb2luaW5nIGEgbGl2ZSBzdHJlYW0gd2l0aCBhdWRpbyB0cmFja3MsIGFjY291bnQgZm9yIGxpdmUgcGxheWxpc3Qgd2luZG93IHNsaWRpbmcgYnkgYWxsb3dpbmdcbiAgICAgIC8vIGEgbGFyZ2VyIGp1bXAgb3ZlciBzdGFydCBnYXBzIGNhdXNlZCBieSB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgYnVmZmVyaW5nIGEgc3RhcnQgZnJhZ21lbnRcbiAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHMgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXSA6IG51bGw7XG4gICAgICBjb25zdCBpc0xpdmUgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRkZXRhaWxzLmxpdmU7XG4gICAgICBjb25zdCBtYXhTdGFydEdhcEp1bXAgPSBpc0xpdmUgPyBsZXZlbC5kZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMiA6IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgIGNvbnN0IHBhcnRpYWxPckdhcCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICBpZiAoc3RhcnRKdW1wID4gMCAmJiAoc3RhcnRKdW1wIDw9IG1heFN0YXJ0R2FwSnVtcCB8fCBwYXJ0aWFsT3JHYXApKSB7XG4gICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWxPckdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGFydCB0cmFja2luZyBzdGFsbCB0aW1lXG4gICAgY29uc3QgdG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHN0YWxsZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJlZFdpdGhIb2xlcywgc3RhbGxlZER1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbk1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpO1xuICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgaW4gdGhpcyBjYXNlLCBtZWFuaW5nXG4gICAgICAvLyB0aGUgYnJhbmNoIGJlbG93IG9ubHkgZXhlY3V0ZXMgd2hlbiB3ZSBoYXZlbid0IHNlZWtlZCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAgaWYgKHRhcmdldFRpbWUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgIC8vIHdlIG1heSBqdXN0IGhhdmUgdG8gXCJudWRnZVwiIHRoZSBwbGF5bGlzdCBhcyB0aGUgYnJvd3NlciBkZWNvZGluZy9yZW5kZXJpbmcgZW5naW5lXG4gICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG4gICAgaWYgKChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPCBjb25maWcubWF4QnVmZmVySG9sZSkgJiYgc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVwb3J0U3RhbGwoYnVmZmVySW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgc3RhbGxSZXBvcnRlZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghc3RhbGxSZXBvcnRlZCAmJiBtZWRpYSkge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHttZWRpYS5jdXJyZW50VGltZX0gZHVlIHRvIGxvdyBidWZmZXIgKCR7SlNPTi5zdHJpbmdpZnkoYnVmZmVySW5mbyl9KWApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAqIEBwYXJhbSBwYXJ0aWFsIC0gVGhlIHBhcnRpYWwgZnJhZ21lbnQgZm91bmQgYXQgdGhlIGN1cnJlbnQgdGltZSAod2hlcmUgcGxheWJhY2sgaXMgc3RhbGxpbmcpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBobHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lIDwgYnVmZmVySW5mby5zdGFydCA/IGJ1ZmZlckluZm8uc3RhcnQgOiBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBidWZmZXJTdGFydmVkID0gYnVmZmVySW5mby5sZW4gPD0gY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICBjb25zdCB3YWl0aW5nID0gYnVmZmVySW5mby5sZW4gPiAwICYmIGJ1ZmZlckluZm8ubGVuIDwgMSAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgMztcbiAgICAgIGNvbnN0IGdhcExlbmd0aCA9IHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGdhcExlbmd0aCA+IDAgJiYgKGJ1ZmZlclN0YXJ2ZWQgfHwgd2FpdGluZykpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBsYXJnZSBnYXBzIHRvIGJlIHNraXBwZWQgaWYgaXQgaXMgYSBzdGFydCBnYXAsIG9yIGFsbCBmcmFnbWVudHMgaW4gc2tpcCByYW5nZSBhcmUgcGFydGlhbFxuICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgc3RhcnRHYXAgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RnJhZyA9IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoMCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgICBpZiAoc3RhcnRGcmFnICYmIHN0YXJ0VGltZSA8IHN0YXJ0RnJhZy5lbmQpIHtcbiAgICAgICAgICAgICAgc3RhcnRHYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0YXJ0R2FwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb3Zpc2lvbmVkID0gcGFydGlhbCB8fCBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgIGxldCBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydFByb3Zpc2lvbmVkLmVuZDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHByb3Zpc2lvbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3JlVG9Mb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobW9yZVRvTG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCwgY3VycmVudFRpbWUgKyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyk7XG4gICAgICAgIGxvZ2dlci53YXJuKGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgIGlmIChwYXJ0aWFsICYmICFwYXJ0aWFsLmdhcCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZzogcGFydGlhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIG51ZGdlUmV0cnlcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLm51ZGdlUmV0cnkrKztcbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUGxheWhlYWQgc3RpbGwgbm90IG1vdmluZyB3aGlsZSBlbm91Z2ggZGF0YSBidWZmZXJlZCBAJHtjdXJyZW50VGltZX0gYWZ0ZXIgJHtjb25maWcubnVkZ2VNYXhSZXRyeX0gbnVkZ2VzYCk7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMJDIgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW3N0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIHRoaXMub252cGxheWluZyA9IG51bGw7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXN0Q3VycmVudFRpbWUsXG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMik7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIGxldCBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgIGlmIChobHMuY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyRsZXZlbDtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfbGV2ZWxzJGxldmVsID0gbGV2ZWxzW2xldmVsXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbHMkbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdGhpcy5sZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgfVxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIHN1cGVyLm9uVGlja0VuZCgpO1xuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH1cbiAgZG9UaWNrSWRsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBsZXZlbExhc3RMb2FkZWQsXG4gICAgICBsZXZlbHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG5leHRMb2FkTGV2ZWw6IGxldmVsXG4gICAgfSA9IGhscztcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgXCJtYWluXCIgbGV2ZWwgaXMgYXVkaW8tb25seSBidXQgd2UgYXJlIGxvYWRpbmcgYW4gYWx0ZXJuYXRlIHRyYWNrIGluIHRoZSBzYW1lIGdyb3VwLCBkbyBub3QgbG9hZCBhbnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsYXN0RGV0YWlscyAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsYXN0RGV0YWlscykpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtsZXZlbH0gZnJvbSBsZXZlbCAke3RoaXMubGV2ZWx9YCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuXG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0IDogYnVmZmVySW5mby5lbmQ7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgIHZhciBfdGhpcyRiYWNrdHJhY2tGcmFnbWU7XG4gICAgICBjb25zdCBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgY29uc3QgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICBpZiAoYmFja3RyYWNrRnJhZyAmJiBmcmFnLmNjID09PSBiYWNrdHJhY2tGcmFnLmNjKSB7XG4gICAgICAgIGZyYWcgPSBiYWNrdHJhY2tGcmFnO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICBpZiAoIWdhcFN0YXJ0KSB7XG4gICAgICAgIC8vIENsZWFudXAgdGhlIGZyYWdtZW50IHRyYWNrZXIgYmVmb3JlIHRyeWluZyB0byBmaW5kIHRoZSBuZXh0IHVuYnVmZmVyZWQgZnJhZ21lbnRcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvID8gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIDogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuICAgICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIG1heEJ1Zkxlbik7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubG9nKGBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfVxuICBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmQgKyAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIGxldCBmZXRjaGRlbGF5O1xuICAgICAgY29uc3QgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgLSAxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgLy8gRG8gbm90IGZsdXNoIGluIGxpdmUgc3RyZWFtIHdpdGggbG93IGJ1ZmZlclxuICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIGNvbnN0IG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgY29uc3QgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgY29uc3QgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLm1heEJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY29uc3Qgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqIDAuNSksIGZyYWdEdXJhdGlvbiAqIDAuNzUpKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0aGlzLmFsdEF1ZGlvID8gJ3ZpZGVvJyA6IG51bGwpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHN1cGVyLm9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSk7XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub25NZWRpYVBsYXlpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcih0aGlzLmNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnBsYXlpbmcgJiYgdGhpcy5vbnZzZWVrZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIGlmICh0aGlzLmdhcENvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cbiAgb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWVkaWFTZWVrZWQoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IG51bGw7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5sb2coYE1lZGlhIHNlZWtlZCB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2Vla2VkIHdhcyBpc3N1ZWQgYmVmb3JlIGJ1ZmZlciB3YXMgYXBwZW5kZWQgZG8gbm90IHRpY2sgaW1tZWRpYXRlbHlcbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICB0aGlzLndhcm4oYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIG9uIFwic2Vla2VkXCIgZXZlbnQgJHtidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknfSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLmxvZygnVHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuZnJhZ1BsYXlpbmcgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmFsdEF1ZGlvID0gdGhpcy5hdWRpb09ubHkgPSBmYWxzZTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgbGV0IGFhYyA9IGZhbHNlO1xuICAgIGxldCBoZWFhYyA9IGZhbHNlO1xuICAgIGxldCBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYyAmJiAhY2hhbmdlVHlwZVN1cHBvcnRlZCgpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZGF0YS5sZXZlbF07XG4gICAgaWYgKCFsZXZlbC5kZXRhaWxzIHx8IGxldmVsLmRldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gZGF0YS5sZXZlbCB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9jdXJMZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke25ld0xldmVsSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBMZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LCBjYyBbJHtuZXdEZXRhaWxzLnN0YXJ0Q0N9LCAke25ld0RldGFpbHMuZW5kQ0N9XSBkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIGNvbnN0IGN1ckxldmVsID0gbGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkpIHtcbiAgICAgIGlmICgoZnJhZ0N1cnJlbnQubGV2ZWwgIT09IGRhdGEubGV2ZWwgfHwgZnJhZ0N1cnJlbnQudXJsSWQgIT09IGN1ckxldmVsLnVybElkKSAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfY3VyTGV2ZWwkZGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMubGl2ZSkge1xuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBsZXZlbDogbmV3TGV2ZWxJZFxuICAgIH0pO1xuXG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKGBEcm9wcGluZyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0YCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgfHwgbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UodGhpcy5obHMsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVzdHJveSB0cmFuc211eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaWYgKGZyb21BbHRBdWRpbykge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgdHlwZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICBjb25zdCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBsZXQgbWVkaWFUcmFjaztcbiAgICBsZXQgbmFtZTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICB0aGlzLmxvZyhgQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUsIHNpbmNlIHRoYXQgd2lsbCBpbnRlcmZlcmUgd2l0aCBhIGxldmVsIHN3aXRjaFxuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfWApO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy5idWZmZXJpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCkpO1xuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRjb250ZXh0O1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIGNoZWNrQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgZ2FwQ29udHJvbGxlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBjb25zdCBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfVxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBzZWVrVG9TdGFydFBvcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coYGNvdWxkIG5vdCBzZWVrIHRvICR7c3RhcnRQb3NpdGlvbn0sIGFscmVhZHkgc2Vla2luZyBhdCAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICBjb25zdCBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgIGNvbnN0IGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuICAgICAgaWYgKGRlbHRhID4gMCAmJiAoZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGRlbHRhIDwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259IGZyb20gY3VycmVudCB0aW1lICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9XG4gIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuICBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCkge1xuICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gJ21haW4nO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICB2aWRlbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG4gICAgICBjb25zdCBpbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUztcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5JTklUX1BUU19GT1VORCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG4gICAgaWYgKHZpZGVvICYmIGRldGFpbHMgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcHJldkZyYWcgPSBkZXRhaWxzLmZyYWdtZW50c1tmcmFnLnNuIC0gMSAtIGRldGFpbHMuc3RhcnRTTl07XG4gICAgICBjb25zdCBpc0ZpcnN0RnJhZ21lbnQgPSBmcmFnLnNuID09PSBkZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBpc0ZpcnN0SW5EaXNjb250aW51aXR5ID0gIXByZXZGcmFnIHx8IGZyYWcuY2MgPiBwcmV2RnJhZy5jYztcbiAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfSA9IHZpZGVvO1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCAmJiBjaHVua01ldGEuaWQgPT09IDEgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuICAgICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBmcmFnLnN0YXJ0LCBlbmRQVFMsIGZyYWcuc3RhcnQsIGVuZERUUywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB2aWRlbyxcbiAgICAgIGF1ZGlvdmlkZW9cbiAgICB9ID0gdHJhY2tzO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgbGV0IGF1ZGlvQ29kZWMgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBpZiAoYXVkaW8ubWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIGF1ZGlvLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRoaXMubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coYFN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFwiJHtjdXJyZW50TGV2ZWwuYXVkaW9Db2RlY31cIiBmb3IgXCIke2F1ZGlvQ29kZWN9XCJgKTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgYXVkaW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke2F1ZGlvLmNvbnRhaW5lcn0sIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVske2F1ZGlvQ29kZWMgfHwgJyd9LyR7Y3VycmVudExldmVsLmF1ZGlvQ29kZWMgfHwgJyd9LyR7YXVkaW8uY29kZWN9XWApO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coYEluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6JHt2aWRlby5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyB8fCAnJ30vJHt2aWRlby5jb2RlY31dYCk7XG4gICAgfVxuICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7YXVkaW92aWRlby5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwuYXR0cnMuQ09ERUNTIHx8ICcnfS8ke2F1ZGlvdmlkZW8uY29kZWN9XWApO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHtcbiAgICAgICAgICB0eXBlOiB0cmFja05hbWUsXG4gICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICB9XG4gIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIGNoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50ID0gbnVsbDtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZ0N1cnJlbnQuc24gIT09IGZyYWdQbGF5aW5nLnNuIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsIHx8IGZyYWdQbGF5aW5nQ3VycmVudC51cmxJZCAhPT0gZnJhZ1BsYXlpbmcudXJsSWQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IGN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKGZyYWcgJiYgaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpICYmIGlzRmluaXRlTnVtYmVyKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICBjb25zdCBlcG9jTXMgPSBmcmFnLnByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NNcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSwgZXN0aW1hdGUgPSAwLCB3ZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG4gIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgY29uc3QgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBjb25zdCB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICBpZiAoemVyb0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gIH1cbn1cblxuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgY29uc3RydWN0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlLCBkZWZhdWx0VFRGQiA9IDEwMCkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbldlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3dfID0gdm9pZCAwO1xuICAgIHRoaXMuZmFzdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgdGhpcy50dGZiXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cbiAgdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbG93XyxcbiAgICAgIGZhc3RfLFxuICAgICAgdHRmYl9cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc2xvd18uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKGZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCwgZmFzdF8uZ2V0RXN0aW1hdGUoKSwgZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmICh0dGZiXy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3csIHR0ZmJfLmdldEVzdGltYXRlKCksIHR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfVxuICBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgY29uc3QgbnVtQml0cyA9IDggKiBudW1CeXRlcztcbiAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICBjb25zdCBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH1cbiAgc2FtcGxlVFRGQih0dGZiKSB7XG4gICAgLy8gd2VpZ2h0IGlzIGZyZXF1ZW5jeSBjdXJ2ZSBhcHBsaWVkIHRvIFRURkIgaW4gc2Vjb25kc1xuICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgIGNvbnN0IHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICB0aGlzLnR0ZmJfLnNhbXBsZSh3ZWlnaHQsIE1hdGgubWF4KHR0ZmIsIDUpKTtcbiAgfVxuICBjYW5Fc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfVxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuICBnZXRFc3RpbWF0ZVRURkIoKSB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbmNsYXNzIEFickNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IDA7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uQ2hlY2sgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHBhcnQ7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIGdldFRpbWVUb0xvYWRGcmFnKHRpbWVUb0ZpcnN0Qnl0ZVNlYywgYmFuZHdpZHRoLCBmcmFnU2l6ZUJpdHMsIGlzU3dpdGNoKSB7XG4gICAgY29uc3QgZnJhZ0xvYWRTZWMgPSB0aW1lVG9GaXJzdEJ5dGVTZWMgKyBmcmFnU2l6ZUJpdHMgLyBiYW5kd2lkdGg7XG4gICAgY29uc3QgcGxheWxpc3RMb2FkU2VjID0gaXNTd2l0Y2ggPyB0aGlzLmxhc3RMZXZlbExvYWRTZWMgOiAwO1xuICAgIHJldHVybiBmcmFnTG9hZFNlYyArIHBsYXlsaXN0TG9hZFNlYztcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdGFsLFxuICAgICAgYndFc3RpbWF0ZVxuICAgIH0gPSBkYXRhLnN0YXRzO1xuICAgIC8vIFRvdGFsIGlzIHRoZSBieXRlbGVuZ3RoIGFuZCBid0VzdGltYXRlIGluIGJpdHMvc2VjXG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRvdGFsKSAmJiBpc0Zpbml0ZU51bWJlcihid0VzdGltYXRlKSkge1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gOCAqIHRvdGFsIC8gYndFc3RpbWF0ZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dMaXZlLCBjb25maWcuYWJyRXdtYUZhc3RMaXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgIHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgdW5kZXJidWZmZXJpbmdcbiAgICAqL1xuICBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQ6IGZyYWcsXG4gICAgICBwYXJ0Q3VycmVudDogcGFydCxcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dG9MZXZlbEVuYWJsZWQsXG4gICAgICBtZWRpYVxuICAgIH0gPSBobHM7XG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgLy8gSWYgZnJhZyBsb2FkaW5nIGlzIGFib3J0ZWQsIGNvbXBsZXRlLCBvciBmcm9tIGxvd2VzdCBsZXZlbCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQgfHwgc3RhdHMubG9hZGVkICYmIHN0YXRzLmxvYWRlZCA9PT0gc3RhdHMudG90YWwgfHwgZnJhZy5sZXZlbCA9PT0gMCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgY2hlY2sgb25seSBydW5zIGlmIHdlJ3JlIGluIEFCUiBtb2RlIGFuZCBhY3R1YWxseSBwbGF5aW5nXG4gICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkIHx8IG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTtcbiAgICAvLyBUbyBtYWludGFpbiBzdGFibGUgYWRhcHRpdmUgcGxheWJhY2ssIG9ubHkgYmVnaW4gbW9uaXRvcmluZyBmcmFnIGxvYWRpbmcgYWZ0ZXIgaGFsZiBvciBtb3JlIG9mIGl0cyBwbGF5YmFjayBkdXJhdGlvbiBoYXMgcGFzc2VkXG4gICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IGJ1ZmZlckluZm8ubGVuIC8gcGxheWJhY2tSYXRlO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiBsZXNzIHRoYW4gMiBmcmFnbWVudCBsZW5ndGhzIGFyZSBidWZmZXJlZFxuICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gMiAqIGR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgIGNvbnN0IGJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IGhscztcbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICBjb25zdCBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsIHx8IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChkdXJhdGlvbiAqIGxldmVsLm1heEJpdHJhdGUgLyA4KSk7XG4gICAgbGV0IHRpbWVTdHJlYW1pbmcgPSB0aW1lTG9hZGluZyAtIHR0ZmI7XG4gICAgaWYgKHRpbWVTdHJlYW1pbmcgPCAxICYmIGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCBzdGF0cy5sb2FkZWQgKiA4IC8gYndFc3RpbWF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRSYXRlID0gbG9hZGVkRmlyc3RCeXRlID8gc3RhdHMubG9hZGVkICogMTAwMCAvIHRpbWVTdHJlYW1pbmcgOiAwO1xuICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZSA/IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSA6IGV4cGVjdGVkTGVuICogOCAvIGJ3RXN0aW1hdGUgKyB0dGZiRXN0aW1hdGUgLyAxMDAwO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgIGlmIChmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ3ZSA9IGxvYWRSYXRlID8gbG9hZFJhdGUgKiA4IDogYndFc3RpbWF0ZTtcbiAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBuZXh0TG9hZExldmVsO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG4gICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZSAvIDEwMDAsIGJ3ZSwgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLCAhbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmRldGFpbHMpO1xuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWQgb2YgY29udGludWluZ1xuICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBlc3RpbWF0ZWQgbG9hZCB0aW1lIG9mIG5ldyBzZWdtZW50IGlzIGNvbXBsZXRlbHkgdW5yZWFzb25hYmxlLCBpZ25vcmUgYW5kIGRvIG5vdCBlbWVyZ2VuY3kgc3dpdGNoIGRvd25cbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID4gZHVyYXRpb24gKiAxMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMubmV4dExvYWRMZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgaWYgKGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIGJhbmR3aWR0aCB1c2luZyBsb2FkaW5nIHRpbWUgb2Zmc2V0IGJ5IG1pbmltdW0gVFRGQiB0aW1lXG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZSh0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksIHN0YXRzLmxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIodGltZUxvYWRpbmcpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBsb2dnZXIud2FybihgW2Ficl0gRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGlzIGxvYWRpbmcgdG9vIHNsb3dseTtcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6ICR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6ICR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGRvd24gc3dpdGNoIGZyYWdtZW50OiAke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBUVEZCIGVzdGltYXRlOiAke3R0ZmJ9XG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiAke2lzRmluaXRlTnVtYmVyKGJ3RXN0aW1hdGUpID8gKGJ3RXN0aW1hdGUgLyAxMDI0KS50b0ZpeGVkKDMpIDogJ1Vua25vd24nfSBLYi9zXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7KHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSAvIDEwMjQpLnRvRml4ZWQoMyl9IEtiL3NcbiAgICAgIEFib3J0aW5nIGFuZCBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfWApO1xuICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgfVxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgc3RhdHNcbiAgICB9KTtcbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIHBhcnRcbiAgfSkge1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcblxuICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBjb25zdCBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgIGNvbnN0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICBsZXZlbC5sb2FkZWQgPSB7XG4gICAgICAgIGJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uXG4gICAgICB9O1xuICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIGNvbnN0IGZyYWdCdWZmZXJlZERhdGEgPSB7XG4gICAgICAgIHN0YXRzLFxuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9O1xuICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChFdmVudHMuRlJBR19CVUZGRVJFRCwgZnJhZ0J1ZmZlcmVkRGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgIT0gbnVsbCAmJiBwYXJ0LnN0YXRzLmxvYWRlZCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHBhcnNpbmcgYW5kIHJlcXVlc3QgaW5zdGVhZCBvZiBidWZmZXJpbmcgYW5kIHJlcXVlc3QgdG8gY29tcHV0ZSBmcmFnTG9hZGluZ1Byb2Nlc3Npbmc7XG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoXG4gICAgLy8gaXMgdXNlZC4gSWYgd2UgdXNlZCBidWZmZXJpbmcgaW4gdGhhdCBjYXNlLCBvdXIgQlcgZXN0aW1hdGUgc2FtcGxlIHdpbGwgYmUgdmVyeSBsYXJnZS5cbiAgICBjb25zdCBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgLSBNYXRoLm1pbihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCwgdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSk7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9XG4gIGlnbm9yZUZyYWdtZW50KGZyYWcpIHtcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG4gICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpO1xuICAgIC8vIHVzZSBmb3JjZWQgYXV0byBsZXZlbCB3aGVuIEFCUiBzZWxlY3RlZCBsZXZlbCBoYXMgZXJyb3JlZFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IE1hdGgubWF4KGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCkgJiYgbGV2ZWxzW2ZvcmNlZEF1dG9MZXZlbF0ubG9hZEVycm9yIDw9IGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50LFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgY29uZmlnLFxuICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgbWVkaWFcbiAgICB9ID0gaGxzO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG5cbiAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiBtZWRpYS5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgbGV0IGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuICAgIGxvZ2dlci50cmFjZShgW2Ficl0gJHtidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSd9LCBmaW5kaW5nIG9wdGltYWwgcXVhbGl0eSBsZXZlbGApO1xuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGxldCBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XG4gICAgbGV0IGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgaWYgKCFidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgIGNvbnN0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBsb2dnZXIudHJhY2UoYFthYnJdIGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgfVxuICBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgcGFydEN1cnJlbnQsXG4gICAgICBsYXN0TG9hZGVkRnJhZ0xldmVsOiBjdXJyZW50TGV2ZWxcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICBjb25zdCBsaXZlID0gISEobGV2ZWwgIT0gbnVsbCAmJiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSAhPSBudWxsICYmIF9sZXZlbCRkZXRhaWxzLmxpdmUpO1xuICAgIGNvbnN0IGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICBjb25zdCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZVNlYyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxMDAwO1xuICAgIGxldCBsZXZlbFNraXBwZWRNaW4gPSBtaW5BdXRvTGV2ZWw7XG4gICAgbGV0IGxldmVsU2tpcHBlZE1heCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tpXTtcbiAgICAgIGlmICghbGV2ZWxJbmZvIHx8IGN1cnJlbnRDb2RlY1NldCAmJiBsZXZlbEluZm8uY29kZWNTZXQgIT09IGN1cnJlbnRDb2RlY1NldCkge1xuICAgICAgICBpZiAobGV2ZWxJbmZvKSB7XG4gICAgICAgICAgbGV2ZWxTa2lwcGVkTWluID0gTWF0aC5taW4oaSwgbGV2ZWxTa2lwcGVkTWluKTtcbiAgICAgICAgICBsZXZlbFNraXBwZWRNYXggPSBNYXRoLm1heChpLCBsZXZlbFNraXBwZWRNYXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsU2tpcHBlZE1heCAhPT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGBbYWJyXSBTa2lwcGVkIGxldmVsKHMpICR7bGV2ZWxTa2lwcGVkTWlufS0ke2xldmVsU2tpcHBlZE1heH0gd2l0aCBDT0RFQ1M6XCIke2xldmVsc1tsZXZlbFNraXBwZWRNYXhdLmF0dHJzLkNPREVDU31cIjsgbm90IGNvbXBhdGlibGUgd2l0aCBcIiR7bGV2ZWwuYXR0cnMuQ09ERUNTfVwiYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgIGNvbnN0IGF2Z0R1cmF0aW9uID0gKHBhcnRDdXJyZW50ID8gbGV2ZWxEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbikgfHwgY3VycmVudEZyYWdEdXJhdGlvbjtcbiAgICAgIGxldCBhZGp1c3RlZGJ3O1xuICAgICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBsZXZlbHNbaV0ubWF4Qml0cmF0ZTtcbiAgICAgIGNvbnN0IGZldGNoRHVyYXRpb24gPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZVNlYywgYWRqdXN0ZWRidywgYml0cmF0ZSAqIGF2Z0R1cmF0aW9uLCBsZXZlbERldGFpbHMgPT09IHVuZGVmaW5lZCk7XG4gICAgICBsb2dnZXIudHJhY2UoYFthYnJdIGxldmVsOiR7aX0gYWRqdXN0ZWRidy1iaXRyYXRlOiR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3IC0gYml0cmF0ZSl9IGF2Z0R1cmF0aW9uOiR7YXZnRHVyYXRpb24udG9GaXhlZCgxKX0gbWF4RmV0Y2hEdXJhdGlvbjoke21heEZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmV0Y2hEdXJhdGlvbjoke2ZldGNoRHVyYXRpb24udG9GaXhlZCgxKX1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmIChcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgZmV0Y2hEdXJhdGlvbiA9PT0gMCB8fCAhaXNGaW5pdGVOdW1iZXIoZmV0Y2hEdXJhdGlvbikgfHwgbGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5IHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5jbGFzcyBDaHVua0NhY2hlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG4gIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNodW5rcyxcbiAgICAgIGRhdGFMZW5ndGhcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghY2h1bmtzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH0gZWxzZSBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gY2h1bmtzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMSA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1thdWRpby1zdHJlYW0tY29udHJvbGxlcl0nLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy52aWRlb1RyYWNrQ0MgPSAtMTtcbiAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIElOSVRfUFRTX0ZPVU5EIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyB0cmFjayBwYXJzZWQgaW4gdGhlIHN0cmVhbS1jb250cm9sbGVyIGhhcyBhIG5ldyBQVFMgdmFsdWVcbiAgb25Jbml0UHRzRm91bmQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIGlkLFxuICAgIGluaXRQVFMsXG4gICAgdGltZXNjYWxlXG4gIH0pIHtcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAvLyBDYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgY29uc3QgY2MgPSBmcmFnLmNjO1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYEluaXRQVFMgZm9yIGNjOiAke2NjfSBmb3VuZCBmcm9tIG1haW46ICR7aW5pdFBUU31gKTtcbiAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gY2M7XG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZywgdGljayBpbW1lZGlhdGVseSB0byB1bmJsb2NrIGF1ZGlvIGZyYWdtZW50IHRyYW5zbXV4aW5nXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMSk7XG4gICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9sZXZlbHMkdHJhY2tJZDtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgZGV0YWlscyA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogKF9sZXZlbHMkdHJhY2tJZCA9IGxldmVsc1t0cmFja0lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbHMkdHJhY2tJZC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdSZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLnRyYWNrSWQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgIGNvbnN0IHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICAgICAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9ID0gd2FpdGluZ0RhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNhY2hlLmZsdXNoKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHN1cGVyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gdGhpcy53YWl0aW5nVmlkZW9DQykge1xuICAgICAgICAgICAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgdmlkZW9UcmFja0NDIGhhcyBjaGFuZ2VkIHNpbmNlIHdhaXRpbmdGcmFnbWVudCB3YXMgc2V0IGFuZCBpbml0UFRTIHdhcyBub3QgZm91bmRcbiAgICAgICAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZnJhZ21lbnQgY2MgKCR7ZnJhZy5jY30pIGNhbmNlbGxlZCBiZWNhdXNlIHZpZGVvIGlzIGF0IGNjICR7dGhpcy52aWRlb1RyYWNrQ0N9YCk7XG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiBhbiBlYXJsaWVyIGZyYWdtZW50IGlzIG5lZWRlZFxuICAgICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcG9zLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiA9IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJJbmZvLmVuZCwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZyk7XG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZyYWdtZW50IGNjICgke2ZyYWcuY2N9KSBAICR7ZnJhZy5zdGFydH0gY2FuY2VsbGVkIGJlY2F1c2UgYW5vdGhlciBmcmFnbWVudCBhdCAke2J1ZmZlckluZm8uZW5kfSBpcyBuZWVkZWRgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgY2xlYXJXYWl0aW5nRnJhZ21lbnQoKSB7XG4gICAgY29uc3Qgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgIGlmICh3YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQod2FpdGluZ0RhdGEuZnJhZyk7XG4gICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgc3VwZXIucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIShtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhLFxuICAgICAgdHJhY2tJZFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW3RyYWNrSWRdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICghbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zdCB0cmFja0RldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICBpZiAoIXRyYWNrRGV0YWlscyB8fCB0cmFja0RldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gdHJhY2tJZCB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4odHJhY2tEZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmFibGUgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgaWYgKHRoaXMuYnVmZmVyRmx1c2hlZCAmJiBidWZmZXJhYmxlKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKGJ1ZmZlcmFibGUsIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJlZFRyYWNrLFxuICAgICAgc3dpdGNoaW5nVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXN3aXRjaGluZ1RyYWNrICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYWluQnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJJbmZvID09IG51bGwgPyB2b2lkIDAgOiBtYWluQnVmZmVySW5mby5sZW4pO1xuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4gJiYgIXN3aXRjaGluZ1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgbGV0IHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJJbmZvLmVuZDtcbiAgICBpZiAoc3dpdGNoaW5nVHJhY2sgJiYgbWVkaWEpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICBpZiAoYnVmZmVyZWRUcmFjayAmJiBzd2l0Y2hpbmdUcmFjay5hdHRycyAhPT0gYnVmZmVyZWRUcmFjay5hdHRycykge1xuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lID0gcG9zO1xuICAgICAgfVxuICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ0FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcbiAgICBsZXQgYXRHYXAgPSBmYWxzZTtcbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGF0R2FwID0gISFmcmFnLmdhcDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIHRyYWNrRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBhdWRpbyB1cCB0byBvbmUgdGFyZ2V0IGR1cmF0aW9uIGFoZWFkIG9mIG1haW4gYnVmZmVyXG4gICAgY29uc3QgYXRCdWZmZXJTeW5jTGltaXQgPSBtYWluQnVmZmVySW5mbyAmJiBmcmFnLnN0YXJ0ID4gbWFpbkJ1ZmZlckluZm8uZW5kICsgdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmIChhdEJ1ZmZlclN5bmNMaW1pdCB8fFxuICAgIC8vIE9yIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuICAgICEobWFpbkJ1ZmZlckluZm8gIT0gbnVsbCAmJiBtYWluQnVmZmVySW5mby5sZW4pICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAvLyBDaGVjayBmcmFnbWVudC10cmFja2VyIGZvciBtYWluIGZyYWdtZW50cyBzaW5jZSBHQVAgc2VnbWVudHMgZG8gbm90IHNob3cgdXAgaW4gYnVmZmVySW5mb1xuICAgICAgY29uc3QgbWFpbkZyYWcgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhmcmFnLnN0YXJ0LCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIGlmIChtYWluRnJhZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBCcmlkZ2UgZ2FwcyBpbiBtYWluIGJ1ZmZlclxuICAgICAgYXRHYXAgfHwgKGF0R2FwID0gISFtYWluRnJhZy5nYXAgfHwgISFhdEJ1ZmZlclN5bmNMaW1pdCAmJiBtYWluQnVmZmVySW5mby5sZW4gPT09IDApO1xuICAgICAgaWYgKGF0QnVmZmVyU3luY0xpbWl0ICYmICFhdEdhcCB8fCBhdEdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IG1haW5GcmFnLmVuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsSW5mbywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBzdXBlci5nZXRNYXhCdWZmZXJMZW5ndGgoKTtcbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJMZW5ndGgpLCB0aGlzLmNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgYXVkaW9UcmFja3NcbiAgfSkge1xuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCkpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgIH1cblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBkYXRhO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gZGF0YTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLm1haW5EZXRhaWxzID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMuYnVmZmVyZWRUcmFjayA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrSWQgPSB0aGlzLnZpZGVvVHJhY2tDQyA9IHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBpZiAodGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgaWYgKHRoaXMubWFpbkRldGFpbHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7dHJhY2tJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgY29uc3QgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICBpZiAoIW5ld0RldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suZGV0YWlscyAmJiBuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIG91ciBhdWRpbyByZW5kaXRpb24gaXMgYWxpZ25lZCB3aXRoIHRoZSBcIm1haW5cIiByZW5kaXRpb24sIHVzaW5nXG4gICAgICAgIC8vIHBkdCBhcyBvdXIgcmVmZXJlbmNlIHRpbWVzLlxuICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrSWQ7XG5cbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICh0aGlzLm1haW5EZXRhaWxzIHx8ICFuZXdEZXRhaWxzLmxpdmUpKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24odHJhY2suZGV0YWlscywgc2xpZGluZyk7XG4gICAgfVxuICAgIC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0sgJiYgIXRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHRyYWNrSWQsXG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHRoaXMud2FybignQXVkaW8gdHJhY2sgaXMgdW5kZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oJ0F1ZGlvIHRyYWNrIGRldGFpbHMgdW5kZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MnKTtcbiAgICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKGZyYWcuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0NvZGVjID0gY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMic7XG4gICAgbGV0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UodGhpcy5obHMsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgY29uc3QgaW5pdFNlZ21lbnREYXRhID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LmRhdGE7XG4gICAgaWYgKGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZmFsc2U7IC8vIGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgICBjb25zdCBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgJycsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgVW5rbm93biB2aWRlbyBQVFMgZm9yIGNjICR7ZnJhZy5jY30sIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyAke2ZyYWcuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FjaGVcbiAgICAgIH0gPSB0aGlzLndhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSB8fCB7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIGNhY2hlOiBuZXcgQ2h1bmtDYWNoZSgpLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjYWNoZS5wdXNoKG5ldyBVaW50OEFycmF5KHBheWxvYWQpKTtcbiAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSB0aGlzLnZpZGVvVHJhY2tDQztcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSk7XG4gIH1cbiAgb25CdWZmZXJSZXNldCggLyogZXZlbnQ6IEV2ZW50cy5CVUZGRVJfUkVTRVQgKi9cbiAgKSB7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICB9XG4gIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyIHx8IG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhLnRyYWNrcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IGRhdGEudHJhY2tzLnZpZGVvLmJ1ZmZlciB8fCBudWxsO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyYWJsZSA9IHRoaXMudmlkZW9CdWZmZXIgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKGJ1ZmZlcmFibGUpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoYnVmZmVyYWJsZSk7XG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkVGltZVJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSBvciBjb25jbHVkaW5nIHRoZSBhdWRpbyBzd2l0Y2g7IG90aGVyd2lzZSwgdGhlIHN3aXRjaGVkLXRvIHRyYWNrIHdpbGwgbm90IGJ1ZmZlclxuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfSwgYXVkaW9Td2l0Y2g6ICR7dGhpcy5zd2l0Y2hpbmdUcmFjayA/IHRoaXMuc3dpdGNoaW5nVHJhY2submFtZSA6ICdmYWxzZSd9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMuc3dpdGNoaW5nVHJhY2s7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgX29iamVjdFNwcmVhZDIoe30sIHRyYWNrKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRjb250ZXh0O1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihQbGF5bGlzdExldmVsVHlwZS5BVURJTywgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdHJhY2ssIGlmIG5vdCByZXRyeWluZyB0byBsb2FkIHRyYWNrLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0sgJiYgKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkY29udGV4dC50eXBlKSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmICghZGF0YS5wYXJlbnQgfHwgZGF0YS5wYXJlbnQgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgICAgICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgdmFyIF9pZDMkc2FtcGxlcztcbiAgICBjb25zdCBpZCA9ICdhdWRpbyc7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gdHJhbnNtdXhSZXN1bHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gbGV2ZWw7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB0ZXh0LFxuICAgICAgaWQzLFxuICAgICAgaW5pdFNlZ21lbnRcbiAgICB9ID0gcmVtdXhSZXN1bHQ7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBmcmFnbWVudCBoYXMgYmVlbiBhYm9ydGVkLiBXZSBjaGVjayB0aGlzIGJ5IGZpcnN0IHNlZWluZyBpZiB3ZSdyZSBzdGlsbCBwbGF5aW5nIHRoZSBjdXJyZW50IGxldmVsLlxuICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhZGV0YWlscykge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrICYmIGF1ZGlvKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlQXVkaW9Td2l0Y2godGhpcy5zd2l0Y2hpbmdUcmFjayk7XG4gICAgfVxuICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICB0aGlzLl9idWZmZXJJbml0U2VnbWVudChpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgIGlkLFxuICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrc1xuICAgICAgfSk7XG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICB9XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUU1xuICAgICAgfSA9IGF1ZGlvO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICBpZiAoaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzXG4gICAgICB9LCBpZDMpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHNcbiAgICAgIH0sIHRleHQpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuICBfYnVmZmVySW5pdFNlZ21lbnQodHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIHRyYW5zbXV4ZXJcbiAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XG4gICAgdHJhY2suaWQgPSAnYXVkaW8nO1xuICAgIHRoaXMubG9nKGBJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSwgY29kZWNzW3BhcnNlZF09WyR7dHJhY2suY29kZWN9XWApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgY29uc3QgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICBkYXRhOiBpbml0U2VnbWVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG5cbiAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nVHJhY2sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIHZhciBfdHJhY2skZGV0YWlsczI7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgdHJhY2spO1xuICAgICAgfSBlbHNlIGlmICgoX3RyYWNrJGRldGFpbHMyID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlsczIubGl2ZSAmJiAhdGhpcy5pbml0UFRTW2ZyYWcuY2NdKSB7XG4gICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZvciB2aWRlbyBQVFMgaW4gY29udGludWl0eSBjb3VudGVyICR7ZnJhZy5jY30gb2YgbGl2ZSBzdHJlYW0gYmVmb3JlIGxvYWRpbmcgYXVkaW8gZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke3RoaXMudHJhY2tJZH1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCB0cmFjaywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZyk7XG4gICAgfVxuICB9XG4gIGNvbXBsZXRlQXVkaW9Td2l0Y2goc3dpdGNoaW5nVHJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIGJ1ZmZlcmVkVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBidWZmZXJlZEF0dHJpYnV0ZXMgPSBidWZmZXJlZFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJlZFRyYWNrLmF0dHJzO1xuICAgIGNvbnN0IHN3aXRjaEF0dHJpYnV0ZXMgPSBzd2l0Y2hpbmdUcmFjay5hdHRycztcbiAgICBpZiAobWVkaWEgJiYgYnVmZmVyZWRBdHRyaWJ1dGVzICYmIChidWZmZXJlZEF0dHJpYnV0ZXMuQ0hBTk5FTFMgIT09IHN3aXRjaEF0dHJpYnV0ZXMuQ0hBTk5FTFMgfHwgYnVmZmVyZWRBdHRyaWJ1dGVzLk5BTUUgIT09IHN3aXRjaEF0dHJpYnV0ZXMuTkFNRSB8fCBidWZmZXJlZEF0dHJpYnV0ZXMuTEFOR1VBR0UgIT09IHN3aXRjaEF0dHJpYnV0ZXMuTEFOR1VBR0UpKSB7XG4gICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XG4gICAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gc3dpdGNoaW5nVHJhY2s7XG4gICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgc3dpdGNoaW5nVHJhY2spKTtcbiAgfVxufVxuXG5jbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlciBleHRlbmRzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsICdbYXVkaW8tdHJhY2stY29udHJvbGxlcl0nKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgdHJhY2tJbkFjdGl2ZUdyb3VwID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcbiAgICBpZiAoIXRyYWNrSW5BY3RpdmVHcm91cCB8fCB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZCAhPT0gZ3JvdXBJZCkge1xuICAgICAgdGhpcy53YXJuKGBUcmFjayB3aXRoIGlkOiR7aWR9IGFuZCBncm91cDoke2dyb3VwSWR9IG5vdCBmb3VuZCBpbiBhY3RpdmUgZ3JvdXAgJHt0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKGBhdWRpby10cmFjayAke2lkfSBcIiR7dHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWV9XCIgbGFuZzoke3RyYWNrSW5BY3RpdmVHcm91cC5sYW5nfSBncm91cDoke2dyb3VwSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIShsZXZlbEluZm8gIT0gbnVsbCAmJiBsZXZlbEluZm8uYXVkaW9Hcm91cElkcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gbGV2ZWxJbmZvLmF1ZGlvR3JvdXBJZHNbbGV2ZWxJbmZvLnVybElkXTtcbiAgICBpZiAodGhpcy5ncm91cElkICE9PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgIHRoaXMuZ3JvdXBJZCA9IGF1ZGlvR3JvdXBJZCB8fCBudWxsO1xuICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBJZCB8fCB0cmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpO1xuXG4gICAgICAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcbiAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhYXVkaW9UcmFja3Muc29tZSh0cmFjayA9PiB0cmFjay5kZWZhdWx0KSkge1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gYXVkaW9UcmFja3M7XG4gICAgICBjb25zdCBhdWRpb1RyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgIGF1ZGlvVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIGF1ZGlvIHRyYWNrcywgJHthdWRpb1RyYWNrcy5sZW5ndGh9IHRyYWNrKHMpIGZvdW5kIGluIGdyb3VwOiR7YXVkaW9Hcm91cElkfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICB0aGlzLnNlbGVjdEluaXRpYWxUcmFjaygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRSZWxvYWRQbGF5bGlzdCh0aGlzLmN1cnJlbnRUcmFjaykpIHtcbiAgICAgIC8vIFJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgaWYgbm8gcGxheWxpc3QgaXMgb3IgaGFzIGJlZW4gbG9hZGVkIHlldFxuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKHRoaXMudHJhY2tJZCk7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiBkYXRhLmNvbnRleHQuZ3JvdXBJZCA9PT0gdGhpcy5ncm91cElkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuICBzZXQgYXVkaW9UcmFjayhuZXdJZCkge1xuICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gIH1cbiAgc2V0QXVkaW9UcmFjayhuZXdJZCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgY29uc3QgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgdHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGdyb3VwSWQsXG4gICAgICBuYW1lXG4gICAgfSA9IHRyYWNrO1xuICAgIHRoaXMubG9nKGBTd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgJHtuZXdJZH0gXCIke25hbWV9XCIgbGFuZzoke3RyYWNrLmxhbmd9IGdyb3VwOiR7Z3JvdXBJZH1gKTtcbiAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IHRyYWNrO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG4gICAgaWYgKHRyYWNrLmRldGFpbHMgJiYgIXRyYWNrLmRldGFpbHMubGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXModHJhY2sudXJsLCBsYXN0VHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgfVxuICBzZWxlY3RJbml0aWFsVHJhY2soKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgY29uc3QgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQodGhpcy5jdXJyZW50VHJhY2spIHwgdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICBpZiAodHJhY2tJZCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayh0cmFja0lkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiAke3RoaXMuZ3JvdXBJZH0gdHJhY2sgY291bnQ6ICR7YXVkaW9UcmFja3MubGVuZ3RofWApO1xuICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrIHx8IHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2sgfHwgY3VycmVudFRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50VHJhY2suYXR0cnNbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXSA9PT0gdHJhY2suYXR0cnNbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFRyYWNrLm5hbWUgPT09IHRyYWNrLm5hbWUgJiYgY3VycmVudFRyYWNrLmxhbmcgPT09IHRyYWNrLmxhbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdChhdWRpb1RyYWNrKSkge1xuICAgICAgY29uc3QgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgY29uc3QgZ3JvdXBJZCA9IGF1ZGlvVHJhY2suZ3JvdXBJZDtcbiAgICAgIGxldCB1cmwgPSBhdWRpb1RyYWNrLnVybDtcbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgdGhpcy5sb2coYGxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgJHtpZH0gXCIke2F1ZGlvVHJhY2submFtZX1cIiBsYW5nOiR7YXVkaW9UcmFjay5sYW5nfSBncm91cDoke2dyb3VwSWR9YCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwodHJhY2tMaXN0MSwgdHJhY2tMaXN0Mikge1xuICBpZiAodHJhY2tMaXN0MS5sZW5ndGggIT09IHRyYWNrTGlzdDIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tMaXN0MS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc3VidGl0bGVBdHRyaWJ1dGVzSWRlbnRpY2FsKHRyYWNrTGlzdDFbaV0uYXR0cnMsIHRyYWNrTGlzdDJbaV0uYXR0cnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc3VidGl0bGVBdHRyaWJ1dGVzSWRlbnRpY2FsKGF0dHJzMSwgYXR0cnMyKSB7XG4gIC8vIE1lZGlhIG9wdGlvbnMgd2l0aCB0aGUgc2FtZSByZW5kaXRpb24gSUQgbXVzdCBiZSBiaXQgaWRlbnRpY2FsXG4gIGNvbnN0IHN0YWJsZVJlbmRpdGlvbklkID0gYXR0cnMxWydTVEFCTEUtUkVORElUSU9OLUlEJ107XG4gIGlmIChzdGFibGVSZW5kaXRpb25JZCkge1xuICAgIHJldHVybiBzdGFibGVSZW5kaXRpb25JZCA9PT0gYXR0cnMyWydTVEFCTEUtUkVORElUSU9OLUlEJ107XG4gIH1cbiAgLy8gV2hlbiByZW5kaXRpb24gSUQgaXMgbm90IHByZXNlbnQsIGNvbXBhcmUgYXR0cmlidXRlc1xuICByZXR1cm4gIVsnTEFOR1VBR0UnLCAnTkFNRScsICdDSEFSQUNURVJJU1RJQ1MnLCAnQVVUT1NFTEVDVCcsICdERUZBVUxUJywgJ0ZPUkNFRCddLnNvbWUoc3VidGl0bGVBdHRyaWJ1dGUgPT4gYXR0cnMxW3N1YnRpdGxlQXR0cmlidXRlXSAhPT0gYXR0cnMyW3N1YnRpdGxlQXR0cmlidXRlXSk7XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgIHN1cGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdbc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJdJywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIHRoaXMubGV2ZWxzID0gW107XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gIH1cbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgc3VjY2Vzc1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWQgPSB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGxldCB0aW1lUmFuZ2U7XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnRW5kID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICB9O1xuICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZyk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBjb25zdCBlbmRPZmZzZXRTdWJ0aXRsZXMgPSBlbmRPZmZzZXQgLSAxO1xuICAgICAgaWYgKGVuZE9mZnNldFN1YnRpdGxlcyA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEuZW5kT2Zmc2V0U3VidGl0bGVzID0gTWF0aC5tYXgoMCwgZW5kT2Zmc2V0U3VidGl0bGVzKTtcbiAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWQuZm9yRWFjaChidWZmZXJlZCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOykge1xuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPD0gZW5kT2Zmc2V0U3VidGl0bGVzKSB7XG4gICAgICAgICAgICBidWZmZXJlZC5zaGlmdCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChidWZmZXJlZFtpXS5zdGFydCA8IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWRbaV0uc3RhcnQgPSBlbmRPZmZzZXRTdWJ0aXRsZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0U3VidGl0bGVzLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGRhdGEuZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICBpZiAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcudHlwZSkgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIGxldmVscy5cbiAgb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIHtcbiAgICBzdWJ0aXRsZVRyYWNrc1xuICB9KSB7XG4gICAgaWYgKHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLmxldmVscywgc3VidGl0bGVUcmFja3MpKSB7XG4gICAgICB0aGlzLmxldmVscyA9IHN1YnRpdGxlVHJhY2tzLm1hcChtZWRpYVBsYXlsaXN0ID0+IG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLmxldmVscyA9IHN1YnRpdGxlVHJhY2tzLm1hcChtZWRpYVBsYXlsaXN0ID0+IHtcbiAgICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZFtsZXZlbC5pZF0gPSBbXTtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9KTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICBpZiAoIXRoaXMubGV2ZWxzLmxlbmd0aCB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdHJhY2sgaGFzIHRoZSBuZWNlc3NhcnkgZGV0YWlscyB0byBsb2FkIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMubGV2ZWxzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmIChjdXJyZW50VHJhY2sgIT0gbnVsbCAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90cmFjayRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFja0lkLFxuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAodHJhY2tJZCA+PSBsZXZlbHMubGVuZ3RoIHx8IHRyYWNrSWQgIT09IGN1cnJlbnRUcmFja0lkIHx8ICF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCB8fCAhbWFpbkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50ID0gbWFpbkRldGFpbHMuZnJhZ21lbnRzWzBdO1xuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgIC8vIGxpbmUgdXAgbGl2ZSBwbGF5bGlzdCB3aXRoIG1haW4gc28gdGhhdCBmcmFnbWVudHMgaW4gcmFuZ2UgYXJlIGxvYWRlZFxuICAgICAgICAgIHNsaWRpbmcgPSBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICAgICAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgICAgIGlmIChzbGlkaW5nID09PSAwICYmIG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgIC8vIHJlYWxpZ24gd2l0aCBtYWluIHdoZW4gdGhlcmUgaXMgbm8gb3ZlcmxhcCB3aXRoIGxhc3QgcmVmcmVzaFxuICAgICAgICAgIHNsaWRpbmcgPSBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICAgICAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrSWQ7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcblxuICAgIC8vIElmIHBsYXlsaXN0IGlzIG1pc2FsaWduZWQgYmVjYXVzZSBvZiBiYWQgUERUIG9yIGRyaWZ0LCBkZWxldGUgZGV0YWlscyB0byByZXN5bmMgd2l0aCBtYWluIG9uIHJlbG9hZFxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgJiYgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICBjb25zdCBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICB0aGlzLndhcm4oJ1N1YnRpdGxlIHBsYXlsaXN0IG5vdCBhbGlnbmVkIHdpdGggcGxheWJhY2snKTtcbiAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZnJhZ0xvYWRlZERhdGE7XG4gICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEuaXYgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG4gICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgICAgIGZyYWdcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMud2FybihgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRvVGljaygpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50VHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHRyYWNrID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcbiAgICAgIGlmICghbGV2ZWxzLmxlbmd0aCB8fCAhdHJhY2sgfHwgIXRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWdcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmQ6IHRhcmdldEJ1ZmZlclRpbWUsXG4gICAgICAgIGxlbjogYnVmZmVyTGVuXG4gICAgICB9ID0gYnVmZmVyZWRJbmZvO1xuICAgICAgY29uc3QgbWFpbkJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICBjb25zdCB0cmFja0RldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbikgKyB0cmFja0RldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICAgIGlmIChidWZmZXJMZW4gPiBtYXhCdWZMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kID0gdHJhY2tEZXRhaWxzLmVkZ2U7XG4gICAgICBsZXQgZm91bmRGcmFnID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IHRhcmdldEJ1ZmZlclRpbWUgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgTWF0aC5tYXgoZnJhZ21lbnRzWzBdLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lKSwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgICAgaWYgKCFmb3VuZEZyYWcgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zdGFydCA8IGZyYWdtZW50c1swXS5zdGFydCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvdW5kRnJhZyA9IHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmb3VuZEZyYWcpO1xuICAgICAgaWYgKGZvdW5kRnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICAvLyBMb2FkIGVhcmxpZXIgZnJhZ21lbnQgaW4gc2FtZSBkaXNjb250aW51aXR5IHRvIG1ha2UgdXAgZm9yIG1pc2FsaWduZWQgcGxheWxpc3RzIGFuZCBjdWVzIHRoYXQgZXh0ZW5kIGJleW9uZCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICBjb25zdCBjdXJTTklkeCA9IGZvdW5kRnJhZy5zbiAtIHRyYWNrRGV0YWlscy5zdGFydFNOO1xuICAgICAgICBjb25zdCBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgICBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcuY2MgPT09IGZvdW5kRnJhZy5jYyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShwcmV2RnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IHByZXZGcmFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZvdW5kRnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgIGNvbnN0IG1heENvbmZpZ0J1ZmZlciA9IHN1cGVyLmdldE1heEJ1ZmZlckxlbmd0aCgpO1xuICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1heENvbmZpZ0J1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYUJ1ZmZlclRpbWVSYW5nZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJhYmxlSW5zdGFuY2UodGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSk7XG4gIH1cbn1cbmNsYXNzIEJ1ZmZlcmFibGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVyYW5nZXMpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gdm9pZCAwO1xuICAgIGNvbnN0IGdldFJhbmdlID0gKG5hbWUsIGluZGV4LCBsZW5ndGgpID0+IHtcbiAgICAgIGluZGV4ID0gaW5kZXggPj4+IDA7XG4gICAgICBpZiAoaW5kZXggPiBsZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICcke25hbWV9JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHtpbmRleH0pIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBib3VuZCAoJHtsZW5ndGh9KWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVyYW5nZXNbaW5kZXhdW25hbWVdO1xuICAgIH07XG4gICAgdGhpcy5idWZmZXJlZCA9IHtcbiAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aW1lcmFuZ2VzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBlbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHN0YXJ0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZSgnc3RhcnQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnW3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lciA9ICgpID0+IHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCgpO1xuICAgIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSAoKSA9PiB0aGlzLnBvbGxUcmFja0NoYW5nZSgwKTtcbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgc3VidGl0bGVEaXNwbGF5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZURpc3BsYXk7XG4gIH1cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZSkge1xuICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKHRoaXMudHJhY2tJZCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIH1cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgfVxuICBwb2xsVHJhY2tDaGFuZ2UodGltZW91dCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIsIHRpbWVvdXQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAvLyBDbGVhciBsb2FkZWQgY3VlcyBvbiBtZWRpYSBkZXRhY2htZW50IGZyb20gdHJhY2tzXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXModHJhY2spO1xuICAgIH0pO1xuICAgIC8vIERpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcyBiZWZvcmUgZGV0YWNobWVudCBzbyB3aGVuIHJlYXR0YWNoZWQgb25seSB0cmFja3MgaW4gdGhhdCBjb250ZW50IGFyZSBlbmFibGVkLlxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cblxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tJZFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0cmFja0lkXTtcbiAgICBpZiAoIWN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIHN1YnRpdGxlIHRyYWNrIGlkICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1ckRldGFpbHMgPSBjdXJyZW50VHJhY2suZGV0YWlscztcbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhgc3VidGl0bGUgdHJhY2sgJHtpZH0gbG9hZGVkIFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV1gKTtcbiAgICBpZiAoaWQgPT09IHRoaXMudHJhY2tJZCkge1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmICghKGxldmVsSW5mbyAhPSBudWxsICYmIGxldmVsSW5mby50ZXh0R3JvdXBJZHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRHcm91cElkID0gbGV2ZWxJbmZvLnRleHRHcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuICAgIGNvbnN0IGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmdyb3VwSWQgIT09IHRleHRHcm91cElkKSB7XG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrcyA9IHRoaXMudHJhY2tzLmZpbHRlcih0cmFjayA9PiAhdGV4dEdyb3VwSWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gdGV4dEdyb3VwSWQpO1xuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gc3VidGl0bGVUcmFja3M7XG4gICAgICBjb25zdCBpbml0aWFsVHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2submFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuICAgICAgdGhpcy5ncm91cElkID0gdGV4dEdyb3VwSWQgfHwgbnVsbDtcbiAgICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgc3VidGl0bGVUcmFja3NcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgc3VidGl0bGUgdHJhY2tzLCAke3N1YnRpdGxlVHJhY2tzLmxlbmd0aH0gdHJhY2socykgZm91bmQgaW4gXCIke3RleHRHcm91cElkfVwiIGdyb3VwLWlkYCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgc3VidGl0bGVUcmFja3NVcGRhdGVkKTtcbiAgICAgIGlmIChpbml0aWFsVHJhY2tJZCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKGluaXRpYWxUcmFja0lkLCBsYXN0VHJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRSZWxvYWRQbGF5bGlzdChsYXN0VHJhY2spKSB7XG4gICAgICAvLyBSZXRyeSBwbGF5bGlzdCBsb2FkaW5nIGlmIG5vIHBsYXlsaXN0IGlzIG9yIGhhcyBiZWVuIGxvYWRlZCB5ZXRcbiAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayh0aGlzLnRyYWNrSWQsIGxhc3RUcmFjayk7XG4gICAgfVxuICB9XG4gIGZpbmRUcmFja0lkKG5hbWUpIHtcbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdERlZmF1bHRUcmFjayB8fCB0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSB0cmFjay5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgZGF0YS5jb250ZXh0Lmdyb3VwSWQgPT09IHRoaXMuZ3JvdXBJZCkge1xuICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG5cbiAgLyoqIGdldC9zZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChiYXNlZCBvbiBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IHN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhuZXdJZCwgbGFzdFRyYWNrKTtcbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdChjdXJyZW50VHJhY2spKSB7XG4gICAgICBjb25zdCBpZCA9IGN1cnJlbnRUcmFjay5pZDtcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSBjdXJyZW50VHJhY2suZ3JvdXBJZDtcbiAgICAgIGxldCB1cmwgPSBjdXJyZW50VHJhY2sudXJsO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBzdWJ0aXRsZSBwbGF5bGlzdCBmb3IgaWQgJHtpZH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgb2xkIHN1YnRpdGxlVHJhY2sgYW5kIHNldHMgY3VycmVudCBtb2RlIG9uIHRoZSBuZXh0IHN1YnRpdGxlVHJhY2suXG4gICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxuICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgKi9cbiAgdG9nZ2xlVHJhY2tNb2RlcyhuZXdJZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgdHJhY2tJZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIGNvbnN0IGdyb3VwVHJhY2tzID0gdGV4dFRyYWNrcy5maWx0ZXIodHJhY2sgPT4gdHJhY2suZ3JvdXBJZCA9PT0gdGhpcy5ncm91cElkKTtcbiAgICBpZiAobmV3SWQgPT09IC0xKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRUcmFjayA9IGdyb3VwVHJhY2tzW3RyYWNrSWRdO1xuICAgICAgaWYgKG9sZFRyYWNrKSB7XG4gICAgICAgIG9sZFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0VHJhY2sgPSBncm91cFRyYWNrc1tuZXdJZF07XG4gICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgbmV4dFRyYWNrLm1vZGUgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgKi9cbiAgc2V0U3VidGl0bGVUcmFjayhuZXdJZCwgbGFzdFRyYWNrKSB7XG4gICAgdmFyIF90cmFja3MkbmV3SWQ7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgLy8gc2V0dGluZyB0aGlzLnN1YnRpdGxlVHJhY2sgd2lsbCB0cmlnZ2VyIGludGVybmFsIGxvZ2ljXG4gICAgLy8gaWYgbWVkaWEgaGFzIG5vdCBiZWVuIGF0dGFjaGVkIHlldCwgaXQgd2lsbCBmYWlsXG4gICAgLy8gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB0cmFjayBpZFxuICAgIC8vIGFuZCB3ZSdsbCBzZXQgc3VidGl0bGVUcmFjayB3aGVuIG9uTWVkaWFBdHRhY2hlZCBpcyB0cmlnZ2VyZWRcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gbmV3SWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IG5ld0lkKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRyYWNrTW9kZXMobmV3SWQpO1xuICAgIH1cblxuICAgIC8vIGV4aXQgaWYgdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXQgb3IgaW52YWxpZFxuICAgIGlmICh0aGlzLnRyYWNrSWQgPT09IG5ld0lkICYmIChuZXdJZCA9PT0gLTEgfHwgKF90cmFja3MkbmV3SWQgPSB0cmFja3NbbmV3SWRdKSAhPSBudWxsICYmIF90cmFja3MkbmV3SWQuZGV0YWlscykgfHwgbmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIHRoaXMubG9nKGBTd2l0Y2hpbmcgdG8gc3VidGl0bGUtdHJhY2sgJHtuZXdJZH1gICsgKHRyYWNrID8gYCBcIiR7dHJhY2submFtZX1cIiBsYW5nOiR7dHJhY2subGFuZ30gZ3JvdXA6JHt0cmFjay5ncm91cElkfWAgOiAnJykpO1xuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgZ3JvdXBJZCA9ICcnLFxuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB1cmxcbiAgICAgIH0gPSB0cmFjaztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdXJsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaCB0byAtMVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBuZXdJZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uVGV4dFRyYWNrc0NoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB9XG4gICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhdGhpcy5obHMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJhY2tJZCA9IC0xO1xuICAgIGNvbnN0IHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgZm9yIChsZXQgaWQgPSAwOyBpZCA8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcbiAgICAgIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgfSBlbHNlIGlmICh0cmFja3NbaWRdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG4gICAgaWYgKHRoaXMuc3VidGl0bGVUcmFjayAhPT0gdHJhY2tJZCkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgY29uc3QgdHJhY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKCh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyB8fCB0cmFjay5raW5kID09PSAnY2FwdGlvbnMnKSAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbmNsYXNzIEJ1ZmZlck9wZXJhdGlvblF1ZXVlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlQnVmZmVyUmVmZXJlbmNlKSB7XG4gICAgdGhpcy5idWZmZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucXVldWVzID0ge1xuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMuYnVmZmVycyA9IHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTtcbiAgfVxuICBhcHBlbmQob3BlcmF0aW9uLCB0eXBlKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS5wdXNoKG9wZXJhdGlvbik7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmJ1ZmZlcnNbdHlwZV0pIHtcbiAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG4gIGluc2VydEFib3J0KG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUudW5zaGlmdChvcGVyYXRpb24pO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cbiAgYXBwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgbGV0IGV4ZWN1dGU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgZXhlY3V0ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICBvbkVycm9yOiAoKSA9PiB7fVxuICAgIH07XG4gICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBleGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVycyxcbiAgICAgIHF1ZXVlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gYnVmZmVyc1t0eXBlXTtcbiAgICBjb25zdCBxdWV1ZSA9IHF1ZXVlc1t0eXBlXTtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBxdWV1ZVswXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIHJlc3VsdCBpbiBhbiAndXBkYXRlZW5kJyBldmVudCBiZWluZyBmaXJlZC4gSWYgbm90LCB0aGUgcXVldWUgd2lsbCBsb2NrLiBPcGVyYXRpb25zXG4gICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICBvcGVyYXRpb24uZXhlY3V0ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybignW2J1ZmZlci1vcGVyYXRpb24tcXVldWVdOiBVbmhhbmRsZWQgZXhjZXB0aW9uIGV4ZWN1dGluZyB0aGUgY3VycmVudCBvcGVyYXRpb24nKTtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZSk7XG5cbiAgICAgICAgLy8gT25seSBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmLCBvdGhlcndpc2UgdGhlIHVwZGF0ZWVuZCBoYW5kbGVyIHdpbGwgZG8gdGhpcyBmb3IgdXNcbiAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgdGhpcy5xdWV1ZXNbdHlwZV0uc2hpZnQoKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIGN1cnJlbnQodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlc1t0eXBlXVswXTtcbiAgfVxufVxuXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG5jb25zdCBWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSA9IC8oW2hhXXZjLikoPzpcXC5bXi4sXSspKy87XG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIHtcbiAgLy8gVGhlIGxldmVsIGRldGFpbHMgdXNlZCB0byBkZXRlcm1pbmUgZHVyYXRpb24sIHRhcmdldC1kdXJhdGlvbiBhbmQgbGl2ZVxuXG4gIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG5cbiAgLy8gQSBxdWV1ZSBvZiBidWZmZXIgb3BlcmF0aW9ucyB3aGljaCByZXF1aXJlIHRoZSBTb3VyY2VCdWZmZXIgdG8gbm90IGJlIHVwZGF0aW5nIHVwb24gZXhlY3V0aW9uXG5cbiAgLy8gUmVmZXJlbmNlcyB0byBldmVudCBsaXN0ZW5lcnMgZm9yIGVhY2ggU291cmNlQnVmZmVyLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgZm9yIGV2ZW50IHJlbW92YWxcblxuICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG5cbiAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkXG5cbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuXG4gIC8vIExhc3QgTVAzIGF1ZGlvIGNodW5rIGFwcGVuZGVkXG5cbiAgLy8gY291bnRlcnNcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSAwO1xuICAgIHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0gdm9pZCAwO1xuICAgIC8vIEtlZXAgYXMgYXJyb3cgZnVuY3Rpb25zIHNvIHRoYXQgd2UgY2FuIGRpcmVjdGx5IHJlZmVyZW5jZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgYXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwge1xuICAgICAgICAgIG1lZGlhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQgPSAoKSA9PiB7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFFbXB0aWVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYSxcbiAgICAgICAgX29iamVjdFVybFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEuc3JjICE9PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgTWVkaWEgZWxlbWVudCBzcmMgd2FzIHNldCB3aGlsZSBhdHRhY2hpbmcgTWVkaWFTb3VyY2UgKCR7X29iamVjdFVybH0gPiAke21lZGlhLnNyY30pYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGhhc1NvdXJjZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdUcmFja3MpLmxlbmd0aCA+IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgfVxuICBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgQnVmZmVyT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICBsZXQgY29kZWNFdmVudHMgPSAyO1xuICAgIGlmIChkYXRhLmF1ZGlvICYmICFkYXRhLnZpZGVvIHx8ICFkYXRhLmFsdEF1ZGlvIHx8ICF0cnVlKSB7XG4gICAgICBjb2RlY0V2ZW50cyA9IDE7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSBjb2RlY0V2ZW50cztcbiAgICBsb2dnZXIubG9nKGAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRgKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgTWVkaWFTb3VyY2UpIHtcbiAgICAgIGNvbnN0IG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgLy8gTWVkaWFTb3VyY2UgbGlzdGVuZXJzIGFyZSBhcnJvdyBmdW5jdGlvbnMgd2l0aCBhIGxleGljYWwgc2NvcGUsIGFuZCBkbyBub3QgbmVlZCB0byBiZSBib3VuZFxuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcbiAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgbWVkaWEuc3JjID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgIC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBtZWRpYS5zcmM7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UsXG4gICAgICBfb2JqZWN0VXJsXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYFtidWZmZXItY29udHJvbGxlcl06IG9uTWVkaWFEZXRhY2hpbmc6ICR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIFNvdXJjZUJ1ZmZlcnMgYnkgaW52b2tpbmcgb25CdWZmZXJSZXNldFxuICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgaWYgKF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoX29iamVjdFVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcbiAgICAgICAgaWYgKG1lZGlhLnNyYyA9PT0gX29iamVjdFVybCkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBtZWRpYS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB1bmRlZmluZWQpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3luY2hyb25vdXNseSByZW1vdmUgdGhlIFNCIGZyb20gdGhlIG1hcCBiZWZvcmUgdGhlIG5leHQgY2FsbCBpbiBvcmRlciB0byBwcmV2ZW50IGFuIGFzeW5jIGZ1bmN0aW9uIGZyb21cbiAgICAgICAgICAvLyBhY2Nlc3NpbmcgaXRcbiAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gcmVzZXQgdGhlICR7dHlwZX0gYnVmZmVyYCwgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gIH1cbiAgb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXJDb3VudCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg7XG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIFNvdXJjZUJ1ZmZlciBjb2RlYyBuZWVkcyB0byBjaGFuZ2VcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAodHJhY2sgJiYgdHlwZW9mIHRyYWNrLmJ1ZmZlci5jaGFuZ2VUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0gPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICAgICAgY29uc3QgY3VycmVudENvZGVjID0gKHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWMpLnJlcGxhY2UoVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UsICckMScpO1xuICAgICAgICAgIGNvbnN0IG5leHRDb2RlYyA9IChsZXZlbENvZGVjIHx8IGNvZGVjKS5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLCAnJDEnKTtcbiAgICAgICAgICBpZiAoY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7Y29udGFpbmVyfTtjb2RlY3M9JHtsZXZlbENvZGVjIHx8IGNvZGVjfWA7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoYW5nZVR5cGUodHJhY2tOYW1lLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBzd2l0Y2hpbmcgY29kZWMgJHtjdXJyZW50Q29kZWN9IHRvICR7bmV4dENvZGVjfWApO1xuICAgICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiB0cmFjay5idWZmZXIsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IGRhdGFbdHJhY2tOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLCAwKTtcbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSAmJiB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kQ2hhbmdlVHlwZSh0eXBlLCBtaW1lVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBjaGFuZ2luZyAke3R5cGV9IHNvdXJjZUJ1ZmZlciB0eXBlIHRvICR7bWltZVR5cGV9YCk7XG4gICAgICAgICAgc2IuY2hhbmdlVHlwZShtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogZSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gY2hhbmdlICR7dHlwZX0gU291cmNlQnVmZmVyIHR5cGVgLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kaW5nKGV2ZW50LCBldmVudERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBvcGVyYXRpb25RdWV1ZSxcbiAgICAgIHRyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB0eXBlLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gZXZlbnREYXRhO1xuICAgIGNvbnN0IGNodW5rU3RhdHMgPSBjaHVua01ldGEuYnVmZmVyaW5nW3R5cGVdO1xuICAgIGNvbnN0IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgY29uc3QgZnJhZ0J1ZmZlcmluZyA9IGZyYWcuc3RhdHMuYnVmZmVyaW5nO1xuICAgIGNvbnN0IHBhcnRCdWZmZXJpbmcgPSBwYXJ0ID8gcGFydC5zdGF0cy5idWZmZXJpbmcgOiBudWxsO1xuICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXQgd2hlbiBhdWRpby9tcGVnIGZyYWdtZW50IG9yIHBhcnQgaXMgbm90IGNvbnRpZ3VvdXMgd2l0aCBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLlxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIGxldCBjaGVja1RpbWVzdGFtcE9mZnNldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIChhdWRpb1RyYWNrID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHwgY2h1bmtNZXRhLmlkID09PSAxIHx8IHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGNodW5rTWV0YTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZVN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKGNoZWNrVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZnJhZ1N0YXJ0IC0gc2IudGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAwLjEpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogVXBkYXRpbmcgYXVkaW8gU291cmNlQnVmZmVyIHRpbWVzdGFtcE9mZnNldCB0byAke2ZyYWdTdGFydH0gKGRlbHRhOiAke2RlbHRhfSkgc246ICR7ZnJhZy5zbn0pYCk7XG4gICAgICAgICAgICAgIHNiLnRpbWVzdGFtcE9mZnNldCA9IGZyYWdTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlZW5kYCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZUVuZCA9IGNodW5rU3RhdHMuZW5kID0gZW5kO1xuICAgICAgICBpZiAoZnJhZ0J1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIGZyYWdCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIHBhcnRCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZUJ1ZmZlclxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGltZVJhbmdlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgdGltZVJhbmdlc1t0eXBlXSA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzb3VyY2VCdWZmZXJbdHlwZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAwO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgdGltZVJhbmdlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBlcnIgPT4ge1xuICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICBsb2dnZXIuZXJyb3IoYFtidWZmZXItY29udHJvbGxlcl06IEVycm9yIGVuY291bnRlcmVkIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgdG8gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyYCwgZXJyKTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG4gICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmbHVzaE9wZXJhdGlvbiA9IHR5cGUgPT4gKHtcbiAgICAgIGV4ZWN1dGU6IHRoaXMucmVtb3ZlRXhlY3V0b3IuYmluZCh0aGlzLCB0eXBlLCBkYXRhLnN0YXJ0T2Zmc2V0LCBkYXRhLmVuZE9mZnNldCksXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogU3RhcnRlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogRmluaXNoZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBlID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYFtidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZW1vdmUgZnJvbSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmAsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkYXRhLnR5cGUpIHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbihkYXRhLnR5cGUpLCBkYXRhLnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKHR5cGUpLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkZyYWdQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGJ1ZmZlcnNBcHBlbmRlZFRvID0gW107XG4gICAgY29uc3QgZWxlbWVudGFyeVN0cmVhbXMgPSBwYXJ0ID8gcGFydC5lbGVtZW50YXJ5U3RyZWFtcyA6IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgndmlkZW8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25VbmJsb2NrZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZnJhZy5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChidWZmZXJzQXBwZW5kZWRUby5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6ICR7ZnJhZy50eXBlfSBsZXZlbDogJHtmcmFnLmxldmVsfSBzbjogJHtmcmFnLnNufWApO1xuICAgIH1cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVyc0FwcGVuZGVkVG8pO1xuICB9XG4gIG9uRnJhZ0NoYW5nZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmZsdXNoQmFja0J1ZmZlcigpO1xuICB9XG5cbiAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBlbmRlZCBhbmQgdHJpZ2dlciBjaGVja0VvcygpXG4gIC8vIGFuIHVuZGVmaW5lZCBkYXRhLnR5cGUgd2lsbCBtYXJrIGFsbCBidWZmZXJzIGFzIEVPUy5cbiAgb25CdWZmZXJFb3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBlbmRlZCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoKGFjYywgdHlwZSkgPT4ge1xuICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmIChzYiAmJiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHNiLmVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICghc2IuZW5kZWQpIHtcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICYmICEhKCFzYiB8fCBzYi5lbmRlZCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgaWYgKGVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBRdWV1ZWluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpYCk7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycygoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBzYi5lbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW2J1ZmZlci1jb250cm9sbGVyXTogQ291bGQgbm90IGNhbGwgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKS4gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZTogJHttZWRpYVNvdXJjZS5yZWFkeVN0YXRlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQ2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpYCk7XG4gICAgICAgIC8vIEFsbG93IHRoaXMgdG8gdGhyb3cgYW5kIGJlIGNhdWdodCBieSB0aGUgZW5xdWV1ZWluZyBmdW5jdGlvblxuICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfVxuICBmbHVzaEJhY2tCdWZmZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgZGV0YWlscyxcbiAgICAgIG1lZGlhLFxuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBkZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIGlmICghc291cmNlQnVmZmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBsaXZlQmFja0J1ZmZlckxlbmd0aFxuICAgIGNvbnN0IGJhY2tCdWZmZXJMZW5ndGggPSBkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCAhPT0gbnVsbCA/IGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggOiBobHMuY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihiYWNrQnVmZmVyTGVuZ3RoKSB8fCBiYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHRhcmdldER1cmF0aW9uID0gZGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgIGNvbnN0IG1heEJhY2tCdWZmZXJMZW5ndGggPSBNYXRoLm1heChiYWNrQnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgY29uc3QgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uIC0gbWF4QmFja0J1ZmZlckxlbmd0aDtcbiAgICBzb3VyY2VCdWZmZXJUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwICYmIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGV2ZW50OlxuICAgICAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2IuZW5kZWQgJiYgYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpIC0gY3VycmVudFRpbWUgPCB0YXJnZXREdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBDYW5ub3QgZmx1c2ggJHt0eXBlfSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbixcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAqL1xuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogMDtcbiAgICBpZiAoZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKGRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWxEdXJhdGlvbiA+IG1zRHVyYXRpb24gJiYgbGV2ZWxEdXJhdGlvbiA+IG1lZGlhRHVyYXRpb24gfHwgIWlzRmluaXRlTnVtYmVyKG1lZGlhRHVyYXRpb24pKSB7XG4gICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAgIC8vIG9ubHkgdXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byAke2xldmVsRHVyYXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gbGV2ZWxEdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2Vla2FibGVSYW5nZShsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgbWVkaWFTb3VyY2UgIT0gbnVsbCAmJiBtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQsIHN0YXJ0ICsgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLFxuICAgICAgb3BlcmF0aW9uUXVldWUsXG4gICAgICBwZW5kaW5nVHJhY2tzXG4gICAgfSA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cbiAgICBjb25zdCBwZW5kaW5nVHJhY2tzQ291bnQgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgaWYgKHBlbmRpbmdUcmFja3NDb3VudCAmJiAhYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCB8fCBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDIpIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgICAgICB0cmFja3M6IHRoaXMudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXJzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlQnVmZmVyLFxuICAgICAgbWVkaWFTb3VyY2VcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgIHRocm93IEVycm9yKGBzb3VyY2UgYnVmZmVyIGV4aXN0cyBmb3IgdHJhY2sgJHt0cmFja05hbWV9LCBob3dldmVyIHRyYWNrIGRvZXMgbm90YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgY29uc3QgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgIGNvbnN0IHNiTmFtZSA9IHRyYWNrTmFtZTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZWVuZCcsIHRoaXMuX29uU0JVcGRhdGVFbmQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnZXJyb3InLCB0aGlzLl9vblNCVXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9vblNCVXBkYXRlU3RhcnQodHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICB9XG4gIF9vblNCVXBkYXRlRW5kKHR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIF9vblNCVXBkYXRlRXJyb3IodHlwZSwgZXZlbnQpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHt0eXBlfSBTb3VyY2VCdWZmZXIgZXJyb3JgKTtcbiAgICBsb2dnZXIuZXJyb3IoYFtidWZmZXItY29udHJvbGxlcl06ICR7ZXJyb3J9YCwgZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLFxuICAgICAgZXJyb3IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTtcbiAgICAvLyB1cGRhdGVlbmQgaXMgYWx3YXlzIGZpcmVkIGFmdGVyIGVycm9yLCBzbyB3ZSdsbCBhbGxvdyB0aGF0IHRvIHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYgb2YgdGhlIHF1ZXVlXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIHJlbW92ZSBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICByZW1vdmVFeGVjdXRvcih0eXBlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZSxcbiAgICAgIG9wZXJhdGlvblF1ZXVlLFxuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICBsb2dnZXIud2FybihgW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byByZW1vdmUgZnJvbSB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhLmR1cmF0aW9uKSA/IG1lZGlhLmR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgY29uc3QgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgY29uc3QgcmVtb3ZlRW5kID0gTWF0aC5taW4oZW5kT2Zmc2V0LCBtZWRpYUR1cmF0aW9uLCBtc0R1cmF0aW9uKTtcbiAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQgJiYgIXNiLmVuZGluZykge1xuICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IFJlbW92aW5nIFske3JlbW92ZVN0YXJ0fSwke3JlbW92ZUVuZH1dIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyYCk7XG4gICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN5Y2xlIHRoZSBxdWV1ZVxuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIGFwcGVuZCBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICBhcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWUsXG4gICAgICBzb3VyY2VCdWZmZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIXNiKSB7XG4gICAgICBsb2dnZXIud2FybihgW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgc2IuYXBwZW5kQnVmZmVyKGRhdGEpO1xuICB9XG5cbiAgLy8gRW5xdWV1ZXMgYW4gb3BlcmF0aW9uIHRvIGVhY2ggU291cmNlQnVmZmVyIHF1ZXVlIHdoaWNoLCB1cG9uIGV4ZWN1dGlvbiwgcmVzb2x2ZXMgYSBwcm9taXNlLiBXaGVuIGFsbCBwcm9taXNlc1xuICAvLyByZXNvbHZlLCB0aGUgb25VbmJsb2NrZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIEZ1bmN0aW9ucyBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvIG5vdCBuZWVkIHRvIHVuYmxvY2sgdGhlIHF1ZXVlXG4gIC8vIHVwb24gY29tcGxldGlvbiwgc2luY2Ugd2UgYWxyZWFkeSBkbyBpdCBoZXJlXG4gIGJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVycyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKSkge1xuICAgIGlmICghYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICBjb25zdCBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJzLm1hcCh0eXBlID0+IG9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIodHlwZSkpO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgLy8gT25seSBjeWNsZSB0aGUgcXVldWUgaWYgdGhlIFNCIGlzIG5vdCB1cGRhdGluZy4gVGhlcmUncyBhIGJ1ZyBpbiBDaHJvbWUgd2hpY2ggc2V0cyB0aGUgU0IgdXBkYXRpbmcgZmxhZyB0b1xuICAgICAgICAvLyB0cnVlIHdoZW4gY2hhbmdpbmcgdGhlIE1lZGlhU291cmNlIGR1cmF0aW9uIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NTkzNTkmY2FuPTImcT1tZWRpYXNvdXJjZSUyMGR1cmF0aW9uKVxuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIGEgd29ya2Fyb3VuZCwgaXQncyBwcm9iYWJseSB1c2VmdWwgdG8gaGF2ZSBhcm91bmRcbiAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXRTb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpO1xuICB9XG4gIGFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsIGV2ZW50LCBmbikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgIGV2ZW50LFxuICAgICAgbGlzdGVuZXJcbiAgICB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChsID0+IHtcbiAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKGwuZXZlbnQsIGwubGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbmNvbnN0IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAweDJhOiAweGUxLFxuICAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDB4NWM6IDB4ZTksXG4gIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZTogMHhlZCxcbiAgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAweDVmOiAweGYzLFxuICAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDB4NjA6IDB4ZmEsXG4gIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMHg3YjogMHhlNyxcbiAgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gIDB4N2M6IDB4ZjcsXG4gIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAweDdkOiAweGQxLFxuICAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAweDdlOiAweGYxLFxuICAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAweDdmOiAweDI1ODgsXG4gIC8vIEZ1bGwgYmxvY2tcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgMHg4MDogMHhhZSxcbiAgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gIDB4ODE6IDB4YjAsXG4gIC8vIGRlZ3JlZSBzaWduXG4gIDB4ODI6IDB4YmQsXG4gIC8vIDEvMiBzeW1ib2xcbiAgMHg4MzogMHhiZixcbiAgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgMHg4NDogMHgyMTIyLFxuICAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgMHg4NTogMHhhMixcbiAgLy8gQ2VudHMgc3ltYm9sXG4gIDB4ODY6IDB4YTMsXG4gIC8vIFBvdW5kcyBzdGVybGluZ1xuICAweDg3OiAweDI2NmEsXG4gIC8vIE11c2ljIDgndGggbm90ZVxuICAweDg4OiAweGUwLFxuICAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gIDB4ODk6IDB4MjAsXG4gIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAweDhhOiAweGU4LFxuICAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDB4OGI6IDB4ZTIsXG4gIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhjOiAweGVhLFxuICAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZDogMHhlZSxcbiAgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGU6IDB4ZjQsXG4gIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhmOiAweGZiLFxuICAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4OTA6IDB4YzEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAweDkxOiAweGM5LFxuICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgMHg5MjogMHhkMyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gIDB4OTM6IDB4ZGEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAweDk0OiAweGRjLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgMHg5NTogMHhmYyxcbiAgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gIDB4OTY6IDB4MjAxOCxcbiAgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgMHg5NzogMHhhMSxcbiAgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAweDk4OiAweDJhLFxuICAvLyBhc3Rlcmlza1xuICAweDk5OiAweDIwMTksXG4gIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDB4OWE6IDB4MjUwMSxcbiAgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMHg5YjogMHhhOSxcbiAgLy8gY29weXJpZ2h0IHNpZ25cbiAgMHg5YzogMHgyMTIwLFxuICAvLyBTZXJ2aWNlIG1hcmtcbiAgMHg5ZDogMHgyMDIyLFxuICAvLyAocm91bmQpIGJ1bGxldFxuICAweDllOiAweDIwMWMsXG4gIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4OWY6IDB4MjAxZCxcbiAgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YTA6IDB4YzAsXG4gIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgMHhhMTogMHhjMixcbiAgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMHhhMjogMHhjNyxcbiAgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gIDB4YTM6IDB4YzgsXG4gIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgMHhhNDogMHhjYSxcbiAgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMHhhNTogMHhjYixcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gIDB4YTY6IDB4ZWIsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gIDB4YTc6IDB4Y2UsXG4gIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDB4YTg6IDB4Y2YsXG4gIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gIDB4YTk6IDB4ZWYsXG4gIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gIDB4YWE6IDB4ZDQsXG4gIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDB4YWI6IDB4ZDksXG4gIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgMHhhYzogMHhmOSxcbiAgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAweGFkOiAweGRiLFxuICAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAweGFlOiAweGFiLFxuICAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAweGFmOiAweGJiLFxuICAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4YjA6IDB4YzMsXG4gIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAweGIxOiAweGUzLFxuICAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgMHhiMjogMHhjZCxcbiAgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAweGIzOiAweGNjLFxuICAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDB4YjQ6IDB4ZWMsXG4gIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgMHhiNTogMHhkMixcbiAgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAweGI2OiAweGYyLFxuICAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDB4Yjc6IDB4ZDUsXG4gIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAweGI4OiAweGY1LFxuICAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgMHhiOTogMHg3YixcbiAgLy8gT3BlbiBjdXJseSBicmFjZVxuICAweGJhOiAweDdkLFxuICAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gIDB4YmI6IDB4NWMsXG4gIC8vIEJhY2tzbGFzaFxuICAweGJjOiAweDVlLFxuICAvLyBDYXJldFxuICAweGJkOiAweDVmLFxuICAvLyBVbmRlcnNjb3JlXG4gIDB4YmU6IDB4N2MsXG4gIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gIDB4YmY6IDB4MjIzYyxcbiAgLy8gVGlsZGUgb3BlcmF0b3JcbiAgMHhjMDogMHhjNCxcbiAgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAweGMxOiAweGU0LFxuICAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzI6IDB4ZDYsXG4gIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgMHhjMzogMHhmNixcbiAgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAweGM0OiAweGRmLFxuICAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAweGM1OiAweGE1LFxuICAvLyBZZW4gc3ltYm9sXG4gIDB4YzY6IDB4YTQsXG4gIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAweGM3OiAweDI1MDMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAweGM4OiAweGM1LFxuICAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAweGM5OiAweGU1LFxuICAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAweGNhOiAweGQ4LFxuICAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDB4Y2I6IDB4ZjgsXG4gIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAweGNjOiAweDI1MGYsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAweGNkOiAweDI1MTMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gIDB4Y2U6IDB4MjUxNyxcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmNvbnN0IGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gZ2V0Q2hhckZvckJ5dGUoYnl0ZSkge1xuICBsZXQgY2hhckNvZGUgPSBieXRlO1xuICBpZiAoc3BlY2lhbENlYTYwOENoYXJzQ29kZXMuaGFzT3duUHJvcGVydHkoYnl0ZSkpIHtcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5jb25zdCBOUl9ST1dTID0gMTU7XG5jb25zdCBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbmNvbnN0IHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMSA9IHtcbiAgMHgxMTogMixcbiAgMHgxMjogNCxcbiAgMHgxNTogNixcbiAgMHgxNjogOCxcbiAgMHgxNzogMTAsXG4gIDB4MTM6IDEzLFxuICAweDE0OiAxNVxufTtcbmNvbnN0IHJvd3NMb3dDaDIgPSB7XG4gIDB4MTk6IDEsXG4gIDB4MWE6IDMsXG4gIDB4MWQ6IDUsXG4gIDB4MWU6IDcsXG4gIDB4MWY6IDksXG4gIDB4MTg6IDExLFxuICAweDFiOiAxMixcbiAgMHgxYzogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbmNvbnN0IGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcbmNsYXNzIENhcHRpb25zTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2VMZXZlbCA9IDA7XG4gIH1cbiAgbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gc2V2ZXJpdHkpIHtcbiAgICAgIGNvbnN0IG0gPSB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2c7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMudGltZX0gWyR7c2V2ZXJpdHl9XSAke219YCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgY29uc3QgaGV4QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuY2xhc3MgUGVuU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljcyA9IHZvaWQgMDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfVxuICBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgY29uc3QgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICB0aGlzW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaDtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kICYmIHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCAmJiB0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaDtcbiAgfVxuICBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgKyAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaDtcbiAgfVxufVxuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhciB7XG4gIGNvbnN0cnVjdG9yKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy51Y2hhciA9IHZvaWQgMDtcbiAgICB0aGlzLnBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuICBzZXRDaGFyKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9XG4gIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICB9XG4gIGNvcHkobmV3Q2hhcikge1xuICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgfVxufVxuXG4vKipcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUm93IHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgdGhpcy5jaGFycyA9IHZvaWQgMDtcbiAgICB0aGlzLnBvcyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgY29weShvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAqL1xuICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gYWJzUG9zO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqL1xuICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIGNvbnN0IG5ld1BvcyA9IHRoaXMucG9zICsgcmVsUG9zO1xuICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5wb3MgKyAxOyBpIDwgbmV3UG9zICsgMTsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAqL1xuICBiYWNrU3BhY2UoKSB7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG4gIGluc2VydENoYXIoYnl0ZSkge1xuICAgIGlmIChieXRlID49IDB4OTApIHtcbiAgICAgIC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICgpID0+ICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfVxuICBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuICBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICB9XG4gIGdldFRleHRTdHJpbmcoKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIGlmIChlbXB0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuICB9XG4gIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICBjb25zdCBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENhcHRpb25TY3JlZW4ge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLnJvd3MgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyUm93ID0gdm9pZCAwO1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdyhsb2dnZXIpKTtcbiAgICB9IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuICBjb3B5KG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG4gIGJhY2tTcGFjZSgpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuYmFja1NwYWNlKCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgKi9cbiAgaW5zZXJ0Q2hhcihjaGFyKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gIH1cbiAgc2V0UGVuKHN0eWxlcykge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgfVxuICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH1cbiAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gIH1cbiAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xuICAgIGxldCBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgY29uc3QgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAvLyBXZSBvbmx5IGNvcHkgaWYgdGhlIGxhc3QgcG9zaXRpb24gd2FzIGFscmVhZHkgc2hvd24uXG4gICAgICAvLyBXZSB1c2UgdGhlIGN1ZVN0YXJ0VGltZSB2YWx1ZSB0byBjaGVjayB0aGlzLlxuICAgICAgY29uc3QgbGFzdE91dHB1dFNjcmVlbiA9IHRoaXMubGFzdE91dHB1dFNjcmVlbjtcbiAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgIGNvbnN0IHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICAgICAgaWYgKHByZXZMaW5lVGltZSAmJiB0aW1lICE9PSBudWxsICYmIHByZXZMaW5lVGltZSA8IHRpbWUpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIGkgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIGldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XG4gICAgICBjb25zdCBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50IC0gMSwgMCk7XG4gICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgZm9yZWdyb3VuZDogcGFjRGF0YS5jb2xvcixcbiAgICAgIHVuZGVybGluZTogcGFjRGF0YS51bmRlcmxpbmUsXG4gICAgICBpdGFsaWNzOiBwYWNEYXRhLml0YWxpY3MsXG4gICAgICBiYWNrZ3JvdW5kOiAnYmxhY2snLFxuICAgICAgZmxhc2g6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICovXG4gIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiAnYmtnRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShia2dEYXRhKSk7XG4gICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vIFNwYWNlXG4gIH1cblxuICBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9XG4gIHJvbGxVcCgpIHtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgIGNvbnN0IHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUm9sbGluZyB1cCcpO1xuICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICovXG4gIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICBjb25zdCBkaXNwbGF5VGV4dCA9IFtdO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IHJvd05yID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgcm93TnIgPSBpICsgMTtcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaCgnUm93ICcgKyByb3dOciArIFwiOiAnXCIgKyByb3dUZXh0ICsgXCInXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH1cbn1cblxuLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcblxuY2xhc3MgQ2VhNjA4Q2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlciwgbG9nZ2VyKSB7XG4gICAgdGhpcy5jaE5yID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZlcmJvc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIucmVzZXQoKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbiAgZ2V0SGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gIH1cbiAgc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICB9XG4gIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH1cbiAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICB9XG4gIHNldE1vZGUobmV3TW9kZSkge1xuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ01PREU9JyArIG5ld01vZGUpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cbiAgaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+IHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+ICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgY2NSQ0woKSB7XG4gICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcbiAgfVxuICBjY0JTKCkge1xuICAgIC8vIEJhY2tTcGFjZVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNjQU9GKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG4gIH1cbiAgY2NBT04oKSB7XG4gICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxuICB9XG4gIGNjREVSKCkge1xuICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgfVxuICBjY1JVKG5yUm93cykge1xuICAgIC8vIFJvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICB9XG4gIGNjRk9OKCkge1xuICAgIC8vIEZsYXNoIE9uXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgIGZsYXNoOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY2NSREMoKSB7XG4gICAgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH1cbiAgY2NUUigpIHtcbiAgICAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVFInKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9XG4gIGNjUlREKCkge1xuICAgIC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuICBjY0VETSgpIHtcbiAgICAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cbiAgY2NDUigpIHtcbiAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cbiAgY2NFTk0oKSB7XG4gICAgLy8gRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgfVxuICBjY0VPQygpIHtcbiAgICAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgY29uc3QgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjVE8obnJDb2xzKSB7XG4gICAgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICB9XG4gIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHtcbiAgICAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIGNvbnN0IGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICBjb25zdCBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuICBvdXRwdXREYXRhVXBkYXRlKGRpc3BhdGNoID0gZmFsc2UpIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0aW1lLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLmNvcHkodGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgIH1cbiAgfVxuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaWxsIGJlIDEgb3IgMiB3aGVuIHBhcnNpbmcgY2FwdGlvbnNcblxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcbiAgY29uc3RydWN0b3IoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgQ2FwdGlvbnNMb2dnZXIoKTtcbiAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkLCBvdXQxLCBsb2dnZXIpLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCArIDEsIG91dDIsIGxvZ2dlcildO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IGNyZWF0ZUNtZEhpc3RvcnkoKTtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuICBnZXRIYW5kbGVyKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5nZXRIYW5kbGVyKCk7XG4gIH1cbiAgc2V0SGFuZGxlcihjaGFubmVsLCBuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5jaGFubmVsc1tjaGFubmVsXS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICovXG4gIGFkZERhdGEodGltZSwgYnl0ZUxpc3QpIHtcbiAgICBsZXQgY21kRm91bmQ7XG4gICAgbGV0IGE7XG4gICAgbGV0IGI7XG4gICAgbGV0IGNoYXJzRm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlci50aW1lID0gdGltZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG4gICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyQ2hOciA9IHRoaXMuY3VycmVudENoYW5uZWw7XG4gICAgICAgICAgaWYgKGN1cnJDaE5yICYmIGN1cnJDaE5yID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY3VyckNoTnJdO1xuICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCAmJiAhY2hhcnNGb3VuZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMiwgXCJDb3VsZG4ndCBwYXJzZSBjbGVhbmVkIGRhdGEgXCIgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgQ29tbWFuZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAqL1xuICBwYXJzZUNtZChhLCBiKSB7XG4gICAgY29uc3Qge1xuICAgICAgY21kSGlzdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWQpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgY29uc3QgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MjEgJiYgYiA8PSAweDIzO1xuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjaE5yID0gYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MTcgPyAxIDogMjtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxZCkge1xuICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgY2hhbm5lbC5jY1JDTCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XG4gICAgICAgIGNoYW5uZWwuY2NCUygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICBjaGFubmVsLmNjQU9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICBjaGFubmVsLmNjUlUoMyk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICBjaGFubmVsLmNjUkRDKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmEpIHtcbiAgICAgICAgY2hhbm5lbC5jY1RSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmIpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJjKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFRE0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICBjaGFubmVsLmNjQ1IoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZSkge1xuICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VPQygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhID09IDB4MTcgfHwgYSA9PSAweDFGXG4gICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xuICAgIH1cbiAgICBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICovXG4gIHBhcnNlTWlkcm93KGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IDA7XG4gICAgaWYgKChhID09PSAweDExIHx8IGEgPT09IDB4MTkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgIGNoTnIgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hOciA9IDI7XG4gICAgICB9XG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMCwgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXG4gICAqL1xuICBwYXJzZVBBQyhhLCBiKSB7XG4gICAgbGV0IHJvdztcbiAgICBjb25zdCBjbWRIaXN0b3J5ID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgIGNvbnN0IGNhc2UxID0gKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcgfHwgYSA+PSAweDE5ICYmIGEgPD0gMHgxZikgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg3ZjtcbiAgICBjb25zdCBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4NWY7XG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSkge1xuICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCBjbWRIaXN0b3J5KTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICB9XG5cbiAgICBjb25zdCBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NWYpIHtcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgIGxldCBwYWNJbmRleDtcbiAgICBjb25zdCBwYWNEYXRhID0ge1xuICAgICAgY29sb3I6IG51bGwsXG4gICAgICBpdGFsaWNzOiBmYWxzZSxcbiAgICAgIGluZGVudDogbnVsbCxcbiAgICAgIHVuZGVybGluZTogZmFsc2UsXG4gICAgICByb3c6IHJvd1xuICAgIH07XG4gICAgaWYgKGJ5dGUgPiAweDVmKSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xuICAgIH1cbiAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xuICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0RhdGEuaW5kZW50ID0gTWF0aC5mbG9vcigocGFjSW5kZXggLSAweDEwKSAvIDIpICogNDtcbiAgICB9XG4gICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgbGV0IGNoYW5uZWxOcjtcbiAgICBsZXQgY2hhckNvZGVzID0gbnVsbDtcbiAgICBsZXQgY2hhckNvZGUxID0gbnVsbDtcbiAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICBjaGFyQ29kZTEgPSBhO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICBsZXQgb25lQ29kZTtcbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2Rlcykge1xuICAgICAgY29uc3QgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgIHNldExhc3RDbWQoYSwgYiwgdGhpcy5jbWRIaXN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcbiAgICBjb25zdCBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MmQgJiYgYiA8PSAweDJmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgY29uc3QgYmtnRGF0YSA9IHt9O1xuICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAqL1xuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgY21kSGlzdG9yeS5hID0gYTtcbiAgY21kSGlzdG9yeS5iID0gYjtcbn1cbmZ1bmN0aW9uIGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgcmV0dXJuIGNtZEhpc3RvcnkuYSA9PT0gYSAmJiBjbWRIaXN0b3J5LmIgPT09IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG5jbGFzcyBPdXRwdXRGaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdGltZWxpbmVDb250cm9sbGVyO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICB9XG4gIGRpc3BhdGNoQ3VlKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbiwgdGhpcy5jdWVSYW5nZXMpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuICBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwgfHwgdGhpcy5zdGFydFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIH1cbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVlRUQ3VlID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLlZUVEN1ZSkge1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgfVxuICBjb25zdCBBbGxvd2VkRGlyZWN0aW9ucyA9IFsnJywgJ2xyJywgJ3JsJ107XG4gIGNvbnN0IEFsbG93ZWRBbGlnbm1lbnRzID0gWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgZnVuY3Rpb24gaXNBbGxvd2VkVmFsdWUoYWxsb3dlZCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBuZWNlc3NhcnkgZm9yIGFzc3VyaW5nIHRoZSBnZW5lcmljIGNvbmZvcm1zIHRvIHRoZSBBcnJheSBpbnRlcmZhY2VcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsb3dlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVzZXQgdGhlIHR5cGUgc28gdGhhdCB0aGUgbmV4dCBuYXJyb3dpbmcgd29ya3Mgd2VsbFxuICAgIGNvbnN0IGxjVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuICAgIGlmICh+YWxsb3dlZC5pbmRleE9mKGxjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbGNWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkQWxpZ25tZW50cywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZChvYmosIC4uLnJlc3QpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICBjb25zdCBjdWUgPSB0aGlzO1xuICAgIGNvbnN0IGJhc2VPYmogPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgLy8gbGF6aWx5LlxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIGxldCBfaWQgPSAnJztcbiAgICBsZXQgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gICAgbGV0IF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgbGV0IF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICBsZXQgX3RleHQgPSB0ZXh0O1xuICAgIGxldCBfcmVnaW9uID0gbnVsbDtcbiAgICBsZXQgX3ZlcnRpY2FsID0gJyc7XG4gICAgbGV0IF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgbGV0IF9saW5lID0gJ2F1dG8nO1xuICAgIGxldCBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICBsZXQgX3Bvc2l0aW9uID0gNTA7XG4gICAgbGV0IF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgbGV0IF9zaXplID0gNTA7XG4gICAgbGV0IF9hbGlnbiA9ICdtaWRkbGUnO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gdG9kbzogaW1wbGVtZW50IFZUVFJlZ2lvbiBwb2x5ZmlsbD9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIGNvbnN0IFdlYlZUVCA9IHNlbGYuV2ViVlRUO1xuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZShzZWxmLCB0aGlzLnRleHQpO1xuICB9O1xuICAvLyB0aGlzIGlzIGEgcG9seWZpbGwgaGFja1xuICByZXR1cm4gVlRUQ3VlO1xufSkoKTtcblxuLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzXG4gKi9cblxuY2xhc3MgU3RyaW5nRGVjb2RlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gIH1cbn1cblxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgcGFyc2VGbG9hdChmIHx8IDApO1xuICB9XG4gIGNvbnN0IG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocGFyc2VGbG9hdChtWzJdKSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzJdLCBtWzNdLCAwLCBtWzRdKTtcbiAgfVxuICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9XG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0KGssIHYsIGEpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQoaywgdikge1xuICAgIGlmICgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLy50ZXN0KHYpKSB7XG4gICAgICBjb25zdCBwZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmIChwZXJjZW50ID49IDAgJiYgcGVyY2VudCA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0IGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICBjb25zdCBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKGNvbnN0IGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGsgPSBrdlswXTtcbiAgICBjb25zdCB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG5jb25zdCBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgY29uc3Qgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgY29uc3QgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgbGV0IHZhbHM7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgbGV0IGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgbGV0IHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnNsaWNlKDAsIDMpICE9PSAnLS0+Jykge1xuICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICsgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuY2xhc3MgVlRUUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgdGhpcy5yZWdpb25MaXN0ID0gW107XG4gICAgdGhpcy5jdWUgPSBudWxsO1xuICAgIHRoaXMub25jdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbnBhcnNpbmdlcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uZmx1c2ggPSB2b2lkIDA7XG4gIH1cbiAgcGFyc2UoZGF0YSkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgbGV0IGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcjtcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmUgPSBidWZmZXIuc2xpY2UoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlci5zbGljZShwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgLy8gc3dpdGNoIChrKSB7XG4gICAgICAgIC8vIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgIC8vIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBsaW5lID0gJyc7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgY29uc3QgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCEobSAhPSBudWxsICYmIG1bMF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuICAgICAgbGV0IGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoX3RoaXMuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmN1ZSA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgX3RoaXMuY3VlLCBfdGhpcy5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY3VlICYmIF90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90aGlzLmN1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdCQURDVUUnOlxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIF90aGlzLmN1ZSAmJiBfdGhpcy5vbmN1ZSkge1xuICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgfVxuICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIC8vIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBfdGhpcy5idWZmZXIgKz0gJ1xcblxcbic7XG4gICAgICAgIF90aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgfHwgX3RoaXMuc3RhdGUgPT09ICdCQURXRUJWVFQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKF90aGlzLm9ucGFyc2luZ2Vycm9yKSB7XG4gICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3RoaXMub25mbHVzaCkge1xuICAgICAgX3RoaXMub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5jb25zdCBMSU5FQlJFQUtTID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5jb25zdCBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApIHtcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG59O1xuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC0zKSk7XG4gIGNvbnN0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC02LCAtNCkpO1xuICBjb25zdCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtOSwgLTcpKTtcbiAgY29uc3QgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cmluZygwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih0cykgfHwgIWlzRmluaXRlTnVtYmVyKHNlY3MpIHx8ICFpc0Zpbml0ZU51bWJlcihtaW5zKSB8fCAhaXNGaW5pdGVOdW1iZXIoaG91cnMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IExvY2FsOiR7dGltZVN0cmluZ31gKTtcbiAgfVxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTtcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuY29uc3QgaGFzaCA9IGZ1bmN0aW9uIGhhc2godGV4dCkge1xuICBsZXQgX2hhc2ggPSA1MzgxO1xuICBsZXQgaSA9IHRleHQubGVuZ3RoO1xuICB3aGlsZSAoaSkge1xuICAgIF9oYXNoID0gX2hhc2ggKiAzMyBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICB9XG4gIHJldHVybiAoX2hhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG4vLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxuY29uc3QgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIGxldCBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG5cbiAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICB3aGlsZSAoKF9wcmV2Q0MgPSBwcmV2Q0MpICE9IG51bGwgJiYgX3ByZXZDQy5uZXcpIHtcbiAgICB2YXIgX3ByZXZDQztcbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcbmZ1bmN0aW9uIHBhcnNlV2ViVlRUKHZ0dEJ5dGVBcnJheSwgaW5pdFBUUywgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gIGNvbnN0IHZ0dExpbmVzID0gdXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UoTElORUJSRUFLUywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgY3VlcyA9IFtdO1xuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTID8gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoaW5pdFBUUy5iYXNlVGltZSwgaW5pdFBUUy50aW1lc2NhbGUpIDogMDtcbiAgbGV0IGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgbGV0IHRpbWVzdGFtcE1hcE1QRUdUUyA9IDA7XG4gIGxldCB0aW1lc3RhbXBNYXBMT0NBTCA9IDA7XG4gIGxldCBwYXJzaW5nRXJyb3I7XG4gIGxldCBpbkhlYWRlciA9IHRydWU7XG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICBjb25zdCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuICAgIGNvbnN0IHdlYlZ0dE1wZWdUc01hcE9mZnNldCA9ICh0aW1lc3RhbXBNYXBNUEVHVFMgLSBpbml0OTBrSHopIC8gOTAwMDA7XG5cbiAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgIGlmIChjdXJyQ0MgIT0gbnVsbCAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICBpZiAodGltZXN0YW1wTWFwTE9DQUwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHdlYlZ0dE1wZWdUc01hcE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgIGlmICghaW5pdFBUUykge1xuICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgaW5pdFBUUyBmb3IgVlRUIE1QRUdUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgY3VlT2Zmc2V0ID0gd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBjdWUuZW5kVGltZSAtIGN1ZS5zdGFydFRpbWU7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm9ybWFsaXplUHRzKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICBjdWUuc3RhcnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCAwKTtcbiAgICBjdWUuZW5kVGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIGR1cmF0aW9uLCAwKTtcblxuICAgIC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcbiAgICBjb25zdCB0ZXh0ID0gY3VlLnRleHQudHJpbSgpO1xuXG4gICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG5cbiAgICAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuICAgIGlmICghY3VlLmlkKSB7XG4gICAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgfVxuICB9O1xuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgfTtcbiAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcnNpbmdFcnJvcikge1xuICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQmFjayhjdWVzKTtcbiAgfTtcblxuICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICBsaW5lLnNsaWNlKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zbGljZSg2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc2xpY2UoNykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgdGltZXN0YW1wTWFwTE9DQUwgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgfSk7XG4gIHBhcnNlci5mbHVzaCgpO1xufVxuXG5jb25zdCBJTVNDMV9DT0RFQyA9ICdzdHBwLnR0bWwuaW0xdCc7XG5cbi8vIFRpbWUgZm9ybWF0OiBoOm06czpmcmFtZXMoLnN1YmZyYW1lcylcbmNvbnN0IEhNU0ZfUkVHRVggPSAvXihcXGR7Mix9KTooXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KVxcLj8oXFxkKyk/JC87XG5cbi8vIFRpbWUgZm9ybWF0OiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBmcmFtZXMsIHRpY2tzXG5jb25zdCBUSU1FX1VOSVRfUkVHRVggPSAvXihcXGQqKD86XFwuXFxkKik/KShofG18c3xtc3xmfHQpJC87XG5jb25zdCB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcmVzdWx0cyA9IGZpbmRCb3gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIFsnbWRhdCddKTtcbiAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3JDYWxsQmFjayhuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBJTVNDMSBtZGF0JykpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dG1sTGlzdCA9IHJlc3VsdHMubWFwKG1kYXQgPT4gdXRmOEFycmF5VG9TdHIobWRhdCkpO1xuICBjb25zdCBzeW5jVGltZSA9IHRvVGltZXNjYWxlRnJvbVNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIDEsIGluaXRQVFMudGltZXNjYWxlKTtcbiAgdHJ5IHtcbiAgICB0dG1sTGlzdC5mb3JFYWNoKHR0bWwgPT4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGVycm9yQ2FsbEJhY2soZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHR0bWwsICd0ZXh0L3htbCcpO1xuICBjb25zdCB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcbiAgaWYgKCF0dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0dG1sJyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgdGlja1JhdGU6IDBcbiAgfTtcbiAgY29uc3QgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShgdHRwOiR7a2V5fWApIHx8IGRlZmF1bHRSYXRlSW5mb1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gIGNvbnN0IHN0eWxlRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnc3R5bGluZycsICdzdHlsZScpKTtcbiAgY29uc3QgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgY29uc3QgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICByZXR1cm4gW10ubWFwLmNhbGwoY3VlRWxlbWVudHMsIGN1ZUVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcbiAgICBpZiAoIWN1ZVRleHQgfHwgIWN1ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdiZWdpbicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYmVnaW4nKSwgcmF0ZUluZm8pO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICBsZXQgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZW5kVGltZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUgLSBzeW5jVGltZSwgZW5kVGltZSAtIHN5bmNUaW1lLCBjdWVUZXh0KTtcbiAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgY29uc3QgcmVnaW9uID0gcmVnaW9uRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZ2lvbicpXTtcbiAgICBjb25zdCBzdHlsZSA9IHN0eWxlRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyldO1xuXG4gICAgLy8gQXBwbHkgc3R5bGVzIHRvIGN1ZVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4dEFsaWduXG4gICAgfSA9IHN0eWxlcztcbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAvLyBjdWUucG9zaXRpb25BbGlnbiBub3Qgc2V0dGFibGUgaW4gRkZ+MjAxNlxuICAgICAgY29uc3QgbGluZUFsaWduID0gdGV4dEFsaWduVG9MaW5lQWxpZ25bdGV4dEFsaWduXTtcbiAgICAgIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgIH1cbiAgICAgIGN1ZS5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICB9XG4gICAgX2V4dGVuZHMoY3VlLCBzdHlsZXMpO1xuICAgIHJldHVybiBjdWU7XG4gIH0pLmZpbHRlcihjdWUgPT4gY3VlICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRDb2xsZWN0aW9uKGZyb21FbGVtZW50LCBwYXJlbnROYW1lLCBjaGlsZE5hbWUpIHtcbiAgY29uc3QgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gIHJldHVybiBlbGVtZW50c1dpdGhJZC5yZWR1Y2UoKGRpY3QsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4bWw6aWQnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGRpY3RbaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3Q7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQsIHRyaW0pIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzKS5yZWR1Y2UoKHN0ciwgbm9kZSwgaSkgPT4ge1xuICAgIHZhciBfbm9kZSRjaGlsZE5vZGVzO1xuICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnYnInICYmIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKChfbm9kZSRjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzKSAhPSBudWxsICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgfSBlbHNlIGlmICh0cmltKSB7XG4gICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlLCBzdHlsZUVsZW1lbnRzKSB7XG4gIGNvbnN0IHR0c05zID0gJ2h0dHA6Ly93d3cudzMub3JnL25zL3R0bWwjc3R5bGluZyc7XG4gIGxldCByZWdpb25TdHlsZSA9IG51bGw7XG4gIGNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IFsnZGlzcGxheUFsaWduJywgJ3RleHRBbGlnbicsICdjb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSdcbiAgLy8gJ2ZvbnRXZWlnaHQnLFxuICAvLyAnbGluZUhlaWdodCcsXG4gIC8vICd3cmFwT3B0aW9uJyxcbiAgLy8gJ2ZvbnRTdHlsZScsXG4gIC8vICdkaXJlY3Rpb24nLFxuICAvLyAnd3JpdGluZ01vZGUnXG4gIF07XG5cbiAgY29uc3QgcmVnaW9uU3R5bGVOYW1lID0gcmVnaW9uICE9IG51bGwgJiYgcmVnaW9uLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSA/IHJlZ2lvbi5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgOiBudWxsO1xuICBpZiAocmVnaW9uU3R5bGVOYW1lICYmIHN0eWxlRWxlbWVudHMuaGFzT3duUHJvcGVydHkocmVnaW9uU3R5bGVOYW1lKSkge1xuICAgIHJlZ2lvblN0eWxlID0gc3R5bGVFbGVtZW50c1tyZWdpb25TdHlsZU5hbWVdO1xuICB9XG4gIHJldHVybiBzdHlsZUF0dHJpYnV0ZXMucmVkdWNlKChzdHlsZXMsIG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEF0dHJpYnV0ZU5TKHN0eWxlLCB0dHNOcywgbmFtZSkgfHwgZ2V0QXR0cmlidXRlTlMocmVnaW9uLCB0dHNOcywgbmFtZSkgfHwgZ2V0QXR0cmlidXRlTlMocmVnaW9uU3R5bGUsIHR0c05zLCBuYW1lKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHN0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBucywgbmFtZSkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGVOUyhucywgbmFtZSkgPyBlbGVtZW50LmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKSA6IG51bGw7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBQYXJzaW5nRXJyb3Iobm9kZSkge1xuICByZXR1cm4gbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgdHRtbCB0aW1lc3RhbXAgJHtub2RlfWApO1xufVxuZnVuY3Rpb24gcGFyc2VUdG1sVGltZSh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGlmICghdGltZUF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHNlY29uZHMgPSBwYXJzZVRpbWVTdGFtcCh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBpZiAoc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIGlmIChITVNGX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgc2Vjb25kcyA9IHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9IGVsc2UgaWYgKFRJTUVfVU5JVF9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlY29uZHM7XG59XG5mdW5jdGlvbiBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBjb25zdCBtID0gSE1TRl9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGNvbnN0IGZyYW1lcyA9IChtWzRdIHwgMCkgKyAobVs1XSB8IDApIC8gcmF0ZUluZm8uc3ViRnJhbWVSYXRlO1xuICByZXR1cm4gKG1bMV0gfCAwKSAqIDM2MDAgKyAobVsyXSB8IDApICogNjAgKyAobVszXSB8IDApICsgZnJhbWVzIC8gcmF0ZUluZm8uZnJhbWVSYXRlO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBjb25zdCBtID0gVElNRV9VTklUX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgY29uc3QgdmFsdWUgPSBOdW1iZXIobVsxXSk7XG4gIGNvbnN0IHVuaXQgPSBtWzJdO1xuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDM2MDA7XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gdmFsdWUgKiA2MDtcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAxMDAwO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIHZhbHVlIC8gcmF0ZUluZm8uZnJhbWVSYXRlO1xuICAgIGNhc2UgJ3QnOlxuICAgICAgcmV0dXJuIHZhbHVlIC8gcmF0ZUluZm8udGlja1JhdGU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuQ3VlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdm9pZCAwO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMzoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrNDoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwxID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgY29uc3QgY2hhbm5lbDIgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2syJyk7XG4gICAgICBjb25zdCBjaGFubmVsMyA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazMnKTtcbiAgICAgIGNvbnN0IGNoYW5uZWw0ID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gbmV3IENlYTYwOFBhcnNlcigxLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IENlYTYwOFBhcnNlcigzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgIH1cbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5jZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIyID0gbnVsbDtcbiAgfVxuICBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIGxldCBtZXJnZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gY3VlUmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICBjb25zdCBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBjdWVSYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgICAgdGhpcy5DdWVzLm5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnY2FwdGlvbnMnLFxuICAgICAgICBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgb25Jbml0UHRzRm91bmQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIGlkLFxuICAgIGluaXRQVFMsXG4gICAgdGltZXNjYWxlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh1bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG4gICAgICAgIGlmICh0ZXh0VHJhY2tbdHJhY2tOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlQ2FwdGlvbnNUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB0aGlzLmNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICBjYXB0aW9uc1RyYWNrcyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBsYW5ndWFnZUNvZGVcbiAgICB9ID0gY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgY29uc3QgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpO1xuICAgIGlmICghZXhpc3RpbmdUcmFjaykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICB0ZXh0VHJhY2tbdHJhY2tOYW1lXSA9IHRydWU7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIHNlbmRBZGRUcmFja0V2ZW50KGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIG1lZGlhKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGEgc2luZ2xlIHRyYWNrIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgIGNvbnN0IHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWwgPSB0cmFja1Byb3BlcnRpZXMubGFiZWw7XG4gICAgY29uc3QgdHJhY2sgPSB7XG4gICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgIGxhYmVsLFxuICAgICAga2luZDogJ2NhcHRpb25zJyxcbiAgICAgIGRlZmF1bHQ6IHRyYWNrUHJvcGVydGllcy5tZWRpYSA/ICEhdHJhY2tQcm9wZXJ0aWVzLm1lZGlhLmRlZmF1bHQgOiBmYWxzZSxcbiAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICB9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgIHRyYWNrczogW3RyYWNrXVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FwdGlvbnNUcmFja3NcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIGRlbGV0ZSBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgIH0pO1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVHJhY2tzKCkge1xuICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcyB8fCBbXTtcbiAgICBjb25zdCBoYXNJTVNDMSA9IHRyYWNrcy5zb21lKHRyYWNrID0+IHRyYWNrLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQgfHwgaGFzSU1TQzEgJiYgdGhpcy5jb25maWcuZW5hYmxlSU1TQzEpIHtcbiAgICAgIGNvbnN0IGxpc3RJc0lkZW50aWNhbCA9IHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLnRyYWNrcywgdHJhY2tzKTtcbiAgICAgIGlmIChsaXN0SXNJZGVudGljYWwpIHtcbiAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIGNvbnN0IGluVXNlVHJhY2tzID0gdGhpcy5tZWRpYSA/IHRoaXMubWVkaWEudGV4dFRyYWNrcyA6IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGxldCB0ZXh0VHJhY2s7XG4gICAgICAgICAgaWYgKGluVXNlVHJhY2tzICYmIGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaW5Vc2VUcmFjayA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrc1tpXSwgdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFja0tpbmQgPSB0aGlzLl9jYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjayk7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjayh0ZXh0VHJhY2tLaW5kLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2suZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQ7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHRyYWNrcyBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgICAgY29uc3QgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcCh0cmFjayA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiB0cmFjay5uYW1lLFxuICAgICAgICAgICAga2luZDogdHJhY2sudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJhY2suZGVmYXVsdCxcbiAgICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IHRyYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgICB0cmFja3M6IHRyYWNrc0xpc3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjaykge1xuICAgIGlmICh0cmFjay5hdHRycy5DSEFSQUNURVJJU1RJQ1MpIHtcbiAgICAgIGNvbnN0IHRyYW5zY3JpYmVzU3Bva2VuRGlhbG9nID0gL3RyYW5zY3JpYmVzLXNwb2tlbi1kaWFsb2cvZ2kudGVzdCh0cmFjay5hdHRycy5DSEFSQUNURVJJU1RJQ1MpO1xuICAgICAgY29uc3QgZGVzY3JpYmVzTXVzaWNBbmRTb3VuZCA9IC9kZXNjcmliZXMtbXVzaWMtYW5kLXNvdW5kL2dpLnRlc3QodHJhY2suYXR0cnMuQ0hBUkFDVEVSSVNUSUNTKTtcbiAgICAgIGlmICh0cmFuc2NyaWJlc1Nwb2tlbkRpYWxvZyAmJiBkZXNjcmliZXNNdXNpY0FuZFNvdW5kKSB7XG4gICAgICAgIHJldHVybiAnY2FwdGlvbnMnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3N1YnRpdGxlcyc7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyAmJiBkYXRhLmNhcHRpb25zKSB7XG4gICAgICBkYXRhLmNhcHRpb25zLmZvckVhY2goY2FwdGlvbnNUcmFjayA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RyZWFtSWRNYXRjaCA9IC8oPzpDQ3xTRVJWSUNFKShbMS00XSkvLmV4ZWMoY2FwdGlvbnNUcmFjay5pbnN0cmVhbUlkKTtcbiAgICAgICAgaWYgKCFpbnN0cmVhbUlkTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2tOYW1lID0gYHRleHRUcmFjayR7aW5zdHJlYW1JZE1hdGNoWzFdfWA7XG4gICAgICAgIGNvbnN0IHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5sYWJlbCA9IGNhcHRpb25zVHJhY2submFtZTtcbiAgICAgICAgaWYgKGNhcHRpb25zVHJhY2subGFuZykge1xuICAgICAgICAgIC8vIG9wdGlvbmFsIGF0dHJpYnV0ZVxuICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5sYW5ndWFnZUNvZGUgPSBjYXB0aW9uc1RyYWNrLmxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLm1lZGlhID0gY2FwdGlvbnNUcmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjbG9zZWRDYXB0aW9uc0ZvckxldmVsKGZyYWcpIHtcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICByZXR1cm4gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmF0dHJzWydDTE9TRUQtQ0FQVElPTlMnXTtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VhNjA4UGFyc2VyMSxcbiAgICAgIGNlYTYwOFBhcnNlcjIsXG4gICAgICBsYXN0U24sXG4gICAgICBsYXN0UGFydEluZGV4XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIShjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgaWYgKGRhdGEuZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB2YXIgX2RhdGEkcGFydCRpbmRleCwgX2RhdGEkcGFydDtcbiAgICAgIGNvbnN0IHNuID0gZGF0YS5mcmFnLnNuO1xuICAgICAgY29uc3QgcGFydEluZGV4ID0gKF9kYXRhJHBhcnQkaW5kZXggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHBhcnQuaW5kZXgpICE9IG51bGwgPyBfZGF0YSRwYXJ0JGluZGV4IDogLTE7XG4gICAgICBpZiAoIShzbiA9PT0gbGFzdFNuICsgMSB8fCBzbiA9PT0gbGFzdFNuICYmIHBhcnRJbmRleCA9PT0gbGFzdFBhcnRJbmRleCArIDEpKSB7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgICAgY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IHBhcnRJbmRleDtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICAgIC8vIGZyYWdtZW50IGFmdGVyIGRlY3J5cHRpb24gaGFzIGEgc3RhdHMgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9ICgnc3RhdHMnIGluIGRhdGEpO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgY29uc3QgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIHByZXZDQzogdGhpcy5wcmV2Q0MsXG4gICAgICAgICAgICAgIG5ldzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFbXB0eSBzdWJ0aXRsZSBwYXlsb2FkJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBwYXJzZUlNU0MxKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgY3VlcyA9PiB7XG4gICAgICB0aGlzLl9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBJTVNDMTogJHtlcnJvcn1gKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9wYXJzZVZUVHMoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkXG4gICAgY29uc3Qge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3NcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhBdkNDID0gaW5pdFBUUy5sZW5ndGggLSAxO1xuICAgIGlmICghaW5pdFBUU1tmcmFnLmNjXSAmJiBtYXhBdkNDID09PSAtMSkge1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgY29uc3QgcGF5bG9hZFdlYlZUVCA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpICE9IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQuZGF0YSA/IGFwcGVuZFVpbnQ4QXJyYXkoZnJhZy5pbml0U2VnbWVudC5kYXRhLCBuZXcgVWludDhBcnJheShwYXlsb2FkKSkgOiBwYXlsb2FkO1xuICAgIHBhcnNlV2ViVlRUKHBheWxvYWRXZWJWVFQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgdGhpcy52dHRDQ3MsIGZyYWcuY2MsIGZyYWcuc3RhcnQsIGN1ZXMgPT4ge1xuICAgICAgdGhpcy5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBjb25zdCBtaXNzaW5nSW5pdFBUUyA9IGVycm9yLm1lc3NhZ2UgPT09ICdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnO1xuICAgICAgaWYgKG1pc3NpbmdJbml0UFRTKSB7XG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZXJyb3J9YCk7XG4gICAgICBpZiAobWlzc2luZ0luaXRQVFMgJiYgbWF4QXZDQyA+IGZyYWcuY2MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgLy8gSWYgdGV4dENvZGVjIGlzIHVua25vd24sIHRyeSBwYXJzaW5nIGFzIElNU0MxLiBTZXQgdGV4dENvZGVjIGJhc2VkIG9uIHRoZSByZXN1bHRcbiAgICBjb25zdCB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICBpZiAoIXRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMpIHtcbiAgICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCAoKSA9PiB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSBJTVNDMV9DT0RFQztcbiAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9ICd3dnR0JztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfYXBwZW5kQ3VlcyhjdWVzLCBmcmFnTGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnRleHRUcmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIC8vIEJlY2F1c2Ugd2UgY2hlY2sgaWYgdGhlIG1vZGUgaXMgZGlzYWJsZWQsIHdlIGNhbiBmb3JjZSBjaGVjayBgY3Vlc2AgYmVsb3cuIFRoZXkgY2FuJ3QgYmUgbnVsbC5cbiAgICAgIGlmICghdGV4dFRyYWNrIHx8IHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4gYWRkQ3VlVG9UcmFjayh0ZXh0VHJhY2ssIGN1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1tmcmFnTGV2ZWxdO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhY2sgPSBjdXJyZW50VHJhY2suZGVmYXVsdCA/ICdkZWZhdWx0JyA6ICdzdWJ0aXRsZXMnICsgZnJhZ0xldmVsO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdzdWJ0aXRsZXMnLFxuICAgICAgICBjdWVzLFxuICAgICAgICB0cmFja1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VhNjA4UGFyc2VyMSxcbiAgICAgIGNlYTYwOFBhcnNlcjJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhKGNlYTYwOFBhcnNlcjEgJiYgY2VhNjA4UGFyc2VyMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHNhbXBsZXNcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIHRoaXMuY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSA9PT0gJ05PTkUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBldmVudCBjb250YWlucyBjYXB0aW9ucyAoZm91bmQgaW4gdGhlIGJ5dGVzIHByb3BlcnR5KSwgcHVzaCBhbGwgYnl0ZXMgaW50byB0aGUgcGFyc2VyIGltbWVkaWF0ZWx5XG4gICAgLy8gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIHRoZSBQVFMgdmFsdWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjQnl0ZXMgPSBzYW1wbGVzW2ldLmJ5dGVzO1xuICAgICAgaWYgKGNjQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1sxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIHtcbiAgICBzdGFydE9mZnNldCxcbiAgICBlbmRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0U3VidGl0bGVzLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBtZWRpYS5jdXJyZW50VGltZSA8IGVuZE9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDbGVhciA2MDggY2FwdGlvbiBjdWVzIGZyb20gdGhlIGNhcHRpb25zIFRleHRUcmFja3Mgd2hlbiB0aGUgdmlkZW8gYmFjayBidWZmZXIgaXMgZmx1c2hlZFxuICAgIC8vIEZvcndhcmQgY3VlcyBhcmUgbmV2ZXIgcmVtb3ZlZCBiZWNhdXNlIHdlIGNhbiBsb29zZSBzdHJlYW1lZCA2MDggY29udGVudCBmcm9tIHJlY2VudCBmcmFnbWVudHNcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4gcmVtb3ZlQ3Vlc0luUmFuZ2UoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAvLyBDbGVhciBWVFQvSU1TQzEgc3VidGl0bGUgY3VlcyBmcm9tIHRoZSBzdWJ0aXRsZSBUZXh0VHJhY2tzIHdoZW4gdGhlIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXRTdWJ0aXRsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGV4dFRyYWNrc1xuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGV4dFRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4gcmVtb3ZlQ3Vlc0luUmFuZ2UodGV4dFRyYWNrc1t0cmFja05hbWVdLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0U3VidGl0bGVzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IGFjdHVhbENDQnl0ZXMgPSBbW10sIFtdXTtcbiAgICBjb25zdCBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDB4MWY7XG4gICAgbGV0IHBvc2l0aW9uID0gMjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGNvbnN0IHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjb25zdCBjY2J5dGUxID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNvbnN0IGNjYnl0ZTIgPSAweDdmICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNjVmFsaWQgPSAoMHgwNCAmIHRtcEJ5dGUpICE9PSAwOyAvLyBTdXBwb3J0IGFsbCBmb3VyIGNoYW5uZWxzXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICBjb25zdCBjY1R5cGUgPSAweDAzICYgdG1wQnl0ZTtcbiAgICAgICAgaWYgKDB4MDAgLyogQ0VBNjA4IGZpZWxkMSovID09PSBjY1R5cGUgfHwgMHgwMSAvKiBDRUE2MDggZmllbGQyKi8gPT09IGNjVHlwZSkge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgQ0VBNzA4IENDIGRhdGEuXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdHVhbENDQnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcbiAgcmV0dXJuICEhaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cblxuLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuICovXG5cbmNsYXNzIENhcExldmVsQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpO1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5kcm9wcGVkTGV2ZWxdO1xuICAgIGlmICh0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxldmVsLndpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXG4gIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgfVxuICBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgIGlmICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWFIZWlnaHQgPiAwICYmIHRoaXMubWVkaWFXaWR0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcgJiYgdGhpcy5zdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICAqL1xuICBnZXRNYXhMZXZlbChjYXBMZXZlbEluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZExldmVscyA9IGxldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4gdGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleCk7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XG4gIH1cbiAgc3RhcnRDYXBwaW5nKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cbiAgc3RvcENhcHBpbmcoKSB7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBnZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFJlY3QubGVmdCB8fCBtZWRpYS53aWR0aCB8fCAwO1xuICAgICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xpZW50UmVjdCA9IGJvdW5kc1JlY3Q7XG4gICAgcmV0dXJuIGJvdW5kc1JlY3Q7XG4gIH1cbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gIH1cbiAgZ2V0IG1lZGlhSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuICBnZXQgY29udGVudFNjYWxlRmFjdG9yKCkge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuICBpc0xldmVsQWxsb3dlZChsZXZlbCkge1xuICAgIGNvbnN0IHJlc3RyaWN0ZWRMZXZlbHMgPSB0aGlzLnJlc3RyaWN0ZWRMZXZlbHM7XG4gICAgcmV0dXJuICFyZXN0cmljdGVkTGV2ZWxzLnNvbWUocmVzdHJpY3RlZExldmVsID0+IHtcbiAgICAgIHJldHVybiBsZXZlbC5iaXRyYXRlID09PSByZXN0cmljdGVkTGV2ZWwuYml0cmF0ZSAmJiBsZXZlbC53aWR0aCA9PT0gcmVzdHJpY3RlZExldmVsLndpZHRoICYmIGxldmVsLmhlaWdodCA9PT0gcmVzdHJpY3RlZExldmVsLmhlaWdodDtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kd2lkdGggPSAoY3VyTGV2ZWwsIG5leHRMZXZlbCkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICBsZXQgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gd2lkdGggfHwgbGV2ZWwuaGVpZ2h0ID49IGhlaWdodCkgJiYgYXRHcmVhdGVzdEJhbmR3aWR0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgbWF4TGV2ZWxJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5jbGFzcyBGUFNDb250cm9sbGVyIHtcbiAgLy8gc3RyZWFtIGNvbnRyb2xsZXIgbXVzdCBiZSBwcm92aWRlZCBhcyBhIGRlcGVuZGVuY3khXG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBzZWxmLkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiB0eXBlb2YgbWVkaWEuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuICBjaGVja0ZQUyh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kO1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QLCB7XG4gICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9XG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IExPR0dFUl9QUkVGSVggPSAnW2VtZV0nO1xuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRU1FQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHt9O1xuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9O1xuICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUgPSBFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID8gW0VNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2VdIDogW107XG4gICAgdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5fb25NZWRpYUVuY3J5cHRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25XYWl0aW5nRm9yS2V5ID0gdGhpcy5fb25XYWl0aW5nRm9yS2V5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWJ1ZyA9IGxvZ2dlci5kZWJ1Zy5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG4gICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyA9IG51bGw7XG4gICAgY29uZmlnLmxpY2Vuc2VYaHJTZXR1cCA9IGNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBjb25maWcuZHJtU3lzdGVtcyA9IGNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zID0ge307XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5vbldhaXRpbmdGb3JLZXkgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRybVN5c3RlbXMsXG4gICAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24ubGljZW5zZVVybDtcbiAgICB9XG5cbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChrZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuV0lERVZJTkUgJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGxpY2Vuc2Ugc2VydmVyIFVSTCBjb25maWd1cmVkIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgfVxuICBnZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybChrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLnNlcnZlckNlcnRpZmljYXRlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgTm8gU2VydmVyIENlcnRpZmljYXRlIGluIGNvbmZpZy5kcm1TeXN0ZW1zW1wiJHtrZXlTeXN0ZW19XCJdYCk7XG4gICAgfVxuICB9XG4gIGF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBjb25zdCB1bmlxdWVDb2RlYyA9ICh2YWx1ZSwgaSwgYSkgPT4gISF2YWx1ZSAmJiBhLmluZGV4T2YodmFsdWUpID09PSBpO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5hdWRpb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC52aWRlb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGlmIChhdWRpb0NvZGVjcy5sZW5ndGggKyB2aWRlb0NvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZpZGVvQ29kZWNzLnB1c2goJ2F2YzEuNDJlMDFlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdHRlbXB0ID0ga2V5U3lzdGVtcyA9PiB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbXMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5nZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKS50aGVuKG1lZGlhS2V5cyA9PiByZXNvbHZlKHtcbiAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgbWVkaWFLZXlzXG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKGtleVN5c3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRlbXB0KGtleVN5c3RlbXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGF0dGVtcHQoa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghKHR5cGVvZiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgbGV0IGVyck1lc3NhZ2UgPSBgQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gJHtyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jfWA7XG4gICAgICBpZiAocmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgZXJyTWVzc2FnZSA9IGBuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCAke2xvY2F0aW9uLnByb3RvY29sfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMoa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyk7XG4gIH1cbiAgZ2V0TWVkaWFLZXlzUHJvbWlzZShrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIC8vIFRoaXMgY2FuIHRocm93LCBidXQgaXMgY2F1Z2h0IGluIGV2ZW50IGhhbmRsZXIgY2FsbHBhdGhcbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICBjb25zdCBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXTtcbiAgICBsZXQga2V5U3lzdGVtQWNjZXNzID0ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzLmtleVN5c3RlbUFjY2VzcztcbiAgICBpZiAoIWtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgdGhpcy5sb2coYFJlcXVlc3RpbmcgZW5jcnlwdGVkIG1lZGlhIFwiJHtrZXlTeXN0ZW19XCIga2V5LXN5c3RlbSBhY2Nlc3Mgd2l0aCBjb25maWc6ICR7SlNPTi5zdHJpbmdpZnkobWVkaWFLZXlTeXN0ZW1Db25maWdzKX1gKTtcbiAgICAgIGtleVN5c3RlbUFjY2VzcyA9IHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKTtcbiAgICAgIGNvbnN0IF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzXG4gICAgICB9O1xuICAgICAga2V5U3lzdGVtQWNjZXNzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBvYnRhaW4gYWNjZXNzIHRvIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIjogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKG1lZGlhS2V5U3lzdGVtQWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7bWVkaWFLZXlTeXN0ZW1BY2Nlc3Mua2V5U3lzdGVtfVwiIG9idGFpbmVkYCk7XG4gICAgICAgIGNvbnN0IGNlcnRpZmljYXRlUmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvZyhgQ3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyA9IG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpLnRoZW4obWVkaWFLZXlzID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhgTWVkaWEta2V5cyBjcmVhdGVkIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgICAgcmV0dXJuIGNlcnRpZmljYXRlUmVxdWVzdC50aGVuKGNlcnRpZmljYXRlID0+IHtcbiAgICAgICAgICAgIGlmIChjZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cIn06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4oKCkgPT4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzKTtcbiAgfVxuICBjcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICBkZWNyeXB0ZGF0YSxcbiAgICBrZXlTeXN0ZW0sXG4gICAgbWVkaWFLZXlzXG4gIH0pIHtcbiAgICB0aGlzLmxvZyhgQ3JlYXRpbmcga2V5LXN5c3RlbSBzZXNzaW9uIFwiJHtrZXlTeXN0ZW19XCIga2V5SWQ6ICR7SGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pfWApO1xuICAgIGNvbnN0IG1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgIGNvbnN0IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleVN5c3RlbSxcbiAgICAgIG1lZGlhS2V5cyxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBrZXlTdGF0dXM6ICdzdGF0dXMtcGVuZGluZydcbiAgICB9O1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9XG4gIHJlbmV3S2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhO1xuICAgIGlmIChkZWNyeXB0ZGF0YS5wc3NoKSB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dChtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF0gPSB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBzY2hlbWUsIGRlY3J5cHRkYXRhLnBzc2gsICdleHBpcmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihgQ291bGQgbm90IHJlbmV3IGV4cGlyZWQgc2Vzc2lvbi4gTWlzc2luZyBwc3NoIGluaXREYXRhLmApO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWFkIGtleUlkIG9mIHVuZGVmaW5lZCBkZWNyeXB0ZGF0YScpO1xuICAgIH1cbiAgICBpZiAoZGVjcnlwdGRhdGEua2V5SWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigna2V5SWQgaXMgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQpO1xuICB9XG4gIHVwZGF0ZUtleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCwgZGF0YSkge1xuICAgIHZhciBfbWVkaWFLZXlTZXNzaW9uQ29udGU7XG4gICAgY29uc3Qga2V5U2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICB0aGlzLmxvZyhgVXBkYXRpbmcga2V5LXNlc3Npb24gXCIke2tleVNlc3Npb24uc2Vzc2lvbklkfVwiIGZvciBrZXlJRCAke0hleC5oZXhEdW1wKCgoX21lZGlhS2V5U2Vzc2lvbkNvbnRlID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZWRpYUtleVNlc3Npb25Db250ZS5rZXlJZCkgfHwgW10pfVxuICAgICAgfSAoZGF0YSBsZW5ndGg6ICR7ZGF0YSA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGF9KWApO1xuICAgIHJldHVybiBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgfVxuICBzZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykge1xuICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyhmcmFnLmxldmVsa2V5cyB8fCB7fSk7XG4gICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgIHRoaXMubG9nKGBTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIGZyYWdtZW50IChzbjogJHtmcmFnLnNufSAke2ZyYWcudHlwZX06ICR7ZnJhZy5sZXZlbH0pIGtleSBmb3JtYXRzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXlGb3JtYXRQcm9taXNlO1xuICB9XG4gIGdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBrZXlTeXN0ZW1zSW5Db25maWcgPSBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbikuZmlsdGVyKHZhbHVlID0+ICEhdmFsdWUgJiYga2V5U3lzdGVtc0luQ29uZmlnLmluZGV4T2YodmFsdWUpICE9PSAtMSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbUZvcm1hdCA9IGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSk7XG4gICAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICByZXNvbHZlKGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZm9ybWF0IGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZEtleShkYXRhKSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBkYXRhLmtleUluZm8uZGVjcnlwdGRhdGE7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICBjb25zdCBrZXlEZXRhaWxzID0gYChrZXlJZDogJHtrZXlJZH0gZm9ybWF0OiBcIiR7ZGVjcnlwdGRhdGEua2V5Rm9ybWF0fVwiIG1ldGhvZDogJHtkZWNyeXB0ZGF0YS5tZXRob2R9IHVyaTogJHtkZWNyeXB0ZGF0YS51cml9KWA7XG4gICAgdGhpcy5sb2coYFN0YXJ0aW5nIHNlc3Npb24gZm9yIGtleSAke2tleURldGFpbHN9YCk7XG4gICAgbGV0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLmxvZyhgSGFuZGxlIGVuY3J5cHRlZCBtZWRpYSBzbjogJHtkYXRhLmZyYWcuc259ICR7ZGF0YS5mcmFnLnR5cGV9OiAke2RhdGEuZnJhZy5sZXZlbH0gdXNpbmcga2V5ICR7a2V5RGV0YWlsc31gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICAgICAgbWVkaWFLZXlzLFxuICAgICAgICAgICAgZGVjcnlwdGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgZGVjcnlwdGRhdGEucHNzaCwgJ3BsYXlsaXN0LWtleScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZTtcbiAgfVxuICB0aHJvd0lmRGVzdHJveWVkKG1lc3NhZ2UgPSAnSW52YWxpZCBzdGF0ZScpIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvci5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICBjb25zdCBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgIGlmICghbWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZGVjcnlwdGRhdGEua2V5Rm9ybWF0KTtcbiAgICAgIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlTeXN0ZW0gPyBba2V5U3lzdGVtXSA6IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gIH1cbiAgZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgaWYgKCFrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCkge1xuICAgICAga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoa2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSwgYE1pc3Npbmcga2V5LXN5c3RlbSBsaWNlbnNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZHJtU3lzdGVtczogdGhpcy5jb25maWcuZHJtU3lzdGVtc1xuICAgICAgfSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gIH1cbiAgX29uTWVkaWFFbmNyeXB0ZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbml0RGF0YVR5cGUsXG4gICAgICBpbml0RGF0YVxuICAgIH0gPSBldmVudDtcbiAgICB0aGlzLmRlYnVnKGBcIiR7ZXZlbnQudHlwZX1cIiBldmVudDogaW5pdCBkYXRhIHR5cGU6IFwiJHtpbml0RGF0YVR5cGV9XCJgKTtcblxuICAgIC8vIElnbm9yZSBldmVudCB3aGVuIGluaXREYXRhIGlzIG51bGxcbiAgICBpZiAoaW5pdERhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleUlkO1xuICAgIGxldCBrZXlTeXN0ZW1Eb21haW47XG4gICAgaWYgKGluaXREYXRhVHlwZSA9PT0gJ3NpbmYnICYmIHRoaXMuY29uZmlnLmRybVN5c3RlbXNbS2V5U3lzdGVtcy5GQUlSUExBWV0pIHtcbiAgICAgIC8vIE1hdGNoIHNpbmYga2V5SWQgdG8gcGxheWxpc3Qgc2tkOi8va2V5SWQ9XG4gICAgICBjb25zdCBqc29uID0gYmluMnN0cihuZXcgVWludDhBcnJheShpbml0RGF0YSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2luZiA9IGJhc2U2NERlY29kZShKU09OLnBhcnNlKGpzb24pLnNpbmYpO1xuICAgICAgICBjb25zdCB0ZW5jID0gcGFyc2VTaW5mKG5ldyBVaW50OEFycmF5KHNpbmYpKTtcbiAgICAgICAgaWYgKCF0ZW5jKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgIGtleVN5c3RlbURvbWFpbiA9IEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBzaW5mIFwiZW5jcnlwdGVkXCIgZXZlbnQgbWVzc2FnZSBpbml0RGF0YScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgY2xlYXItbGVhZCBrZXktc2Vzc2lvbiBjcmVhdGlvbiAob3RoZXJ3aXNlIGRlcGVuZCBvbiBwbGF5bGlzdCBrZXlzKVxuICAgICAgY29uc3QgcHNzaEluZm8gPSBwYXJzZVBzc2goaW5pdERhdGEpO1xuICAgICAgaWYgKHBzc2hJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwc3NoSW5mby52ZXJzaW9uID09PSAwICYmIHBzc2hJbmZvLnN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuV0lERVZJTkUgJiYgcHNzaEluZm8uZGF0YSkge1xuICAgICAgICBrZXlJZCA9IHBzc2hJbmZvLmRhdGEuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgfVxuICAgICAga2V5U3lzdGVtRG9tYWluID0ga2V5U3lzdGVtSWRUb0tleVN5c3RlbURvbWFpbihwc3NoSW5mby5zeXN0ZW1JZCk7XG4gICAgfVxuICAgIGlmICgha2V5U3lzdGVtRG9tYWluIHx8ICFrZXlJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXlJZEhleCA9IEhleC5oZXhEdW1wKGtleUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2UsXG4gICAgICBtZWRpYUtleVNlc3Npb25zXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYUtleVNlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXRjaCBwbGF5bGlzdCBrZXlcbiAgICAgIGNvbnN0IGtleUNvbnRleHQgPSBtZWRpYUtleVNlc3Npb25zW2ldO1xuICAgICAgY29uc3QgZGVjcnlwdGRhdGEgPSBrZXlDb250ZXh0LmRlY3J5cHRkYXRhO1xuICAgICAgaWYgKGRlY3J5cHRkYXRhLnBzc2ggfHwgIWRlY3J5cHRkYXRhLmtleUlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkS2V5SWRIZXggPSBIZXguaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCk7XG4gICAgICBpZiAoa2V5SWRIZXggPT09IG9sZEtleUlkSGV4IHx8IGRlY3J5cHRkYXRhLnVyaS5yZXBsYWNlKC8tL2csICcnKS5pbmRleE9mKGtleUlkSGV4KSAhPT0gLTEpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW29sZEtleUlkSGV4XTtcbiAgICAgICAgZGVsZXRlIGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtvbGRLZXlJZEhleF07XG4gICAgICAgIGRlY3J5cHRkYXRhLnBzc2ggPSBuZXcgVWludDhBcnJheShpbml0RGF0YSk7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF0gPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5Q29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgJ2VuY3J5cHRlZC1ldmVudC1rZXktbWF0Y2gnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgLy8gQ2xlYXItbGVhZCBrZXkgKG5vdCBlbmNvdW50ZXJlZCBpbiBwbGF5bGlzdClcbiAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF0gPSB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2UoW2tleVN5c3RlbURvbWFpbl0pLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICBtZWRpYUtleXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdmFyIF9rZXlTeXN0ZW1Ub0tleVN5c3RlbTtcbiAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KCdJU08tMjMwMDEtNycsIGtleUlkSGV4LCAoX2tleVN5c3RlbVRvS2V5U3lzdGVtID0ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSkgIT0gbnVsbCA/IF9rZXlTeXN0ZW1Ub0tleVN5c3RlbSA6ICcnKTtcbiAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5SWQgPSBrZXlJZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgJ2VuY3J5cHRlZC1ldmVudC1uby1tYXRjaCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcikpO1xuICB9XG4gIF9vbldhaXRpbmdGb3JLZXkoZXZlbnQpIHtcbiAgICB0aGlzLmxvZyhgXCIke2V2ZW50LnR5cGV9XCIgZXZlbnRgKTtcbiAgfVxuICBhdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnNsaWNlKCk7XG4gICAgdGhpcy5sb2coYFNldHRpbmcgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgLy8gY2FuIGJlIHF1ZXVlZCBmb3IgZXhlY3V0aW9uIGZvciBtdWx0aXBsZSBrZXkgc2Vzc2lvbnMuXG4gICAgY29uc3Qgc2V0TWVkaWFLZXlzUHJvbWlzZSA9IFByb21pc2UuYWxsKHF1ZXVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgbWVkaWEgZWxlbWVudCBhdHRhY2hlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc2V0TWVkaWFLZXlzKG1lZGlhS2V5cyk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgIHJldHVybiBzZXRNZWRpYUtleXNQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5sb2coYE1lZGlhLWtleXMgc2V0IGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICBxdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IHRoaXMuc2V0TWVkaWFLZXlzUXVldWUuZmlsdGVyKHAgPT4gcXVldWUuaW5kZXhPZihwKSA9PT0gLTEpO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIHJlYXNvbikge1xuICAgIHZhciBfdGhpcyRjb25maWckZHJtU3lzdGUsIF90aGlzJGNvbmZpZyRkcm1TeXN0ZTI7XG4gICAgY29uc3QgZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyID0gKF90aGlzJGNvbmZpZyRkcm1TeXN0ZSA9IHRoaXMuY29uZmlnLmRybVN5c3RlbXMpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkY29uZmlnJGRybVN5c3RlMiA9IF90aGlzJGNvbmZpZyRkcm1TeXN0ZVtjb250ZXh0LmtleVN5c3RlbV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb25maWckZHJtU3lzdGUyLmdlbmVyYXRlUmVxdWVzdDtcbiAgICBpZiAoZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXBwZWRJbml0RGF0YSA9IGdlbmVyYXRlUmVxdWVzdEZpbHRlci5jYWxsKHRoaXMuaGxzLCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFtYXBwZWRJbml0RGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGluaXREYXRhVHlwZSA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhVHlwZTtcbiAgICAgICAgaW5pdERhdGEgPSBjb250ZXh0LmRlY3J5cHRkYXRhLnBzc2ggPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YSA/IG5ldyBVaW50OEFycmF5KG1hcHBlZEluaXREYXRhLmluaXREYXRhKSA6IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2coYFNraXBwaW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCIgKG5vIGluaXREYXRhKWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGNvbnRleHQuZGVjcnlwdGRhdGEpO1xuICAgIHRoaXMubG9nKGBHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCI6ICR7a2V5SWR9IChpbml0IGRhdGEgdHlwZTogJHtpbml0RGF0YVR5cGV9IGxlbmd0aDogJHtpbml0RGF0YSA/IGluaXREYXRhLmJ5dGVMZW5ndGggOiBudWxsfSlgKTtcbiAgICBjb25zdCBsaWNlbnNlU3RhdHVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVzc2FnZVR5cGUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHRoaXMubG9nKGBcIiR7bWVzc2FnZVR5cGV9XCIgbWVzc2FnZSBldmVudCBmb3Igc2Vzc2lvbiBcIiR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9XCIgbWVzc2FnZSBzaXplOiAke21lc3NhZ2UuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVxdWVzdCcgfHwgbWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlbmV3YWwnKSB7XG4gICAgICAgIHRoaXMucmVuZXdMaWNlbnNlKGNvbnRleHQsIG1lc3NhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlbGVhc2UnKSB7XG4gICAgICAgIGlmIChjb250ZXh0LmtleVN5c3RlbSA9PT0gS2V5U3lzdGVtcy5GQUlSUExBWSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlS2V5U2Vzc2lvbihjb250ZXh0LCBzdHJUb1V0ZjhhcnJheSgnYWNrbm93bGVkZ2VkJykpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXJuKGB1bmhhbmRsZWQgbWVkaWEga2V5IG1lc3NhZ2UgdHlwZSBcIiR7bWVzc2FnZVR5cGV9XCJgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5vbmtleXN0YXR1c2VzY2hhbmdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uS2V5U3RhdHVzQ2hhbmdlKGNvbnRleHQpO1xuICAgICAgY29uc3Qga2V5U3RhdHVzID0gY29udGV4dC5rZXlTdGF0dXM7XG4gICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2tleVN0YXR1cycsIGtleVN0YXR1cyk7XG4gICAgICBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgdGhpcy53YXJuKGAke2NvbnRleHQua2V5U3lzdGVtfSBleHBpcmVkIGZvciBrZXkgJHtrZXlJZH1gKTtcbiAgICAgICAgdGhpcy5yZW5ld0tleVNlc3Npb24oY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBrZXlVc2FibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgbGljZW5zZVN0YXR1cy5vbigna2V5U3RhdHVzJywga2V5U3RhdHVzID0+IHtcbiAgICAgICAgaWYgKGtleVN0YXR1cy5zdGFydHNXaXRoKCd1c2FibGUnKSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdvdXRwdXQtcmVzdHJpY3RlZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgIH0sICdIRENQIGxldmVsIG91dHB1dCByZXN0cmljdGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ2ludGVybmFsLWVycm9yJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICB9LCBga2V5IHN0YXR1cyBjaGFuZ2VkIHRvIFwiJHtrZXlTdGF0dXN9XCJgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdrZXkgZXhwaXJlZCB3aGlsZSBnZW5lcmF0aW5nIHJlcXVlc3QnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53YXJuKGB1bmhhbmRsZWQga2V5IHN0YXR1cyBjaGFuZ2UgXCIke2tleVN0YXR1c31cImApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKS50aGVuKCgpID0+IHtcbiAgICAgIHZhciBfY29udGV4dCRtZWRpYUtleXNTZXM7XG4gICAgICB0aGlzLmxvZyhgUmVxdWVzdCBnZW5lcmF0ZWQgZm9yIGtleS1zZXNzaW9uIFwiJHsoX2NvbnRleHQkbWVkaWFLZXlzU2VzID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkbWVkaWFLZXlzU2VzLnNlc3Npb25JZH1cIiBrZXlJZDogJHtrZXlJZH1gKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICB0aHJvdyBuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0sIGBFcnJvciBnZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3Q6ICR7ZXJyb3J9YCk7XG4gICAgfSkudGhlbigoKSA9PiBrZXlVc2FibGVQcm9taXNlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5yZW1vdmVTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSk7XG4gIH1cbiAgb25LZXlTdGF0dXNDaGFuZ2UobWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5rZXlTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXMsIGtleUlkKSA9PiB7XG4gICAgICB0aGlzLmxvZyhga2V5IHN0YXR1cyBjaGFuZ2UgXCIke3N0YXR1c31cIiBmb3Iga2V5U3RhdHVzZXMga2V5SWQ6ICR7SGV4LmhleER1bXAoJ2J1ZmZlcicgaW4ga2V5SWQgPyBuZXcgVWludDhBcnJheShrZXlJZC5idWZmZXIsIGtleUlkLmJ5dGVPZmZzZXQsIGtleUlkLmJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoa2V5SWQpKX0gc2Vzc2lvbiBrZXlJZDogJHtIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKSl9IHVyaTogJHttZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLnVyaX1gKTtcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQua2V5U3RhdHVzID0gc3RhdHVzO1xuICAgIH0pO1xuICB9XG4gIGZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBjZXJ0TG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgRmV0Y2hpbmcgc2VydmVyQ2VydGlmaWNhdGUgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmxcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmNlcnRMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSlcbiAgICAgICAgICB9LCBgXCIke2tleVN5c3RlbX1cIiBjZXJ0aWZpY2F0ZSByZXF1ZXN0IGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3Jlc3BvbnNlLmNvZGV9ICgke3Jlc3BvbnNlLnRleHR9KWApKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCB0aW1lZCBvdXQgKCR7dXJsfSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2VydExvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBtZWRpYUtleXMuc2V0U2VydmVyQ2VydGlmaWNhdGUoY2VydCkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYHNldFNlcnZlckNlcnRpZmljYXRlICR7c3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdub3Qgc3VwcG9ydGVkIGJ5IENETSd9ICgke2NlcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNlcnQuYnl0ZUxlbmd0aH0pIG9uIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgcmVzb2x2ZShtZWRpYUtleXMpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVuZXdMaWNlbnNlKGNvbnRleHQsIGtleU1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TGljZW5zZShjb250ZXh0LCBuZXcgVWludDhBcnJheShrZXlNZXNzYWdlKSkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLmNvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgaWYgKCFsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSByZW1vdmVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgIC8vIEtleSBzZXNzaW9uIHJlbW92ZWQuIENhbmNlbCBsaWNlbnNlIHJlcXVlc3QuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaWNlbnNlWGhyU2V0dXAuY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgfSkudGhlbihsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgLy8gaWYgbGljZW5zZVhoclNldHVwIGRpZCBub3QgeWV0IGNhbGwgb3BlbiwgbGV0J3MgZG8gaXQgbm93XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbmFsTGljZW5zZUNoYWxsZW5nZSA9IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA/IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA6IGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IGZpbmFsTGljZW5zZUNoYWxsZW5nZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGtleUxvYWRQb2xpY3kgPSB0aGlzLmNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0pO1xuICAgICAgdGhpcy5sb2coYFNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogJHt1cmx9YCk7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhscyB8fCAha2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5sb2coYExpY2Vuc2UgcmVjZWl2ZWQgJHtkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhfWApO1xuICAgICAgICAgICAgY29uc3QgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB0aGlzLmNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjaztcbiAgICAgICAgICAgIGlmIChsaWNlbnNlUmVzcG9uc2VDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjay5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUNvbmZpZyA9IGtleUxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICAgIGNvbnN0IG1heE51bVJldHJ5ID0gcmV0cnlDb25maWcgPyByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID4gbWF4TnVtUmV0cnkgfHwgeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogeGhyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGBMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3hoci5zdGF0dXN9ICgke3hoci5zdGF0dXNUZXh0fSlgKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBhdHRlbXB0c0xlZnQgPSBtYXhOdW1SZXRyeSAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsICR7YXR0ZW1wdHNMZWZ0fSBhdHRlbXB0cyBsZWZ0YCk7XG4gICAgICAgICAgICAgIHRoaXMucmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociAmJiBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociA9IHhocjtcbiAgICAgIHRoaXMuc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkudGhlbigoe1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH0pID0+IHtcbiAgICAgICAgeGhyLnNlbmQobGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5vbk1lZGlhRW5jcnlwdGVkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIHRoaXMub25NZWRpYUVuY3J5cHRlZCk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gW107XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgIC8vIENsb3NlIGFsbCBzZXNzaW9ucyBhbmQgcmVtb3ZlIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICBjb25zdCBrZXlTZXNzaW9uQ291bnQgPSBtZWRpYUtleXNMaXN0Lmxlbmd0aDtcbiAgICBFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gUHJvbWlzZS5hbGwobWVkaWFLZXlzTGlzdC5tYXAobWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9PiB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkpLmNvbmNhdChtZWRpYSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWEuc2V0TWVkaWFLZXlzKG51bGwpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn0uIG1lZGlhLnNyYzogJHttZWRpYSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWEuc3JjfWApO1xuICAgIH0pKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvdW50KSB7XG4gICAgICAgIHRoaXMubG9nKCdmaW5pc2hlZCBjbG9zaW5nIGtleSBzZXNzaW9ucyBhbmQgY2xlYXJpbmcgbWVkaWEga2V5cycpO1xuICAgICAgICBtZWRpYUtleXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9ucyBhbmQgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn0uIG1lZGlhLnNyYzogJHttZWRpYSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWEuc3JjfWApO1xuICAgIH0pO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwge1xuICAgIHNlc3Npb25LZXlzXG4gIH0pIHtcbiAgICBpZiAoIXNlc3Npb25LZXlzIHx8ICF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICBjb25zdCBrZXlGb3JtYXRzID0gc2Vzc2lvbktleXMucmVkdWNlKChmb3JtYXRzLCBzZXNzaW9uS2V5KSA9PiB7XG4gICAgICAgIGlmIChmb3JtYXRzLmluZGV4T2Yoc2Vzc2lvbktleS5rZXlGb3JtYXQpID09PSAtMSkge1xuICAgICAgICAgIGZvcm1hdHMucHVzaChzZXNzaW9uS2V5LmtleUZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCBbXSk7XG4gICAgICB0aGlzLmxvZyhgU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBzZXNzaW9uLWtleXMgJHtrZXlGb3JtYXRzLmpvaW4oJywgJyl9YCk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBsaWNlbnNlWGhyXG4gICAgfSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgaWYgKG1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmUgbGljZW5zZXMgYW5kIGtleXMgYW5kIGNsb3NlIHNlc3Npb24gJHttZWRpYUtleXNTZXNzaW9uLnNlc3Npb25JZH1gKTtcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24ub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24ub25rZXlzdGF0dXNlc2NoYW5nZSA9IG51bGw7XG4gICAgICBpZiAobGljZW5zZVhociAmJiBsaWNlbnNlWGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgbGljZW5zZVhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZWRpYUtleVNlc3Npb25zLmluZGV4T2YobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZSgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCByZW1vdmUgc2Vzc2lvbjogJHtlcnJvcn1gKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbWVkaWFLZXlzU2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsb3NlIHNlc3Npb246ICR7ZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbkVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSB2b2lkIDA7XG5jbGFzcyBFTUVLZXlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICBkYXRhLmVycm9yIHx8IChkYXRhLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGRhdGEuZXJyID0gZGF0YS5lcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENNQ0Qgc3BlYyB2ZXJzaW9uXG4gKi9cbmNvbnN0IENNQ0RWZXJzaW9uID0gMTtcblxuLyoqXG4gKiBDTUNEIE9iamVjdCBUeXBlXG4gKi9cbnZhciBDTUNET2JqZWN0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6IFwibVwiLFxuICBBVURJTzogXCJhXCIsXG4gIFZJREVPOiBcInZcIixcbiAgTVVYRUQ6IFwiYXZcIixcbiAgSU5JVDogXCJpXCIsXG4gIENBUFRJT046IFwiY1wiLFxuICBUSU1FRF9URVhUOiBcInR0XCIsXG4gIEtFWTogXCJrXCIsXG4gIE9USEVSOiBcIm9cIlxufTtcblxuLyoqXG4gKiBDTUNEIFN0cmVhbWluZyBGb3JtYXRcbiAqL1xuY29uc3QgQ01DRFN0cmVhbWluZ0Zvcm1hdEhMUyA9ICdoJztcblxuLyoqXG4gKiBDTUNEIFN0cmVhbWluZyBUeXBlXG4gKi9cblxuLyoqXG4gKiBDTUNEIEhlYWRlcnNcbiAqL1xuXG4vKipcbiAqIENNQ0RcbiAqL1xuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSAoQ01DRClcbiAqIEBzZWUgaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGZcbiAqL1xuY2xhc3MgQ01DRENvbnRyb2xsZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaWQgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vbldhaXRpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnN0YXJ2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5vblBsYXlpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgbWFuaWZlc3QgcmVxdWVzdC5cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5UGxheWxpc3REYXRhID0gY29udGV4dCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmFwcGx5KGNvbnRleHQsIHtcbiAgICAgICAgICBvdDogQ01DRE9iamVjdFR5cGUuTUFOSUZFU1QsXG4gICAgICAgICAgc3U6ICF0aGlzLmluaXRpYWxpemVkXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBnZW5lcmF0ZSBtYW5pZmVzdCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgc2VnbWVudCByZXF1ZXN0XG4gICAgICovXG4gICAgdGhpcy5hcHBseUZyYWdtZW50RGF0YSA9IGNvbnRleHQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWdtZW50LmxldmVsXTtcbiAgICAgICAgY29uc3Qgb3QgPSB0aGlzLmdldE9iamVjdFR5cGUoZnJhZ21lbnQpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgIGQ6IGZyYWdtZW50LmR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICBvdFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3QgPT09IENNQ0RPYmplY3RUeXBlLlZJREVPIHx8IG90ID09PSBDTUNET2JqZWN0VHlwZS5BVURJTyB8fCBvdCA9PSBDTUNET2JqZWN0VHlwZS5NVVhFRCkge1xuICAgICAgICAgIGRhdGEuYnIgPSBsZXZlbC5iaXRyYXRlIC8gMTAwMDtcbiAgICAgICAgICBkYXRhLnRiID0gdGhpcy5nZXRUb3BCYW5kd2lkdGgob3QpIC8gMTAwMDtcbiAgICAgICAgICBkYXRhLmJsID0gdGhpcy5nZXRCdWZmZXJMZW5ndGgob3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHkoY29udGV4dCwgZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIHNlZ21lbnQgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCB7XG4gICAgICBjbWNkXG4gICAgfSA9IGNvbmZpZztcbiAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICBjb25maWcucExvYWRlciA9IHRoaXMuY3JlYXRlUGxheWxpc3RMb2FkZXIoKTtcbiAgICAgIGNvbmZpZy5mTG9hZGVyID0gdGhpcy5jcmVhdGVGcmFnbWVudExvYWRlcigpO1xuICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCBDTUNEQ29udHJvbGxlci51dWlkKCk7XG4gICAgICB0aGlzLmNpZCA9IGNtY2QuY29udGVudElkO1xuICAgICAgdGhpcy51c2VIZWFkZXJzID0gY21jZC51c2VIZWFkZXJzID09PSB0cnVlO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5hdWRpb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG4gIH1cbiAgb25NZWRpYURldGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSR0cmFja3MkYXVkaW8sIF9kYXRhJHRyYWNrcyR2aWRlbztcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gKF9kYXRhJHRyYWNrcyRhdWRpbyA9IGRhdGEudHJhY2tzLmF1ZGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkdHJhY2tzJGF1ZGlvLmJ1ZmZlcjtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gKF9kYXRhJHRyYWNrcyR2aWRlbyA9IGRhdGEudHJhY2tzLnZpZGVvKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkdHJhY2tzJHZpZGVvLmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJhc2VsaW5lIENNQ0QgZGF0YVxuICAgKi9cbiAgY3JlYXRlRGF0YSgpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgcmV0dXJuIHtcbiAgICAgIHY6IENNQ0RWZXJzaW9uLFxuICAgICAgc2Y6IENNQ0RTdHJlYW1pbmdGb3JtYXRITFMsXG4gICAgICBzaWQ6IHRoaXMuc2lkLFxuICAgICAgY2lkOiB0aGlzLmNpZCxcbiAgICAgIHByOiAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEucGxheWJhY2tSYXRlLFxuICAgICAgbXRwOiB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSAvIDEwMDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHJlcXVlc3QuXG4gICAqL1xuICBhcHBseShjb250ZXh0LCBkYXRhID0ge30pIHtcbiAgICAvLyBhcHBseSBiYXNlbGluZSBkYXRhXG4gICAgX2V4dGVuZHMoZGF0YSwgdGhpcy5jcmVhdGVEYXRhKCkpO1xuICAgIGNvbnN0IGlzVmlkZW8gPSBkYXRhLm90ID09PSBDTUNET2JqZWN0VHlwZS5JTklUIHx8IGRhdGEub3QgPT09IENNQ0RPYmplY3RUeXBlLlZJREVPIHx8IGRhdGEub3QgPT09IENNQ0RPYmplY3RUeXBlLk1VWEVEO1xuICAgIGlmICh0aGlzLnN0YXJ2ZWQgJiYgaXNWaWRlbykge1xuICAgICAgZGF0YS5icyA9IHRydWU7XG4gICAgICBkYXRhLnN1ID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHJ0cCwgbnJyLCBub3IsIGRsXG5cbiAgICBpZiAodGhpcy51c2VIZWFkZXJzKSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gQ01DRENvbnRyb2xsZXIudG9IZWFkZXJzKGRhdGEpO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhoZWFkZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICAgICAgY29udGV4dC5oZWFkZXJzID0ge307XG4gICAgICB9XG4gICAgICBfZXh0ZW5kcyhjb250ZXh0LmhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeSA9IENNQ0RDb250cm9sbGVyLnRvUXVlcnkoZGF0YSk7XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQudXJsID0gQ01DRENvbnRyb2xsZXIuYXBwZW5kUXVlcnlUb1VyaShjb250ZXh0LnVybCwgcXVlcnkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIENNQ0Qgb2JqZWN0IHR5cGUuXG4gICAqL1xuICBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSBmcmFnbWVudDtcbiAgICBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuIENNQ0RPYmplY3RUeXBlLlRJTUVEX1RFWFQ7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudC5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuIENNQ0RPYmplY3RUeXBlLklOSVQ7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gQ01DRE9iamVjdFR5cGUuQVVESU87XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy5obHMuYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBDTUNET2JqZWN0VHlwZS5NVVhFRDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDTUNET2JqZWN0VHlwZS5WSURFTztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhpZ2hlc3QgYml0cmF0ZS5cbiAgICovXG4gIGdldFRvcEJhbmR3aWR0aCh0eXBlKSB7XG4gICAgbGV0IGJpdHJhdGUgPSAwO1xuICAgIGxldCBsZXZlbHM7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHR5cGUgPT09IENNQ0RPYmplY3RUeXBlLkFVRElPKSB7XG4gICAgICBsZXZlbHMgPSBobHMuYXVkaW9UcmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICBjb25zdCBsZW4gPSBtYXggPiAtMSA/IG1heCArIDEgOiBobHMubGV2ZWxzLmxlbmd0aDtcbiAgICAgIGxldmVscyA9IGhscy5sZXZlbHMuc2xpY2UoMCwgbGVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsZXZlbCBvZiBsZXZlbHMpIHtcbiAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICBiaXRyYXRlID0gbGV2ZWwuYml0cmF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpdHJhdGUgPiAwID8gYml0cmF0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBsZW5ndGggZm9yIGEgbWVkaWEgdHlwZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGdldEJ1ZmZlckxlbmd0aCh0eXBlKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLmhscy5tZWRpYTtcbiAgICBjb25zdCBidWZmZXIgPSB0eXBlID09PSBDTUNET2JqZWN0VHlwZS5BVURJTyA/IHRoaXMuYXVkaW9CdWZmZXIgOiB0aGlzLnZpZGVvQnVmZmVyO1xuICAgIGlmICghYnVmZmVyIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlciwgbWVkaWEuY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHJldHVybiBpbmZvLmxlbiAqIDEwMDA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICBjcmVhdGVQbGF5bGlzdExvYWRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwTG9hZGVyXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGFwcGx5ID0gdGhpcy5hcHBseVBsYXlsaXN0RGF0YTtcbiAgICBjb25zdCBDdG9yID0gcExvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIGNsYXNzIENtY2RQbGF5bGlzdExvYWRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgY3JlYXRlRnJhZ21lbnRMb2FkZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZkxvYWRlclxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBhcHBseSA9IHRoaXMuYXBwbHlGcmFnbWVudERhdGE7XG4gICAgY29uc3QgQ3RvciA9IGZMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiBjbGFzcyBDbWNkRnJhZ21lbnRMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgIH1cbiAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyB1dWlkKCkge1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoKSk7XG4gICAgY29uc3QgdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICByZXR1cm4gdXVpZC5zbGljZSh1dWlkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBDTUNEIGRhdGEgb2JqZWN0IGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBpbiB0aGVcbiAgICogc2VjdGlvbiAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqL1xuICBzdGF0aWMgc2VyaWFsaXplKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgaXNWYWxpZCA9IHZhbHVlID0+ICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbiAgICBjb25zdCB0b1JvdW5kZWQgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICBjb25zdCB0b0h1bmRyZWQgPSB2YWx1ZSA9PiB0b1JvdW5kZWQodmFsdWUgLyAxMDApICogMTAwO1xuICAgIGNvbnN0IHRvVXJsU2FmZSA9IHZhbHVlID0+IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgICAgIGJyOiB0b1JvdW5kZWQsXG4gICAgICBkOiB0b1JvdW5kZWQsXG4gICAgICBibDogdG9IdW5kcmVkLFxuICAgICAgZGw6IHRvSHVuZHJlZCxcbiAgICAgIG10cDogdG9IdW5kcmVkLFxuICAgICAgbm9yOiB0b1VybFNhZmUsXG4gICAgICBydHA6IHRvSHVuZHJlZCxcbiAgICAgIHRiOiB0b1JvdW5kZWRcbiAgICB9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5zb3J0KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IHZhbHVlID0gZGF0YVtrZXldO1xuXG4gICAgICAvLyBpZ25vcmUgaW52YWxpZCB2YWx1ZXNcbiAgICAgIGlmICghaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnNpb24gc2hvdWxkIG9ubHkgYmUgcmVwb3J0ZWQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgICBpZiAoa2V5ID09PSAndicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFBsYXliYWNrIHJhdGUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICAgIGlmIChrZXkgPT0gJ3ByJyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2VydGFpbiB2YWx1ZXMgcmVxdWlyZSBzcGVjaWFsIGZvcm1hdHRpbmdcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNba2V5XTtcbiAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXJpYWxpemUgdGhlIGtleS92YWx1ZSBwYWlyXG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChrZXkgPT09ICdvdCcgfHwga2V5ID09PSAnc2YnIHx8IGtleSA9PT0gJ3N0Jykge1xuICAgICAgICByZXN1bHQgPSBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBgJHtrZXl9PSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIHJlcXVlc3QgaGVhZGVycyBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzXG4gICAqIGRlZmluZWQgaW4gdGhlIHNlY3Rpb24gMi4xIGFuZCAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqL1xuICBzdGF0aWMgdG9IZWFkZXJzKGRhdGEpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGNvbnN0IGhlYWRlck5hbWVzID0gWydPYmplY3QnLCAnUmVxdWVzdCcsICdTZXNzaW9uJywgJ1N0YXR1cyddO1xuICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IFt7fSwge30sIHt9LCB7fV07XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge1xuICAgICAgYnI6IDAsXG4gICAgICBkOiAwLFxuICAgICAgb3Q6IDAsXG4gICAgICB0YjogMCxcbiAgICAgIGJsOiAxLFxuICAgICAgZGw6IDEsXG4gICAgICBtdHA6IDEsXG4gICAgICBub3I6IDEsXG4gICAgICBucnI6IDEsXG4gICAgICBzdTogMSxcbiAgICAgIGNpZDogMixcbiAgICAgIHByOiAyLFxuICAgICAgc2Y6IDIsXG4gICAgICBzaWQ6IDIsXG4gICAgICBzdDogMixcbiAgICAgIHY6IDIsXG4gICAgICBiczogMyxcbiAgICAgIHJ0cDogM1xuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gVW5tYXBwZWQgZmllbGRzIGFyZSBtYXBwZWQgdG8gdGhlIFJlcXVlc3QgaGVhZGVyXG4gICAgICBjb25zdCBpbmRleCA9IGhlYWRlck1hcFtrZXldICE9IG51bGwgPyBoZWFkZXJNYXBba2V5XSA6IDE7XG4gICAgICBoZWFkZXJHcm91cHNbaW5kZXhdW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IENNQ0RDb250cm9sbGVyLnNlcmlhbGl6ZShoZWFkZXJHcm91cHNbaV0pO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnNbYENNQ0QtJHtoZWFkZXJOYW1lc1tpXX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byBxdWVyeSBhcmdzIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAgICogZGVmaW5lZCBpbiB0aGUgc2VjdGlvbiAyLjIgYW5kIDMuMiBvZlxuICAgKiBbQ1RBLTUwMDRdKGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmKS5cbiAgICovXG4gIHN0YXRpYyB0b1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gYENNQ0Q9JHtlbmNvZGVVUklDb21wb25lbnQoQ01DRENvbnRyb2xsZXIuc2VyaWFsaXplKGRhdGEpKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBxdWVyeSBhcmdzIHRvIGEgdXJpLlxuICAgKi9cbiAgc3RhdGljIGFwcGVuZFF1ZXJ5VG9VcmkodXJpLCBxdWVyeSkge1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHVyaS5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICAgIHJldHVybiBgJHt1cml9JHtzZXBhcmF0b3J9JHtxdWVyeX1gO1xuICB9XG59XG5cbmNvbnN0IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUyA9IDMwMDAwMDtcbmNsYXNzIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMucGF0aHdheVByaW9yaXR5ID0gbnVsbDtcbiAgICB0aGlzLnRpbWVUb0xvYWQgPSAzMDA7XG4gICAgdGhpcy5yZWxvYWRUaW1lciA9IC0xO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5cyA9IHt9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYFtjb250ZW50LXN0ZWVyaW5nXTpgKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKTtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMudXJpKSB7XG4gICAgICBpZiAodGhpcy51cGRhdGVkKSB7XG4gICAgICAgIGNvbnN0IHR0bCA9IE1hdGgubWF4KHRoaXMudGltZVRvTG9hZCAqIDEwMDAgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnVwZGF0ZWQpLCAwKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmksIHR0bCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHRoaXMudXJpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkVGltZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmF1ZGlvVHJhY2tzID0gdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxUb1JlbW92ZSkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIHRoaXMubGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihsZXZlbCA9PiBsZXZlbCAhPT0gbGV2ZWxUb1JlbW92ZSk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgIHRoaXMudXJpID0gbnVsbDtcbiAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuYXVkaW9UcmFja3MgPSB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhdGh3YXlJZCA9IGNvbnRlbnRTdGVlcmluZy5wYXRod2F5SWQ7XG4gICAgdGhpcy51cmkgPSBjb250ZW50U3RlZXJpbmcudXJpO1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcztcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXJyb3JBY3Rpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoKGVycm9yQWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckFjdGlvbi5hY3Rpb24pID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCAmJiBlcnJvckFjdGlvbi5mbGFncyA9PT0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCkge1xuICAgICAgbGV0IHBhdGh3YXlQcmlvcml0eSA9IHRoaXMucGF0aHdheVByaW9yaXR5O1xuICAgICAgY29uc3QgcGF0aHdheUlkID0gdGhpcy5wYXRod2F5SWQ7XG4gICAgICBpZiAoIXRoaXMucGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXSkge1xuICAgICAgICB0aGlzLnBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0aHdheVByaW9yaXR5ICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICAgIC8vIElmIFBBVEhXQVktUFJJT1JJVFkgd2FzIG5vdCBwcm92aWRlZCwgbGlzdCBwYXRod2F5cyBmb3IgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgcGF0aHdheVByaW9yaXR5ID0gdGhpcy5sZXZlbHMucmVkdWNlKChwYXRod2F5cywgbGV2ZWwpID0+IHtcbiAgICAgICAgICBpZiAocGF0aHdheXMuaW5kZXhPZihsZXZlbC5wYXRod2F5SWQpID09PSAtMSkge1xuICAgICAgICAgICAgcGF0aHdheXMucHVzaChsZXZlbC5wYXRod2F5SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGF0aHdheXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkgJiYgcGF0aHdheVByaW9yaXR5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0aGlzLnBhdGh3YXlJZCAhPT0gcGF0aHdheUlkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKSB7XG4gICAgLy8gRmlsdGVyIGxldmVscyB0byBvbmx5IGluY2x1ZGUgdGhvc2UgdGhhdCBhcmUgaW4gdGhlIGluaXRpYWwgcGF0aHdheVxuICAgIHRoaXMubGV2ZWxzID0gbGV2ZWxzO1xuICAgIGxldCBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHRoaXMucGF0aHdheUlkKTtcbiAgICBpZiAocGF0aHdheUxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsc1swXS5wYXRod2F5SWQ7XG4gICAgICB0aGlzLmxvZyhgTm8gbGV2ZWxzIGZvdW5kIGluIFBhdGh3YXkgJHt0aGlzLnBhdGh3YXlJZH0uIFNldHRpbmcgaW5pdGlhbCBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgKTtcbiAgICAgIHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgIH1cbiAgICBpZiAocGF0aHdheUxldmVscy5sZW5ndGggIT09IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKGBGb3VuZCAke3BhdGh3YXlMZXZlbHMubGVuZ3RofS8ke2xldmVscy5sZW5ndGh9IGxldmVscyBpbiBQYXRod2F5IFwiJHt0aGlzLnBhdGh3YXlJZH1cImApO1xuICAgICAgcmV0dXJuIHBhdGh3YXlMZXZlbHM7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cbiAgZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxzLmZpbHRlcihsZXZlbCA9PiBwYXRod2F5SWQgPT09IGxldmVsLnBhdGh3YXlJZCk7XG4gIH1cbiAgdXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSkge1xuICAgIHRoaXMucGF0aHdheVByaW9yaXR5ID0gcGF0aHdheVByaW9yaXR5O1xuICAgIGxldCBsZXZlbHM7XG5cbiAgICAvLyBFdmFsdWF0ZSBpZiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwYXRod2F5IGZyb20gdGhlIHBlbmFsaXplZCBsaXN0XG4gICAgY29uc3QgcGVuYWxpemVkUGF0aHdheXMgPSB0aGlzLnBlbmFsaXplZFBhdGh3YXlzO1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHBlbmFsaXplZFBhdGh3YXlzKS5mb3JFYWNoKHBhdGh3YXlJZCA9PiB7XG4gICAgICBpZiAobm93IC0gcGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXSA+IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUykge1xuICAgICAgICBkZWxldGUgcGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGh3YXlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aHdheUlkID0gcGF0aHdheVByaW9yaXR5W2ldO1xuICAgICAgaWYgKHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheUlkID09PSB0aGlzLnBhdGh3YXlJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgKTtcbiAgICAgICAgdGhpcy5wYXRod2F5SWQgPSBwYXRod2F5SWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICAgICAgbGV2ZWxzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgTGV2ZWxDb250cm9sbGVyJ3MgbGV2ZWwgdG8gdHJpZ2dlciBMRVZFTF9TV0lUQ0hJTkcgd2hpY2ggbG9hZHMgcGxheWxpc3QgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IGxldmVsQWZ0ZXJDaGFuZ2UgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIGlmIChzZWxlY3RlZExldmVsICYmIGxldmVsQWZ0ZXJDaGFuZ2UgJiYgdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICBpZiAobGV2ZWxBZnRlckNoYW5nZS5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAhPT0gc2VsZWN0ZWRMZXZlbC5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAmJiBsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGUgIT09IHNlbGVjdGVkTGV2ZWwuYml0cmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coYFVuc3RhYmxlIFBhdGh3YXlzIGNoYW5nZSBmcm9tIGJpdHJhdGUgJHtzZWxlY3RlZExldmVsLmJpdHJhdGV9IHRvICR7bGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xvbmVQYXRod2F5cyhwYXRod2F5Q2xvbmVzKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cENsb25lTWFwID0ge307XG4gICAgY29uc3Qgc3VidGl0bGVHcm91cENsb25lTWFwID0ge307XG4gICAgcGF0aHdheUNsb25lcy5mb3JFYWNoKHBhdGh3YXlDbG9uZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIElEOiBjbG9uZUlkLFxuICAgICAgICAnQkFTRS1JRCc6IGJhc2VJZCxcbiAgICAgICAgJ1VSSS1SRVBMQUNFTUVOVCc6IHVyaVJlcGxhY2VtZW50XG4gICAgICB9ID0gcGF0aHdheUNsb25lO1xuICAgICAgaWYgKGxldmVscy5zb21lKGxldmVsID0+IGxldmVsLnBhdGh3YXlJZCA9PT0gY2xvbmVJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvbmVkVmFyaWFudHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoYmFzZUlkKS5tYXAoYmFzZUxldmVsID0+IHtcbiAgICAgICAgY29uc3QgbGV2ZWxQYXJzZWQgPSBfZXh0ZW5kcyh7fSwgYmFzZUxldmVsKTtcbiAgICAgICAgbGV2ZWxQYXJzZWQuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV2ZWxQYXJzZWQudXJsID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KGJhc2VMZXZlbC51cmksIGJhc2VMZXZlbC5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSwgJ1BFUi1WQVJJQU5ULVVSSVMnLCB1cmlSZXBsYWNlbWVudCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYmFzZUxldmVsLmF0dHJzKTtcbiAgICAgICAgYXR0cmlidXRlc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgICAgY29uc3QgY2xvbmVkQXVkaW9Hcm91cElkID0gYXR0cmlidXRlcy5BVURJTyAmJiBgJHthdHRyaWJ1dGVzLkFVRElPfV9jbG9uZV8ke2Nsb25lSWR9YDtcbiAgICAgICAgY29uc3QgY2xvbmVkU3VidGl0bGVHcm91cElkID0gYXR0cmlidXRlcy5TVUJUSVRMRVMgJiYgYCR7YXR0cmlidXRlcy5TVUJUSVRMRVN9X2Nsb25lXyR7Y2xvbmVJZH1gO1xuICAgICAgICBpZiAoY2xvbmVkQXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgYXVkaW9Hcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuQVVESU9dID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lZFN1YnRpdGxlR3JvdXBJZCkge1xuICAgICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLlNVQlRJVExFU10gPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgICAgYXR0cmlidXRlcy5TVUJUSVRMRVMgPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWxQYXJzZWQuYXR0cnMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBjbG9uZWRMZXZlbCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgIGFkZEdyb3VwSWQoY2xvbmVkTGV2ZWwsICdhdWRpbycsIGNsb25lZEF1ZGlvR3JvdXBJZCk7XG4gICAgICAgIGFkZEdyb3VwSWQoY2xvbmVkTGV2ZWwsICd0ZXh0JywgY2xvbmVkU3VidGl0bGVHcm91cElkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZExldmVsO1xuICAgICAgfSk7XG4gICAgICBsZXZlbHMucHVzaCguLi5jbG9uZWRWYXJpYW50cyk7XG4gICAgICBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0aGlzLmF1ZGlvVHJhY2tzLCBhdWRpb0dyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICAgIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRoaXMuc3VidGl0bGVUcmFja3MsIHN1YnRpdGxlR3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpO1xuICAgIH0pO1xuICB9XG4gIGxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFVSSTogJHt1cml9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1cmwucHJvdG9jb2wgIT09ICdkYXRhOicpIHtcbiAgICAgIGNvbnN0IHRocm91Z2hwdXQgPSAodGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgfHwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHwgMDtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhdGh3YXknLCB0aGlzLnBhdGh3YXlJZCk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU190aHJvdWdocHV0JywgJycgKyB0aHJvdWdocHV0KTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgdXJsOiB1cmwuaHJlZlxuICAgIH07XG4gICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5zdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfTtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBMb2FkZWQgc3RlZXJpbmcgbWFuaWZlc3Q6IFwiJHt1cmx9XCJgKTtcbiAgICAgICAgY29uc3Qgc3RlZXJpbmdEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgaWYgKHN0ZWVyaW5nRGF0YS5WRVJTSU9OICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIFZFUlNJT04gJHtzdGVlcmluZ0RhdGEuVkVSU0lPTn0gbm90IHN1cHBvcnRlZCFgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudGltZVRvTG9hZCA9IHN0ZWVyaW5nRGF0YS5UVEw7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAnUkVMT0FELVVSSSc6IHJlbG9hZFVyaSxcbiAgICAgICAgICAnUEFUSFdBWS1DTE9ORVMnOiBwYXRod2F5Q2xvbmVzLFxuICAgICAgICAgICdQQVRIV0FZLVBSSU9SSVRZJzogcGF0aHdheVByaW9yaXR5XG4gICAgICAgIH0gPSBzdGVlcmluZ0RhdGE7XG4gICAgICAgIGlmIChyZWxvYWRVcmkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cmkgPSBuZXcgc2VsZi5VUkwocmVsb2FkVXJpLCB1cmwpLmhyZWY7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBSRUxPQUQtVVJJOiAke3JlbG9hZFVyaX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgICBpZiAocGF0aHdheUNsb25lcykge1xuICAgICAgICAgIHRoaXMuY2xvbmVQYXRod2F5cyhwYXRod2F5Q2xvbmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aHdheVByaW9yaXR5KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChlcnJvciwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBFcnJvciBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke2Vycm9yLmNvZGV9ICR7ZXJyb3IudGV4dH0gKCR7Y29udGV4dC51cmx9KWApO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MTApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gbm8gbG9uZ2VyIGF2YWlsYWJsZWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHRsID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMDtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQyOSkge1xuICAgICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgICAgICAgIGlmICh0eXBlb2YgKGxvYWRlciA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignUmV0cnktQWZ0ZXInKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgIHR0bCA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gcmF0ZSBsaW1pdGVkYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsLCB0dGwpO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgVGltZW91dCBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2coYFJlcXVlc3Rpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6ICR7dXJsfWApO1xuICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBjYWxsYmFja3MpO1xuICB9XG4gIHNjaGVkdWxlUmVmcmVzaCh1cmksIHR0bE1zID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMCkge1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkVGltZXIpO1xuICAgIHRoaXMucmVsb2FkVGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2FkU3RlZXJpbmdNYW5pZmVzdCh1cmkpO1xuICAgIH0sIHR0bE1zKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVSZW5kaXRpb25Hcm91cHModHJhY2tzLCBncm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCkge1xuICBpZiAoIXRyYWNrcykge1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3Qua2V5cyhncm91cENsb25lTWFwKS5mb3JFYWNoKGF1ZGlvR3JvdXBJZCA9PiB7XG4gICAgY29uc3QgY2xvbmVkVHJhY2tzID0gdHJhY2tzLmZpbHRlcih0cmFjayA9PiB0cmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpLm1hcCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBjbG9uZWRUcmFjayA9IF9leHRlbmRzKHt9LCB0cmFjayk7XG4gICAgICBjbG9uZWRUcmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgY2xvbmVkVHJhY2suYXR0cnMgPSBuZXcgQXR0ckxpc3QoY2xvbmVkVHJhY2suYXR0cnMpO1xuICAgICAgY2xvbmVkVHJhY2sudXJsID0gY2xvbmVkVHJhY2suYXR0cnMuVVJJID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KHRyYWNrLnVybCwgdHJhY2suYXR0cnNbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXSwgJ1BFUi1SRU5ESVRJT04tVVJJUycsIHVyaVJlcGxhY2VtZW50KTtcbiAgICAgIGNsb25lZFRyYWNrLmdyb3VwSWQgPSBjbG9uZWRUcmFjay5hdHRyc1snR1JPVVAtSUQnXSA9IGdyb3VwQ2xvbmVNYXBbYXVkaW9Hcm91cElkXTtcbiAgICAgIGNsb25lZFRyYWNrLmF0dHJzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgcmV0dXJuIGNsb25lZFRyYWNrO1xuICAgIH0pO1xuICAgIHRyYWNrcy5wdXNoKC4uLmNsb25lZFRyYWNrcyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGVyZm9ybVVyaVJlcGxhY2VtZW50KHVyaSwgc3RhYmxlSWQsIHBlck9wdGlvbktleSwgdXJpUmVwbGFjZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIEhPU1Q6IGhvc3QsXG4gICAgUEFSQU1TOiBwYXJhbXMsXG4gICAgW3Blck9wdGlvbktleV06IHBlck9wdGlvblVyaXNcbiAgfSA9IHVyaVJlcGxhY2VtZW50O1xuICBsZXQgcGVyVmFyaWFudFVyaTtcbiAgaWYgKHN0YWJsZUlkKSB7XG4gICAgcGVyVmFyaWFudFVyaSA9IHBlck9wdGlvblVyaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBlck9wdGlvblVyaXNbc3RhYmxlSWRdO1xuICAgIGlmIChwZXJWYXJpYW50VXJpKSB7XG4gICAgICB1cmkgPSBwZXJWYXJpYW50VXJpO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgaWYgKGhvc3QgJiYgIXBlclZhcmlhbnRVcmkpIHtcbiAgICB1cmwuaG9zdCA9IGhvc3Q7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbXNba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVybC5ocmVmO1xufVxuXG5jb25zdCBBR0VfSEVBREVSX0xJTkVfUkVHRVggPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL2ltO1xuY2xhc3MgWGhyTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy54aHJTZXR1cCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnhoclNldHVwID0gY29uZmlnID8gY29uZmlnLnhoclNldHVwIHx8IG51bGwgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICB9XG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgaWYgKGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgfVxuICB9XG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICBpZiAodGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9XG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIHN0YXRzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG4gICAgaWYgKHhoclNldHVwKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6IHhoci5zdGF0dXMsXG4gICAgICAgICAgdGV4dDogZXJyb3IubWVzc2FnZVxuICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgIH1cbiAgfVxuICBvcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZykge1xuICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmNvbnRleHQuaGVhZGVycztcbiAgICBjb25zdCB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgIG1heExvYWRUaW1lTXNcbiAgICB9ID0gY29uZmlnLmxvYWRQb2xpY3k7XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPSBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBpc0Zpbml0ZU51bWJlcihtYXhUaW1lVG9GaXJzdEJ5dGVNcykgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG4gIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIGxvYWRlcjogeGhyLFxuICAgICAgc3RhdHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgaWYgKHN0YXRzLmxvYWRpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgIT09IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMpIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICBjb25maWcudGltZW91dCA9IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXM7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgLSAoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB4aHIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgY29uc3QgdXNlUmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlICE9PSAndGV4dCc7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCAmJiAodXNlUmVzcG9uc2UgJiYgeGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQgIT09IG51bGwpKSB7XG4gICAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdXNlUmVzcG9uc2UgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGNvbnN0IGxlbiA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBzdGF0cy5id0VzdGltYXRlID0gc3RhdHMudG90YWwgKiA4MDAwIC8gKHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgeGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGNvZGU6IHN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXRyeUNvbmZpZyA9IGNvbmZpZy5sb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgICAgY29uc3QgcmV0cnlDb3VudCA9IHN0YXRzLnJldHJ5O1xuICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBmYWxzZSwgc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgdmFyIF90aGlzJGNvbmZpZztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IChfdGhpcyRjb25maWcgPSB0aGlzLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZy5sb2FkUG9saWN5LnRpbWVvdXRSZXRyeTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5zdGF0cy5yZXRyeTtcbiAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIHRydWUpKSB7XG4gICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCk7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcztcbiAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHJ5KHJldHJ5Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHN0YXRzXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgc3RhdHMucmV0cnkpO1xuICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgbG9nZ2VyLndhcm4oYCR7c3RhdHVzID8gJ0hUVFAgU3RhdHVzICcgKyBzdGF0dXMgOiAnVGltZW91dCd9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH0sIHJldHJ5aW5nICR7c3RhdHMucmV0cnl9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGluICR7dGhpcy5yZXRyeURlbGF5fW1zYCk7XG4gICAgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gIH1cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHRoaXMubG9hZGVyICYmIEFHRV9IRUFERVJfTElORV9SRUdFWC50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyICYmIG5ldyBSZWdFeHAoYF4ke25hbWV9OlxcXFxzKltcXFxcZC5dK1xcXFxzKiRgLCAnaW0nKS50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmZXRjaFN1cHBvcnRlZCgpIHtcbiAgaWYgKFxuICAvLyBAdHMtaWdub3JlXG4gIHNlbGYuZmV0Y2ggJiYgc2VsZi5BYm9ydENvbnRyb2xsZXIgJiYgc2VsZi5SZWFkYWJsZVN0cmVhbSAmJiBzZWxmLlJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IHNlbGYuUmVhZGFibGVTdHJlYW0oe30pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogbm9vcCAqL1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBCWVRFUkFOR0UgPSAvKFxcZCspLShcXGQrKVxcLyhcXGQrKS87XG5jbGFzcyBGZXRjaExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyAvKiBIbHNDb25maWcgKi8pIHtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3QgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXNwb25zZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgfHwgZ2V0UmVxdWVzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gIH1cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG4gICAgaWYgKCEocmVzcG9uc2UgIT0gbnVsbCAmJiByZXNwb25zZS5vaykpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICB9XG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHRoaXMuY29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSBjYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgY29uc3QgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgbWF4TG9hZFRpbWVNc1xuICAgIH0gPSBjb25maWcubG9hZFBvbGljeTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXR1cChjb250ZXh0LCBpbml0UGFyYW1zKTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmxvYWRlciA9IHJlc3BvbnNlO1xuICAgICAgY29uc3QgZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgY29uZmlnLnRpbWVvdXQgPSBtYXhMb2FkVGltZU1zO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgIH0sIG1heExvYWRUaW1lTXMgLSAoZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dFxuICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IGZpcnN0O1xuICAgICAgc3RhdHMudG90YWwgPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpIHx8IHN0YXRzLnRvdGFsO1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgaXNGaW5pdGVOdW1iZXIoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgY29uZmlnLmhpZ2hXYXRlck1hcmssIG9uUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9KS50aGVuKHJlc3BvbnNlRGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgIGNvbnN0IHRvdGFsID0gcmVzcG9uc2VEYXRhW0xFTkdUSF07XG4gICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSB0b3RhbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgIH07XG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiAhaXNGaW5pdGVOdW1iZXIoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLm9uU3VjY2Vzcyhsb2FkZXJSZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAvLyB3aGVuIGRlc3Ryb3lpbmcsICdlcnJvcicgaXRzZWxmIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgIGNvbnN0IGNvZGUgPSAhZXJyb3IgPyAwIDogZXJyb3IuY29kZSB8fCAwO1xuICAgICAgY29uc3QgdGV4dCA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICBjb2RlLFxuICAgICAgICB0ZXh0XG4gICAgICB9LCBjb250ZXh0LCBlcnJvciA/IGVycm9yLmRldGFpbHMgOiBudWxsLCBzdGF0cyk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UgPyB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpIDogbnVsbDtcbiAgfVxuICBsb2FkUHJvZ3Jlc3NpdmVseShyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIGhpZ2hXYXRlck1hcmsgPSAwLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgY2h1bmtDYWNoZSA9IG5ldyBDaHVua0NhY2hlKCk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEuZG9uZSkge1xuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBkYXRhLnZhbHVlO1xuICAgICAgICBjb25zdCBsZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHN0YXRzLmxvYWRlZCArPSBsZW47XG4gICAgICAgIGlmIChsZW4gPCBoaWdoV2F0ZXJNYXJrIHx8IGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNodW5rIGlzIHRvbyBzbWFsbCB0byB0byBiZSBlbWl0dGVkIG9yIHRoZSBjYWNoZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgLy8gUHVzaCBpdCB0byB0aGUgY2FjaGVcbiAgICAgICAgICBjaHVua0NhY2hlLnB1c2goY2h1bmspO1xuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgLy8gZmx1c2ggaW4gb3JkZXIgdG8gam9pbiB0aGUgdHlwZWQgYXJyYXlzXG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBub3RoaW5nIGNhY2hlZCBhbHJlYWR5LCBhbmQgdGhlIGNoYWNoZSBpcyBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmssIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvKiBhYm9ydGVkICovXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcHVtcCgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCBzaWduYWwpIHtcbiAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWwsXG4gICAgaGVhZGVyczogbmV3IHNlbGYuSGVhZGVycyhfZXh0ZW5kcyh7fSwgY29udGV4dC5oZWFkZXJzKSlcbiAgfTtcbiAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICBpbml0UGFyYW1zLmhlYWRlcnMuc2V0KCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgU3RyaW5nKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gIH1cbiAgcmV0dXJuIGluaXRQYXJhbXM7XG59XG5mdW5jdGlvbiBnZXRCeXRlUmFuZ2VMZW5ndGgoYnl0ZVJhbmdlSGVhZGVyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IEJZVEVSQU5HRS5leGVjKGJ5dGVSYW5nZUhlYWRlcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0WzJdKSAtIHBhcnNlSW50KHJlc3VsdFsxXSkgKyAxO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFJhbmdlID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtUmFuZ2UnKTtcbiAgaWYgKGNvbnRlbnRSYW5nZSkge1xuICAgIGNvbnN0IGJ5dGVSYW5nZUxlbmd0aCA9IGdldEJ5dGVSYW5nZUxlbmd0aChjb250ZW50UmFuZ2UpO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICByZXR1cm4gYnl0ZVJhbmdlTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0KGNvbnRleHQsIGluaXRQYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLlJlcXVlc3QoY29udGV4dC51cmwsIGluaXRQYXJhbXMpO1xufVxuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5cbmNvbnN0IFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xuY29uc3QgQ3VlcyA9IHtcbiAgbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcm93O1xuICAgIC8vIHRoZSB0eXBlIGRhdGEgc3RhdGVzIHRoaXMgaXMgVlRUQ3VlLCBidXQgaXQgY2FuIHBvdGVudGlhbGx5IGJlIGEgVGV4dFRyYWNrQ3VlIG9uIG9sZCBicm93c2Vyc1xuICAgIGxldCBjdWU7XG4gICAgbGV0IGluZGVudGluZztcbiAgICBsZXQgaW5kZW50O1xuICAgIGxldCB0ZXh0O1xuICAgIGNvbnN0IEN1ZSA9IHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgX3RyYWNrJGN1ZXM7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgaWYgKFdISVRFU1BBQ0VfQ0hBUi50ZXN0KHJvdy5jaGFyc1tjXS51Y2hhcikgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VlVGV4dCA9IGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpO1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlQ3VlSWQoc3RhcnRUaW1lLCBlbmRUaW1lLCBjdWVUZXh0KTtcblxuICAgICAgICAvLyBJZiB0aGlzIGN1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgdHJhY2sgZG8gbm90IHB1c2ggaXRcbiAgICAgICAgaWYgKCEodHJhY2sgIT0gbnVsbCAmJiAoX3RyYWNrJGN1ZXMgPSB0cmFjay5jdWVzKSAhPSBudWxsICYmIF90cmFjayRjdWVzLmdldEN1ZUJ5SWQoaWQpKSkge1xuICAgICAgICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBjdWVUZXh0KTtcbiAgICAgICAgICBjdWUuaWQgPSBpZDtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICAgIGN1ZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAxMCBhbmQgODAgcGVyY2VudCAoQ0VBLTYwOCBQQUMgaW5kZW50IGNvZGUpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy90ZXh0LXRyYWNrcy9yYXctZmlsZS9kZWZhdWx0LzYwOHRvVlRULzYwOHRvVlRULmh0bWwjcG9zaXRpb25pbmctaW4tY2VhLTYwOFxuICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWsgd2l0aCBvdXQgb2YgYm91bmRzIDAtMTAwIHZhbHVlc1xuICAgICAgICAgIGN1ZS5wb3NpdGlvbiA9IDEwICsgTWF0aC5taW4oODAsIE1hdGguZmxvb3IoaW5kZW50ICogOCAvIDMyKSAqIDEwKTtcbiAgICAgICAgICByZXN1bHQucHVzaChjdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFjayAmJiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgICByZXN1bHQuc29ydCgoY3VlQSwgY3VlQikgPT4ge1xuICAgICAgICBpZiAoY3VlQS5saW5lID09PSAnYXV0bycgfHwgY3VlQi5saW5lID09PSAnYXV0bycpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VlQS5saW5lID4gOCAmJiBjdWVCLmxpbmUgPiA4KSB7XG4gICAgICAgICAgcmV0dXJuIGN1ZUIubGluZSAtIGN1ZUEubGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VlQS5saW5lIC0gY3VlQi5saW5lO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuZm9yRWFjaChjdWUgPT4gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGZyYWdMb2FkUG9saWN5LmRlZmF1bHRcbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBtYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdCBhbmQgcGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHRcbiAqL1xuXG5jb25zdCBkZWZhdWx0TG9hZFBvbGljeSA9IHtcbiAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gIGVycm9yUmV0cnk6IG51bGxcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICogSWYgcG9zc2libGUsIGtlZXAgaGxzRGVmYXVsdENvbmZpZyBzaGFsbG93XG4gKiBJdCBpcyBjbG9uZWQgd2hlbmV2ZXIgYSBuZXcgSGxzIGluc3RhbmNlIGlzIGNyZWF0ZWQsIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ1xuICogc2hhbGxvdyB0aGUgcHJvcGVydGllcyBhcmUgY2xvbmVkLCBhbmQgd2UgZG9uJ3QgZW5kIHVwIG1hbmlwdWxhdGluZyB0aGUgZGVmYXVsdFxuICovXG5jb25zdCBobHNEZWZhdWx0Q29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICBhdXRvU3RhcnRMb2FkOiB0cnVlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIHN0YXJ0UG9zaXRpb246IC0xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlZmF1bHRBdWRpb0NvZGVjOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVidWc6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGxvZ2dlclxuICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGlnbm9yZURldmljZVBpeGVsUmF0aW86IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgYmFja0J1ZmZlckxlbmd0aDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJIb2xlOiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAyLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlT2Zmc2V0OiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBiYWNrQnVmZmVyTGVuZ3RoXG4gICAqL1xuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogbnVsbCxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBlbmFibGVXb3JrZXI6IHRydWUsXG4gIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICB3b3JrZXJQYXRoOiBudWxsLFxuICAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbG9hZGVyOiBYaHJMb2FkZXIsXG4gIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHhoci1sb2FkZXJcbiAgbGljZW5zZVhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyLFxuICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcbiAgZXJyb3JDb250cm9sbGVyOiBFcnJvckNvbnRyb2xsZXIsXG4gIGZwc0NvbnRyb2xsZXI6IEZQU0NvbnRyb2xsZXIsXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LFxuICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsXG4gIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbXM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgdGVzdEJhbmR3aWR0aDogdHJ1ZSxcbiAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuICBsb3dMYXRlbmN5TW9kZTogdHJ1ZSxcbiAgY21jZDogdW5kZWZpbmVkLFxuICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgY2VydExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiBkZWZhdWx0TG9hZFBvbGljeVxuICB9LFxuICBrZXlMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGF5bGlzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDQsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9IFxuICB9LFxuICAvLyBUaGVzZSBkZWZhdWx0IHNldHRpbmdzIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBhYm92ZSBwb2xpY2llc1xuICAvLyBhbmQgYXJlIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMFxufSwgdGltZWxpbmVDb25maWcoKSksIHt9LCB7XG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyICxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyICxcbiAgdGltZWxpbmVDb250cm9sbGVyOiBUaW1lbGluZUNvbnRyb2xsZXIgLFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IEF1ZGlvU3RyZWFtQ29udHJvbGxlciAsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlciAsXG4gIGVtZUNvbnRyb2xsZXI6IEVNRUNvbnRyb2xsZXIgLFxuICBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXIgLFxuICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIFxufSk7XG5mdW5jdGlvbiB0aW1lbGluZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBDdWVzLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZVdlYlZUVDogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogJ0VuZ2xpc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZTogJ2VuJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZTogJ2VzJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6ICcnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZVxuICB9O1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZykge1xuICBpZiAoKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICB9XG4gIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgfVxuICBjb25zdCBkZWZhdWx0c0NvcHkgPSBkZWVwQ3B5KGRlZmF1bHRDb25maWcpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZGVwcmVjYXRlZCBjb25maWcgdmFsdWVzXG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMgPSBbJ21hbmlmZXN0JywgJ2xldmVsJywgJ2ZyYWcnXTtcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdzID0gWydUaW1lT3V0JywgJ01heFJldHJ5JywgJ1JldHJ5RGVsYXknLCAnTWF4UmV0cnlUaW1lb3V0J107XG4gIGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBwb2xpY3lOYW1lID0gYCR7dHlwZSA9PT0gJ2xldmVsJyA/ICdwbGF5bGlzdCcgOiB0eXBlfUxvYWRQb2xpY3lgO1xuICAgIGNvbnN0IHBvbGljeU5vdFNldCA9IHVzZXJDb25maWdbcG9saWN5TmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXBvcnQgPSBbXTtcbiAgICBkZXByZWNhdGVkU2V0dGluZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nID0gYCR7dHlwZX1Mb2FkaW5nJHtzZXR0aW5nfWA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVzZXJDb25maWdbZGVwcmVjYXRlZFNldHRpbmddO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgcG9saWN5Tm90U2V0KSB7XG4gICAgICAgIHJlcG9ydC5wdXNoKGRlcHJlY2F0ZWRTZXR0aW5nKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBkZWZhdWx0c0NvcHlbcG9saWN5TmFtZV0uZGVmYXVsdDtcbiAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHtcbiAgICAgICAgICBkZWZhdWx0OiBzZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgICAgICBjYXNlICdUaW1lT3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLm1heExvYWRUaW1lTXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5yZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5yZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01heFJldHJ5VGltZW91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVwb3J0Lmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oYGhscy5qcyBjb25maWc6IFwiJHtyZXBvcnQuam9pbignXCIsIFwiJyl9XCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFwiJHtwb2xpY3lOYW1lfVwiOiAke0pTT04uc3RyaW5naWZ5KHVzZXJDb25maWdbcG9saWN5TmFtZV0pfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHNDb3B5KSwgdXNlckNvbmZpZyk7XG59XG5mdW5jdGlvbiBkZWVwQ3B5KG9iaikge1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENweSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVlcENweShvYmpba2V5XSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpIHtcbiAgY29uc3QgY3VycmVudExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IEN1c3RvbSBsb2FkZXIgZGV0ZWN0ZWQsIGNhbm5vdCBlbmFibGUgcHJvZ3Jlc3NpdmUgc3RyZWFtaW5nJyk7XG4gICAgY29uZmlnLnByb2dyZXNzaXZlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9IGZldGNoU3VwcG9ydGVkKCk7XG4gICAgaWYgKGNhblN0cmVhbVByb2dyZXNzaXZlbHkpIHtcbiAgICAgIGNvbmZpZy5sb2FkZXIgPSBGZXRjaExvYWRlcjtcbiAgICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICBjb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgSGxzYCBjbGFzcyBpcyB0aGUgY29yZSBvZiB0aGUgSExTLmpzIGxpYnJhcnkgdXNlZCB0byBpbnN0YW50aWF0ZSBwbGF5ZXIgaW5zdGFuY2VzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBIbHMge1xuICAvKipcbiAgICogVGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbiB1c2VkIGJ5IHRoZSBwbGF5ZXIuIEF0IGluc3RhbnRpYXRpb24gdGhpcyBpcyBjb21iaW5hdGlvbiBvZiBgaGxzLnVzZXJDb25maWdgIG1lcmdlZCBvdmVyIGBIbHMuRGVmYXVsdENvbmZpZ2AuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQgb24gcGxheWVyIGluc3RhbnRpYXRpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZGVvLWRldi9obHMuanMgcGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjEuNC4xMFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXF1aXJlZCBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudHMoKSB7XG4gICAgcmV0dXJuIEV2ZW50cztcbiAgfVxuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XG4gICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWcpIHtcbiAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAqIEBwYXJhbSB1c2VyQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFwcGxpZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VyQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIGVuYWJsZUxvZ3ModXNlckNvbmZpZy5kZWJ1ZyB8fCBmYWxzZSwgJ0hscyBpbnN0YW5jZScpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbWVyZ2VDb25maWcoSGxzLkRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHVzZXJDb25maWc7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICBjb25zdCB7XG4gICAgICBhYnJDb250cm9sbGVyOiBDb25maWdBYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogQ29uZmlnQnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcjogQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZXJyb3JDb250cm9sbGVyOiBDb25maWdFcnJvckNvbnRyb2xsZXIsXG4gICAgICBmcHNDb250cm9sbGVyOiBDb25maWdGcHNDb250cm9sbGVyXG4gICAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBlcnJvckNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRXJyb3JDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBidWZmZXJDb250cm9sbGVyID0gdGhpcy5idWZmZXJDb250cm9sbGVyID0gbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgY2FwTGV2ZWxDb250cm9sbGVyID0gdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPSBjb25maWcuY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAvLyBDb25lbnRTdGVlcmluZ0NvbnRyb2xsZXIgaXMgZGVmaW5lZCBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZyA9IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPyBuZXcgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKSA6IG51bGw7XG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcik7XG5cbiAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIC8vIGZwc0NvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIHN3aXRjaCB3aGVuIGZyYW1lcyBhcmUgYmVpbmcgZHJvcHBlZFxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbcGxheUxpc3RMb2FkZXIsIGxldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBjb250ZW50U3RlZXJpbmcpO1xuICAgIH1cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcbiAgICBjb25zdCBjb3JlQ29tcG9uZW50cyA9IFthYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICBjb25zdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgLy8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgY29uc3QgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcudGltZWxpbmVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAga2V5TG9hZGVyLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmVtZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5jbWNkQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoTGF0ZW5jeUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG5cbiAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzIGVycm9yIGxpc3RlbmVyc1xuICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKGVycm9yQ29udHJvbGxlcik7XG4gICAgY29uc3Qgb25FcnJvck91dCA9IGVycm9yQ29udHJvbGxlci5vbkVycm9yT3V0O1xuICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbihFdmVudHMuRVJST1IsIG9uRXJyb3JPdXQsIGVycm9yQ29udHJvbGxlcik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBjb21wb25lbnRzKSB7XG4gICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgY29uc3QgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzLCBvbmNlKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgfVxuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIGVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpO1xuICB9XG4gIHRyaWdnZXIoZXZlbnQsIGV2ZW50T2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgKyBldmVudCArICcuIEVycm9yIG1lc3NhZ2U6IFwiJyArIGUubWVzc2FnZSArICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JywgZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy54aHJTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwID0gdW5kZWZpbmVkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJDb25maWcgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICovXG4gIGF0dGFjaE1lZGlhKG1lZGlhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB7XG4gICAgICBtZWRpYTogbWVkaWFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2ggSGxzLmpzIGZyb20gdGhlIG1lZGlhXG4gICAqL1xuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICovXG4gIGxvYWRTb3VyY2UodXJsKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBsb2FkZWRTb3VyY2UgPSB0aGlzLnVybDtcbiAgICBjb25zdCBsb2FkaW5nU291cmNlID0gdGhpcy51cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHNlbGYubG9jYXRpb24uaHJlZiwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7bG9hZGluZ1NvdXJjZX1gKTtcbiAgICBpZiAobWVkaWEgJiYgbG9hZGVkU291cmNlICYmIChsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgfHwgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpKSB7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BRElORywge1xuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gLSBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tLlxuICAgKiBEZWZhdWx0cyB0byAtMSAoTm9uZTogc3RhcnRzIGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiA9IC0xKSB7XG4gICAgbG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7c3RhcnRQb3NpdGlvbn0pYCk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAqL1xuICBzdG9wTG9hZCgpIHtcbiAgICBsb2dnZXIubG9nKCdzdG9wTG9hZCcpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgKi9cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkID0gMCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgQkFORFdJRFRILCBTQ09SRSwgYW5kIFJFU09MVVRJT04gKGhlaWdodClcbiAgICovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgIHJldHVybiBsZXZlbHMgPyBsZXZlbHMgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsICh2YXJpYW50KSBjdXJyZW50bHkgcGxheWVkXG4gICAqL1xuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGltbWVkaWF0ZWx5LiBUaGlzIHdpbGwgZmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyIHRvIHJlcGxhY2UgdGhlIHF1YWxpdHkgYXNhcC4gVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LiBTZXQgdG8gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24uXG4gICAqL1xuICBzZXQgY3VycmVudExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAqL1xuICBnZXQgbG9hZExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGxvYWRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICovXG4gIHNldCBuZXh0TG9hZExldmVsKGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICovXG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGxldmVsIGNhcHBpbmcgaXMgZW5hYmxlZC5cbiAgICogRGVmYXVsdCB2YWx1ZSBpcyBzZXQgdmlhIGBjb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemVgLlxuICAgKi9cbiAgZ2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGxldmVsIGNhcHBpbmcuIElmIGRpc2FibGVkIGFmdGVyIHByZXZpb3VzbHkgZW5hYmxlZCwgYG5leHRMZXZlbFN3aXRjaGAgd2lsbCBiZSBpbW1lZGlhdGVseSBjYWxsZWQuXG4gICAqL1xuICBzZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoc2hvdWxkU3RhcnRDYXBwaW5nKSB7XG4gICAgY29uc3QgbmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgPSAhIXNob3VsZFN0YXJ0Q2FwcGluZztcbiAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCk7XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXQgYmFuZHdpZHRoRXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3JcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aW1lIHRvIGZpcnN0IGJ5dGUgZXN0aW1hdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB0dGZiRXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3JcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBzZXQgYXV0b0xldmVsQ2FwcGluZyhuZXdMZXZlbCkge1xuICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cbiAgZ2V0IG1heEhkY3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICB9XG4gIHNldCBtYXhIZGNwTGV2ZWwodmFsdWUpIHtcbiAgICBpZiAoSGRjcExldmVscy5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICB0aGlzLl9tYXhIZGNwTGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICovXG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICovXG4gIGdldCBtaW5BdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIG1pbkF1dG9CaXRyYXRlXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHJldHVybiAwO1xuICAgIGNvbnN0IGxlbiA9IGxldmVscy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID49IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICovXG4gIGdldCBtYXhBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgIG1heEhkY3BMZXZlbFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBtYXhBdXRvTGV2ZWw7XG4gICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG4gICAgaWYgKG1heEhkY3BMZXZlbCkge1xuICAgICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaS0tOykge1xuICAgICAgICBjb25zdCBoZGNwTGV2ZWwgPSBsZXZlbHNbaV0uYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgaWYgKGhkY3BMZXZlbCAmJiBoZGNwTGV2ZWwgPD0gbWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgKi9cbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCksIHRoaXMubWF4QXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KHRoaXMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0ZXRpbWUgdmFsdWUgcmVsYXRpdmUgdG8gbWVkaWEuY3VycmVudFRpbWUgZm9yIHRoZSBhY3RpdmUgbGV2ZWwgUHJvZ3JhbSBEYXRlIFRpbWUgaWYgcHJlc2VudFxuICAgKi9cbiAgZ2V0IHBsYXlpbmdEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudFByb2dyYW1EYXRlVGltZTtcbiAgfVxuICBnZXQgbWFpbkZvcndhcmRCdWZmZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICB9XG4gIGdldCBtZWRpYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgc3VidGl0bGUgZGlzcGxheSBpcyBlbmFibGVkIG9yIG5vdFxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSgpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICovXG4gIHNldCBzdWJ0aXRsZURpc3BsYXkodmFsdWUpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IG1vZGUgZm9yIExvdy1MYXRlbmN5IEhMUyBsb2FkaW5nXG4gICAqL1xuICBnZXQgbG93TGF0ZW5jeU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIExvdy1MYXRlbmN5IEhMUyBwYXJ0IHBsYXlsaXN0IGFuZCBzZWdtZW50IGxvYWRpbmcsIGFuZCBzdGFydCBsaXZlIHN0cmVhbXMgYXQgcGxheWxpc3QgUEFSVC1IT0xELUJBQ0sgcmF0aGVyIHRoYW4gSE9MRC1CQUNLLlxuICAgKi9cbiAgc2V0IGxvd0xhdGVuY3lNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSA9IG1vZGU7XG4gIH1cblxuICAvKipcbiAgICogUG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgc3luYyBwb2ludCAoaWUgZWRnZSBvZiBsaXZlIHBvc2l0aW9uIG1pbnVzIHNhZmV0eSBkZWxheSBkZWZpbmVkIGJ5IGBgYGhscy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbmBgYClcbiAgICogQHJldHVybnMgbnVsbCBwcmlvciB0byBsb2FkaW5nIGxpdmUgUGxheWxpc3RcbiAgICovXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVkIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIGVkZ2UgKGllIGVkZ2Ugb2YgbGl2ZSBwbGF5bGlzdCBwbHVzIHRpbWUgc3luYyBwbGF5bGlzdCBhZHZhbmNlZClcbiAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAqL1xuICBnZXQgbGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5sYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBiZWZvcmUgdGhlIHBsYXllciBzZWVrcyBmb3J3YXJkIHRvIGBgYGhscy5saXZlU3luY1Bvc2l0aW9uYGBgXG4gICAqIGNvbmZpZ3VyZWQgdXNpbmcgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50YGBgIChtdWx0aXBsZSBvZiB0YXJnZXQgZHVyYXRpb24pIG9yIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25gYGBcbiAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAqL1xuICBnZXQgbWF4TGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5tYXhMYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIHRhcmdldCBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGFzIGNhbGN1bGF0ZWQgYnkgdGhlIGxhdGVuY3kgY29udHJvbGxlclxuICAgKi9cbiAgZ2V0IHRhcmdldExhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIudGFyZ2V0TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgZWRnZSBvZiB0aGUgY3VycmVudCBsaXZlIHBsYXlsaXN0IGlzIGFkdmFuY2luZyBvciAxIGlmIHRoZXJlIGlzIG5vbmVcbiAgICovXG4gIGdldCBkcmlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgdG8gdHJ1ZSB3aGVuIHN0YXJ0TG9hZCBpcyBjYWxsZWQgYmVmb3JlIE1BTklGRVNUX1BBUlNFRCBldmVudFxuICAgKi9cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZm9yY2VTdGFydExvYWQ7XG4gIH1cbn1cbkhscy5kZWZhdWx0Q29uZmlnID0gdm9pZCAwO1xuXG5leHBvcnQgeyBIbHMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGxzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/hls.js/dist/hls.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/media-chrome/dist/constants.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttributeToStateChangeEventMap: function() { return /* binding */ AttributeToStateChangeEventMap; },\n/* harmony export */   AvailabilityStates: function() { return /* binding */ AvailabilityStates; },\n/* harmony export */   MediaStateChangeEvents: function() { return /* binding */ MediaStateChangeEvents; },\n/* harmony export */   MediaStateReceiverAttributes: function() { return /* binding */ MediaStateReceiverAttributes; },\n/* harmony export */   MediaUIAttributes: function() { return /* binding */ MediaUIAttributes; },\n/* harmony export */   MediaUIEvents: function() { return /* binding */ MediaUIEvents; },\n/* harmony export */   MediaUIProps: function() { return /* binding */ MediaUIProps; },\n/* harmony export */   PointerTypes: function() { return /* binding */ PointerTypes; },\n/* harmony export */   ReadyStates: function() { return /* binding */ ReadyStates; },\n/* harmony export */   StateChangeEventToAttributeMap: function() { return /* binding */ StateChangeEventToAttributeMap; },\n/* harmony export */   StreamTypes: function() { return /* binding */ StreamTypes; },\n/* harmony export */   TextTrackKinds: function() { return /* binding */ TextTrackKinds; },\n/* harmony export */   TextTrackModes: function() { return /* binding */ TextTrackModes; }\n/* harmony export */ });\nconst MediaUIEvents = {\n  MEDIA_PLAY_REQUEST: \"mediaplayrequest\",\n  MEDIA_PAUSE_REQUEST: \"mediapauserequest\",\n  MEDIA_MUTE_REQUEST: \"mediamuterequest\",\n  MEDIA_UNMUTE_REQUEST: \"mediaunmuterequest\",\n  MEDIA_VOLUME_REQUEST: \"mediavolumerequest\",\n  MEDIA_SEEK_REQUEST: \"mediaseekrequest\",\n  MEDIA_AIRPLAY_REQUEST: \"mediaairplayrequest\",\n  MEDIA_ENTER_FULLSCREEN_REQUEST: \"mediaenterfullscreenrequest\",\n  MEDIA_EXIT_FULLSCREEN_REQUEST: \"mediaexitfullscreenrequest\",\n  MEDIA_PREVIEW_REQUEST: \"mediapreviewrequest\",\n  MEDIA_ENTER_PIP_REQUEST: \"mediaenterpiprequest\",\n  MEDIA_EXIT_PIP_REQUEST: \"mediaexitpiprequest\",\n  MEDIA_ENTER_CAST_REQUEST: \"mediaentercastrequest\",\n  MEDIA_EXIT_CAST_REQUEST: \"mediaexitcastrequest\",\n  MEDIA_SHOW_TEXT_TRACKS_REQUEST: \"mediashowtexttracksrequest\",\n  MEDIA_HIDE_TEXT_TRACKS_REQUEST: \"mediahidetexttracksrequest\",\n  MEDIA_SHOW_SUBTITLES_REQUEST: \"mediashowsubtitlesrequest\",\n  MEDIA_DISABLE_SUBTITLES_REQUEST: \"mediadisablesubtitlesrequest\",\n  MEDIA_PLAYBACK_RATE_REQUEST: \"mediaplaybackraterequest\",\n  MEDIA_SEEK_TO_LIVE_REQUEST: \"mediaseektoliverequest\",\n  REGISTER_MEDIA_STATE_RECEIVER: \"registermediastatereceiver\",\n  UNREGISTER_MEDIA_STATE_RECEIVER: \"unregistermediastatereceiver\"\n};\nconst MediaStateReceiverAttributes = {\n  MEDIA_CHROME_ATTRIBUTES: \"mediachromeattributes\",\n  MEDIA_CONTROLLER: \"mediacontroller\"\n};\nconst MediaUIProps = {\n  MEDIA_AIRPLAY_UNAVAILABLE: \"mediaAirplayUnavailable\",\n  MEDIA_FULLSCREEN_UNAVAILABLE: \"mediaFullscreenUnavailable\",\n  MEDIA_PIP_UNAVAILABLE: \"mediaPipUnavailable\",\n  MEDIA_CAST_UNAVAILABLE: \"mediaCastUnavailable\",\n  MEDIA_PAUSED: \"mediaPaused\",\n  MEDIA_HAS_PLAYED: \"mediaHasPlayed\",\n  MEDIA_ENDED: \"mediaEnded\",\n  MEDIA_MUTED: \"mediaMuted\",\n  MEDIA_VOLUME_LEVEL: \"mediaVolumeLevel\",\n  MEDIA_VOLUME: \"mediaVolume\",\n  MEDIA_VOLUME_UNAVAILABLE: \"mediaVolumeUnavailable\",\n  MEDIA_IS_PIP: \"mediaIsPip\",\n  MEDIA_IS_CASTING: \"mediaIsCasting\",\n  MEDIA_SUBTITLES_LIST: \"mediaSubtitlesList\",\n  MEDIA_SUBTITLES_SHOWING: \"mediaSubtitlesShowing\",\n  MEDIA_IS_FULLSCREEN: \"mediaIsFullscreen\",\n  MEDIA_PLAYBACK_RATE: \"mediaPlaybackRate\",\n  MEDIA_CURRENT_TIME: \"mediaCurrentTime\",\n  MEDIA_DURATION: \"mediaDuration\",\n  MEDIA_SEEKABLE: \"mediaSeekable\",\n  MEDIA_PREVIEW_TIME: \"mediaPreviewTime\",\n  MEDIA_PREVIEW_IMAGE: \"mediaPreviewImage\",\n  MEDIA_PREVIEW_COORDS: \"mediaPreviewCoords\",\n  MEDIA_LOADING: \"mediaLoading\",\n  MEDIA_BUFFERED: \"mediaBuffered\",\n  MEDIA_STREAM_TYPE: \"mediaStreamType\",\n  MEDIA_TARGET_LIVE_WINDOW: \"mediaTargetLiveWindow\",\n  MEDIA_TIME_IS_LIVE: \"mediaTimeIsLive\"\n};\nconst MediaUIPropsEntries = Object.entries(MediaUIProps);\nconst MediaUIAttributes = MediaUIPropsEntries.reduce((dictObj, [key, propName]) => {\n  dictObj[key] = `${propName.toLowerCase()}`;\n  return dictObj;\n}, {});\nconst MediaStateChangeEvents = MediaUIPropsEntries.reduce(\n  (dictObj, [key, propName]) => {\n    dictObj[key] = `${propName.toLowerCase()}`;\n    return dictObj;\n  },\n  {\n    USER_INACTIVE: \"userinactivechange\",\n    BREAKPOINTS_CHANGE: \"breakpointchange\"\n  }\n);\nconst StateChangeEventToAttributeMap = Object.entries(\n  MediaStateChangeEvents\n).reduce(\n  (mapObj, [key, eventType]) => {\n    const attrName = MediaUIAttributes[key];\n    if (attrName) {\n      mapObj[eventType] = attrName;\n    }\n    return mapObj;\n  },\n  { userinactivechange: \"userinactive\" }\n);\nconst AttributeToStateChangeEventMap = Object.entries(\n  MediaUIAttributes\n).reduce(\n  (mapObj, [key, attrName]) => {\n    const evtType = MediaStateChangeEvents[key];\n    if (evtType) {\n      mapObj[attrName] = evtType;\n    }\n    return mapObj;\n  },\n  { userinactive: \"userinactivechange\" }\n);\nconst TextTrackKinds = {\n  SUBTITLES: \"subtitles\",\n  CAPTIONS: \"captions\",\n  DESCRIPTIONS: \"descriptions\",\n  CHAPTERS: \"chapters\",\n  METADATA: \"metadata\"\n};\nconst TextTrackModes = {\n  DISABLED: \"disabled\",\n  HIDDEN: \"hidden\",\n  SHOWING: \"showing\"\n};\nconst ReadyStates = {\n  HAVE_NOTHING: 0,\n  HAVE_METADATA: 1,\n  HAVE_CURRENT_DATA: 2,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_ENOUGH_DATA: 4\n};\nconst PointerTypes = {\n  MOUSE: \"mouse\",\n  PEN: \"pen\",\n  TOUCH: \"touch\"\n};\nconst AvailabilityStates = {\n  UNAVAILABLE: \"unavailable\",\n  UNSUPPORTED: \"unsupported\"\n};\nconst StreamTypes = {\n  LIVE: \"live\",\n  ON_DEMAND: \"on-demand\",\n  UNKNOWN: \"unknown\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9jb25zdGFudHMuanM/ZjA3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNZWRpYVVJRXZlbnRzID0ge1xuICBNRURJQV9QTEFZX1JFUVVFU1Q6IFwibWVkaWFwbGF5cmVxdWVzdFwiLFxuICBNRURJQV9QQVVTRV9SRVFVRVNUOiBcIm1lZGlhcGF1c2VyZXF1ZXN0XCIsXG4gIE1FRElBX01VVEVfUkVRVUVTVDogXCJtZWRpYW11dGVyZXF1ZXN0XCIsXG4gIE1FRElBX1VOTVVURV9SRVFVRVNUOiBcIm1lZGlhdW5tdXRlcmVxdWVzdFwiLFxuICBNRURJQV9WT0xVTUVfUkVRVUVTVDogXCJtZWRpYXZvbHVtZXJlcXVlc3RcIixcbiAgTUVESUFfU0VFS19SRVFVRVNUOiBcIm1lZGlhc2Vla3JlcXVlc3RcIixcbiAgTUVESUFfQUlSUExBWV9SRVFVRVNUOiBcIm1lZGlhYWlycGxheXJlcXVlc3RcIixcbiAgTUVESUFfRU5URVJfRlVMTFNDUkVFTl9SRVFVRVNUOiBcIm1lZGlhZW50ZXJmdWxsc2NyZWVucmVxdWVzdFwiLFxuICBNRURJQV9FWElUX0ZVTExTQ1JFRU5fUkVRVUVTVDogXCJtZWRpYWV4aXRmdWxsc2NyZWVucmVxdWVzdFwiLFxuICBNRURJQV9QUkVWSUVXX1JFUVVFU1Q6IFwibWVkaWFwcmV2aWV3cmVxdWVzdFwiLFxuICBNRURJQV9FTlRFUl9QSVBfUkVRVUVTVDogXCJtZWRpYWVudGVycGlwcmVxdWVzdFwiLFxuICBNRURJQV9FWElUX1BJUF9SRVFVRVNUOiBcIm1lZGlhZXhpdHBpcHJlcXVlc3RcIixcbiAgTUVESUFfRU5URVJfQ0FTVF9SRVFVRVNUOiBcIm1lZGlhZW50ZXJjYXN0cmVxdWVzdFwiLFxuICBNRURJQV9FWElUX0NBU1RfUkVRVUVTVDogXCJtZWRpYWV4aXRjYXN0cmVxdWVzdFwiLFxuICBNRURJQV9TSE9XX1RFWFRfVFJBQ0tTX1JFUVVFU1Q6IFwibWVkaWFzaG93dGV4dHRyYWNrc3JlcXVlc3RcIixcbiAgTUVESUFfSElERV9URVhUX1RSQUNLU19SRVFVRVNUOiBcIm1lZGlhaGlkZXRleHR0cmFja3NyZXF1ZXN0XCIsXG4gIE1FRElBX1NIT1dfU1VCVElUTEVTX1JFUVVFU1Q6IFwibWVkaWFzaG93c3VidGl0bGVzcmVxdWVzdFwiLFxuICBNRURJQV9ESVNBQkxFX1NVQlRJVExFU19SRVFVRVNUOiBcIm1lZGlhZGlzYWJsZXN1YnRpdGxlc3JlcXVlc3RcIixcbiAgTUVESUFfUExBWUJBQ0tfUkFURV9SRVFVRVNUOiBcIm1lZGlhcGxheWJhY2tyYXRlcmVxdWVzdFwiLFxuICBNRURJQV9TRUVLX1RPX0xJVkVfUkVRVUVTVDogXCJtZWRpYXNlZWt0b2xpdmVyZXF1ZXN0XCIsXG4gIFJFR0lTVEVSX01FRElBX1NUQVRFX1JFQ0VJVkVSOiBcInJlZ2lzdGVybWVkaWFzdGF0ZXJlY2VpdmVyXCIsXG4gIFVOUkVHSVNURVJfTUVESUFfU1RBVEVfUkVDRUlWRVI6IFwidW5yZWdpc3Rlcm1lZGlhc3RhdGVyZWNlaXZlclwiXG59O1xuY29uc3QgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcyA9IHtcbiAgTUVESUFfQ0hST01FX0FUVFJJQlVURVM6IFwibWVkaWFjaHJvbWVhdHRyaWJ1dGVzXCIsXG4gIE1FRElBX0NPTlRST0xMRVI6IFwibWVkaWFjb250cm9sbGVyXCJcbn07XG5jb25zdCBNZWRpYVVJUHJvcHMgPSB7XG4gIE1FRElBX0FJUlBMQVlfVU5BVkFJTEFCTEU6IFwibWVkaWFBaXJwbGF5VW5hdmFpbGFibGVcIixcbiAgTUVESUFfRlVMTFNDUkVFTl9VTkFWQUlMQUJMRTogXCJtZWRpYUZ1bGxzY3JlZW5VbmF2YWlsYWJsZVwiLFxuICBNRURJQV9QSVBfVU5BVkFJTEFCTEU6IFwibWVkaWFQaXBVbmF2YWlsYWJsZVwiLFxuICBNRURJQV9DQVNUX1VOQVZBSUxBQkxFOiBcIm1lZGlhQ2FzdFVuYXZhaWxhYmxlXCIsXG4gIE1FRElBX1BBVVNFRDogXCJtZWRpYVBhdXNlZFwiLFxuICBNRURJQV9IQVNfUExBWUVEOiBcIm1lZGlhSGFzUGxheWVkXCIsXG4gIE1FRElBX0VOREVEOiBcIm1lZGlhRW5kZWRcIixcbiAgTUVESUFfTVVURUQ6IFwibWVkaWFNdXRlZFwiLFxuICBNRURJQV9WT0xVTUVfTEVWRUw6IFwibWVkaWFWb2x1bWVMZXZlbFwiLFxuICBNRURJQV9WT0xVTUU6IFwibWVkaWFWb2x1bWVcIixcbiAgTUVESUFfVk9MVU1FX1VOQVZBSUxBQkxFOiBcIm1lZGlhVm9sdW1lVW5hdmFpbGFibGVcIixcbiAgTUVESUFfSVNfUElQOiBcIm1lZGlhSXNQaXBcIixcbiAgTUVESUFfSVNfQ0FTVElORzogXCJtZWRpYUlzQ2FzdGluZ1wiLFxuICBNRURJQV9TVUJUSVRMRVNfTElTVDogXCJtZWRpYVN1YnRpdGxlc0xpc3RcIixcbiAgTUVESUFfU1VCVElUTEVTX1NIT1dJTkc6IFwibWVkaWFTdWJ0aXRsZXNTaG93aW5nXCIsXG4gIE1FRElBX0lTX0ZVTExTQ1JFRU46IFwibWVkaWFJc0Z1bGxzY3JlZW5cIixcbiAgTUVESUFfUExBWUJBQ0tfUkFURTogXCJtZWRpYVBsYXliYWNrUmF0ZVwiLFxuICBNRURJQV9DVVJSRU5UX1RJTUU6IFwibWVkaWFDdXJyZW50VGltZVwiLFxuICBNRURJQV9EVVJBVElPTjogXCJtZWRpYUR1cmF0aW9uXCIsXG4gIE1FRElBX1NFRUtBQkxFOiBcIm1lZGlhU2Vla2FibGVcIixcbiAgTUVESUFfUFJFVklFV19USU1FOiBcIm1lZGlhUHJldmlld1RpbWVcIixcbiAgTUVESUFfUFJFVklFV19JTUFHRTogXCJtZWRpYVByZXZpZXdJbWFnZVwiLFxuICBNRURJQV9QUkVWSUVXX0NPT1JEUzogXCJtZWRpYVByZXZpZXdDb29yZHNcIixcbiAgTUVESUFfTE9BRElORzogXCJtZWRpYUxvYWRpbmdcIixcbiAgTUVESUFfQlVGRkVSRUQ6IFwibWVkaWFCdWZmZXJlZFwiLFxuICBNRURJQV9TVFJFQU1fVFlQRTogXCJtZWRpYVN0cmVhbVR5cGVcIixcbiAgTUVESUFfVEFSR0VUX0xJVkVfV0lORE9XOiBcIm1lZGlhVGFyZ2V0TGl2ZVdpbmRvd1wiLFxuICBNRURJQV9USU1FX0lTX0xJVkU6IFwibWVkaWFUaW1lSXNMaXZlXCJcbn07XG5jb25zdCBNZWRpYVVJUHJvcHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoTWVkaWFVSVByb3BzKTtcbmNvbnN0IE1lZGlhVUlBdHRyaWJ1dGVzID0gTWVkaWFVSVByb3BzRW50cmllcy5yZWR1Y2UoKGRpY3RPYmosIFtrZXksIHByb3BOYW1lXSkgPT4ge1xuICBkaWN0T2JqW2tleV0gPSBgJHtwcm9wTmFtZS50b0xvd2VyQ2FzZSgpfWA7XG4gIHJldHVybiBkaWN0T2JqO1xufSwge30pO1xuY29uc3QgTWVkaWFTdGF0ZUNoYW5nZUV2ZW50cyA9IE1lZGlhVUlQcm9wc0VudHJpZXMucmVkdWNlKFxuICAoZGljdE9iaiwgW2tleSwgcHJvcE5hbWVdKSA9PiB7XG4gICAgZGljdE9ialtrZXldID0gYCR7cHJvcE5hbWUudG9Mb3dlckNhc2UoKX1gO1xuICAgIHJldHVybiBkaWN0T2JqO1xuICB9LFxuICB7XG4gICAgVVNFUl9JTkFDVElWRTogXCJ1c2VyaW5hY3RpdmVjaGFuZ2VcIixcbiAgICBCUkVBS1BPSU5UU19DSEFOR0U6IFwiYnJlYWtwb2ludGNoYW5nZVwiXG4gIH1cbik7XG5jb25zdCBTdGF0ZUNoYW5nZUV2ZW50VG9BdHRyaWJ1dGVNYXAgPSBPYmplY3QuZW50cmllcyhcbiAgTWVkaWFTdGF0ZUNoYW5nZUV2ZW50c1xuKS5yZWR1Y2UoXG4gIChtYXBPYmosIFtrZXksIGV2ZW50VHlwZV0pID0+IHtcbiAgICBjb25zdCBhdHRyTmFtZSA9IE1lZGlhVUlBdHRyaWJ1dGVzW2tleV07XG4gICAgaWYgKGF0dHJOYW1lKSB7XG4gICAgICBtYXBPYmpbZXZlbnRUeXBlXSA9IGF0dHJOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbWFwT2JqO1xuICB9LFxuICB7IHVzZXJpbmFjdGl2ZWNoYW5nZTogXCJ1c2VyaW5hY3RpdmVcIiB9XG4pO1xuY29uc3QgQXR0cmlidXRlVG9TdGF0ZUNoYW5nZUV2ZW50TWFwID0gT2JqZWN0LmVudHJpZXMoXG4gIE1lZGlhVUlBdHRyaWJ1dGVzXG4pLnJlZHVjZShcbiAgKG1hcE9iaiwgW2tleSwgYXR0ck5hbWVdKSA9PiB7XG4gICAgY29uc3QgZXZ0VHlwZSA9IE1lZGlhU3RhdGVDaGFuZ2VFdmVudHNba2V5XTtcbiAgICBpZiAoZXZ0VHlwZSkge1xuICAgICAgbWFwT2JqW2F0dHJOYW1lXSA9IGV2dFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBtYXBPYmo7XG4gIH0sXG4gIHsgdXNlcmluYWN0aXZlOiBcInVzZXJpbmFjdGl2ZWNoYW5nZVwiIH1cbik7XG5jb25zdCBUZXh0VHJhY2tLaW5kcyA9IHtcbiAgU1VCVElUTEVTOiBcInN1YnRpdGxlc1wiLFxuICBDQVBUSU9OUzogXCJjYXB0aW9uc1wiLFxuICBERVNDUklQVElPTlM6IFwiZGVzY3JpcHRpb25zXCIsXG4gIENIQVBURVJTOiBcImNoYXB0ZXJzXCIsXG4gIE1FVEFEQVRBOiBcIm1ldGFkYXRhXCJcbn07XG5jb25zdCBUZXh0VHJhY2tNb2RlcyA9IHtcbiAgRElTQUJMRUQ6IFwiZGlzYWJsZWRcIixcbiAgSElEREVOOiBcImhpZGRlblwiLFxuICBTSE9XSU5HOiBcInNob3dpbmdcIlxufTtcbmNvbnN0IFJlYWR5U3RhdGVzID0ge1xuICBIQVZFX05PVEhJTkc6IDAsXG4gIEhBVkVfTUVUQURBVEE6IDEsXG4gIEhBVkVfQ1VSUkVOVF9EQVRBOiAyLFxuICBIQVZFX0ZVVFVSRV9EQVRBOiAzLFxuICBIQVZFX0VOT1VHSF9EQVRBOiA0XG59O1xuY29uc3QgUG9pbnRlclR5cGVzID0ge1xuICBNT1VTRTogXCJtb3VzZVwiLFxuICBQRU46IFwicGVuXCIsXG4gIFRPVUNIOiBcInRvdWNoXCJcbn07XG5jb25zdCBBdmFpbGFiaWxpdHlTdGF0ZXMgPSB7XG4gIFVOQVZBSUxBQkxFOiBcInVuYXZhaWxhYmxlXCIsXG4gIFVOU1VQUE9SVEVEOiBcInVuc3VwcG9ydGVkXCJcbn07XG5jb25zdCBTdHJlYW1UeXBlcyA9IHtcbiAgTElWRTogXCJsaXZlXCIsXG4gIE9OX0RFTUFORDogXCJvbi1kZW1hbmRcIixcbiAgVU5LTk9XTjogXCJ1bmtub3duXCJcbn07XG5leHBvcnQge1xuICBBdHRyaWJ1dGVUb1N0YXRlQ2hhbmdlRXZlbnRNYXAsXG4gIEF2YWlsYWJpbGl0eVN0YXRlcyxcbiAgTWVkaWFTdGF0ZUNoYW5nZUV2ZW50cyxcbiAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcyxcbiAgTWVkaWFVSUF0dHJpYnV0ZXMsXG4gIE1lZGlhVUlFdmVudHMsXG4gIE1lZGlhVUlQcm9wcyxcbiAgUG9pbnRlclR5cGVzLFxuICBSZWFkeVN0YXRlcyxcbiAgU3RhdGVDaGFuZ2VFdmVudFRvQXR0cmlidXRlTWFwLFxuICBTdHJlYW1UeXBlcyxcbiAgVGV4dFRyYWNrS2luZHMsXG4gIFRleHRUcmFja01vZGVzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/constants.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/controller.js":
/*!******************************************************!*\
  !*** ./node_modules/media-chrome/dist/controller.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaUIRequestHandlers: function() { return /* binding */ MediaUIRequestHandlers; },\n/* harmony export */   MediaUIStates: function() { return /* binding */ MediaUIStates; },\n/* harmony export */   volumeSupportPromise: function() { return /* binding */ volumeSupportPromise; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/fullscreen-api.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/fullscreen-api.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/platform-tests.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/platform-tests.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_captions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/captions.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/captions.js\");\n\n\n\n\n\n\nlet volumeSupported;\nconst volumeSupportPromise = (0,_utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.hasVolumeSupportAsync)().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst StreamTypeValues = Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes);\nconst getSubtitleTracks = (controller) => {\n  return (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.getTextTracksList)(controller.media, (textTrack) => {\n    return [_constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackKinds.SUBTITLES, _constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackKinds.CAPTIONS].includes(textTrack.kind);\n  }).sort((a, b) => a.kind >= b.kind ? 1 : -1);\n};\nconst getShowingSubtitleTracks = (controller) => {\n  return (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.getTextTracksList)(controller.media, (textTrack) => {\n    return textTrack.mode === _constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackModes.SHOWING && [_constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackKinds.SUBTITLES, _constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackKinds.CAPTIONS].includes(textTrack.kind);\n  });\n};\nconst MediaUIStates = {\n  MEDIA_PAUSED: {\n    get: function(controller) {\n      const { media } = controller;\n      return media ? media.paused : true;\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  MEDIA_HAS_PLAYED: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media)\n        return false;\n      return !media.paused;\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  MEDIA_ENDED: {\n    get: function(controller) {\n      const { media } = controller;\n      return media ? media.ended : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  MEDIA_PLAYBACK_RATE: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media || typeof media.playbackRate == \"undefined\") {\n        return 1;\n      }\n      return media.playbackRate;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  MEDIA_MUTED: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media || typeof media.muted == \"undefined\") {\n        return false;\n      }\n      return media.muted;\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  MEDIA_VOLUME: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media || typeof media.volume == \"undefined\") {\n        return 1;\n      }\n      return Number(media.volume);\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  MEDIA_VOLUME_LEVEL: {\n    get: function(controller) {\n      const { media } = controller;\n      let level = \"high\";\n      if (!media || typeof media.volume == \"undefined\") {\n        return level;\n      }\n      const { muted, volume } = media;\n      if (volume === 0 || muted) {\n        level = \"off\";\n      } else if (volume < 0.5) {\n        level = \"low\";\n      } else if (volume < 0.75) {\n        level = \"medium\";\n      }\n      return level;\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  MEDIA_CURRENT_TIME: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media || typeof media.currentTime == \"undefined\") {\n        return 0;\n      }\n      return media.currentTime;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  MEDIA_DURATION: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media || !Number.isFinite(media.duration)) {\n        return NaN;\n      }\n      return media.duration;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  MEDIA_SEEKABLE: {\n    get: function(controller) {\n      var _a;\n      const { media } = controller;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length))\n        return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end)\n        return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\"]\n  },\n  MEDIA_LOADING: {\n    get: function(controller) {\n      var _a;\n      return !!(((_a = controller.media) == null ? void 0 : _a.readyState) < 3);\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  MEDIA_BUFFERED: {\n    get: function(controller) {\n      var _a, _b, _c;\n      const timeRanges = (_a = controller.media) == null ? void 0 : _a.buffered;\n      return Array.from((_c = (_b = controller.media) == null ? void 0 : _b.buffered) != null ? _c : []).map((_, i) => [\n        Number(timeRanges.start(i)).toFixed(3),\n        Number(timeRanges.end(i)).toFixed(3)\n      ]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  MEDIA_STREAM_TYPE: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media)\n        return void 0;\n      const { streamType } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.UNKNOWN) {\n          const defaultType = controller.getAttribute(\"defaultstreamtype\");\n          if ([_constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.LIVE, _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.ON_DEMAND].includes(defaultType)) {\n            return defaultType;\n          }\n          return void 0;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.ON_DEMAND;\n      } else {\n        const defaultType = controller.getAttribute(\"defaultstreamtype\");\n        if ([_constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.LIVE, _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.ON_DEMAND].includes(defaultType)) {\n          return defaultType;\n        }\n      }\n      return void 0;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\"\n    ]\n  },\n  MEDIA_TARGET_LIVE_WINDOW: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media)\n        return Number.NaN;\n      const { targetLiveWindow } = media;\n      const streamType = MediaUIStates.MEDIA_STREAM_TYPE.get(controller);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\",\n      \"targetlivewindowchange\"\n    ]\n  },\n  MEDIA_TIME_IS_LIVE: {\n    get: function(controller) {\n      const { media } = controller;\n      if (!media)\n        return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart))\n          return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = MediaUIStates.MEDIA_STREAM_TYPE.get(controller) === \"live\";\n      if (!live)\n        return false;\n      const seekable = media.seekable;\n      if (!seekable)\n        return true;\n      if (!seekable.length)\n        return false;\n      const liveEdgeStartOffset = controller.hasAttribute(\"liveedgeoffset\") ? Number(controller.getAttribute(\"liveedgeoffset\")) : 10;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeStartOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  MEDIA_IS_FULLSCREEN: {\n    get: function(controller, event) {\n      var _a;\n      const media = controller.media;\n      if (media && _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.element] === void 0 && \"webkitDisplayingFullscreen\" in media) {\n        return media.webkitDisplayingFullscreen && media.webkitPresentationMode === \"fullscreen\";\n      }\n      let fullscreenEl;\n      if (event) {\n        const isSomeElementFullscreen = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.element];\n        fullscreenEl = isSomeElementFullscreen ? event.target : null;\n      } else {\n        fullscreenEl = (_a = controller.getRootNode().fullscreenElement) != null ? _a : _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.element];\n      }\n      return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.containsComposedNode)(controller.fullscreenElement, fullscreenEl);\n    },\n    rootEvents: _utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.rootEvents,\n    mediaEvents: _utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.mediaEvents\n  },\n  MEDIA_IS_PIP: {\n    get: function(controller, e) {\n      var _a;\n      const media = controller.media;\n      if (!media)\n        return false;\n      if (e) {\n        return e.type == \"enterpictureinpicture\";\n      } else {\n        const pipElement = (_a = controller.getRootNode().pictureInPictureElement) != null ? _a : _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.pictureInPictureElement;\n        return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.containsComposedNode)(media, pipElement);\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  MEDIA_IS_CASTING: {\n    get: function(controller, e) {\n      var _a;\n      const { media } = controller;\n      if (!media)\n        return false;\n      const castElement = (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CastableVideoElement) == null ? void 0 : _a.castElement;\n      let castState = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.containsComposedNode)(media, castElement);\n      if ((e == null ? void 0 : e.type) === \"castchange\" && (e == null ? void 0 : e.detail) === \"CONNECTING\") {\n        castState = \"connecting\";\n      }\n      return castState;\n    },\n    mediaEvents: [\"entercast\", \"leavecast\", \"castchange\"]\n  },\n  MEDIA_AIRPLAY_UNAVAILABLE: {\n    get: function(controller, e) {\n      if (!_utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.airplaySupported)\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNSUPPORTED;\n      if (!e)\n        return void 0;\n      if (e.availability === \"available\") {\n        return void 0;\n      } else if (e.availability === \"not-available\") {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNAVAILABLE;\n      }\n    },\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"]\n  },\n  MEDIA_CAST_UNAVAILABLE: {\n    get: function() {\n      var _a;\n      const castState = (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CastableVideoElement) == null ? void 0 : _a.castState;\n      if (!_utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.castSupported || !castState) {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNSUPPORTED;\n      }\n      if (castState.includes(\"CONNECT\")) {\n        return void 0;\n      } else {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNAVAILABLE;\n      }\n    },\n    mediaEvents: [\"castchange\"]\n  },\n  MEDIA_FULLSCREEN_UNAVAILABLE: {\n    get: function() {\n      return _utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.fullscreenSupported ? void 0 : _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNAVAILABLE;\n    }\n  },\n  MEDIA_PIP_UNAVAILABLE: {\n    get: function() {\n      return _utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.pipSupported ? void 0 : _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  MEDIA_VOLUME_UNAVAILABLE: {\n    get: function(controller) {\n      if (volumeSupported !== void 0 && !volumeSupported) {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNSUPPORTED;\n      }\n      const { media } = controller;\n      if (media && typeof media.volume == \"undefined\") {\n        return _constants_js__WEBPACK_IMPORTED_MODULE_4__.AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"loadstart\"]\n  },\n  MEDIA_SUBTITLES_LIST: {\n    get: function(controller) {\n      return getSubtitleTracks(controller).map(({ kind, label, language }) => ({ kind, label, language }));\n    },\n    mediaEvents: [\"loadstart\"],\n    trackListEvents: [\"addtrack\", \"removetrack\"]\n  },\n  MEDIA_SUBTITLES_SHOWING: {\n    get: function(controller) {\n      if (controller.hasAttribute(\"defaultsubtitles\") && !controller.hasAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_HAS_PLAYED) && !controller.hasAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING)) {\n        (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.toggleSubsCaps)(controller, true);\n      }\n      return getShowingSubtitleTracks(controller).map(({ kind, label, language }) => ({ kind, label, language }));\n    },\n    mediaEvents: [\"loadstart\"],\n    trackListEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  }\n};\nconst MediaUIRequestHandlers = {\n  MEDIA_PLAY_REQUEST: (media, e, controller) => {\n    var _a;\n    const streamType = MediaUIStates.MEDIA_STREAM_TYPE.get(controller);\n    const autoSeekToLive = controller.getAttribute(\"noautoseektolive\") === null;\n    if (streamType == _constants_js__WEBPACK_IMPORTED_MODULE_4__.StreamTypes.LIVE && autoSeekToLive) {\n      MediaUIRequestHandlers[\"MEDIA_SEEK_TO_LIVE_REQUEST\"](media);\n    }\n    (_a = media.play()) == null ? void 0 : _a.catch(() => {\n    });\n  },\n  MEDIA_PAUSE_REQUEST: (media) => media.pause(),\n  MEDIA_MUTE_REQUEST: (media) => media.muted = true,\n  MEDIA_UNMUTE_REQUEST: (media) => {\n    media.muted = false;\n    if (media.volume === 0) {\n      media.volume = 0.25;\n    }\n  },\n  MEDIA_VOLUME_REQUEST: (media, e, mediaController) => {\n    const volume = e.detail;\n    media.volume = volume;\n    if (volume > 0 && media.muted) {\n      media.muted = false;\n    }\n    if (!mediaController.hasAttribute(\"novolumepref\")) {\n      try {\n        _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.localStorage.setItem(\n          \"media-chrome-pref-volume\",\n          volume.toString()\n        );\n      } catch (err) {\n      }\n    }\n  },\n  MEDIA_ENTER_FULLSCREEN_REQUEST: (media, e, controller) => {\n    if (!_utils_platform_tests_js__WEBPACK_IMPORTED_MODULE_3__.fullscreenSupported) {\n      console.warn(\n        \"Fullscreen support is unavailable; not entering fullscreen\"\n      );\n      return;\n    }\n    if (_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.pictureInPictureElement) {\n      _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.exitPictureInPicture();\n    }\n    if (controller[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.enter]) {\n      controller.fullscreenElement[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.enter]();\n    } else if (media.webkitEnterFullscreen) {\n      media.webkitEnterFullscreen();\n    } else if (media.requestFullscreen) {\n      media.requestFullscreen();\n    } else {\n      console.warn(\"MediaChrome: Fullscreen not supported\");\n    }\n  },\n  MEDIA_EXIT_FULLSCREEN_REQUEST: () => {\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.exit]();\n  },\n  MEDIA_ENTER_PIP_REQUEST: (media) => {\n    if (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.pictureInPictureEnabled) {\n      console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n      return;\n    }\n    if (!media.requestPictureInPicture) {\n      console.warn(\n        \"MediaChrome: The current media does not support picture-in-picture\"\n      );\n      return;\n    }\n    if (_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.element]) {\n      _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.exit]();\n    }\n    const warnNotReady = () => {\n      console.warn(\n        \"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\"\n      );\n    };\n    media.requestPictureInPicture().catch((err) => {\n      if (err.code === 11) {\n        if (media.readyState === 0 && media.preload === \"none\") {\n          const cleanup = () => {\n            media.removeEventListener(\"loadedmetadata\", tryPip);\n            media.preload = \"none\";\n          };\n          const tryPip = () => {\n            media.requestPictureInPicture().catch(warnNotReady);\n            cleanup();\n          };\n          media.addEventListener(\"loadedmetadata\", tryPip);\n          media.preload = \"metadata\";\n          setTimeout(() => {\n            if (media.readyState === 0)\n              warnNotReady();\n            cleanup();\n          }, 1e3);\n        } else {\n          throw err;\n        }\n      } else {\n        throw err;\n      }\n    });\n  },\n  MEDIA_EXIT_PIP_REQUEST: () => {\n    if (_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.pictureInPictureElement) {\n      _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.exitPictureInPicture();\n    }\n  },\n  MEDIA_ENTER_CAST_REQUEST: (media) => {\n    var _a;\n    if (!((_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CastableVideoElement) == null ? void 0 : _a.castEnabled))\n      return;\n    if (_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.element]) {\n      _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_utils_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_1__.fullscreenApi.exit]();\n    }\n    media.requestCast();\n  },\n  MEDIA_EXIT_CAST_REQUEST: async () => {\n    var _a;\n    if ((_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CastableVideoElement) == null ? void 0 : _a.castElement) {\n      _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CastableVideoElement.exitCast();\n    }\n  },\n  MEDIA_SEEK_REQUEST: (media, e) => {\n    const time = e.detail;\n    if (media.readyState > 0 || media.readyState === void 0) {\n      media.currentTime = time;\n    }\n  },\n  MEDIA_PLAYBACK_RATE_REQUEST: (media, e) => {\n    media.playbackRate = e.detail;\n  },\n  MEDIA_PREVIEW_REQUEST: (media, e, controller) => {\n    var _a;\n    if (!media)\n      return;\n    const time = e.detail;\n    if (time === null) {\n      controller.propagateMediaState(\n        _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_TIME,\n        void 0\n      );\n    }\n    controller.propagateMediaState(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_TIME, time);\n    const [track] = (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.getTextTracksList)(media, {\n      kind: _constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackKinds.METADATA,\n      label: \"thumbnails\"\n    });\n    if (!(track && track.cues))\n      return;\n    if (time === null) {\n      controller.propagateMediaState(\n        _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n        void 0\n      );\n      controller.propagateMediaState(\n        _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_COORDS,\n        void 0\n      );\n      return;\n    }\n    const cue = Array.prototype.find.call(\n      track.cues,\n      (c) => c.startTime >= time\n    );\n    if (!cue)\n      return;\n    const base = !/'^(?:[a-z]+:)?\\/\\//i.test(cue.text) ? (_a = media.querySelector('track[label=\"thumbnails\"]')) == null ? void 0 : _a.src : void 0;\n    const url = new URL(cue.text, base);\n    const previewCoordsStr = new URLSearchParams(url.hash).get(\"#xywh\");\n    controller.propagateMediaState(\n      _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n      url.href\n    );\n    controller.propagateMediaState(\n      _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_PREVIEW_COORDS,\n      previewCoordsStr.split(\",\")\n    );\n  },\n  MEDIA_SHOW_SUBTITLES_REQUEST: (media, e, controller) => {\n    const tracks = getSubtitleTracks(controller);\n    const { detail: tracksToUpdate = [] } = e;\n    (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.updateTracksModeTo)(_constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackModes.SHOWING, tracks, tracksToUpdate);\n  },\n  MEDIA_DISABLE_SUBTITLES_REQUEST: (media, e, controller) => {\n    const tracks = getSubtitleTracks(controller);\n    const { detail: tracksToUpdate = [] } = e;\n    (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_5__.updateTracksModeTo)(_constants_js__WEBPACK_IMPORTED_MODULE_4__.TextTrackModes.DISABLED, tracks, tracksToUpdate);\n  },\n  MEDIA_AIRPLAY_REQUEST: (media) => {\n    if (!media)\n      return;\n    if (!(media.webkitShowPlaybackTargetPicker && _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n      console.warn(\n        \"received a request to select AirPlay but AirPlay is not supported in this environment\"\n      );\n      return;\n    }\n    media.webkitShowPlaybackTargetPicker();\n  },\n  MEDIA_SEEK_TO_LIVE_REQUEST: (media) => {\n    const seekable = media.seekable;\n    if (!seekable) {\n      console.warn(\n        \"MediaController: Media element does not support seeking to live.\"\n      );\n      return;\n    }\n    if (!seekable.length) {\n      console.warn(\"MediaController: Media is unable to seek to live.\");\n      return;\n    }\n    media.currentTime = seekable.end(seekable.length - 1);\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2NvbnRyb2xsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNFO0FBQ1o7QUFDTTtBQU83QjtBQU9YO0FBS0s7QUFDN0I7QUFDQSw2QkFBNkIsK0VBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLHNEQUFXO0FBQ2xEO0FBQ0EsU0FBUyxxRUFBaUI7QUFDMUIsWUFBWSx5REFBYyxZQUFZLHlEQUFjO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxxRUFBaUI7QUFDMUIsOEJBQThCLHlEQUFjLGFBQWEseURBQWMsWUFBWSx5REFBYztBQUNqRyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBLDJCQUEyQixzREFBVztBQUN0QztBQUNBLGVBQWUsc0RBQVcsT0FBTyxzREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQixRQUFRO0FBQ1IsZUFBZSxzREFBVztBQUMxQixRQUFRO0FBQ1I7QUFDQSxhQUFhLHNEQUFXLE9BQU8sc0RBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EseUZBQXlGLHNEQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBUSxDQUFDLG1FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1FQUFRLENBQUMsbUVBQWE7QUFDOUQ7QUFDQSxRQUFRO0FBQ1Isd0ZBQXdGLG1FQUFRLENBQUMsbUVBQWE7QUFDOUc7QUFDQSxhQUFhLDZFQUFvQjtBQUNqQyxLQUFLO0FBQ0wsZ0JBQWdCLG1FQUFhO0FBQzdCLGlCQUFpQixtRUFBYTtBQUM5QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrR0FBa0csbUVBQVE7QUFDMUcsZUFBZSw2RUFBb0I7QUFDbkM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0MscUVBQVU7QUFDMUMsc0JBQXNCLDZFQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxzRUFBZ0I7QUFDM0IsZUFBZSw2REFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSw2REFBa0I7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFVO0FBQ3hDLFdBQVcsbUVBQWE7QUFDeEIsZUFBZSw2REFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGVBQWUsNkRBQWtCO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLHlFQUFtQixZQUFZLDZEQUFrQjtBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxrRUFBWSxZQUFZLDZEQUFrQjtBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFrQjtBQUNqQztBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGVBQWUsNkRBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUIsUUFBUSx1QkFBdUI7QUFDeEcsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtGQUFrRiw0REFBaUIsK0NBQStDLDREQUFpQjtBQUNuSyxRQUFRLGtFQUFjO0FBQ3RCO0FBQ0EseURBQXlELHVCQUF1QixRQUFRLHVCQUF1QjtBQUMvRyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxTQUFTLHlFQUFtQjtBQUM1QjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFRO0FBQ2hCLE1BQU0sbUVBQVE7QUFDZDtBQUNBLG1CQUFtQixtRUFBYTtBQUNoQyxtQ0FBbUMsbUVBQWE7QUFDaEQsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLG1FQUFRLENBQUMsbUVBQWE7QUFDMUIsR0FBRztBQUNIO0FBQ0EsU0FBUyxtRUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFRLENBQUMsbUVBQWE7QUFDOUIsTUFBTSxtRUFBUSxDQUFDLG1FQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxRQUFRLG1FQUFRO0FBQ2hCLE1BQU0sbUVBQVE7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFVO0FBQzFCO0FBQ0EsUUFBUSxtRUFBUSxDQUFDLG1FQUFhO0FBQzlCLE1BQU0sbUVBQVEsQ0FBQyxtRUFBYTtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLHFFQUFVO0FBQ3hCLE1BQU0scUVBQVU7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFpQjtBQUNwRCxvQkFBb0IscUVBQWlCO0FBQ3JDLFlBQVkseURBQWM7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsSUFBSSxzRUFBa0IsQ0FBQyx5REFBYztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDLElBQUksc0VBQWtCLENBQUMseURBQWM7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxRUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2NvbnRyb2xsZXIuanM/Y2YxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IGZ1bGxzY3JlZW5BcGkgfSBmcm9tIFwiLi91dGlscy9mdWxsc2NyZWVuLWFwaS5qc1wiO1xuaW1wb3J0IHsgY29udGFpbnNDb21wb3NlZE5vZGUgfSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5pbXBvcnQge1xuICBoYXNWb2x1bWVTdXBwb3J0QXN5bmMsXG4gIGZ1bGxzY3JlZW5TdXBwb3J0ZWQsXG4gIHBpcFN1cHBvcnRlZCxcbiAgYWlycGxheVN1cHBvcnRlZCxcbiAgY2FzdFN1cHBvcnRlZFxufSBmcm9tIFwiLi91dGlscy9wbGF0Zm9ybS10ZXN0cy5qc1wiO1xuaW1wb3J0IHtcbiAgTWVkaWFVSUF0dHJpYnV0ZXMsXG4gIFRleHRUcmFja0tpbmRzLFxuICBUZXh0VHJhY2tNb2RlcyxcbiAgQXZhaWxhYmlsaXR5U3RhdGVzLFxuICBTdHJlYW1UeXBlc1xufSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7XG4gIGdldFRleHRUcmFja3NMaXN0LFxuICB1cGRhdGVUcmFja3NNb2RlVG8sXG4gIHRvZ2dsZVN1YnNDYXBzXG59IGZyb20gXCIuL3V0aWxzL2NhcHRpb25zLmpzXCI7XG5sZXQgdm9sdW1lU3VwcG9ydGVkO1xuY29uc3Qgdm9sdW1lU3VwcG9ydFByb21pc2UgPSBoYXNWb2x1bWVTdXBwb3J0QXN5bmMoKS50aGVuKChzdXBwb3J0ZWQpID0+IHtcbiAgdm9sdW1lU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICByZXR1cm4gdm9sdW1lU3VwcG9ydGVkO1xufSk7XG5jb25zdCBTdHJlYW1UeXBlVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhTdHJlYW1UeXBlcyk7XG5jb25zdCBnZXRTdWJ0aXRsZVRyYWNrcyA9IChjb250cm9sbGVyKSA9PiB7XG4gIHJldHVybiBnZXRUZXh0VHJhY2tzTGlzdChjb250cm9sbGVyLm1lZGlhLCAodGV4dFRyYWNrKSA9PiB7XG4gICAgcmV0dXJuIFtUZXh0VHJhY2tLaW5kcy5TVUJUSVRMRVMsIFRleHRUcmFja0tpbmRzLkNBUFRJT05TXS5pbmNsdWRlcyh0ZXh0VHJhY2sua2luZCk7XG4gIH0pLnNvcnQoKGEsIGIpID0+IGEua2luZCA+PSBiLmtpbmQgPyAxIDogLTEpO1xufTtcbmNvbnN0IGdldFNob3dpbmdTdWJ0aXRsZVRyYWNrcyA9IChjb250cm9sbGVyKSA9PiB7XG4gIHJldHVybiBnZXRUZXh0VHJhY2tzTGlzdChjb250cm9sbGVyLm1lZGlhLCAodGV4dFRyYWNrKSA9PiB7XG4gICAgcmV0dXJuIHRleHRUcmFjay5tb2RlID09PSBUZXh0VHJhY2tNb2Rlcy5TSE9XSU5HICYmIFtUZXh0VHJhY2tLaW5kcy5TVUJUSVRMRVMsIFRleHRUcmFja0tpbmRzLkNBUFRJT05TXS5pbmNsdWRlcyh0ZXh0VHJhY2sua2luZCk7XG4gIH0pO1xufTtcbmNvbnN0IE1lZGlhVUlTdGF0ZXMgPSB7XG4gIE1FRElBX1BBVVNFRDoge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBtZWRpYSB9ID0gY29udHJvbGxlcjtcbiAgICAgIHJldHVybiBtZWRpYSA/IG1lZGlhLnBhdXNlZCA6IHRydWU7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wicGxheVwiLCBcInBsYXlpbmdcIiwgXCJwYXVzZVwiLCBcImVtcHRpZWRcIl1cbiAgfSxcbiAgTUVESUFfSEFTX1BMQVlFRDoge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBtZWRpYSB9ID0gY29udHJvbGxlcjtcbiAgICAgIGlmICghbWVkaWEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAhbWVkaWEucGF1c2VkO1xuICAgIH0sXG4gICAgbWVkaWFFdmVudHM6IFtcInBsYXlpbmdcIiwgXCJlbXB0aWVkXCJdXG4gIH0sXG4gIE1FRElBX0VOREVEOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IG1lZGlhIH0gPSBjb250cm9sbGVyO1xuICAgICAgcmV0dXJuIG1lZGlhID8gbWVkaWEuZW5kZWQgOiBmYWxzZTtcbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJzZWVrZWRcIiwgXCJlbmRlZFwiLCBcImVtcHRpZWRcIl1cbiAgfSxcbiAgTUVESUFfUExBWUJBQ0tfUkFURToge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBtZWRpYSB9ID0gY29udHJvbGxlcjtcbiAgICAgIGlmICghbWVkaWEgfHwgdHlwZW9mIG1lZGlhLnBsYXliYWNrUmF0ZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lZGlhLnBsYXliYWNrUmF0ZTtcbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJyYXRlY2hhbmdlXCIsIFwibG9hZHN0YXJ0XCJdXG4gIH0sXG4gIE1FRElBX01VVEVEOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IG1lZGlhIH0gPSBjb250cm9sbGVyO1xuICAgICAgaWYgKCFtZWRpYSB8fCB0eXBlb2YgbWVkaWEubXV0ZWQgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVkaWEubXV0ZWQ7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1widm9sdW1lY2hhbmdlXCJdXG4gIH0sXG4gIE1FRElBX1ZPTFVNRToge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBtZWRpYSB9ID0gY29udHJvbGxlcjtcbiAgICAgIGlmICghbWVkaWEgfHwgdHlwZW9mIG1lZGlhLnZvbHVtZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE51bWJlcihtZWRpYS52b2x1bWUpO1xuICAgIH0sXG4gICAgbWVkaWFFdmVudHM6IFtcInZvbHVtZWNoYW5nZVwiXVxuICB9LFxuICBNRURJQV9WT0xVTUVfTEVWRUw6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWVkaWEgfSA9IGNvbnRyb2xsZXI7XG4gICAgICBsZXQgbGV2ZWwgPSBcImhpZ2hcIjtcbiAgICAgIGlmICghbWVkaWEgfHwgdHlwZW9mIG1lZGlhLnZvbHVtZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbXV0ZWQsIHZvbHVtZSB9ID0gbWVkaWE7XG4gICAgICBpZiAodm9sdW1lID09PSAwIHx8IG11dGVkKSB7XG4gICAgICAgIGxldmVsID0gXCJvZmZcIjtcbiAgICAgIH0gZWxzZSBpZiAodm9sdW1lIDwgMC41KSB7XG4gICAgICAgIGxldmVsID0gXCJsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAodm9sdW1lIDwgMC43NSkge1xuICAgICAgICBsZXZlbCA9IFwibWVkaXVtXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1widm9sdW1lY2hhbmdlXCJdXG4gIH0sXG4gIE1FRElBX0NVUlJFTlRfVElNRToge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBtZWRpYSB9ID0gY29udHJvbGxlcjtcbiAgICAgIGlmICghbWVkaWEgfHwgdHlwZW9mIG1lZGlhLmN1cnJlbnRUaW1lID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1widGltZXVwZGF0ZVwiLCBcImxvYWRlZG1ldGFkYXRhXCJdXG4gIH0sXG4gIE1FRElBX0RVUkFUSU9OOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IG1lZGlhIH0gPSBjb250cm9sbGVyO1xuICAgICAgaWYgKCFtZWRpYSB8fCAhTnVtYmVyLmlzRmluaXRlKG1lZGlhLmR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lZGlhLmR1cmF0aW9uO1xuICAgIH0sXG4gICAgbWVkaWFFdmVudHM6IFtcImR1cmF0aW9uY2hhbmdlXCIsIFwibG9hZGVkbWV0YWRhdGFcIiwgXCJlbXB0aWVkXCJdXG4gIH0sXG4gIE1FRElBX1NFRUtBQkxFOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IG1lZGlhIH0gPSBjb250cm9sbGVyO1xuICAgICAgaWYgKCEoKF9hID0gbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNlZWthYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbWVkaWEuc2Vla2FibGUuc3RhcnQoMCk7XG4gICAgICBjb25zdCBlbmQgPSBtZWRpYS5zZWVrYWJsZS5lbmQobWVkaWEuc2Vla2FibGUubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoIXN0YXJ0ICYmICFlbmQpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICByZXR1cm4gW051bWJlcihzdGFydC50b0ZpeGVkKDMpKSwgTnVtYmVyKGVuZC50b0ZpeGVkKDMpKV07XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wibG9hZGVkbWV0YWRhdGFcIiwgXCJlbXB0aWVkXCIsIFwicHJvZ3Jlc3NcIl1cbiAgfSxcbiAgTUVESUFfTE9BRElORzoge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuICEhKCgoX2EgPSBjb250cm9sbGVyLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPCAzKTtcbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJ3YWl0aW5nXCIsIFwicGxheWluZ1wiLCBcImVtcHRpZWRcIl1cbiAgfSxcbiAgTUVESUFfQlVGRkVSRUQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3QgdGltZVJhbmdlcyA9IChfYSA9IGNvbnRyb2xsZXIubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWZmZXJlZDtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKChfYyA9IChfYiA9IGNvbnRyb2xsZXIubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5idWZmZXJlZCkgIT0gbnVsbCA/IF9jIDogW10pLm1hcCgoXywgaSkgPT4gW1xuICAgICAgICBOdW1iZXIodGltZVJhbmdlcy5zdGFydChpKSkudG9GaXhlZCgzKSxcbiAgICAgICAgTnVtYmVyKHRpbWVSYW5nZXMuZW5kKGkpKS50b0ZpeGVkKDMpXG4gICAgICBdKTtcbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJwcm9ncmVzc1wiLCBcImVtcHRpZWRcIl1cbiAgfSxcbiAgTUVESUFfU1RSRUFNX1RZUEU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWVkaWEgfSA9IGNvbnRyb2xsZXI7XG4gICAgICBpZiAoIW1lZGlhKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgY29uc3QgeyBzdHJlYW1UeXBlIH0gPSBtZWRpYTtcbiAgICAgIGlmIChTdHJlYW1UeXBlVmFsdWVzLmluY2x1ZGVzKHN0cmVhbVR5cGUpKSB7XG4gICAgICAgIGlmIChzdHJlYW1UeXBlID09PSBTdHJlYW1UeXBlcy5VTktOT1dOKSB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdFR5cGUgPSBjb250cm9sbGVyLmdldEF0dHJpYnV0ZShcImRlZmF1bHRzdHJlYW10eXBlXCIpO1xuICAgICAgICAgIGlmIChbU3RyZWFtVHlwZXMuTElWRSwgU3RyZWFtVHlwZXMuT05fREVNQU5EXS5pbmNsdWRlcyhkZWZhdWx0VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtVHlwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgICBpZiAoZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBTdHJlYW1UeXBlcy5MSVZFO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBTdHJlYW1UeXBlcy5PTl9ERU1BTkQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGNvbnRyb2xsZXIuZ2V0QXR0cmlidXRlKFwiZGVmYXVsdHN0cmVhbXR5cGVcIik7XG4gICAgICAgIGlmIChbU3RyZWFtVHlwZXMuTElWRSwgU3RyZWFtVHlwZXMuT05fREVNQU5EXS5pbmNsdWRlcyhkZWZhdWx0VHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1xuICAgICAgXCJlbXB0aWVkXCIsXG4gICAgICBcImR1cmF0aW9uY2hhbmdlXCIsXG4gICAgICBcImxvYWRlZG1ldGFkYXRhXCIsXG4gICAgICBcInN0cmVhbXR5cGVjaGFuZ2VcIlxuICAgIF1cbiAgfSxcbiAgTUVESUFfVEFSR0VUX0xJVkVfV0lORE9XOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IG1lZGlhIH0gPSBjb250cm9sbGVyO1xuICAgICAgaWYgKCFtZWRpYSlcbiAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICBjb25zdCB7IHRhcmdldExpdmVXaW5kb3cgfSA9IG1lZGlhO1xuICAgICAgY29uc3Qgc3RyZWFtVHlwZSA9IE1lZGlhVUlTdGF0ZXMuTUVESUFfU1RSRUFNX1RZUEUuZ2V0KGNvbnRyb2xsZXIpO1xuICAgICAgaWYgKCh0YXJnZXRMaXZlV2luZG93ID09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHRhcmdldExpdmVXaW5kb3cpKSAmJiBzdHJlYW1UeXBlID09PSBTdHJlYW1UeXBlcy5MSVZFKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldExpdmVXaW5kb3c7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1xuICAgICAgXCJlbXB0aWVkXCIsXG4gICAgICBcImR1cmF0aW9uY2hhbmdlXCIsXG4gICAgICBcImxvYWRlZG1ldGFkYXRhXCIsXG4gICAgICBcInN0cmVhbXR5cGVjaGFuZ2VcIixcbiAgICAgIFwidGFyZ2V0bGl2ZXdpbmRvd2NoYW5nZVwiXG4gICAgXVxuICB9LFxuICBNRURJQV9USU1FX0lTX0xJVkU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWVkaWEgfSA9IGNvbnRyb2xsZXI7XG4gICAgICBpZiAoIW1lZGlhKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIG1lZGlhLmxpdmVFZGdlU3RhcnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtZWRpYS5saXZlRWRnZVN0YXJ0KSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBtZWRpYS5jdXJyZW50VGltZSA+PSBtZWRpYS5saXZlRWRnZVN0YXJ0O1xuICAgICAgfVxuICAgICAgY29uc3QgbGl2ZSA9IE1lZGlhVUlTdGF0ZXMuTUVESUFfU1RSRUFNX1RZUEUuZ2V0KGNvbnRyb2xsZXIpID09PSBcImxpdmVcIjtcbiAgICAgIGlmICghbGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3Qgc2Vla2FibGUgPSBtZWRpYS5zZWVrYWJsZTtcbiAgICAgIGlmICghc2Vla2FibGUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCFzZWVrYWJsZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IGxpdmVFZGdlU3RhcnRPZmZzZXQgPSBjb250cm9sbGVyLmhhc0F0dHJpYnV0ZShcImxpdmVlZGdlb2Zmc2V0XCIpID8gTnVtYmVyKGNvbnRyb2xsZXIuZ2V0QXR0cmlidXRlKFwibGl2ZWVkZ2VvZmZzZXRcIikpIDogMTA7XG4gICAgICBjb25zdCBsaXZlRWRnZVN0YXJ0ID0gc2Vla2FibGUuZW5kKHNlZWthYmxlLmxlbmd0aCAtIDEpIC0gbGl2ZUVkZ2VTdGFydE9mZnNldDtcbiAgICAgIHJldHVybiBtZWRpYS5jdXJyZW50VGltZSA+PSBsaXZlRWRnZVN0YXJ0O1xuICAgIH0sXG4gICAgbWVkaWFFdmVudHM6IFtcInBsYXlpbmdcIiwgXCJ0aW1ldXBkYXRlXCIsIFwicHJvZ3Jlc3NcIiwgXCJ3YWl0aW5nXCIsIFwiZW1wdGllZFwiXVxuICB9LFxuICBNRURJQV9JU19GVUxMU0NSRUVOOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyLCBldmVudCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbWVkaWEgPSBjb250cm9sbGVyLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIGRvY3VtZW50W2Z1bGxzY3JlZW5BcGkuZWxlbWVudF0gPT09IHZvaWQgMCAmJiBcIndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuXCIgaW4gbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG1lZGlhLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuICYmIG1lZGlhLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgPT09IFwiZnVsbHNjcmVlblwiO1xuICAgICAgfVxuICAgICAgbGV0IGZ1bGxzY3JlZW5FbDtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBjb25zdCBpc1NvbWVFbGVtZW50RnVsbHNjcmVlbiA9IGRvY3VtZW50W2Z1bGxzY3JlZW5BcGkuZWxlbWVudF07XG4gICAgICAgIGZ1bGxzY3JlZW5FbCA9IGlzU29tZUVsZW1lbnRGdWxsc2NyZWVuID8gZXZlbnQudGFyZ2V0IDogbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGxzY3JlZW5FbCA9IChfYSA9IGNvbnRyb2xsZXIuZ2V0Um9vdE5vZGUoKS5mdWxsc2NyZWVuRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZG9jdW1lbnRbZnVsbHNjcmVlbkFwaS5lbGVtZW50XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluc0NvbXBvc2VkTm9kZShjb250cm9sbGVyLmZ1bGxzY3JlZW5FbGVtZW50LCBmdWxsc2NyZWVuRWwpO1xuICAgIH0sXG4gICAgcm9vdEV2ZW50czogZnVsbHNjcmVlbkFwaS5yb290RXZlbnRzLFxuICAgIG1lZGlhRXZlbnRzOiBmdWxsc2NyZWVuQXBpLm1lZGlhRXZlbnRzXG4gIH0sXG4gIE1FRElBX0lTX1BJUDoge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlciwgZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbWVkaWEgPSBjb250cm9sbGVyLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZSA9PSBcImVudGVycGljdHVyZWlucGljdHVyZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGlwRWxlbWVudCA9IChfYSA9IGNvbnRyb2xsZXIuZ2V0Um9vdE5vZGUoKS5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBjb250YWluc0NvbXBvc2VkTm9kZShtZWRpYSwgcGlwRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wiZW50ZXJwaWN0dXJlaW5waWN0dXJlXCIsIFwibGVhdmVwaWN0dXJlaW5waWN0dXJlXCJdXG4gIH0sXG4gIE1FRElBX0lTX0NBU1RJTkc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIGUpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbWVkaWEgfSA9IGNvbnRyb2xsZXI7XG4gICAgICBpZiAoIW1lZGlhKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBjYXN0RWxlbWVudCA9IChfYSA9IGdsb2JhbFRoaXMuQ2FzdGFibGVWaWRlb0VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXN0RWxlbWVudDtcbiAgICAgIGxldCBjYXN0U3RhdGUgPSBjb250YWluc0NvbXBvc2VkTm9kZShtZWRpYSwgY2FzdEVsZW1lbnQpO1xuICAgICAgaWYgKChlID09IG51bGwgPyB2b2lkIDAgOiBlLnR5cGUpID09PSBcImNhc3RjaGFuZ2VcIiAmJiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5kZXRhaWwpID09PSBcIkNPTk5FQ1RJTkdcIikge1xuICAgICAgICBjYXN0U3RhdGUgPSBcImNvbm5lY3RpbmdcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXN0U3RhdGU7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wiZW50ZXJjYXN0XCIsIFwibGVhdmVjYXN0XCIsIFwiY2FzdGNoYW5nZVwiXVxuICB9LFxuICBNRURJQV9BSVJQTEFZX1VOQVZBSUxBQkxFOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyLCBlKSB7XG4gICAgICBpZiAoIWFpcnBsYXlTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBBdmFpbGFiaWxpdHlTdGF0ZXMuVU5TVVBQT1JURUQ7XG4gICAgICBpZiAoIWUpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBpZiAoZS5hdmFpbGFiaWxpdHkgPT09IFwiYXZhaWxhYmxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoZS5hdmFpbGFiaWxpdHkgPT09IFwibm90LWF2YWlsYWJsZVwiKSB7XG4gICAgICAgIHJldHVybiBBdmFpbGFiaWxpdHlTdGF0ZXMuVU5BVkFJTEFCTEU7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wid2Via2l0cGxheWJhY2t0YXJnZXRhdmFpbGFiaWxpdHljaGFuZ2VkXCJdXG4gIH0sXG4gIE1FRElBX0NBU1RfVU5BVkFJTEFCTEU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY2FzdFN0YXRlID0gKF9hID0gZ2xvYmFsVGhpcy5DYXN0YWJsZVZpZGVvRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhc3RTdGF0ZTtcbiAgICAgIGlmICghY2FzdFN1cHBvcnRlZCB8fCAhY2FzdFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBBdmFpbGFiaWxpdHlTdGF0ZXMuVU5TVVBQT1JURUQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFN0YXRlLmluY2x1ZGVzKFwiQ09OTkVDVFwiKSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEF2YWlsYWJpbGl0eVN0YXRlcy5VTkFWQUlMQUJMRTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJjYXN0Y2hhbmdlXCJdXG4gIH0sXG4gIE1FRElBX0ZVTExTQ1JFRU5fVU5BVkFJTEFCTEU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bGxzY3JlZW5TdXBwb3J0ZWQgPyB2b2lkIDAgOiBBdmFpbGFiaWxpdHlTdGF0ZXMuVU5BVkFJTEFCTEU7XG4gICAgfVxuICB9LFxuICBNRURJQV9QSVBfVU5BVkFJTEFCTEU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBpcFN1cHBvcnRlZCA/IHZvaWQgMCA6IEF2YWlsYWJpbGl0eVN0YXRlcy5VTlNVUFBPUlRFRDtcbiAgICB9XG4gIH0sXG4gIE1FRElBX1ZPTFVNRV9VTkFWQUlMQUJMRToge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgaWYgKHZvbHVtZVN1cHBvcnRlZCAhPT0gdm9pZCAwICYmICF2b2x1bWVTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIEF2YWlsYWJpbGl0eVN0YXRlcy5VTlNVUFBPUlRFRDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbWVkaWEgfSA9IGNvbnRyb2xsZXI7XG4gICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLnZvbHVtZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBBdmFpbGFiaWxpdHlTdGF0ZXMuVU5BVkFJTEFCTEU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgbWVkaWFFdmVudHM6IFtcImxvYWRzdGFydFwiXVxuICB9LFxuICBNRURJQV9TVUJUSVRMRVNfTElTVDoge1xuICAgIGdldDogZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIGdldFN1YnRpdGxlVHJhY2tzKGNvbnRyb2xsZXIpLm1hcCgoeyBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UgfSkgPT4gKHsga2luZCwgbGFiZWwsIGxhbmd1YWdlIH0pKTtcbiAgICB9LFxuICAgIG1lZGlhRXZlbnRzOiBbXCJsb2Fkc3RhcnRcIl0sXG4gICAgdHJhY2tMaXN0RXZlbnRzOiBbXCJhZGR0cmFja1wiLCBcInJlbW92ZXRyYWNrXCJdXG4gIH0sXG4gIE1FRElBX1NVQlRJVExFU19TSE9XSU5HOiB7XG4gICAgZ2V0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5oYXNBdHRyaWJ1dGUoXCJkZWZhdWx0c3VidGl0bGVzXCIpICYmICFjb250cm9sbGVyLmhhc0F0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9IQVNfUExBWUVEKSAmJiAhY29udHJvbGxlci5oYXNBdHRyaWJ1dGUoTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX1NIT1dJTkcpKSB7XG4gICAgICAgIHRvZ2dsZVN1YnNDYXBzKGNvbnRyb2xsZXIsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFNob3dpbmdTdWJ0aXRsZVRyYWNrcyhjb250cm9sbGVyKS5tYXAoKHsga2luZCwgbGFiZWwsIGxhbmd1YWdlIH0pID0+ICh7IGtpbmQsIGxhYmVsLCBsYW5ndWFnZSB9KSk7XG4gICAgfSxcbiAgICBtZWRpYUV2ZW50czogW1wibG9hZHN0YXJ0XCJdLFxuICAgIHRyYWNrTGlzdEV2ZW50czogW1wiYWRkdHJhY2tcIiwgXCJyZW1vdmV0cmFja1wiLCBcImNoYW5nZVwiXVxuICB9XG59O1xuY29uc3QgTWVkaWFVSVJlcXVlc3RIYW5kbGVycyA9IHtcbiAgTUVESUFfUExBWV9SRVFVRVNUOiAobWVkaWEsIGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc3RyZWFtVHlwZSA9IE1lZGlhVUlTdGF0ZXMuTUVESUFfU1RSRUFNX1RZUEUuZ2V0KGNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IGF1dG9TZWVrVG9MaXZlID0gY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJub2F1dG9zZWVrdG9saXZlXCIpID09PSBudWxsO1xuICAgIGlmIChzdHJlYW1UeXBlID09IFN0cmVhbVR5cGVzLkxJVkUgJiYgYXV0b1NlZWtUb0xpdmUpIHtcbiAgICAgIE1lZGlhVUlSZXF1ZXN0SGFuZGxlcnNbXCJNRURJQV9TRUVLX1RPX0xJVkVfUkVRVUVTVFwiXShtZWRpYSk7XG4gICAgfVxuICAgIChfYSA9IG1lZGlhLnBsYXkoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgfSxcbiAgTUVESUFfUEFVU0VfUkVRVUVTVDogKG1lZGlhKSA9PiBtZWRpYS5wYXVzZSgpLFxuICBNRURJQV9NVVRFX1JFUVVFU1Q6IChtZWRpYSkgPT4gbWVkaWEubXV0ZWQgPSB0cnVlLFxuICBNRURJQV9VTk1VVEVfUkVRVUVTVDogKG1lZGlhKSA9PiB7XG4gICAgbWVkaWEubXV0ZWQgPSBmYWxzZTtcbiAgICBpZiAobWVkaWEudm9sdW1lID09PSAwKSB7XG4gICAgICBtZWRpYS52b2x1bWUgPSAwLjI1O1xuICAgIH1cbiAgfSxcbiAgTUVESUFfVk9MVU1FX1JFUVVFU1Q6IChtZWRpYSwgZSwgbWVkaWFDb250cm9sbGVyKSA9PiB7XG4gICAgY29uc3Qgdm9sdW1lID0gZS5kZXRhaWw7XG4gICAgbWVkaWEudm9sdW1lID0gdm9sdW1lO1xuICAgIGlmICh2b2x1bWUgPiAwICYmIG1lZGlhLm11dGVkKSB7XG4gICAgICBtZWRpYS5tdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW1lZGlhQ29udHJvbGxlci5oYXNBdHRyaWJ1dGUoXCJub3ZvbHVtZXByZWZcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgXCJtZWRpYS1jaHJvbWUtcHJlZi12b2x1bWVcIixcbiAgICAgICAgICB2b2x1bWUudG9TdHJpbmcoKVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBNRURJQV9FTlRFUl9GVUxMU0NSRUVOX1JFUVVFU1Q6IChtZWRpYSwgZSwgY29udHJvbGxlcikgPT4ge1xuICAgIGlmICghZnVsbHNjcmVlblN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIkZ1bGxzY3JlZW4gc3VwcG9ydCBpcyB1bmF2YWlsYWJsZTsgbm90IGVudGVyaW5nIGZ1bGxzY3JlZW5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50KSB7XG4gICAgICBkb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSgpO1xuICAgIH1cbiAgICBpZiAoY29udHJvbGxlcltmdWxsc2NyZWVuQXBpLmVudGVyXSkge1xuICAgICAgY29udHJvbGxlci5mdWxsc2NyZWVuRWxlbWVudFtmdWxsc2NyZWVuQXBpLmVudGVyXSgpO1xuICAgIH0gZWxzZSBpZiAobWVkaWEud2Via2l0RW50ZXJGdWxsc2NyZWVuKSB7XG4gICAgICBtZWRpYS53ZWJraXRFbnRlckZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBtZWRpYS5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJNZWRpYUNocm9tZTogRnVsbHNjcmVlbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgfSxcbiAgTUVESUFfRVhJVF9GVUxMU0NSRUVOX1JFUVVFU1Q6ICgpID0+IHtcbiAgICBkb2N1bWVudFtmdWxsc2NyZWVuQXBpLmV4aXRdKCk7XG4gIH0sXG4gIE1FRElBX0VOVEVSX1BJUF9SRVFVRVNUOiAobWVkaWEpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbmFibGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJNZWRpYUNocm9tZTogUGljdHVyZS1pbi1waWN0dXJlIGlzIG5vdCBlbmFibGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW1lZGlhLnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiTWVkaWFDaHJvbWU6IFRoZSBjdXJyZW50IG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgcGljdHVyZS1pbi1waWN0dXJlXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb2N1bWVudFtmdWxsc2NyZWVuQXBpLmVsZW1lbnRdKSB7XG4gICAgICBkb2N1bWVudFtmdWxsc2NyZWVuQXBpLmV4aXRdKCk7XG4gICAgfVxuICAgIGNvbnN0IHdhcm5Ob3RSZWFkeSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJNZWRpYUNocm9tZTogVGhlIG1lZGlhIGlzIG5vdCByZWFkeSBmb3IgcGljdHVyZS1pbi1waWN0dXJlLiBJdCBtdXN0IGhhdmUgYSByZWFkeVN0YXRlID4gMC5cIlxuICAgICAgKTtcbiAgICB9O1xuICAgIG1lZGlhLnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAxMSkge1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSA9PT0gMCAmJiBtZWRpYS5wcmVsb2FkID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgdHJ5UGlwKTtcbiAgICAgICAgICAgIG1lZGlhLnByZWxvYWQgPSBcIm5vbmVcIjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHRyeVBpcCA9ICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhLnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKCkuY2F0Y2god2Fybk5vdFJlYWR5KTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCB0cnlQaXApO1xuICAgICAgICAgIG1lZGlhLnByZWxvYWQgPSBcIm1ldGFkYXRhXCI7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSA9PT0gMClcbiAgICAgICAgICAgICAgd2Fybk5vdFJlYWR5KCk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSwgMWUzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgTUVESUFfRVhJVF9QSVBfUkVRVUVTVDogKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCkge1xuICAgICAgZG9jdW1lbnQuZXhpdFBpY3R1cmVJblBpY3R1cmUoKTtcbiAgICB9XG4gIH0sXG4gIE1FRElBX0VOVEVSX0NBU1RfUkVRVUVTVDogKG1lZGlhKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKChfYSA9IGdsb2JhbFRoaXMuQ2FzdGFibGVWaWRlb0VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXN0RW5hYmxlZCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGRvY3VtZW50W2Z1bGxzY3JlZW5BcGkuZWxlbWVudF0pIHtcbiAgICAgIGRvY3VtZW50W2Z1bGxzY3JlZW5BcGkuZXhpdF0oKTtcbiAgICB9XG4gICAgbWVkaWEucmVxdWVzdENhc3QoKTtcbiAgfSxcbiAgTUVESUFfRVhJVF9DQVNUX1JFUVVFU1Q6IGFzeW5jICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKChfYSA9IGdsb2JhbFRoaXMuQ2FzdGFibGVWaWRlb0VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXN0RWxlbWVudCkge1xuICAgICAgZ2xvYmFsVGhpcy5DYXN0YWJsZVZpZGVvRWxlbWVudC5leGl0Q2FzdCgpO1xuICAgIH1cbiAgfSxcbiAgTUVESUFfU0VFS19SRVFVRVNUOiAobWVkaWEsIGUpID0+IHtcbiAgICBjb25zdCB0aW1lID0gZS5kZXRhaWw7XG4gICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUgPiAwIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfSxcbiAgTUVESUFfUExBWUJBQ0tfUkFURV9SRVFVRVNUOiAobWVkaWEsIGUpID0+IHtcbiAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBlLmRldGFpbDtcbiAgfSxcbiAgTUVESUFfUFJFVklFV19SRVFVRVNUOiAobWVkaWEsIGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFtZWRpYSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0aW1lID0gZS5kZXRhaWw7XG4gICAgaWYgKHRpbWUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRyb2xsZXIucHJvcGFnYXRlTWVkaWFTdGF0ZShcbiAgICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19USU1FLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnRyb2xsZXIucHJvcGFnYXRlTWVkaWFTdGF0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX1RJTUUsIHRpbWUpO1xuICAgIGNvbnN0IFt0cmFja10gPSBnZXRUZXh0VHJhY2tzTGlzdChtZWRpYSwge1xuICAgICAga2luZDogVGV4dFRyYWNrS2luZHMuTUVUQURBVEEsXG4gICAgICBsYWJlbDogXCJ0aHVtYm5haWxzXCJcbiAgICB9KTtcbiAgICBpZiAoISh0cmFjayAmJiB0cmFjay5jdWVzKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgY29udHJvbGxlci5wcm9wYWdhdGVNZWRpYVN0YXRlKFxuICAgICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0lNQUdFLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb250cm9sbGVyLnByb3BhZ2F0ZU1lZGlhU3RhdGUoXG4gICAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfQ09PUkRTLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1ZSA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoXG4gICAgICB0cmFjay5jdWVzLFxuICAgICAgKGMpID0+IGMuc3RhcnRUaW1lID49IHRpbWVcbiAgICApO1xuICAgIGlmICghY3VlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJhc2UgPSAhLydeKD86W2Etel0rOik/XFwvXFwvL2kudGVzdChjdWUudGV4dCkgPyAoX2EgPSBtZWRpYS5xdWVyeVNlbGVjdG9yKCd0cmFja1tsYWJlbD1cInRodW1ibmFpbHNcIl0nKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNyYyA6IHZvaWQgMDtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGN1ZS50ZXh0LCBiYXNlKTtcbiAgICBjb25zdCBwcmV2aWV3Q29vcmRzU3RyID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuaGFzaCkuZ2V0KFwiI3h5d2hcIik7XG4gICAgY29udHJvbGxlci5wcm9wYWdhdGVNZWRpYVN0YXRlKFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRSxcbiAgICAgIHVybC5ocmVmXG4gICAgKTtcbiAgICBjb250cm9sbGVyLnByb3BhZ2F0ZU1lZGlhU3RhdGUoXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0NPT1JEUyxcbiAgICAgIHByZXZpZXdDb29yZHNTdHIuc3BsaXQoXCIsXCIpXG4gICAgKTtcbiAgfSxcbiAgTUVESUFfU0hPV19TVUJUSVRMRVNfUkVRVUVTVDogKG1lZGlhLCBlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgY29uc3QgdHJhY2tzID0gZ2V0U3VidGl0bGVUcmFja3MoY29udHJvbGxlcik7XG4gICAgY29uc3QgeyBkZXRhaWw6IHRyYWNrc1RvVXBkYXRlID0gW10gfSA9IGU7XG4gICAgdXBkYXRlVHJhY2tzTW9kZVRvKFRleHRUcmFja01vZGVzLlNIT1dJTkcsIHRyYWNrcywgdHJhY2tzVG9VcGRhdGUpO1xuICB9LFxuICBNRURJQV9ESVNBQkxFX1NVQlRJVExFU19SRVFVRVNUOiAobWVkaWEsIGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICBjb25zdCB0cmFja3MgPSBnZXRTdWJ0aXRsZVRyYWNrcyhjb250cm9sbGVyKTtcbiAgICBjb25zdCB7IGRldGFpbDogdHJhY2tzVG9VcGRhdGUgPSBbXSB9ID0gZTtcbiAgICB1cGRhdGVUcmFja3NNb2RlVG8oVGV4dFRyYWNrTW9kZXMuRElTQUJMRUQsIHRyYWNrcywgdHJhY2tzVG9VcGRhdGUpO1xuICB9LFxuICBNRURJQV9BSVJQTEFZX1JFUVVFU1Q6IChtZWRpYSkgPT4ge1xuICAgIGlmICghbWVkaWEpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCEobWVkaWEud2Via2l0U2hvd1BsYXliYWNrVGFyZ2V0UGlja2VyICYmIGdsb2JhbFRoaXMuV2ViS2l0UGxheWJhY2tUYXJnZXRBdmFpbGFiaWxpdHlFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJyZWNlaXZlZCBhIHJlcXVlc3QgdG8gc2VsZWN0IEFpclBsYXkgYnV0IEFpclBsYXkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lZGlhLndlYmtpdFNob3dQbGF5YmFja1RhcmdldFBpY2tlcigpO1xuICB9LFxuICBNRURJQV9TRUVLX1RPX0xJVkVfUkVRVUVTVDogKG1lZGlhKSA9PiB7XG4gICAgY29uc3Qgc2Vla2FibGUgPSBtZWRpYS5zZWVrYWJsZTtcbiAgICBpZiAoIXNlZWthYmxlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiTWVkaWFDb250cm9sbGVyOiBNZWRpYSBlbGVtZW50IGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZyB0byBsaXZlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNlZWthYmxlLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFwiTWVkaWFDb250cm9sbGVyOiBNZWRpYSBpcyB1bmFibGUgdG8gc2VlayB0byBsaXZlLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVkaWEuY3VycmVudFRpbWUgPSBzZWVrYWJsZS5lbmQoc2Vla2FibGUubGVuZ3RoIC0gMSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBNZWRpYVVJUmVxdWVzdEhhbmRsZXJzLFxuICBNZWRpYVVJU3RhdGVzLFxuICB2b2x1bWVTdXBwb3J0UHJvbWlzZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/controller.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-listbox.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/media-chrome/dist/experimental/media-captions-listbox.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_captions_listbox_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_listbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-listbox.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listbox.js\");\n/* harmony import */ var _media_chrome_listitem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./media-chrome-listitem.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listitem.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_captions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/captions.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/captions.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _subs, _offOption, _captionsIndicator, _perTypeUpdate, perTypeUpdate_fn, _renderTracks, renderTracks_fn, _render, render_fn, _onChange, onChange_fn;\n\n\n\n\n\n\nconst captionsIndicatorInlineStyle = `\n  fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n  height: var(--media-captions-indicator-height, 1em);\n  vertical-align: var(--media-captions-indicator-vertical-align, bottom);\n  margin-inline-start: 1ch;\n`;\nconst ccIcon = `\n<svg style=\"${captionsIndicatorInlineStyle}\" aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n    media-chrome-listitem {\n      white-space: var(--media-captions-listbox-white-space, nowrap);\n    }\n  </style>\n  <slot hidden name=\"captions-indicator\">${ccIcon}</slot>\n`;\nconst compareTracks = (a, b) => {\n  return a.label === b.label && a.language === b.language;\n};\nclass MediaCaptionsListbox extends _media_chrome_listbox_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor() {\n    super({ slotTemplate });\n    __privateAdd(this, _perTypeUpdate);\n    __privateAdd(this, _renderTracks);\n    __privateAdd(this, _render);\n    __privateAdd(this, _onChange);\n    __privateAdd(this, _subs, []);\n    __privateAdd(this, _offOption, void 0);\n    __privateAdd(this, _captionsIndicator, void 0);\n    const offOption = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"media-chrome-listitem\");\n    offOption.part.add(\"listitem\");\n    offOption.value = \"off\";\n    offOption.textContent = \"Off\";\n    __privateSet(this, _offOption, offOption);\n    const captionsIndicatorSlot = this.shadowRoot.querySelector('[name=\"captions-indicator\"]');\n    __privateSet(this, _captionsIndicator, captionsIndicatorSlot.firstElementChild);\n    captionsIndicatorSlot.addEventListener(\"slotchange\", () => {\n      let els = captionsIndicatorSlot.assignedElements();\n      if (els.length === 1 && els[0].nodeName.toLowerCase() === \"slot\") {\n        const assignedElements = els[0].assignedElements();\n        if (assignedElements.length === 0) {\n          __privateSet(this, _captionsIndicator, els[0].firstElementChild);\n        } else if (assignedElements.length === 1) {\n          __privateSet(this, _captionsIndicator, assignedElements[0]);\n        }\n      }\n      if (!__privateGet(this, _captionsIndicator)) {\n        __privateSet(this, _captionsIndicator, captionsIndicatorSlot.firstElementChild);\n      }\n      __privateSet(this, _captionsIndicator, __privateGet(this, _captionsIndicator).cloneNode(true));\n      __privateGet(this, _captionsIndicator).removeAttribute(\"slot\");\n      __privateGet(this, _captionsIndicator).setAttribute(\"style\", captionsIndicatorInlineStyle);\n    });\n  }\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      \"aria-multiselectable\",\n      _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_SUBTITLES_LIST,\n      _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING\n    ];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_SUBTITLES_LIST && oldValue !== newValue) {\n      __privateSet(this, _subs, __privateMethod(this, _perTypeUpdate, perTypeUpdate_fn).call(this, newValue, __privateGet(this, _subs)));\n      __privateMethod(this, _render, render_fn).call(this);\n    } else if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING && oldValue !== newValue) {\n      const selectedTrack = (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.parseTextTracksStr)(newValue != null ? newValue : \"\")[0];\n      __privateGet(this, _subs).forEach((track) => {\n        track.selected = track.language === selectedTrack.language && track.label === selectedTrack.label;\n      });\n      __privateMethod(this, _render, render_fn).call(this);\n    } else if (attrName === \"aria-multiselectable\") {\n      this.removeAttribute(\"aria-multiselectable\");\n      console.warn(\"Captions List doesn't currently support multiple selections. You can enable multiple items via the media.textTrack API.\");\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  connectedCallback() {\n    __privateMethod(this, _render, render_fn).call(this);\n    this.addEventListener(\"change\", __privateMethod(this, _onChange, onChange_fn));\n    super.connectedCallback();\n  }\n  disconnectedCallback() {\n    this.removeEventListener(\"change\", __privateMethod(this, _onChange, onChange_fn));\n    super.disconnectedCallback();\n  }\n}\n_subs = new WeakMap();\n_offOption = new WeakMap();\n_captionsIndicator = new WeakMap();\n_perTypeUpdate = new WeakSet();\nperTypeUpdate_fn = function(newValue, oldItems) {\n  const newItems = newValue ? (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.parseTextTracksStr)(newValue != null ? newValue : \"\") : [];\n  const removedTracks = [];\n  const newTracks = [];\n  oldItems.forEach((track) => {\n    if (!newItems.some((newTrack) => compareTracks(newTrack, track))) {\n      removedTracks.push(track);\n    }\n  });\n  newItems.forEach((track) => {\n    if (!oldItems.some((newTrack) => compareTracks(newTrack, track))) {\n      newTracks.push(track);\n    }\n  });\n  removedTracks.forEach((track) => track.el.remove());\n  return oldItems.filter((track) => !removedTracks.includes(track)).concat(newTracks);\n};\n_renderTracks = new WeakSet();\nrenderTracks_fn = function(tracks) {\n  const container = this.shadowRoot.querySelector(\"ul slot\");\n  tracks.forEach((track) => {\n    var _a;\n    let option = track.el;\n    let alreadyInDom = true;\n    const type = (_a = track.kind) != null ? _a : \"subs\";\n    if (!option) {\n      option = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"media-chrome-listitem\");\n      alreadyInDom = false;\n      option.part.add(\"listitem\");\n      option.value = (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.formatTextTrackObj)(track);\n      const label = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"span\");\n      label.textContent = track.label;\n      option.append(label);\n      if (type === \"captions\") {\n        option.append(__privateGet(this, _captionsIndicator).cloneNode(true));\n      }\n    }\n    if (track.selected) {\n      option.setAttribute(\"aria-selected\", \"true\");\n    } else {\n      option.setAttribute(\"aria-selected\", \"false\");\n    }\n    if (!alreadyInDom) {\n      container.append(option);\n      track.el = option;\n    }\n  });\n};\n_render = new WeakSet();\nrender_fn = function() {\n  const container = this.shadowRoot.querySelector(\"ul slot\");\n  if (!container.contains(__privateGet(this, _offOption))) {\n    container.append(__privateGet(this, _offOption));\n  }\n  if (!this.hasAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING)) {\n    __privateGet(this, _offOption).setAttribute(\"aria-selected\", \"true\");\n    __privateGet(this, _offOption).setAttribute(\"tabindex\", \"0\");\n  } else {\n    __privateGet(this, _offOption).setAttribute(\"aria-selected\", \"false\");\n    __privateGet(this, _offOption).setAttribute(\"tabindex\", \"-1\");\n  }\n  __privateMethod(this, _renderTracks, renderTracks_fn).call(this, __privateGet(this, _subs));\n};\n_onChange = new WeakSet();\nonChange_fn = function() {\n  var _a;\n  const selectedOption = (_a = this.selectedOptions[0]) == null ? void 0 : _a.value;\n  (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.toggleSubsCaps)(this, false);\n  if (!selectedOption)\n    return;\n  const event = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.CustomEvent(\n    _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIEvents.MEDIA_SHOW_SUBTITLES_REQUEST,\n    {\n      composed: true,\n      bubbles: true,\n      detail: selectedOption\n    }\n  );\n  this.dispatchEvent(event);\n};\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-captions-listbox\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-captions-listbox\", MediaCaptionsListbox);\n}\nvar media_captions_listbox_default = MediaCaptionsListbox;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jYXB0aW9ucy1saXN0Ym94LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDdkI7QUFDbUM7QUFDSjtBQUNXO0FBQ3hCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBLHFCQUFxQixtRUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBa0I7QUFDckQ7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUVBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkIsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFpQjtBQUN0QztBQUNBO0FBQ0EsTUFBTSxzQkFBc0IsNERBQWlCO0FBQzdDLDRCQUE0QixzRUFBa0I7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNFQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtRUFBUTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCLHNFQUFrQjtBQUN2QyxvQkFBb0IsbUVBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrRUFBYztBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFVO0FBQzlCLElBQUksd0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9leHBlcmltZW50YWwvbWVkaWEtY2FwdGlvbnMtbGlzdGJveC5qcz8yMzA3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpO1xuICByZXR1cm4gbWV0aG9kO1xufTtcbnZhciBfc3VicywgX29mZk9wdGlvbiwgX2NhcHRpb25zSW5kaWNhdG9yLCBfcGVyVHlwZVVwZGF0ZSwgcGVyVHlwZVVwZGF0ZV9mbiwgX3JlbmRlclRyYWNrcywgcmVuZGVyVHJhY2tzX2ZuLCBfcmVuZGVyLCByZW5kZXJfZm4sIF9vbkNoYW5nZSwgb25DaGFuZ2VfZm47XG5pbXBvcnQgTWVkaWFDaHJvbWVMaXN0Ym94IGZyb20gXCIuL21lZGlhLWNocm9tZS1saXN0Ym94LmpzXCI7XG5pbXBvcnQgXCIuL21lZGlhLWNocm9tZS1saXN0aXRlbS5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUF0dHJpYnV0ZXMsIE1lZGlhVUlFdmVudHMgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVRleHRUcmFja3NTdHIsIGZvcm1hdFRleHRUcmFja09iaiB9IGZyb20gXCIuLi91dGlscy9jYXB0aW9ucy5qc1wiO1xuaW1wb3J0IHsgdG9nZ2xlU3Vic0NhcHMgfSBmcm9tIFwiLi4vdXRpbHMvY2FwdGlvbnMuanNcIjtcbmNvbnN0IGNhcHRpb25zSW5kaWNhdG9ySW5saW5lU3R5bGUgPSBgXG4gIGZpbGw6IHZhcigtLW1lZGlhLWljb24tY29sb3IsIHZhcigtLW1lZGlhLXByaW1hcnktY29sb3IsIHJnYigyMzggMjM4IDIzOCkpKTtcbiAgaGVpZ2h0OiB2YXIoLS1tZWRpYS1jYXB0aW9ucy1pbmRpY2F0b3ItaGVpZ2h0LCAxZW0pO1xuICB2ZXJ0aWNhbC1hbGlnbjogdmFyKC0tbWVkaWEtY2FwdGlvbnMtaW5kaWNhdG9yLXZlcnRpY2FsLWFsaWduLCBib3R0b20pO1xuICBtYXJnaW4taW5saW5lLXN0YXJ0OiAxY2g7XG5gO1xuY29uc3QgY2NJY29uID0gYFxuPHN2ZyBzdHlsZT1cIiR7Y2FwdGlvbnNJbmRpY2F0b3JJbmxpbmVTdHlsZX1cIiBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI2IDI0XCI+XG4gIDxwYXRoIGQ9XCJNMjIuODMgNS42OGEyLjU4IDIuNTggMCAwIDAtMi4zLTIuNWMtMy42Mi0uMjQtMTEuNDQtLjI0LTE1LjA2IDBhMi41OCAyLjU4IDAgMCAwLTIuMyAyLjVjLS4yMyA0LjIxLS4yMyA4LjQzIDAgMTIuNjRhMi41OCAyLjU4IDAgMCAwIDIuMyAyLjVjMy42Mi4yNCAxMS40NC4yNCAxNS4wNiAwYTIuNTggMi41OCAwIDAgMCAyLjMtMi41Yy4yMy00LjIxLjIzLTguNDMgMC0xMi42NFptLTExLjM5IDkuNDVhMy4wNyAzLjA3IDAgMCAxLTEuOTEuNTcgMy4wNiAzLjA2IDAgMCAxLTIuMzQtMSAzLjc1IDMuNzUgMCAwIDEtLjkyLTIuNjcgMy45MiAzLjkyIDAgMCAxIC45Mi0yLjc3IDMuMTggMy4xOCAwIDAgMSAyLjQzLTEgMi45NCAyLjk0IDAgMCAxIDIuMTMuNzhjLjM2NC4zNTkuNjIuODEzLjc0IDEuMzFsLTEuNDMuMzVhMS40OSAxLjQ5IDAgMCAwLTEuNTEtMS4xNyAxLjYxIDEuNjEgMCAwIDAtMS4yOS41OCAyLjc5IDIuNzkgMCAwIDAtLjUgMS44OSAzIDMgMCAwIDAgLjQ5IDEuOTMgMS42MSAxLjYxIDAgMCAwIDEuMjcuNTggMS40OCAxLjQ4IDAgMCAwIDEtLjM3IDIuMSAyLjEgMCAwIDAgLjU5LTEuMTRsMS40LjQ0YTMuMjMgMy4yMyAwIDAgMS0xLjA3IDEuNjlabTcuMjIgMGEzLjA3IDMuMDcgMCAwIDEtMS45MS41NyAzLjA2IDMuMDYgMCAwIDEtMi4zNC0xIDMuNzUgMy43NSAwIDAgMS0uOTItMi42NyAzLjg4IDMuODggMCAwIDEgLjkzLTIuNzcgMy4xNCAzLjE0IDAgMCAxIDIuNDItMSAzIDMgMCAwIDEgMi4xNi44MiAyLjggMi44IDAgMCAxIC43MyAxLjMxbC0xLjQzLjM1YTEuNDkgMS40OSAwIDAgMC0xLjUxLTEuMjEgMS42MSAxLjYxIDAgMCAwLTEuMjkuNThBMi43OSAyLjc5IDAgMCAwIDE1IDEyYTMgMyAwIDAgMCAuNDkgMS45MyAxLjYxIDEuNjEgMCAwIDAgMS4yNy41OCAxLjQ0IDEuNDQgMCAwIDAgMS0uMzcgMi4xIDIuMSAwIDAgMCAuNi0xLjE1bDEuNC40NGEzLjE3IDMuMTcgMCAwIDEtMS4xIDEuN1pcIi8+XG48L3N2Zz5gO1xuY29uc3Qgc2xvdFRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICAgIG1lZGlhLWNocm9tZS1saXN0aXRlbSB7XG4gICAgICB3aGl0ZS1zcGFjZTogdmFyKC0tbWVkaWEtY2FwdGlvbnMtbGlzdGJveC13aGl0ZS1zcGFjZSwgbm93cmFwKTtcbiAgICB9XG4gIDwvc3R5bGU+XG4gIDxzbG90IGhpZGRlbiBuYW1lPVwiY2FwdGlvbnMtaW5kaWNhdG9yXCI+JHtjY0ljb259PC9zbG90PlxuYDtcbmNvbnN0IGNvbXBhcmVUcmFja3MgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS5sYWJlbCA9PT0gYi5sYWJlbCAmJiBhLmxhbmd1YWdlID09PSBiLmxhbmd1YWdlO1xufTtcbmNsYXNzIE1lZGlhQ2FwdGlvbnNMaXN0Ym94IGV4dGVuZHMgTWVkaWFDaHJvbWVMaXN0Ym94IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wZXJUeXBlVXBkYXRlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbmRlclRyYWNrcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZW5kZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25DaGFuZ2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc3VicywgW10pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb2ZmT3B0aW9uLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2FwdGlvbnNJbmRpY2F0b3IsIHZvaWQgMCk7XG4gICAgY29uc3Qgb2ZmT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1lZGlhLWNocm9tZS1saXN0aXRlbVwiKTtcbiAgICBvZmZPcHRpb24ucGFydC5hZGQoXCJsaXN0aXRlbVwiKTtcbiAgICBvZmZPcHRpb24udmFsdWUgPSBcIm9mZlwiO1xuICAgIG9mZk9wdGlvbi50ZXh0Q29udGVudCA9IFwiT2ZmXCI7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9vZmZPcHRpb24sIG9mZk9wdGlvbik7XG4gICAgY29uc3QgY2FwdGlvbnNJbmRpY2F0b3JTbG90ID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwiY2FwdGlvbnMtaW5kaWNhdG9yXCJdJyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jYXB0aW9uc0luZGljYXRvciwgY2FwdGlvbnNJbmRpY2F0b3JTbG90LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICBjYXB0aW9uc0luZGljYXRvclNsb3QuYWRkRXZlbnRMaXN0ZW5lcihcInNsb3RjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgbGV0IGVscyA9IGNhcHRpb25zSW5kaWNhdG9yU2xvdC5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICBpZiAoZWxzLmxlbmd0aCA9PT0gMSAmJiBlbHNbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzbG90XCIpIHtcbiAgICAgICAgY29uc3QgYXNzaWduZWRFbGVtZW50cyA9IGVsc1swXS5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChhc3NpZ25lZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2FwdGlvbnNJbmRpY2F0b3IsIGVsc1swXS5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXNzaWduZWRFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NhcHRpb25zSW5kaWNhdG9yLCBhc3NpZ25lZEVsZW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2NhcHRpb25zSW5kaWNhdG9yKSkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NhcHRpb25zSW5kaWNhdG9yLCBjYXB0aW9uc0luZGljYXRvclNsb3QuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jYXB0aW9uc0luZGljYXRvciwgX19wcml2YXRlR2V0KHRoaXMsIF9jYXB0aW9uc0luZGljYXRvcikuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FwdGlvbnNJbmRpY2F0b3IpLnJlbW92ZUF0dHJpYnV0ZShcInNsb3RcIik7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NhcHRpb25zSW5kaWNhdG9yKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYXB0aW9uc0luZGljYXRvcklubGluZVN0eWxlKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX0xJU1QsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TVUJUSVRMRVNfU0hPV0lOR1xuICAgIF07XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NVQlRJVExFU19MSVNUICYmIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zdWJzLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX3BlclR5cGVVcGRhdGUsIHBlclR5cGVVcGRhdGVfZm4pLmNhbGwodGhpcywgbmV3VmFsdWUsIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3VicykpKTtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcmVuZGVyLCByZW5kZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX1NIT1dJTkcgJiYgb2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFRyYWNrID0gcGFyc2VUZXh0VHJhY2tzU3RyKG5ld1ZhbHVlICE9IG51bGwgPyBuZXdWYWx1ZSA6IFwiXCIpWzBdO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zZWxlY3RlZCA9IHRyYWNrLmxhbmd1YWdlID09PSBzZWxlY3RlZFRyYWNrLmxhbmd1YWdlICYmIHRyYWNrLmxhYmVsID09PSBzZWxlY3RlZFRyYWNrLmxhYmVsO1xuICAgICAgfSk7XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3JlbmRlciwgcmVuZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09IFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIikge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcIkNhcHRpb25zIExpc3QgZG9lc24ndCBjdXJyZW50bHkgc3VwcG9ydCBtdWx0aXBsZSBzZWxlY3Rpb25zLiBZb3UgY2FuIGVuYWJsZSBtdWx0aXBsZSBpdGVtcyB2aWEgdGhlIG1lZGlhLnRleHRUcmFjayBBUEkuXCIpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9yZW5kZXIsIHJlbmRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9vbkNoYW5nZSwgb25DaGFuZ2VfZm4pKTtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX29uQ2hhbmdlLCBvbkNoYW5nZV9mbikpO1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbn1cbl9zdWJzID0gbmV3IFdlYWtNYXAoKTtcbl9vZmZPcHRpb24gPSBuZXcgV2Vha01hcCgpO1xuX2NhcHRpb25zSW5kaWNhdG9yID0gbmV3IFdlYWtNYXAoKTtcbl9wZXJUeXBlVXBkYXRlID0gbmV3IFdlYWtTZXQoKTtcbnBlclR5cGVVcGRhdGVfZm4gPSBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkSXRlbXMpIHtcbiAgY29uc3QgbmV3SXRlbXMgPSBuZXdWYWx1ZSA/IHBhcnNlVGV4dFRyYWNrc1N0cihuZXdWYWx1ZSAhPSBudWxsID8gbmV3VmFsdWUgOiBcIlwiKSA6IFtdO1xuICBjb25zdCByZW1vdmVkVHJhY2tzID0gW107XG4gIGNvbnN0IG5ld1RyYWNrcyA9IFtdO1xuICBvbGRJdGVtcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuc29tZSgobmV3VHJhY2spID0+IGNvbXBhcmVUcmFja3MobmV3VHJhY2ssIHRyYWNrKSkpIHtcbiAgICAgIHJlbW92ZWRUcmFja3MucHVzaCh0cmFjayk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICBpZiAoIW9sZEl0ZW1zLnNvbWUoKG5ld1RyYWNrKSA9PiBjb21wYXJlVHJhY2tzKG5ld1RyYWNrLCB0cmFjaykpKSB7XG4gICAgICBuZXdUcmFja3MucHVzaCh0cmFjayk7XG4gICAgfVxuICB9KTtcbiAgcmVtb3ZlZFRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suZWwucmVtb3ZlKCkpO1xuICByZXR1cm4gb2xkSXRlbXMuZmlsdGVyKCh0cmFjaykgPT4gIXJlbW92ZWRUcmFja3MuaW5jbHVkZXModHJhY2spKS5jb25jYXQobmV3VHJhY2tzKTtcbn07XG5fcmVuZGVyVHJhY2tzID0gbmV3IFdlYWtTZXQoKTtcbnJlbmRlclRyYWNrc19mbiA9IGZ1bmN0aW9uKHRyYWNrcykge1xuICBjb25zdCBjb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInVsIHNsb3RcIik7XG4gIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3B0aW9uID0gdHJhY2suZWw7XG4gICAgbGV0IGFscmVhZHlJbkRvbSA9IHRydWU7XG4gICAgY29uc3QgdHlwZSA9IChfYSA9IHRyYWNrLmtpbmQpICE9IG51bGwgPyBfYSA6IFwic3Vic1wiO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWVkaWEtY2hyb21lLWxpc3RpdGVtXCIpO1xuICAgICAgYWxyZWFkeUluRG9tID0gZmFsc2U7XG4gICAgICBvcHRpb24ucGFydC5hZGQoXCJsaXN0aXRlbVwiKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGZvcm1hdFRleHRUcmFja09iaih0cmFjayk7XG4gICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSB0cmFjay5sYWJlbDtcbiAgICAgIG9wdGlvbi5hcHBlbmQobGFiZWwpO1xuICAgICAgaWYgKHR5cGUgPT09IFwiY2FwdGlvbnNcIikge1xuICAgICAgICBvcHRpb24uYXBwZW5kKF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FwdGlvbnNJbmRpY2F0b3IpLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFjay5zZWxlY3RlZCkge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgICBpZiAoIWFscmVhZHlJbkRvbSkge1xuICAgICAgY29udGFpbmVyLmFwcGVuZChvcHRpb24pO1xuICAgICAgdHJhY2suZWwgPSBvcHRpb247XG4gICAgfVxuICB9KTtcbn07XG5fcmVuZGVyID0gbmV3IFdlYWtTZXQoKTtcbnJlbmRlcl9mbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBjb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInVsIHNsb3RcIik7XG4gIGlmICghY29udGFpbmVyLmNvbnRhaW5zKF9fcHJpdmF0ZUdldCh0aGlzLCBfb2ZmT3B0aW9uKSkpIHtcbiAgICBjb250YWluZXIuYXBwZW5kKF9fcHJpdmF0ZUdldCh0aGlzLCBfb2ZmT3B0aW9uKSk7XG4gIH1cbiAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TVUJUSVRMRVNfU0hPV0lORykpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX29mZk9wdGlvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vZmZPcHRpb24pLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgfSBlbHNlIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX29mZk9wdGlvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb2ZmT3B0aW9uKS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICB9XG4gIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcmVuZGVyVHJhY2tzLCByZW5kZXJUcmFja3NfZm4pLmNhbGwodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzKSk7XG59O1xuX29uQ2hhbmdlID0gbmV3IFdlYWtTZXQoKTtcbm9uQ2hhbmdlX2ZuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSAoX2EgPSB0aGlzLnNlbGVjdGVkT3B0aW9uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICB0b2dnbGVTdWJzQ2Fwcyh0aGlzLCBmYWxzZSk7XG4gIGlmICghc2VsZWN0ZWRPcHRpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBldmVudCA9IG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KFxuICAgIE1lZGlhVUlFdmVudHMuTUVESUFfU0hPV19TVUJUSVRMRVNfUkVRVUVTVCxcbiAgICB7XG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBkZXRhaWw6IHNlbGVjdGVkT3B0aW9uXG4gICAgfVxuICApO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1jYXB0aW9ucy1saXN0Ym94XCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtY2FwdGlvbnMtbGlzdGJveFwiLCBNZWRpYUNhcHRpb25zTGlzdGJveCk7XG59XG52YXIgbWVkaWFfY2FwdGlvbnNfbGlzdGJveF9kZWZhdWx0ID0gTWVkaWFDYXB0aW9uc0xpc3Rib3g7XG5leHBvcnQge1xuICBtZWRpYV9jYXB0aW9uc19saXN0Ym94X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-listbox.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-selectmenu.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/media-chrome/dist/experimental/media-captions-selectmenu.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_captions_selectmenu_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_selectmenu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-selectmenu.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-selectmenu.js\");\n/* harmony import */ var _media_captions_button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../media-captions-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-captions-button.js\");\n/* harmony import */ var _media_captions_listbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./media-captions-listbox.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-listbox.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n\n\n\n\nclass MediaCaptionsSelectMenu extends _media_chrome_selectmenu_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor() {\n    super();\n  }\n  init() {\n    const captionsButton = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_3__.document.createElement(\"media-captions-button\");\n    captionsButton.part.add(\"button\");\n    captionsButton.preventClick = true;\n    const captionsListbox = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_3__.document.createElement(\"media-captions-listbox\");\n    captionsListbox.part.add(\"listbox\");\n    captionsListbox.setAttribute(\"exportparts\", \"listitem\");\n    const buttonSlot = this.shadowRoot.querySelector(\"slot[name=button]\");\n    const listboxSlot = this.shadowRoot.querySelector(\"slot[name=listbox]\");\n    buttonSlot.textContent = \"\";\n    listboxSlot.textContent = \"\";\n    buttonSlot.append(captionsButton);\n    listboxSlot.append(captionsListbox);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_3__.globalThis.customElements.get(\"media-captions-selectmenu\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_3__.globalThis.customElements.define(\"media-captions-selectmenu\", MediaCaptionsSelectMenu);\n}\nvar media_captions_selectmenu_default = MediaCaptionsSelectMenu;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jYXB0aW9ucy1zZWxlY3RtZW51LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlFO0FBQzVCO0FBQ0E7QUFDa0M7QUFDdkUsc0NBQXNDLG1FQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBUTtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLG1FQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jYXB0aW9ucy1zZWxlY3RtZW51LmpzPzg0NzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1lZGlhQ2hyb21lU2VsZWN0TWVudSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtc2VsZWN0bWVudS5qc1wiO1xuaW1wb3J0IFwiLi4vbWVkaWEtY2FwdGlvbnMtYnV0dG9uLmpzXCI7XG5pbXBvcnQgXCIuL21lZGlhLWNhcHRpb25zLWxpc3Rib3guanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmNsYXNzIE1lZGlhQ2FwdGlvbnNTZWxlY3RNZW51IGV4dGVuZHMgTWVkaWFDaHJvbWVTZWxlY3RNZW51IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGNhcHRpb25zQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1lZGlhLWNhcHRpb25zLWJ1dHRvblwiKTtcbiAgICBjYXB0aW9uc0J1dHRvbi5wYXJ0LmFkZChcImJ1dHRvblwiKTtcbiAgICBjYXB0aW9uc0J1dHRvbi5wcmV2ZW50Q2xpY2sgPSB0cnVlO1xuICAgIGNvbnN0IGNhcHRpb25zTGlzdGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtZWRpYS1jYXB0aW9ucy1saXN0Ym94XCIpO1xuICAgIGNhcHRpb25zTGlzdGJveC5wYXJ0LmFkZChcImxpc3Rib3hcIik7XG4gICAgY2FwdGlvbnNMaXN0Ym94LnNldEF0dHJpYnV0ZShcImV4cG9ydHBhcnRzXCIsIFwibGlzdGl0ZW1cIik7XG4gICAgY29uc3QgYnV0dG9uU2xvdCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic2xvdFtuYW1lPWJ1dHRvbl1cIik7XG4gICAgY29uc3QgbGlzdGJveFNsb3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInNsb3RbbmFtZT1saXN0Ym94XVwiKTtcbiAgICBidXR0b25TbG90LnRleHRDb250ZW50ID0gXCJcIjtcbiAgICBsaXN0Ym94U2xvdC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgYnV0dG9uU2xvdC5hcHBlbmQoY2FwdGlvbnNCdXR0b24pO1xuICAgIGxpc3Rib3hTbG90LmFwcGVuZChjYXB0aW9uc0xpc3Rib3gpO1xuICB9XG59XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtY2FwdGlvbnMtc2VsZWN0bWVudVwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLWNhcHRpb25zLXNlbGVjdG1lbnVcIiwgTWVkaWFDYXB0aW9uc1NlbGVjdE1lbnUpO1xufVxudmFyIG1lZGlhX2NhcHRpb25zX3NlbGVjdG1lbnVfZGVmYXVsdCA9IE1lZGlhQ2FwdGlvbnNTZWxlY3RNZW51O1xuZXhwb3J0IHtcbiAgbWVkaWFfY2FwdGlvbnNfc2VsZWN0bWVudV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/experimental/media-captions-selectmenu.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listbox.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/media-chrome/dist/experimental/media-chrome-listbox.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_chrome_listbox_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _keysSoFar, _clearKeysTimeout, _slot, __assignedElements, _metaPressed, _assignedElements, assignedElements_get, assignedElements_set, _items, items_get, _clickListener, _handleKeyListener, handleKeyListener_fn, _keyupListener, _keydownListener, _getItem, getItem_fn, _selectItem, selectItem_fn, _searchItem, searchItem_fn, _clearKeysOnDelay, clearKeysOnDelay_fn;\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\n  :host ul {\n    font: var(--media-font,\n      var(--media-font-weight, normal)\n      var(--media-font-size, 1em) /\n      var(--media-text-content-height, var(--media-control-height, 24px))\n      var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n    color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n    background: var(--media-listbox-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));\n    list-style: none;\n    display: inline-flex;\n    flex-direction: column;\n    gap: 0.5em;\n    margin: 0;\n    padding: 0.5em;\n  }\n\n  ::slotted(media-chrome-listitem[tabindex=\"0\"]:focus-visible),\n  media-chrome-listitem[tabindex=\"0\"]:focus-visible {\n    box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);\n    outline: 0;\n  }\n\n  ::slotted(media-chrome-listitem[aria-selected=\"true\"]),\n  media-chrome-listitem[aria-selected=\"true\"] {\n    background-color: var(--media-listbox-selected-background, rgb(122 122 184 / .8));\n  }\n\n  ::slotted(media-chrome-listitem:hover),\n  media-chrome-listitem:hover {\n    background-color: var(--media-listbox-hover-background, rgb(82 82 122 / .8));\n    outline: var(--media-listbox-hover-outline, none);\n  }\n</style>\n<ul tabindex=\"0\">\n  <slot></slot>\n</ul>\n`;\nclass MediaChromeListbox extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.HTMLElement {\n  constructor(options = {}) {\n    super();\n    __privateAdd(this, _assignedElements);\n    __privateAdd(this, _items);\n    __privateAdd(this, _handleKeyListener);\n    __privateAdd(this, _getItem);\n    __privateAdd(this, _selectItem);\n    __privateAdd(this, _searchItem);\n    __privateAdd(this, _clearKeysOnDelay);\n    __privateAdd(this, _keysSoFar, \"\");\n    __privateAdd(this, _clearKeysTimeout, null);\n    __privateAdd(this, _slot, void 0);\n    __privateAdd(this, __assignedElements, void 0);\n    __privateAdd(this, _metaPressed, false);\n    __privateAdd(this, _clickListener, (e) => {\n      this.handleClick(e);\n    });\n    __privateAdd(this, _keyupListener, (e) => {\n      const { key } = e;\n      if (key === \"Escape\") {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      if (key === \"Meta\") {\n        __privateSet(this, _metaPressed, false);\n        return;\n      }\n      __privateMethod(this, _handleKeyListener, handleKeyListener_fn).call(this, e);\n    });\n    __privateAdd(this, _keydownListener, (e) => {\n      const { key, altKey } = e;\n      if (altKey) {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      if (key === \"Meta\") {\n        __privateSet(this, _metaPressed, true);\n        return;\n      }\n      if (this.keysUsed.includes(key)) {\n        e.preventDefault();\n      }\n      if (__privateGet(this, _metaPressed) && this.keysUsed.includes(key)) {\n        __privateMethod(this, _handleKeyListener, handleKeyListener_fn).call(this, e);\n        return;\n      }\n      this.addEventListener(\"keyup\", __privateGet(this, _keyupListener), { once: true });\n    });\n    if (!this.shadowRoot) {\n      const shadow = this.attachShadow({ mode: \"open\" });\n      const listboxHTML = template.content.cloneNode(true);\n      this.nativeEl = listboxHTML;\n      let slotTemplate = options.slotTemplate;\n      if (!slotTemplate) {\n        slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\n        slotTemplate.innerHTML = `<slot>${options.defaultContent || \"\"}</slot>`;\n      }\n      this.nativeEl.appendChild(slotTemplate.content.cloneNode(true));\n      shadow.appendChild(listboxHTML);\n    }\n    __privateSet(this, _slot, this.shadowRoot.querySelector(\"slot\"));\n    __privateGet(this, _slot).addEventListener(\"slotchange\", () => {\n      __privateSet(this, _assignedElements, __privateGet(this, _slot).assignedElements({ flatten: true }), assignedElements_set);\n      if (__privateGet(this, _assignedElements, assignedElements_get).length === 1 && __privateGet(this, _assignedElements, assignedElements_get)[0].nodeName.toLowerCase() === \"slot\") {\n        __privateSet(this, _assignedElements, __privateGet(this, _assignedElements, assignedElements_get)[0].assignedElements({ flatten: true }), assignedElements_set);\n      }\n      const els = __privateGet(this, _items, items_get);\n      const activeEls = els.some((el) => el.getAttribute(\"tabindex\") === \"0\");\n      if (activeEls) {\n        return;\n      }\n      let elToSelect = els.filter((el) => el.getAttribute(\"aria-selected\") === \"true\")[0];\n      if (!elToSelect) {\n        elToSelect = els[0];\n      }\n      if (elToSelect) {\n        elToSelect.setAttribute(\"tabindex\", 0);\n        elToSelect.setAttribute(\"aria-selected\", \"true\");\n      }\n    });\n  }\n  static get observedAttributes() {\n    return [\"disabled\", _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER];\n  }\n  get selectedOptions() {\n    return __privateGet(this, _items, items_get).filter((el) => el.getAttribute(\"aria-selected\") === \"true\");\n  }\n  get value() {\n    return this.selectedOptions[0].value || this.selectedOptions[0].textContent;\n  }\n  set value(newValue) {\n    const item = __privateGet(this, _items, items_get).find((el) => el.value === newValue || el.textContent === newValue);\n    if (!item)\n      return;\n    __privateMethod(this, _selectItem, selectItem_fn).call(this, item);\n  }\n  focus() {\n    var _a;\n    (_a = this.selectedOptions[0]) == null ? void 0 : _a.focus();\n  }\n  enable() {\n    this.addEventListener(\"click\", __privateGet(this, _clickListener));\n    this.addEventListener(\"keydown\", __privateGet(this, _keydownListener));\n  }\n  disable() {\n    this.removeEventListener(\"click\", __privateGet(this, _clickListener));\n    this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(oldValue);\n        (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n      }\n      if (newValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(newValue);\n        (_b = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _b.call(mediaControllerEl, this);\n      }\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n  }\n  connectedCallback() {\n    var _a;\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    if (!this.hasAttribute(\"role\")) {\n      this.setAttribute(\"role\", \"listbox\");\n    }\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a;\n    this.disable();\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n    }\n  }\n  get keysUsed() {\n    return [\"Enter\", \" \", \"ArrowDown\", \"ArrowUp\", \"Home\", \"End\"];\n  }\n  handleSelection(e, toggle) {\n    const item = __privateMethod(this, _getItem, getItem_fn).call(this, e);\n    if (!item)\n      return;\n    __privateMethod(this, _selectItem, selectItem_fn).call(this, item, toggle);\n  }\n  handleMovement(e) {\n    const { key } = e;\n    const els = __privateGet(this, _items, items_get);\n    let currentOption = __privateMethod(this, _getItem, getItem_fn).call(this, e);\n    if (!currentOption) {\n      currentOption = els.filter((el) => el.getAttribute(\"tabindex\") === \"0\")[0];\n    }\n    let nextOption;\n    switch (key) {\n      case \"ArrowDown\":\n        nextOption = currentOption.nextElementSibling;\n        if (nextOption == null ? void 0 : nextOption.hasAttribute(\"disabled\")) {\n          nextOption = nextOption.nextElementSibling;\n        }\n        break;\n      case \"ArrowUp\":\n        nextOption = currentOption.previousElementSibling;\n        if (nextOption == null ? void 0 : nextOption.hasAttribute(\"disabled\")) {\n          nextOption = nextOption.previousElementSibling;\n        }\n        break;\n      case \"Home\":\n        nextOption = els[0];\n        break;\n      case \"End\":\n        nextOption = els[els.length - 1];\n        break;\n      default:\n        nextOption = __privateMethod(this, _searchItem, searchItem_fn).call(this, key);\n        break;\n    }\n    if (nextOption) {\n      els.forEach((el) => el.setAttribute(\"tabindex\", \"-1\"));\n      nextOption.setAttribute(\"tabindex\", \"0\");\n      nextOption.focus();\n    }\n  }\n  handleClick(e) {\n    const item = __privateMethod(this, _getItem, getItem_fn).call(this, e);\n    if (!item || item.hasAttribute(\"disabled\"))\n      return;\n    __privateGet(this, _items, items_get).forEach((el) => el.setAttribute(\"tabindex\", \"-1\"));\n    item.setAttribute(\"tabindex\", \"0\");\n    this.handleSelection(e, this.hasAttribute(\"aria-multiselectable\") && this.getAttribute(\"aria-multiselectable\") === \"true\");\n  }\n}\n_keysSoFar = new WeakMap();\n_clearKeysTimeout = new WeakMap();\n_slot = new WeakMap();\n__assignedElements = new WeakMap();\n_metaPressed = new WeakMap();\n_assignedElements = new WeakSet();\nassignedElements_get = function() {\n  if (!__privateGet(this, __assignedElements)) {\n    __privateSet(this, __assignedElements, Array.from(this.shadowRoot.querySelectorAll(\"media-chrome-listitem\")));\n  }\n  return __privateGet(this, __assignedElements);\n};\nassignedElements_set = function(value) {\n  __privateSet(this, __assignedElements, value);\n};\n_items = new WeakSet();\nitems_get = function() {\n  return __privateGet(this, _assignedElements, assignedElements_get).filter((el) => !el.hasAttribute(\"disabled\"));\n};\n_clickListener = new WeakMap();\n_handleKeyListener = new WeakSet();\nhandleKeyListener_fn = function(e) {\n  const { key } = e;\n  if (key === \"Enter\" || key === \" \") {\n    this.handleSelection(e, this.hasAttribute(\"aria-multiselectable\") && this.getAttribute(\"aria-multiselectable\") === \"true\");\n  } else {\n    this.handleMovement(e);\n  }\n};\n_keyupListener = new WeakMap();\n_keydownListener = new WeakMap();\n_getItem = new WeakSet();\ngetItem_fn = function(e) {\n  const composedPath = e.composedPath();\n  const index = composedPath.findIndex((el) => el.nodeName === \"MEDIA-CHROME-LISTITEM\");\n  return composedPath[index];\n};\n_selectItem = new WeakSet();\nselectItem_fn = function(item, toggle) {\n  if (!this.hasAttribute(\"aria-multiselectable\") || this.getAttribute(\"aria-multiselectable\") !== \"true\") {\n    __privateGet(this, _assignedElements, assignedElements_get).forEach((el) => el.setAttribute(\"aria-selected\", \"false\"));\n  }\n  if (toggle) {\n    const selected = item.getAttribute(\"aria-selected\") === \"true\";\n    if (selected) {\n      item.setAttribute(\"aria-selected\", \"false\");\n    } else {\n      item.setAttribute(\"aria-selected\", \"true\");\n    }\n  } else {\n    item.setAttribute(\"aria-selected\", \"true\");\n  }\n  this.dispatchEvent(new Event(\"change\"));\n};\n_searchItem = new WeakSet();\nsearchItem_fn = function(key) {\n  __privateMethod(this, _clearKeysOnDelay, clearKeysOnDelay_fn).call(this);\n  const els = __privateGet(this, _items, items_get);\n  const activeIndex = els.findIndex((el) => el.getAttribute(\"tabindex\") === \"0\");\n  __privateSet(this, _keysSoFar, __privateGet(this, _keysSoFar) + key);\n  const repeatedKey = __privateGet(this, _keysSoFar).split(\"\").every((k) => k === key);\n  const after = els.slice(activeIndex + (repeatedKey ? 1 : 0)).filter((el) => el.textContent.toLowerCase().startsWith(__privateGet(this, _keysSoFar)));\n  const before = els.slice(0, activeIndex - (repeatedKey ? 1 : 0)).filter((el) => el.textContent.toLowerCase().startsWith(__privateGet(this, _keysSoFar)));\n  let afterRepeated = [];\n  let beforeRepeated = [];\n  if (repeatedKey) {\n    afterRepeated = els.slice(activeIndex + (repeatedKey ? 1 : 0)).filter((el) => el.textContent.startsWith(key));\n    beforeRepeated = els.slice(0, activeIndex - (repeatedKey ? 1 : 0)).filter((el) => el.textContent.startsWith(key));\n  }\n  const returns = [...after, ...before, ...afterRepeated, ...beforeRepeated];\n  return returns[0];\n};\n_clearKeysOnDelay = new WeakSet();\nclearKeysOnDelay_fn = function() {\n  clearTimeout(__privateGet(this, _clearKeysTimeout));\n  __privateSet(this, _clearKeysTimeout, null);\n  __privateSet(this, _clearKeysTimeout, setTimeout(() => {\n    __privateSet(this, _keysSoFar, \"\");\n    __privateSet(this, _clearKeysTimeout, null);\n  }, 500));\n};\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-chrome-listbox\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-chrome-listbox\", MediaChromeListbox);\n}\nvar media_chrome_listbox_default = MediaChromeListbox;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jaHJvbWUtbGlzdGJveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytEO0FBQ1E7QUFDdkUsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxRUFBVTtBQUMzQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsWUFBWTtBQUN2RixLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBUTtBQUMvQiwwQ0FBMEMsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixlQUFlO0FBQ3hHO0FBQ0EsZ0lBQWdJLGVBQWU7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLHVFQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUVBQTRCO0FBQ2pEO0FBQ0Esa0NBQWtDLG1FQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtRUFBUTtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQztBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQyxtRUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9leHBlcmltZW50YWwvbWVkaWEtY2hyb21lLWxpc3Rib3guanM/ZDcwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX2tleXNTb0ZhciwgX2NsZWFyS2V5c1RpbWVvdXQsIF9zbG90LCBfX2Fzc2lnbmVkRWxlbWVudHMsIF9tZXRhUHJlc3NlZCwgX2Fzc2lnbmVkRWxlbWVudHMsIGFzc2lnbmVkRWxlbWVudHNfZ2V0LCBhc3NpZ25lZEVsZW1lbnRzX3NldCwgX2l0ZW1zLCBpdGVtc19nZXQsIF9jbGlja0xpc3RlbmVyLCBfaGFuZGxlS2V5TGlzdGVuZXIsIGhhbmRsZUtleUxpc3RlbmVyX2ZuLCBfa2V5dXBMaXN0ZW5lciwgX2tleWRvd25MaXN0ZW5lciwgX2dldEl0ZW0sIGdldEl0ZW1fZm4sIF9zZWxlY3RJdGVtLCBzZWxlY3RJdGVtX2ZuLCBfc2VhcmNoSXRlbSwgc2VhcmNoSXRlbV9mbiwgX2NsZWFyS2V5c09uRGVsYXksIGNsZWFyS2V5c09uRGVsYXlfZm47XG5pbXBvcnQgeyBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG4gIDpob3N0IHVsIHtcbiAgICBmb250OiB2YXIoLS1tZWRpYS1mb250LFxuICAgICAgdmFyKC0tbWVkaWEtZm9udC13ZWlnaHQsIG5vcm1hbClcbiAgICAgIHZhcigtLW1lZGlhLWZvbnQtc2l6ZSwgMWVtKSAvXG4gICAgICB2YXIoLS1tZWRpYS10ZXh0LWNvbnRlbnQtaGVpZ2h0LCB2YXIoLS1tZWRpYS1jb250cm9sLWhlaWdodCwgMjRweCkpXG4gICAgICB2YXIoLS1tZWRpYS1mb250LWZhbWlseSwgaGVsdmV0aWNhIG5ldWUsIHNlZ29lIHVpLCByb2JvdG8sIGFyaWFsLCBzYW5zLXNlcmlmKSk7XG4gICAgY29sb3I6IHZhcigtLW1lZGlhLXRleHQtY29sb3IsIHZhcigtLW1lZGlhLXByaW1hcnktY29sb3IsIHJnYigyMzggMjM4IDIzOCkpKTtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS1saXN0Ym94LWJhY2tncm91bmQsIHZhcigtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZCwgdmFyKC0tbWVkaWEtc2Vjb25kYXJ5LWNvbG9yLCByZ2IoMjAgMjAgMzAgLyAuOCkpKSk7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGdhcDogMC41ZW07XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDAuNWVtO1xuICB9XG5cbiAgOjpzbG90dGVkKG1lZGlhLWNocm9tZS1saXN0aXRlbVt0YWJpbmRleD1cIjBcIl06Zm9jdXMtdmlzaWJsZSksXG4gIG1lZGlhLWNocm9tZS1saXN0aXRlbVt0YWJpbmRleD1cIjBcIl06Zm9jdXMtdmlzaWJsZSB7XG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMnB4IHJnYigyNyAxMjcgMjA0IC8gLjkpO1xuICAgIG91dGxpbmU6IDA7XG4gIH1cblxuICA6OnNsb3R0ZWQobWVkaWEtY2hyb21lLWxpc3RpdGVtW2FyaWEtc2VsZWN0ZWQ9XCJ0cnVlXCJdKSxcbiAgbWVkaWEtY2hyb21lLWxpc3RpdGVtW2FyaWEtc2VsZWN0ZWQ9XCJ0cnVlXCJdIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tZWRpYS1saXN0Ym94LXNlbGVjdGVkLWJhY2tncm91bmQsIHJnYigxMjIgMTIyIDE4NCAvIC44KSk7XG4gIH1cblxuICA6OnNsb3R0ZWQobWVkaWEtY2hyb21lLWxpc3RpdGVtOmhvdmVyKSxcbiAgbWVkaWEtY2hyb21lLWxpc3RpdGVtOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tZWRpYS1saXN0Ym94LWhvdmVyLWJhY2tncm91bmQsIHJnYig4MiA4MiAxMjIgLyAuOCkpO1xuICAgIG91dGxpbmU6IHZhcigtLW1lZGlhLWxpc3Rib3gtaG92ZXItb3V0bGluZSwgbm9uZSk7XG4gIH1cbjwvc3R5bGU+XG48dWwgdGFiaW5kZXg9XCIwXCI+XG4gIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG5gO1xuY2xhc3MgTWVkaWFDaHJvbWVMaXN0Ym94IGV4dGVuZHMgZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hc3NpZ25lZEVsZW1lbnRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2l0ZW1zKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUtleUxpc3RlbmVyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldEl0ZW0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2VsZWN0SXRlbSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZWFyY2hJdGVtKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsZWFyS2V5c09uRGVsYXkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfa2V5c1NvRmFyLCBcIlwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsZWFyS2V5c1RpbWVvdXQsIG51bGwpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2xvdCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX19hc3NpZ25lZEVsZW1lbnRzLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWV0YVByZXNzZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsaWNrTGlzdGVuZXIsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZUNsaWNrKGUpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfa2V5dXBMaXN0ZW5lciwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBlO1xuICAgICAgaWYgKGtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleXVwTGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJNZXRhXCIpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXRhUHJlc3NlZCwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hhbmRsZUtleUxpc3RlbmVyLCBoYW5kbGVLZXlMaXN0ZW5lcl9mbikuY2FsbCh0aGlzLCBlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2tleWRvd25MaXN0ZW5lciwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsga2V5LCBhbHRLZXkgfSA9IGU7XG4gICAgICBpZiAoYWx0S2V5KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5dXBMaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcIk1ldGFcIikge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21ldGFQcmVzc2VkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5c1VzZWQuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhUHJlc3NlZCkgJiYgdGhpcy5rZXlzVXNlZC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfaGFuZGxlS2V5TGlzdGVuZXIsIGhhbmRsZUtleUxpc3RlbmVyX2ZuKS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleXVwTGlzdGVuZXIpLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGNvbnN0IHNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICBjb25zdCBsaXN0Ym94SFRNTCA9IHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdGhpcy5uYXRpdmVFbCA9IGxpc3Rib3hIVE1MO1xuICAgICAgbGV0IHNsb3RUZW1wbGF0ZSA9IG9wdGlvbnMuc2xvdFRlbXBsYXRlO1xuICAgICAgaWYgKCFzbG90VGVtcGxhdGUpIHtcbiAgICAgICAgc2xvdFRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgICBzbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYDxzbG90PiR7b3B0aW9ucy5kZWZhdWx0Q29udGVudCB8fCBcIlwifTwvc2xvdD5gO1xuICAgICAgfVxuICAgICAgdGhpcy5uYXRpdmVFbC5hcHBlbmRDaGlsZChzbG90VGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGxpc3Rib3hIVE1MKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zbG90LCB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInNsb3RcIikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2xvdCkuYWRkRXZlbnRMaXN0ZW5lcihcInNsb3RjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9hc3NpZ25lZEVsZW1lbnRzLCBfX3ByaXZhdGVHZXQodGhpcywgX3Nsb3QpLmFzc2lnbmVkRWxlbWVudHMoeyBmbGF0dGVuOiB0cnVlIH0pLCBhc3NpZ25lZEVsZW1lbnRzX3NldCk7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9hc3NpZ25lZEVsZW1lbnRzLCBhc3NpZ25lZEVsZW1lbnRzX2dldCkubGVuZ3RoID09PSAxICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXNzaWduZWRFbGVtZW50cywgYXNzaWduZWRFbGVtZW50c19nZXQpWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2xvdFwiKSB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYXNzaWduZWRFbGVtZW50cywgX19wcml2YXRlR2V0KHRoaXMsIF9hc3NpZ25lZEVsZW1lbnRzLCBhc3NpZ25lZEVsZW1lbnRzX2dldClbMF0uYXNzaWduZWRFbGVtZW50cyh7IGZsYXR0ZW46IHRydWUgfSksIGFzc2lnbmVkRWxlbWVudHNfc2V0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVscyA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfaXRlbXMsIGl0ZW1zX2dldCk7XG4gICAgICBjb25zdCBhY3RpdmVFbHMgPSBlbHMuc29tZSgoZWwpID0+IGVsLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID09PSBcIjBcIik7XG4gICAgICBpZiAoYWN0aXZlRWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlbFRvU2VsZWN0ID0gZWxzLmZpbHRlcigoZWwpID0+IGVsLmdldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikgPT09IFwidHJ1ZVwiKVswXTtcbiAgICAgIGlmICghZWxUb1NlbGVjdCkge1xuICAgICAgICBlbFRvU2VsZWN0ID0gZWxzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKGVsVG9TZWxlY3QpIHtcbiAgICAgICAgZWxUb1NlbGVjdC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgZWxUb1NlbGVjdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1wiZGlzYWJsZWRcIiwgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXTtcbiAgfVxuICBnZXQgc2VsZWN0ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2l0ZW1zLCBpdGVtc19nZXQpLmZpbHRlcigoZWwpID0+IGVsLmdldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikgPT09IFwidHJ1ZVwiKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRPcHRpb25zWzBdLnZhbHVlIHx8IHRoaXMuc2VsZWN0ZWRPcHRpb25zWzBdLnRleHRDb250ZW50O1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IGl0ZW0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2l0ZW1zLCBpdGVtc19nZXQpLmZpbmQoKGVsKSA9PiBlbC52YWx1ZSA9PT0gbmV3VmFsdWUgfHwgZWwudGV4dENvbnRlbnQgPT09IG5ld1ZhbHVlKTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICByZXR1cm47XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZWxlY3RJdGVtLCBzZWxlY3RJdGVtX2ZuKS5jYWxsKHRoaXMsIGl0ZW0pO1xuICB9XG4gIGZvY3VzKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLnNlbGVjdGVkT3B0aW9uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpY2tMaXN0ZW5lcikpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXlkb3duTGlzdGVuZXIpKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpY2tMaXN0ZW5lcikpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5dXBMaXN0ZW5lcikpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikge1xuICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2xkVmFsdWUpO1xuICAgICAgICAoX2EgPSBtZWRpYUNvbnRyb2xsZXJFbCA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDb250cm9sbGVyRWwudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChtZWRpYUNvbnRyb2xsZXJFbCwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVkaWFDb250cm9sbGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuZXdWYWx1ZSk7XG4gICAgICAgIChfYiA9IG1lZGlhQ29udHJvbGxlckVsID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNvbnRyb2xsZXJFbC5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChtZWRpYUNvbnRyb2xsZXJFbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gXCJkaXNhYmxlZFwiICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKFwicm9sZVwiKSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICB9XG4gICAgY29uc3QgbWVkaWFDb250cm9sbGVySWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUlxuICAgICk7XG4gICAgaWYgKG1lZGlhQ29udHJvbGxlcklkKSB7XG4gICAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1lZGlhQ29udHJvbGxlcklkKTtcbiAgICAgIChfYSA9IG1lZGlhQ29udHJvbGxlckVsID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNvbnRyb2xsZXJFbC5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChtZWRpYUNvbnRyb2xsZXJFbCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKFxuICAgICAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXG4gICAgKTtcbiAgICBpZiAobWVkaWFDb250cm9sbGVySWQpIHtcbiAgICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVkaWFDb250cm9sbGVySWQpO1xuICAgICAgKF9hID0gbWVkaWFDb250cm9sbGVyRWwgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhQ29udHJvbGxlckVsLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQga2V5c1VzZWQoKSB7XG4gICAgcmV0dXJuIFtcIkVudGVyXCIsIFwiIFwiLCBcIkFycm93RG93blwiLCBcIkFycm93VXBcIiwgXCJIb21lXCIsIFwiRW5kXCJdO1xuICB9XG4gIGhhbmRsZVNlbGVjdGlvbihlLCB0b2dnbGUpIHtcbiAgICBjb25zdCBpdGVtID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRJdGVtLCBnZXRJdGVtX2ZuKS5jYWxsKHRoaXMsIGUpO1xuICAgIGlmICghaXRlbSlcbiAgICAgIHJldHVybjtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NlbGVjdEl0ZW0sIHNlbGVjdEl0ZW1fZm4pLmNhbGwodGhpcywgaXRlbSwgdG9nZ2xlKTtcbiAgfVxuICBoYW5kbGVNb3ZlbWVudChlKSB7XG4gICAgY29uc3QgeyBrZXkgfSA9IGU7XG4gICAgY29uc3QgZWxzID0gX19wcml2YXRlR2V0KHRoaXMsIF9pdGVtcywgaXRlbXNfZ2V0KTtcbiAgICBsZXQgY3VycmVudE9wdGlvbiA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0SXRlbSwgZ2V0SXRlbV9mbikuY2FsbCh0aGlzLCBlKTtcbiAgICBpZiAoIWN1cnJlbnRPcHRpb24pIHtcbiAgICAgIGN1cnJlbnRPcHRpb24gPSBlbHMuZmlsdGVyKChlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgPT09IFwiMFwiKVswXTtcbiAgICB9XG4gICAgbGV0IG5leHRPcHRpb247XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgbmV4dE9wdGlvbiA9IGN1cnJlbnRPcHRpb24ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBpZiAobmV4dE9wdGlvbiA9PSBudWxsID8gdm9pZCAwIDogbmV4dE9wdGlvbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICAgICAgICAgIG5leHRPcHRpb24gPSBuZXh0T3B0aW9uLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIG5leHRPcHRpb24gPSBjdXJyZW50T3B0aW9uLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0T3B0aW9uID09IG51bGwgPyB2b2lkIDAgOiBuZXh0T3B0aW9uLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICAgICAgbmV4dE9wdGlvbiA9IG5leHRPcHRpb24ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgIG5leHRPcHRpb24gPSBlbHNbMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBuZXh0T3B0aW9uID0gZWxzW2Vscy5sZW5ndGggLSAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXh0T3B0aW9uID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZWFyY2hJdGVtLCBzZWFyY2hJdGVtX2ZuKS5jYWxsKHRoaXMsIGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dE9wdGlvbikge1xuICAgICAgZWxzLmZvckVhY2goKGVsKSA9PiBlbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpKTtcbiAgICAgIG5leHRPcHRpb24uc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgbmV4dE9wdGlvbi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDbGljayhlKSB7XG4gICAgY29uc3QgaXRlbSA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0SXRlbSwgZ2V0SXRlbV9mbikuY2FsbCh0aGlzLCBlKTtcbiAgICBpZiAoIWl0ZW0gfHwgaXRlbS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSlcbiAgICAgIHJldHVybjtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2l0ZW1zLCBpdGVtc19nZXQpLmZvckVhY2goKGVsKSA9PiBlbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpKTtcbiAgICBpdGVtLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbihlLCB0aGlzLmhhc0F0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIpICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIikgPT09IFwidHJ1ZVwiKTtcbiAgfVxufVxuX2tleXNTb0ZhciA9IG5ldyBXZWFrTWFwKCk7XG5fY2xlYXJLZXlzVGltZW91dCA9IG5ldyBXZWFrTWFwKCk7XG5fc2xvdCA9IG5ldyBXZWFrTWFwKCk7XG5fX2Fzc2lnbmVkRWxlbWVudHMgPSBuZXcgV2Vha01hcCgpO1xuX21ldGFQcmVzc2VkID0gbmV3IFdlYWtNYXAoKTtcbl9hc3NpZ25lZEVsZW1lbnRzID0gbmV3IFdlYWtTZXQoKTtcbmFzc2lnbmVkRWxlbWVudHNfZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9fYXNzaWduZWRFbGVtZW50cykpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX19hc3NpZ25lZEVsZW1lbnRzLCBBcnJheS5mcm9tKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKFwibWVkaWEtY2hyb21lLWxpc3RpdGVtXCIpKSk7XG4gIH1cbiAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfX2Fzc2lnbmVkRWxlbWVudHMpO1xufTtcbmFzc2lnbmVkRWxlbWVudHNfc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9fYXNzaWduZWRFbGVtZW50cywgdmFsdWUpO1xufTtcbl9pdGVtcyA9IG5ldyBXZWFrU2V0KCk7XG5pdGVtc19nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXNzaWduZWRFbGVtZW50cywgYXNzaWduZWRFbGVtZW50c19nZXQpLmZpbHRlcigoZWwpID0+ICFlbC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSk7XG59O1xuX2NsaWNrTGlzdGVuZXIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUtleUxpc3RlbmVyID0gbmV3IFdlYWtTZXQoKTtcbmhhbmRsZUtleUxpc3RlbmVyX2ZuID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCB7IGtleSB9ID0gZTtcbiAgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIpIHtcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbihlLCB0aGlzLmhhc0F0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIpICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIikgPT09IFwidHJ1ZVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZU1vdmVtZW50KGUpO1xuICB9XG59O1xuX2tleXVwTGlzdGVuZXIgPSBuZXcgV2Vha01hcCgpO1xuX2tleWRvd25MaXN0ZW5lciA9IG5ldyBXZWFrTWFwKCk7XG5fZ2V0SXRlbSA9IG5ldyBXZWFrU2V0KCk7XG5nZXRJdGVtX2ZuID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCBjb21wb3NlZFBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuICBjb25zdCBpbmRleCA9IGNvbXBvc2VkUGF0aC5maW5kSW5kZXgoKGVsKSA9PiBlbC5ub2RlTmFtZSA9PT0gXCJNRURJQS1DSFJPTUUtTElTVElURU1cIik7XG4gIHJldHVybiBjb21wb3NlZFBhdGhbaW5kZXhdO1xufTtcbl9zZWxlY3RJdGVtID0gbmV3IFdlYWtTZXQoKTtcbnNlbGVjdEl0ZW1fZm4gPSBmdW5jdGlvbihpdGVtLCB0b2dnbGUpIHtcbiAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIikgIT09IFwidHJ1ZVwiKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9hc3NpZ25lZEVsZW1lbnRzLCBhc3NpZ25lZEVsZW1lbnRzX2dldCkuZm9yRWFjaCgoZWwpID0+IGVsLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiKSk7XG4gIH1cbiAgaWYgKHRvZ2dsZSkge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gaXRlbS5nZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpID09PSBcInRydWVcIjtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpdGVtLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICB9XG4gIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjaGFuZ2VcIikpO1xufTtcbl9zZWFyY2hJdGVtID0gbmV3IFdlYWtTZXQoKTtcbnNlYXJjaEl0ZW1fZm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9jbGVhcktleXNPbkRlbGF5LCBjbGVhcktleXNPbkRlbGF5X2ZuKS5jYWxsKHRoaXMpO1xuICBjb25zdCBlbHMgPSBfX3ByaXZhdGVHZXQodGhpcywgX2l0ZW1zLCBpdGVtc19nZXQpO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGVscy5maW5kSW5kZXgoKGVsKSA9PiBlbC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSA9PT0gXCIwXCIpO1xuICBfX3ByaXZhdGVTZXQodGhpcywgX2tleXNTb0ZhciwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXlzU29GYXIpICsga2V5KTtcbiAgY29uc3QgcmVwZWF0ZWRLZXkgPSBfX3ByaXZhdGVHZXQodGhpcywgX2tleXNTb0Zhcikuc3BsaXQoXCJcIikuZXZlcnkoKGspID0+IGsgPT09IGtleSk7XG4gIGNvbnN0IGFmdGVyID0gZWxzLnNsaWNlKGFjdGl2ZUluZGV4ICsgKHJlcGVhdGVkS2V5ID8gMSA6IDApKS5maWx0ZXIoKGVsKSA9PiBlbC50ZXh0Q29udGVudC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoX19wcml2YXRlR2V0KHRoaXMsIF9rZXlzU29GYXIpKSk7XG4gIGNvbnN0IGJlZm9yZSA9IGVscy5zbGljZSgwLCBhY3RpdmVJbmRleCAtIChyZXBlYXRlZEtleSA/IDEgOiAwKSkuZmlsdGVyKChlbCkgPT4gZWwudGV4dENvbnRlbnQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5c1NvRmFyKSkpO1xuICBsZXQgYWZ0ZXJSZXBlYXRlZCA9IFtdO1xuICBsZXQgYmVmb3JlUmVwZWF0ZWQgPSBbXTtcbiAgaWYgKHJlcGVhdGVkS2V5KSB7XG4gICAgYWZ0ZXJSZXBlYXRlZCA9IGVscy5zbGljZShhY3RpdmVJbmRleCArIChyZXBlYXRlZEtleSA/IDEgOiAwKSkuZmlsdGVyKChlbCkgPT4gZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aChrZXkpKTtcbiAgICBiZWZvcmVSZXBlYXRlZCA9IGVscy5zbGljZSgwLCBhY3RpdmVJbmRleCAtIChyZXBlYXRlZEtleSA/IDEgOiAwKSkuZmlsdGVyKChlbCkgPT4gZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aChrZXkpKTtcbiAgfVxuICBjb25zdCByZXR1cm5zID0gWy4uLmFmdGVyLCAuLi5iZWZvcmUsIC4uLmFmdGVyUmVwZWF0ZWQsIC4uLmJlZm9yZVJlcGVhdGVkXTtcbiAgcmV0dXJuIHJldHVybnNbMF07XG59O1xuX2NsZWFyS2V5c09uRGVsYXkgPSBuZXcgV2Vha1NldCgpO1xuY2xlYXJLZXlzT25EZWxheV9mbiA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQoX19wcml2YXRlR2V0KHRoaXMsIF9jbGVhcktleXNUaW1lb3V0KSk7XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xlYXJLZXlzVGltZW91dCwgbnVsbCk7XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xlYXJLZXlzVGltZW91dCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9rZXlzU29GYXIsIFwiXCIpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xlYXJLZXlzVGltZW91dCwgbnVsbCk7XG4gIH0sIDUwMCkpO1xufTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1jaHJvbWUtbGlzdGJveFwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLWNocm9tZS1saXN0Ym94XCIsIE1lZGlhQ2hyb21lTGlzdGJveCk7XG59XG52YXIgbWVkaWFfY2hyb21lX2xpc3Rib3hfZGVmYXVsdCA9IE1lZGlhQ2hyb21lTGlzdGJveDtcbmV4cG9ydCB7XG4gIG1lZGlhX2Nocm9tZV9saXN0Ym94X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listbox.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listitem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/media-chrome/dist/experimental/media-chrome-listitem.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_chrome_listitem_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\n  :host {\n    display: list-item;\n    line-height: 1em;\n    padding: 0.5em;\n    margin: 0em;\n    cursor: pointer;\n  }\n\n  ::slotted:not(:focus-visible) {\n    outline: none;\n  }\n</style>\n<li>\n  <slot></slot>\n</li>\n`;\nconst Attributes = {\n  VALUE: \"value\"\n};\nclass MediaChromeListitem extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.HTMLElement {\n  static get observedAttributes() {\n    return [\n      \"disabled\",\n      \"aria-selected\",\n      Attributes.VALUE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    ];\n  }\n  constructor() {\n    super();\n    if (!this.shadowRoot) {\n      const shadow = this.attachShadow({ mode: \"open\" });\n      const listitemHTML = template.content.cloneNode(true);\n      this.nativeEl = listitemHTML;\n      shadow.appendChild(listitemHTML);\n    }\n  }\n  set value(value) {\n    this.setAttribute(Attributes.VALUE, value);\n  }\n  get value() {\n    return this.getAttribute(Attributes.VALUE);\n  }\n  enable() {\n    if (!this.hasAttribute(\"tabindex\")) {\n      this.setAttribute(\"tabindex\", -1);\n    }\n    if (!this.hasAttribute(\"aria-selected\")) {\n      this.setAttribute(\"aria-selected\", \"false\");\n    }\n  }\n  disable() {\n    this.removeAttribute(\"tabindex\");\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(oldValue);\n        (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n      }\n      if (newValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(newValue);\n        (_b = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _b.call(mediaControllerEl, this);\n      }\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n  }\n  connectedCallback() {\n    var _a;\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    this.setAttribute(\"role\", \"option\");\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a;\n    this.disable();\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n    }\n  }\n  handleClick() {\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-chrome-listitem\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-chrome-listitem\", MediaChromeListitem);\n}\nvar media_chrome_listitem_default = MediaChromeListitem;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jaHJvbWUtbGlzdGl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRDtBQUNRO0FBQ3ZFLGlCQUFpQixtRUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxRUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQSxrQ0FBa0MsbUVBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1FQUFRO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQyxtRUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUVBQTRCO0FBQ2xDO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jaHJvbWUtbGlzdGl0ZW0uanM/ODJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG4gIDpob3N0IHtcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XG4gICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICBwYWRkaW5nOiAwLjVlbTtcbiAgICBtYXJnaW46IDBlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cblxuICA6OnNsb3R0ZWQ6bm90KDpmb2N1cy12aXNpYmxlKSB7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgfVxuPC9zdHlsZT5cbjxsaT5cbiAgPHNsb3Q+PC9zbG90PlxuPC9saT5cbmA7XG5jb25zdCBBdHRyaWJ1dGVzID0ge1xuICBWQUxVRTogXCJ2YWx1ZVwiXG59O1xuY2xhc3MgTWVkaWFDaHJvbWVMaXN0aXRlbSBleHRlbmRzIGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXNhYmxlZFwiLFxuICAgICAgXCJhcmlhLXNlbGVjdGVkXCIsXG4gICAgICBBdHRyaWJ1dGVzLlZBTFVFLFxuICAgICAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXG4gICAgXTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICBjb25zdCBzaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgY29uc3QgbGlzdGl0ZW1IVE1MID0gdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0aGlzLm5hdGl2ZUVsID0gbGlzdGl0ZW1IVE1MO1xuICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGxpc3RpdGVtSFRNTCk7XG4gICAgfVxuICB9XG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKEF0dHJpYnV0ZXMuVkFMVUUsIHZhbHVlKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKEF0dHJpYnV0ZXMuVkFMVUUpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIikpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGF0dHJOYW1lID09PSBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVIpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9sZFZhbHVlKTtcbiAgICAgICAgKF9hID0gbWVkaWFDb250cm9sbGVyRWwgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhQ29udHJvbGxlckVsLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmV3VmFsdWUpO1xuICAgICAgICAoX2IgPSBtZWRpYUNvbnRyb2xsZXJFbCA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDb250cm9sbGVyRWwuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09IFwiZGlzYWJsZWRcIiAmJiBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICApO1xuICAgIGlmIChtZWRpYUNvbnRyb2xsZXJJZCkge1xuICAgICAgY29uc3QgbWVkaWFDb250cm9sbGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZWRpYUNvbnRyb2xsZXJJZCk7XG4gICAgICAoX2EgPSBtZWRpYUNvbnRyb2xsZXJFbCA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDb250cm9sbGVyRWwuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgY29uc3QgbWVkaWFDb250cm9sbGVySWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUlxuICAgICk7XG4gICAgaWYgKG1lZGlhQ29udHJvbGxlcklkKSB7XG4gICAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1lZGlhQ29udHJvbGxlcklkKTtcbiAgICAgIChfYSA9IG1lZGlhQ29udHJvbGxlckVsID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNvbnRyb2xsZXJFbC51bmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG1lZGlhQ29udHJvbGxlckVsLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2xpY2soKSB7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1jaHJvbWUtbGlzdGl0ZW1cIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1jaHJvbWUtbGlzdGl0ZW1cIiwgTWVkaWFDaHJvbWVMaXN0aXRlbSk7XG59XG52YXIgbWVkaWFfY2hyb21lX2xpc3RpdGVtX2RlZmF1bHQgPSBNZWRpYUNocm9tZUxpc3RpdGVtO1xuZXhwb3J0IHtcbiAgQXR0cmlidXRlcyxcbiAgbWVkaWFfY2hyb21lX2xpc3RpdGVtX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listitem.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-selectmenu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/media-chrome/dist/experimental/media-chrome-selectmenu.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_chrome_selectmenu_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _media_chrome_listbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./media-chrome-listbox.js */ \"(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-listbox.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _handleClick, _handleChange, _enabledState, _button, _buttonSlot, _listbox, _listboxSlot, _expanded, _keyupListener, _keydownListener, _documentClickHandler, _handleClick_, handleClick__fn, _handleChange_, handleChange__fn, _toggle, toggle_fn, _updateMenuPosition, updateMenuPosition_fn, _toggleExpanded, toggleExpanded_fn;\n\n\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n  :host {\n    display: inline-flex;\n    position: relative;\n    flex-shrink: .5;\n  }\n\n  [name=\"listbox\"]::slotted(*),\n  [part=listbox] {\n    position: absolute;\n    left: 0;\n    bottom: 100%;\n    max-height: 300px;\n    overflow: hidden auto;\n  }\n  </style>\n\n  <slot name=\"button\">\n    <media-chrome-button aria-haspopup=\"listbox\" part=\"button\">\n      <slot name=\"button-content\"></slot>\n    </media-chrome-button>\n  </slot>\n  <slot name=\"listbox\" hidden>\n    <media-chrome-listbox id=\"listbox\" part=\"listbox\">\n      <slot></slot>\n    </media-chrome-listbox>\n  </slot>\n`;\nclass MediaChromeSelectMenu extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor() {\n    var _a;\n    super();\n    __privateAdd(this, _handleClick_);\n    __privateAdd(this, _handleChange_);\n    __privateAdd(this, _toggle);\n    __privateAdd(this, _updateMenuPosition);\n    __privateAdd(this, _toggleExpanded);\n    __privateAdd(this, _handleClick, void 0);\n    __privateAdd(this, _handleChange, void 0);\n    __privateAdd(this, _enabledState, true);\n    __privateAdd(this, _button, void 0);\n    __privateAdd(this, _buttonSlot, void 0);\n    __privateAdd(this, _listbox, void 0);\n    __privateAdd(this, _listboxSlot, void 0);\n    __privateAdd(this, _expanded, false);\n    __privateAdd(this, _keyupListener, (e) => {\n      const { key } = e;\n      if (!this.keysUsed.includes(key)) {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      const isButton = e.composedPath().includes(__privateGet(this, _button));\n      if (isButton && (key === \"Enter\" || key === \" \")) {\n        __privateGet(this, _handleClick).call(this);\n      } else if (key === \"Escape\" && !__privateGet(this, _listboxSlot).hidden) {\n        __privateMethod(this, _toggle, toggle_fn).call(this);\n      }\n    });\n    __privateAdd(this, _keydownListener, (e) => {\n      const { metaKey, altKey, key } = e;\n      if (metaKey || altKey || !this.keysUsed.includes(key)) {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      e.preventDefault();\n      this.addEventListener(\"keyup\", __privateGet(this, _keyupListener), { once: true });\n    });\n    __privateAdd(this, _documentClickHandler, (e) => {\n      if (e.composedPath().includes(this))\n        return;\n      if (!__privateGet(this, _listboxSlot).hidden) {\n        __privateMethod(this, _toggle, toggle_fn).call(this);\n      }\n    });\n    if (!this.shadowRoot) {\n      const shadow = this.attachShadow({ mode: \"open\" });\n      const buttonHTML = template.content.cloneNode(true);\n      this.nativeEl = buttonHTML;\n      shadow.appendChild(buttonHTML);\n    }\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    style.setProperty(\"display\", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`);\n    __privateSet(this, _handleClick, __privateMethod(this, _handleClick_, handleClick__fn).bind(this));\n    __privateSet(this, _handleChange, __privateMethod(this, _handleChange_, handleChange__fn).bind(this));\n    (_a = this.init) == null ? void 0 : _a.call(this);\n    __privateSet(this, _button, this.shadowRoot.querySelector(\"[part=button]\"));\n    __privateSet(this, _listbox, this.shadowRoot.querySelector(\"[part=listbox]\"));\n    __privateSet(this, _buttonSlot, this.shadowRoot.querySelector(\"slot[name=button]\"));\n    __privateGet(this, _buttonSlot).addEventListener(\"slotchange\", () => {\n      const newButton = __privateGet(this, _buttonSlot).assignedElements()[0];\n      if (!newButton)\n        return;\n      this.disable();\n      __privateSet(this, _button, newButton);\n      __privateGet(this, _button).preventClick = true;\n      if (__privateGet(this, _button).hasAttribute(\"disabled\")) {\n        __privateSet(this, _enabledState, false);\n      }\n      if (__privateGet(this, _enabledState)) {\n        this.enable();\n        __privateGet(this, _button).setAttribute(\"aria-haspopup\", \"listbox\");\n      } else {\n        this.disable();\n      }\n    });\n    __privateSet(this, _listboxSlot, this.shadowRoot.querySelector(\"slot[name=listbox]\"));\n    __privateGet(this, _listboxSlot).addEventListener(\"slotchange\", () => {\n      this.disable();\n      __privateSet(this, _listbox, __privateGet(this, _listboxSlot).assignedElements()[0] || __privateGet(this, _listbox));\n      this.enable();\n    });\n  }\n  static get observedAttributes() {\n    return [\n      \"disabled\",\n      _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    ];\n  }\n  enable() {\n    __privateGet(this, _button).removeAttribute(\"disabled\");\n    __privateGet(this, _button).addEventListener(\"click\", __privateGet(this, _handleClick));\n    __privateGet(this, _button).addEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    __privateGet(this, _listbox).addEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    __privateMethod(this, _toggleExpanded, toggleExpanded_fn).call(this);\n    __privateGet(this, _listbox).addEventListener(\"change\", __privateGet(this, _handleChange));\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.addEventListener(\"click\", __privateGet(this, _documentClickHandler));\n  }\n  disable() {\n    __privateGet(this, _button).setAttribute(\"disabled\", \"\");\n    __privateGet(this, _button).removeEventListener(\"click\", __privateGet(this, _handleClick));\n    __privateGet(this, _button).removeEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    __privateGet(this, _button).removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n    __privateGet(this, _listbox).removeEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    __privateGet(this, _listbox).removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n    __privateGet(this, _listbox).addEventListener(\"change\", __privateGet(this, _handleChange));\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.removeEventListener(\"click\", __privateGet(this, _documentClickHandler));\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.getElementById(oldValue);\n        (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n        __privateGet(this, _listbox).removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER);\n      }\n      if (newValue) {\n        const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.getElementById(newValue);\n        (_b = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _b.call(mediaControllerEl, this);\n        __privateGet(this, _listbox).setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER, newValue);\n      }\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        __privateSet(this, _enabledState, true);\n        this.enable();\n      } else {\n        __privateSet(this, _enabledState, false);\n        this.disable();\n      }\n    }\n  }\n  connectedCallback() {\n    var _a;\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.associateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n      __privateGet(this, _listbox).setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER, mediaControllerId);\n    }\n  }\n  disconnectedCallback() {\n    var _a;\n    this.disable();\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      const mediaControllerEl = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.getElementById(mediaControllerId);\n      (_a = mediaControllerEl == null ? void 0 : mediaControllerEl.unassociateElement) == null ? void 0 : _a.call(mediaControllerEl, this);\n      __privateGet(this, _listbox).removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaStateReceiverAttributes.MEDIA_CONTROLLER);\n    }\n  }\n  get keysUsed() {\n    return [\"Enter\", \"Escape\", \" \", \"ArrowUp\", \"ArrowDown\", \"f\", \"c\", \"k\", \"m\"];\n  }\n}\n_handleClick = new WeakMap();\n_handleChange = new WeakMap();\n_enabledState = new WeakMap();\n_button = new WeakMap();\n_buttonSlot = new WeakMap();\n_listbox = new WeakMap();\n_listboxSlot = new WeakMap();\n_expanded = new WeakMap();\n_keyupListener = new WeakMap();\n_keydownListener = new WeakMap();\n_documentClickHandler = new WeakMap();\n_handleClick_ = new WeakSet();\nhandleClick__fn = function() {\n  __privateMethod(this, _toggle, toggle_fn).call(this);\n};\n_handleChange_ = new WeakSet();\nhandleChange__fn = function() {\n  __privateMethod(this, _toggle, toggle_fn).call(this, true);\n};\n_toggle = new WeakSet();\ntoggle_fn = function(closeOnly) {\n  __privateGet(this, _listboxSlot).hidden = !__privateGet(this, _listboxSlot).hidden || closeOnly;\n  __privateMethod(this, _toggleExpanded, toggleExpanded_fn).call(this, closeOnly);\n  if (!__privateGet(this, _listboxSlot).hidden) {\n    __privateGet(this, _listbox).focus();\n    __privateMethod(this, _updateMenuPosition, updateMenuPosition_fn).call(this);\n  } else if (this.shadowRoot.activeElement === __privateGet(this, _listbox) || __privateGet(this, _listbox).contains(this.shadowRoot.activeElement)) {\n    __privateGet(this, _button).focus();\n  }\n};\n_updateMenuPosition = new WeakSet();\nupdateMenuPosition_fn = function() {\n  var _a;\n  if (__privateGet(this, _listbox).offsetWidth === 0)\n    return;\n  const buttonRect = __privateGet(this, _button).getBoundingClientRect();\n  if (this.hasAttribute(\"mediacontroller\") || __privateGet(this, _button).hasAttribute(\"mediacontroller\") || __privateGet(this, _listbox).hasAttribute(\"mediacontroller\")) {\n    __privateGet(this, _listbox).style.zIndex = \"1\";\n    __privateGet(this, _listbox).style.bottom = \"unset\";\n    __privateGet(this, _listbox).style.top = buttonRect.height + \"px\";\n    return;\n  }\n  const bounds = (_a = this.getAttribute(\"bounds\") ? (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.closestComposedNode)(this, `#${this.getAttribute(\"bounds\")}`) : this.parentElement) != null ? _a : this;\n  const boundsRect = bounds.getBoundingClientRect();\n  const listboxRect = __privateGet(this, _listbox).getBoundingClientRect();\n  let position = -Math.max(buttonRect.x + listboxRect.width - boundsRect.right, 0);\n  __privateGet(this, _listbox).style.transform = `translateX(${position}px)`;\n};\n_toggleExpanded = new WeakSet();\ntoggleExpanded_fn = function(closeOnly = false) {\n  __privateSet(this, _expanded, !__privateGet(this, _expanded) || closeOnly);\n  __privateGet(this, _button).setAttribute(\"aria-expanded\", __privateGet(this, _expanded));\n};\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-chrome-selectmenu\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-chrome-selectmenu\", MediaChromeSelectMenu);\n}\nvar media_chrome_selectmenu_default = MediaChromeSelectMenu;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS1jaHJvbWUtc2VsZWN0bWVudS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQ0E7QUFDb0M7QUFDYTtBQUNyQjtBQUMvRCxpQkFBaUIsbUVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxZQUFZO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxFQUFFLDJFQUFrQjtBQUN4Qyx1RUFBdUUsZUFBZTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQSxrQ0FBa0MsbUVBQVE7QUFDMUM7QUFDQSxxREFBcUQsdUVBQTRCO0FBQ2pGO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQVE7QUFDMUM7QUFDQSxrREFBa0QsdUVBQTRCO0FBQzlFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQyxtRUFBUTtBQUN4QztBQUNBLGdEQUFnRCx1RUFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQyxtRUFBUTtBQUN4QztBQUNBLG1EQUFtRCx1RUFBNEI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNEVBQW1CLFdBQVcsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9leHBlcmltZW50YWwvbWVkaWEtY2hyb21lLXNlbGVjdG1lbnUuanM/MjcwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX2hhbmRsZUNsaWNrLCBfaGFuZGxlQ2hhbmdlLCBfZW5hYmxlZFN0YXRlLCBfYnV0dG9uLCBfYnV0dG9uU2xvdCwgX2xpc3Rib3gsIF9saXN0Ym94U2xvdCwgX2V4cGFuZGVkLCBfa2V5dXBMaXN0ZW5lciwgX2tleWRvd25MaXN0ZW5lciwgX2RvY3VtZW50Q2xpY2tIYW5kbGVyLCBfaGFuZGxlQ2xpY2tfLCBoYW5kbGVDbGlja19fZm4sIF9oYW5kbGVDaGFuZ2VfLCBoYW5kbGVDaGFuZ2VfX2ZuLCBfdG9nZ2xlLCB0b2dnbGVfZm4sIF91cGRhdGVNZW51UG9zaXRpb24sIHVwZGF0ZU1lbnVQb3NpdGlvbl9mbiwgX3RvZ2dsZUV4cGFuZGVkLCB0b2dnbGVFeHBhbmRlZF9mbjtcbmltcG9ydCBcIi4uL21lZGlhLWNocm9tZS1idXR0b24uanNcIjtcbmltcG9ydCBcIi4vbWVkaWEtY2hyb21lLWxpc3Rib3guanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IGNsb3Nlc3RDb21wb3NlZE5vZGUsIGdldE9ySW5zZXJ0Q1NTUnVsZSB9IGZyb20gXCIuLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5pbXBvcnQgeyBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmbGV4LXNocmluazogLjU7XG4gIH1cblxuICBbbmFtZT1cImxpc3Rib3hcIl06OnNsb3R0ZWQoKiksXG4gIFtwYXJ0PWxpc3Rib3hdIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICBib3R0b206IDEwMCU7XG4gICAgbWF4LWhlaWdodDogMzAwcHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbiBhdXRvO1xuICB9XG4gIDwvc3R5bGU+XG5cbiAgPHNsb3QgbmFtZT1cImJ1dHRvblwiPlxuICAgIDxtZWRpYS1jaHJvbWUtYnV0dG9uIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCIgcGFydD1cImJ1dHRvblwiPlxuICAgICAgPHNsb3QgbmFtZT1cImJ1dHRvbi1jb250ZW50XCI+PC9zbG90PlxuICAgIDwvbWVkaWEtY2hyb21lLWJ1dHRvbj5cbiAgPC9zbG90PlxuICA8c2xvdCBuYW1lPVwibGlzdGJveFwiIGhpZGRlbj5cbiAgICA8bWVkaWEtY2hyb21lLWxpc3Rib3ggaWQ9XCJsaXN0Ym94XCIgcGFydD1cImxpc3Rib3hcIj5cbiAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L21lZGlhLWNocm9tZS1saXN0Ym94PlxuICA8L3Nsb3Q+XG5gO1xuY2xhc3MgTWVkaWFDaHJvbWVTZWxlY3RNZW51IGV4dGVuZHMgZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQ2xpY2tfKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUNoYW5nZV8pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdG9nZ2xlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3VwZGF0ZU1lbnVQb3NpdGlvbik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90b2dnbGVFeHBhbmRlZCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVDbGljaywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUNoYW5nZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VuYWJsZWRTdGF0ZSwgdHJ1ZSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9idXR0b24sIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9idXR0b25TbG90LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGlzdGJveCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xpc3Rib3hTbG90LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZXhwYW5kZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2tleXVwTGlzdGVuZXIsIChlKSA9PiB7XG4gICAgICBjb25zdCB7IGtleSB9ID0gZTtcbiAgICAgIGlmICghdGhpcy5rZXlzVXNlZC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5dXBMaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0J1dHRvbiA9IGUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pKTtcbiAgICAgIGlmIChpc0J1dHRvbiAmJiAoa2V5ID09PSBcIkVudGVyXCIgfHwga2V5ID09PSBcIiBcIikpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbGljaykuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIkVzY2FwZVwiICYmICFfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3hTbG90KS5oaWRkZW4pIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF90b2dnbGUsIHRvZ2dsZV9mbikuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2tleWRvd25MaXN0ZW5lciwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgbWV0YUtleSwgYWx0S2V5LCBrZXkgfSA9IGU7XG4gICAgICBpZiAobWV0YUtleSB8fCBhbHRLZXkgfHwgIXRoaXMua2V5c1VzZWQuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleXVwTGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXl1cExpc3RlbmVyKSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZG9jdW1lbnRDbGlja0hhbmRsZXIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3hTbG90KS5oaWRkZW4pIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF90b2dnbGUsIHRvZ2dsZV9mbikuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgY29uc3Qgc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIGNvbnN0IGJ1dHRvbkhUTUwgPSB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHRoaXMubmF0aXZlRWwgPSBidXR0b25IVE1MO1xuICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGJ1dHRvbkhUTUwpO1xuICAgIH1cbiAgICBjb25zdCB7IHN0eWxlIH0gPSBnZXRPckluc2VydENTU1J1bGUodGhpcy5zaGFkb3dSb290LCBcIjpob3N0XCIpO1xuICAgIHN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBgdmFyKC0tbWVkaWEtY29udHJvbC1kaXNwbGF5LCB2YXIoLS0ke3RoaXMubG9jYWxOYW1lfS1kaXNwbGF5LCBpbmxpbmUtZmxleCkpYCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9oYW5kbGVDbGljaywgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9oYW5kbGVDbGlja18sIGhhbmRsZUNsaWNrX19mbikuYmluZCh0aGlzKSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9oYW5kbGVDaGFuZ2UsIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfaGFuZGxlQ2hhbmdlXywgaGFuZGxlQ2hhbmdlX19mbikuYmluZCh0aGlzKSk7XG4gICAgKF9hID0gdGhpcy5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2J1dHRvbiwgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJbcGFydD1idXR0b25dXCIpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2xpc3Rib3gsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiW3BhcnQ9bGlzdGJveF1cIikpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYnV0dG9uU2xvdCwgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzbG90W25hbWU9YnV0dG9uXVwiKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b25TbG90KS5hZGRFdmVudExpc3RlbmVyKFwic2xvdGNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdCdXR0b24gPSBfX3ByaXZhdGVHZXQodGhpcywgX2J1dHRvblNsb3QpLmFzc2lnbmVkRWxlbWVudHMoKVswXTtcbiAgICAgIGlmICghbmV3QnV0dG9uKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYnV0dG9uLCBuZXdCdXR0b24pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLnByZXZlbnRDbGljayA9IHRydWU7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZW5hYmxlZFN0YXRlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9lbmFibGVkU3RhdGUpKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwibGlzdGJveFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGlzdGJveFNsb3QsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic2xvdFtuYW1lPWxpc3Rib3hdXCIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3hTbG90KS5hZGRFdmVudExpc3RlbmVyKFwic2xvdGNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGlzdGJveCwgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94U2xvdCkuYXNzaWduZWRFbGVtZW50cygpWzBdIHx8IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkpO1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXNhYmxlZFwiLFxuICAgICAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXG4gICAgXTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbGljaykpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleWRvd25MaXN0ZW5lcikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXlkb3duTGlzdGVuZXIpKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3RvZ2dsZUV4cGFuZGVkLCB0b2dnbGVFeHBhbmRlZF9mbikuY2FsbCh0aGlzKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDaGFuZ2UpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9kb2N1bWVudENsaWNrSGFuZGxlcikpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbGljaykpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleWRvd25MaXN0ZW5lcikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXl1cExpc3RlbmVyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleWRvd25MaXN0ZW5lcikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5dXBMaXN0ZW5lcikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUNoYW5nZSkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2RvY3VtZW50Q2xpY2tIYW5kbGVyKSk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKSB7XG4gICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVkaWFDb250cm9sbGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvbGRWYWx1ZSk7XG4gICAgICAgIChfYSA9IG1lZGlhQ29udHJvbGxlckVsID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNvbnRyb2xsZXJFbC51bmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG1lZGlhQ29udHJvbGxlckVsLCB0aGlzKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVBdHRyaWJ1dGUoTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5ld1ZhbHVlKTtcbiAgICAgICAgKF9iID0gbWVkaWFDb250cm9sbGVyRWwgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhQ29udHJvbGxlckVsLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG1lZGlhQ29udHJvbGxlckVsLCB0aGlzKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zZXRBdHRyaWJ1dGUoTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gXCJkaXNhYmxlZFwiICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9lbmFibGVkU3RhdGUsIHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9lbmFibGVkU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICApO1xuICAgIGlmIChtZWRpYUNvbnRyb2xsZXJJZCkge1xuICAgICAgY29uc3QgbWVkaWFDb250cm9sbGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZWRpYUNvbnRyb2xsZXJJZCk7XG4gICAgICAoX2EgPSBtZWRpYUNvbnRyb2xsZXJFbCA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDb250cm9sbGVyRWwuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zZXRBdHRyaWJ1dGUoTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSLCBtZWRpYUNvbnRyb2xsZXJJZCk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKFxuICAgICAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXG4gICAgKTtcbiAgICBpZiAobWVkaWFDb250cm9sbGVySWQpIHtcbiAgICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVkaWFDb250cm9sbGVySWQpO1xuICAgICAgKF9hID0gbWVkaWFDb250cm9sbGVyRWwgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhQ29udHJvbGxlckVsLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobWVkaWFDb250cm9sbGVyRWwsIHRoaXMpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVBdHRyaWJ1dGUoTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGtleXNVc2VkKCkge1xuICAgIHJldHVybiBbXCJFbnRlclwiLCBcIkVzY2FwZVwiLCBcIiBcIiwgXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCIsIFwiZlwiLCBcImNcIiwgXCJrXCIsIFwibVwiXTtcbiAgfVxufVxuX2hhbmRsZUNsaWNrID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVDaGFuZ2UgPSBuZXcgV2Vha01hcCgpO1xuX2VuYWJsZWRTdGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5fYnV0dG9uID0gbmV3IFdlYWtNYXAoKTtcbl9idXR0b25TbG90ID0gbmV3IFdlYWtNYXAoKTtcbl9saXN0Ym94ID0gbmV3IFdlYWtNYXAoKTtcbl9saXN0Ym94U2xvdCA9IG5ldyBXZWFrTWFwKCk7XG5fZXhwYW5kZWQgPSBuZXcgV2Vha01hcCgpO1xuX2tleXVwTGlzdGVuZXIgPSBuZXcgV2Vha01hcCgpO1xuX2tleWRvd25MaXN0ZW5lciA9IG5ldyBXZWFrTWFwKCk7XG5fZG9jdW1lbnRDbGlja0hhbmRsZXIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUNsaWNrXyA9IG5ldyBXZWFrU2V0KCk7XG5oYW5kbGVDbGlja19fZm4gPSBmdW5jdGlvbigpIHtcbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF90b2dnbGUsIHRvZ2dsZV9mbikuY2FsbCh0aGlzKTtcbn07XG5faGFuZGxlQ2hhbmdlXyA9IG5ldyBXZWFrU2V0KCk7XG5oYW5kbGVDaGFuZ2VfX2ZuID0gZnVuY3Rpb24oKSB7XG4gIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfdG9nZ2xlLCB0b2dnbGVfZm4pLmNhbGwodGhpcywgdHJ1ZSk7XG59O1xuX3RvZ2dsZSA9IG5ldyBXZWFrU2V0KCk7XG50b2dnbGVfZm4gPSBmdW5jdGlvbihjbG9zZU9ubHkpIHtcbiAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94U2xvdCkuaGlkZGVuID0gIV9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveFNsb3QpLmhpZGRlbiB8fCBjbG9zZU9ubHk7XG4gIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfdG9nZ2xlRXhwYW5kZWQsIHRvZ2dsZUV4cGFuZGVkX2ZuKS5jYWxsKHRoaXMsIGNsb3NlT25seSk7XG4gIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94U2xvdCkuaGlkZGVuKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5mb2N1cygpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfdXBkYXRlTWVudVBvc2l0aW9uLCB1cGRhdGVNZW51UG9zaXRpb25fZm4pLmNhbGwodGhpcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQgPT09IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkgfHwgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5jb250YWlucyh0aGlzLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCkpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2J1dHRvbikuZm9jdXMoKTtcbiAgfVxufTtcbl91cGRhdGVNZW51UG9zaXRpb24gPSBuZXcgV2Vha1NldCgpO1xudXBkYXRlTWVudVBvc2l0aW9uX2ZuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfYTtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkub2Zmc2V0V2lkdGggPT09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBidXR0b25SZWN0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoXCJtZWRpYWNvbnRyb2xsZXJcIikgfHwgX19wcml2YXRlR2V0KHRoaXMsIF9idXR0b24pLmhhc0F0dHJpYnV0ZShcIm1lZGlhY29udHJvbGxlclwiKSB8fCBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmhhc0F0dHJpYnV0ZShcIm1lZGlhY29udHJvbGxlclwiKSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuc3R5bGUuekluZGV4ID0gXCIxXCI7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zdHlsZS5ib3R0b20gPSBcInVuc2V0XCI7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zdHlsZS50b3AgPSBidXR0b25SZWN0LmhlaWdodCArIFwicHhcIjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYm91bmRzID0gKF9hID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJib3VuZHNcIikgPyBjbG9zZXN0Q29tcG9zZWROb2RlKHRoaXMsIGAjJHt0aGlzLmdldEF0dHJpYnV0ZShcImJvdW5kc1wiKX1gKSA6IHRoaXMucGFyZW50RWxlbWVudCkgIT0gbnVsbCA/IF9hIDogdGhpcztcbiAgY29uc3QgYm91bmRzUmVjdCA9IGJvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgbGlzdGJveFJlY3QgPSBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgcG9zaXRpb24gPSAtTWF0aC5tYXgoYnV0dG9uUmVjdC54ICsgbGlzdGJveFJlY3Qud2lkdGggLSBib3VuZHNSZWN0LnJpZ2h0LCAwKTtcbiAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3Bvc2l0aW9ufXB4KWA7XG59O1xuX3RvZ2dsZUV4cGFuZGVkID0gbmV3IFdlYWtTZXQoKTtcbnRvZ2dsZUV4cGFuZGVkX2ZuID0gZnVuY3Rpb24oY2xvc2VPbmx5ID0gZmFsc2UpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9leHBhbmRlZCwgIV9fcHJpdmF0ZUdldCh0aGlzLCBfZXhwYW5kZWQpIHx8IGNsb3NlT25seSk7XG4gIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnV0dG9uKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXhwYW5kZWQpKTtcbn07XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtY2hyb21lLXNlbGVjdG1lbnVcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1jaHJvbWUtc2VsZWN0bWVudVwiLCBNZWRpYUNocm9tZVNlbGVjdE1lbnUpO1xufVxudmFyIG1lZGlhX2Nocm9tZV9zZWxlY3RtZW51X2RlZmF1bHQgPSBNZWRpYUNocm9tZVNlbGVjdE1lbnU7XG5leHBvcnQge1xuICBtZWRpYV9jaHJvbWVfc2VsZWN0bWVudV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/experimental/media-chrome-selectmenu.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/media-chrome/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaAirplayButton: function() { return /* reexport safe */ _media_airplay_button_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   MediaCaptionsButton: function() { return /* reexport safe */ _media_captions_button_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; },\n/* harmony export */   MediaCastButton: function() { return /* reexport safe */ _media_cast_button_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   MediaChromeButton: function() { return /* reexport safe */ _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; },\n/* harmony export */   MediaChromeRange: function() { return /* reexport safe */ _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   MediaControlBar: function() { return /* reexport safe */ _media_control_bar_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; },\n/* harmony export */   MediaController: function() { return /* reexport safe */ _media_controller_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   MediaDurationDisplay: function() { return /* reexport safe */ _media_duration_display_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; },\n/* harmony export */   MediaFullscreenButton: function() { return /* reexport safe */ _media_fullscreen_button_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; },\n/* harmony export */   MediaGestureReceiver: function() { return /* reexport safe */ _media_gesture_receiver_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   MediaLiveButton: function() { return /* reexport safe */ _media_live_button_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; },\n/* harmony export */   MediaLoadingIndicator: function() { return /* reexport safe */ _media_loading_indicator_js__WEBPACK_IMPORTED_MODULE_25__[\"default\"]; },\n/* harmony export */   MediaMuteButton: function() { return /* reexport safe */ _media_mute_button_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; },\n/* harmony export */   MediaPipButton: function() { return /* reexport safe */ _media_pip_button_js__WEBPACK_IMPORTED_MODULE_17__[\"default\"]; },\n/* harmony export */   MediaPlayButton: function() { return /* reexport safe */ _media_play_button_js__WEBPACK_IMPORTED_MODULE_18__[\"default\"]; },\n/* harmony export */   MediaPlaybackRateButton: function() { return /* reexport safe */ _media_playback_rate_button_js__WEBPACK_IMPORTED_MODULE_19__[\"default\"]; },\n/* harmony export */   MediaPosterImage: function() { return /* reexport safe */ _media_poster_image_js__WEBPACK_IMPORTED_MODULE_20__[\"default\"]; },\n/* harmony export */   MediaPreviewThumbnail: function() { return /* reexport safe */ _media_preview_thumbnail_js__WEBPACK_IMPORTED_MODULE_23__[\"default\"]; },\n/* harmony export */   MediaPreviewTimeDisplay: function() { return /* reexport safe */ _media_preview_time_display_js__WEBPACK_IMPORTED_MODULE_22__[\"default\"]; },\n/* harmony export */   MediaSeekBackwardButton: function() { return /* reexport safe */ _media_seek_backward_button_js__WEBPACK_IMPORTED_MODULE_21__[\"default\"]; },\n/* harmony export */   MediaSeekForwardButton: function() { return /* reexport safe */ _media_seek_forward_button_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; },\n/* harmony export */   MediaTimeDisplay: function() { return /* reexport safe */ _media_time_display_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; },\n/* harmony export */   MediaTimeRange: function() { return /* reexport safe */ _media_time_range_js__WEBPACK_IMPORTED_MODULE_24__[\"default\"]; },\n/* harmony export */   MediaVolumeRange: function() { return /* reexport safe */ _media_volume_range_js__WEBPACK_IMPORTED_MODULE_26__[\"default\"]; },\n/* harmony export */   constants: function() { return /* reexport module object */ _constants_js__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   labels: function() { return /* reexport safe */ _labels_labels_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   timeUtils: function() { return /* reexport module object */ _utils_time_js__WEBPACK_IMPORTED_MODULE_2__; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_time_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/time.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/time.js\");\n/* harmony import */ var _media_airplay_button_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./media-airplay-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-airplay-button.js\");\n/* harmony import */ var _media_cast_button_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./media-cast-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-cast-button.js\");\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _media_gesture_receiver_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./media-gesture-receiver.js */ \"(app-client)/./node_modules/media-chrome/dist/media-gesture-receiver.js\");\n/* harmony import */ var _media_controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./media-controller.js */ \"(app-client)/./node_modules/media-chrome/dist/media-controller.js\");\n/* harmony import */ var _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./media-chrome-range.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-range.js\");\n/* harmony import */ var _media_control_bar_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./media-control-bar.js */ \"(app-client)/./node_modules/media-chrome/dist/media-control-bar.js\");\n/* harmony import */ var _media_duration_display_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./media-duration-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-duration-display.js\");\n/* harmony import */ var _media_time_display_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./media-time-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-time-display.js\");\n/* harmony import */ var _media_captions_button_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./media-captions-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-captions-button.js\");\n/* harmony import */ var _media_seek_forward_button_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./media-seek-forward-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-seek-forward-button.js\");\n/* harmony import */ var _media_fullscreen_button_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./media-fullscreen-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-fullscreen-button.js\");\n/* harmony import */ var _media_live_button_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./media-live-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-live-button.js\");\n/* harmony import */ var _media_mute_button_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./media-mute-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-mute-button.js\");\n/* harmony import */ var _media_pip_button_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./media-pip-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-pip-button.js\");\n/* harmony import */ var _media_play_button_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./media-play-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-play-button.js\");\n/* harmony import */ var _media_playback_rate_button_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./media-playback-rate-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-playback-rate-button.js\");\n/* harmony import */ var _media_poster_image_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./media-poster-image.js */ \"(app-client)/./node_modules/media-chrome/dist/media-poster-image.js\");\n/* harmony import */ var _media_seek_backward_button_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./media-seek-backward-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-seek-backward-button.js\");\n/* harmony import */ var _media_preview_time_display_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./media-preview-time-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-preview-time-display.js\");\n/* harmony import */ var _media_preview_thumbnail_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./media-preview-thumbnail.js */ \"(app-client)/./node_modules/media-chrome/dist/media-preview-thumbnail.js\");\n/* harmony import */ var _media_time_range_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./media-time-range.js */ \"(app-client)/./node_modules/media-chrome/dist/media-time-range.js\");\n/* harmony import */ var _media_loading_indicator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./media-loading-indicator.js */ \"(app-client)/./node_modules/media-chrome/dist/media-loading-indicator.js\");\n/* harmony import */ var _media_volume_range_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./media-volume-range.js */ \"(app-client)/./node_modules/media-chrome/dist/media-volume-range.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNhO0FBQ1o7QUFDYztBQUNOO0FBQ0k7QUFDTTtBQUNYO0FBQ0c7QUFDRjtBQUNVO0FBQ1I7QUFDTTtBQUNPO0FBQ0g7QUFDWjtBQUNBO0FBQ0Y7QUFDRTtBQUNpQjtBQUNmO0FBQ2U7QUFDQTtBQUNMO0FBQ2Q7QUFDYztBQUNWO0FBNkJyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvaW5kZXguanM/OTZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIGRlZmF1bHQyIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0ICogYXMgdGltZVV0aWxzIGZyb20gXCIuL3V0aWxzL3RpbWUuanNcIjtcbmltcG9ydCBNZWRpYUFpcnBsYXlCdXR0b24gZnJvbSBcIi4vbWVkaWEtYWlycGxheS1idXR0b24uanNcIjtcbmltcG9ydCBNZWRpYUNhc3RCdXR0b24gZnJvbSBcIi4vbWVkaWEtY2FzdC1idXR0b24uanNcIjtcbmltcG9ydCBNZWRpYUNocm9tZUJ1dHRvbiBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgTWVkaWFHZXN0dXJlUmVjZWl2ZXIgZnJvbSBcIi4vbWVkaWEtZ2VzdHVyZS1yZWNlaXZlci5qc1wiO1xuaW1wb3J0IE1lZGlhQ29udHJvbGxlciBmcm9tIFwiLi9tZWRpYS1jb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgTWVkaWFDaHJvbWVSYW5nZSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtcmFuZ2UuanNcIjtcbmltcG9ydCBNZWRpYUNvbnRyb2xCYXIgZnJvbSBcIi4vbWVkaWEtY29udHJvbC1iYXIuanNcIjtcbmltcG9ydCBNZWRpYUR1cmF0aW9uRGlzcGxheSBmcm9tIFwiLi9tZWRpYS1kdXJhdGlvbi1kaXNwbGF5LmpzXCI7XG5pbXBvcnQgTWVkaWFUaW1lRGlzcGxheSBmcm9tIFwiLi9tZWRpYS10aW1lLWRpc3BsYXkuanNcIjtcbmltcG9ydCBNZWRpYUNhcHRpb25zQnV0dG9uIGZyb20gXCIuL21lZGlhLWNhcHRpb25zLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhU2Vla0ZvcndhcmRCdXR0b24gZnJvbSBcIi4vbWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhRnVsbHNjcmVlbkJ1dHRvbiBmcm9tIFwiLi9tZWRpYS1mdWxsc2NyZWVuLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhTGl2ZUJ1dHRvbiBmcm9tIFwiLi9tZWRpYS1saXZlLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhTXV0ZUJ1dHRvbiBmcm9tIFwiLi9tZWRpYS1tdXRlLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhUGlwQnV0dG9uIGZyb20gXCIuL21lZGlhLXBpcC1idXR0b24uanNcIjtcbmltcG9ydCBNZWRpYVBsYXlCdXR0b24gZnJvbSBcIi4vbWVkaWEtcGxheS1idXR0b24uanNcIjtcbmltcG9ydCBNZWRpYVBsYXliYWNrUmF0ZUJ1dHRvbiBmcm9tIFwiLi9tZWRpYS1wbGF5YmFjay1yYXRlLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IE1lZGlhUG9zdGVySW1hZ2UgZnJvbSBcIi4vbWVkaWEtcG9zdGVyLWltYWdlLmpzXCI7XG5pbXBvcnQgTWVkaWFTZWVrQmFja3dhcmRCdXR0b24gZnJvbSBcIi4vbWVkaWEtc2Vlay1iYWNrd2FyZC1idXR0b24uanNcIjtcbmltcG9ydCBNZWRpYVByZXZpZXdUaW1lRGlzcGxheSBmcm9tIFwiLi9tZWRpYS1wcmV2aWV3LXRpbWUtZGlzcGxheS5qc1wiO1xuaW1wb3J0IE1lZGlhUHJldmlld1RodW1ibmFpbCBmcm9tIFwiLi9tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC5qc1wiO1xuaW1wb3J0IE1lZGlhVGltZVJhbmdlIGZyb20gXCIuL21lZGlhLXRpbWUtcmFuZ2UuanNcIjtcbmltcG9ydCBNZWRpYUxvYWRpbmdJbmRpY2F0b3IgZnJvbSBcIi4vbWVkaWEtbG9hZGluZy1pbmRpY2F0b3IuanNcIjtcbmltcG9ydCBNZWRpYVZvbHVtZVJhbmdlIGZyb20gXCIuL21lZGlhLXZvbHVtZS1yYW5nZS5qc1wiO1xuZXhwb3J0IHtcbiAgTWVkaWFBaXJwbGF5QnV0dG9uLFxuICBNZWRpYUNhcHRpb25zQnV0dG9uLFxuICBNZWRpYUNhc3RCdXR0b24sXG4gIE1lZGlhQ2hyb21lQnV0dG9uLFxuICBNZWRpYUNocm9tZVJhbmdlLFxuICBNZWRpYUNvbnRyb2xCYXIsXG4gIE1lZGlhQ29udHJvbGxlcixcbiAgTWVkaWFEdXJhdGlvbkRpc3BsYXksXG4gIE1lZGlhRnVsbHNjcmVlbkJ1dHRvbixcbiAgTWVkaWFHZXN0dXJlUmVjZWl2ZXIsXG4gIE1lZGlhTGl2ZUJ1dHRvbixcbiAgTWVkaWFMb2FkaW5nSW5kaWNhdG9yLFxuICBNZWRpYU11dGVCdXR0b24sXG4gIE1lZGlhUGlwQnV0dG9uLFxuICBNZWRpYVBsYXlCdXR0b24sXG4gIE1lZGlhUGxheWJhY2tSYXRlQnV0dG9uLFxuICBNZWRpYVBvc3RlckltYWdlLFxuICBNZWRpYVByZXZpZXdUaHVtYm5haWwsXG4gIE1lZGlhUHJldmlld1RpbWVEaXNwbGF5LFxuICBNZWRpYVNlZWtCYWNrd2FyZEJ1dHRvbixcbiAgTWVkaWFTZWVrRm9yd2FyZEJ1dHRvbixcbiAgTWVkaWFUaW1lRGlzcGxheSxcbiAgTWVkaWFUaW1lUmFuZ2UsXG4gIE1lZGlhVm9sdW1lUmFuZ2UsXG4gIGNvbnN0YW50cyxcbiAgZGVmYXVsdDIgYXMgbGFiZWxzLFxuICB0aW1lVXRpbHNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/labels/labels.js":
/*!*********************************************************!*\
  !*** ./node_modules/media-chrome/dist/labels/labels.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ labels_default; },\n/* harmony export */   nouns: function() { return /* binding */ nouns; },\n/* harmony export */   verbs: function() { return /* binding */ verbs; }\n/* harmony export */ });\nconst nouns = {\n  AUDIO_PLAYER: () => \"audio player\",\n  VIDEO_PLAYER: () => \"video player\",\n  VOLUME: () => \"volume\",\n  SEEK: () => \"seek\",\n  CLOSED_CAPTIONS: () => \"closed captions\",\n  PLAYBACK_RATE: ({ playbackRate = 1 } = {}) => `current playback rate ${playbackRate}`,\n  PLAYBACK_TIME: () => `playback time`,\n  MEDIA_LOADING: () => `media loading`\n};\nconst verbs = {\n  PLAY: () => \"play\",\n  PAUSE: () => \"pause\",\n  MUTE: () => \"mute\",\n  UNMUTE: () => \"unmute\",\n  AIRPLAY: () => \"air play\",\n  ENTER_CAST: () => \"start casting\",\n  EXIT_CAST: () => \"stop casting\",\n  ENTER_FULLSCREEN: () => \"enter fullscreen mode\",\n  EXIT_FULLSCREEN: () => \"exit fullscreen mode\",\n  ENTER_PIP: () => \"enter picture in picture mode\",\n  EXIT_PIP: () => \"exit picture in picture mode\",\n  SEEK_FORWARD_N_SECS: ({ seekOffset = 30 } = {}) => `seek forward ${seekOffset} seconds`,\n  SEEK_BACK_N_SECS: ({ seekOffset = 30 } = {}) => `seek back ${seekOffset} seconds`,\n  SEEK_LIVE: () => \"seek to live\",\n  PLAYING_LIVE: () => \"playing live\"\n};\nvar labels_default = {\n  ...nouns,\n  ...verbs\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L2xhYmVscy9sYWJlbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQixJQUFJLDhCQUE4QixhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0IsSUFBSSxxQkFBcUIsWUFBWTtBQUNqRix1QkFBdUIsa0JBQWtCLElBQUksa0JBQWtCLFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbGFiZWxzL2xhYmVscy5qcz9jNjMzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG5vdW5zID0ge1xuICBBVURJT19QTEFZRVI6ICgpID0+IFwiYXVkaW8gcGxheWVyXCIsXG4gIFZJREVPX1BMQVlFUjogKCkgPT4gXCJ2aWRlbyBwbGF5ZXJcIixcbiAgVk9MVU1FOiAoKSA9PiBcInZvbHVtZVwiLFxuICBTRUVLOiAoKSA9PiBcInNlZWtcIixcbiAgQ0xPU0VEX0NBUFRJT05TOiAoKSA9PiBcImNsb3NlZCBjYXB0aW9uc1wiLFxuICBQTEFZQkFDS19SQVRFOiAoeyBwbGF5YmFja1JhdGUgPSAxIH0gPSB7fSkgPT4gYGN1cnJlbnQgcGxheWJhY2sgcmF0ZSAke3BsYXliYWNrUmF0ZX1gLFxuICBQTEFZQkFDS19USU1FOiAoKSA9PiBgcGxheWJhY2sgdGltZWAsXG4gIE1FRElBX0xPQURJTkc6ICgpID0+IGBtZWRpYSBsb2FkaW5nYFxufTtcbmNvbnN0IHZlcmJzID0ge1xuICBQTEFZOiAoKSA9PiBcInBsYXlcIixcbiAgUEFVU0U6ICgpID0+IFwicGF1c2VcIixcbiAgTVVURTogKCkgPT4gXCJtdXRlXCIsXG4gIFVOTVVURTogKCkgPT4gXCJ1bm11dGVcIixcbiAgQUlSUExBWTogKCkgPT4gXCJhaXIgcGxheVwiLFxuICBFTlRFUl9DQVNUOiAoKSA9PiBcInN0YXJ0IGNhc3RpbmdcIixcbiAgRVhJVF9DQVNUOiAoKSA9PiBcInN0b3AgY2FzdGluZ1wiLFxuICBFTlRFUl9GVUxMU0NSRUVOOiAoKSA9PiBcImVudGVyIGZ1bGxzY3JlZW4gbW9kZVwiLFxuICBFWElUX0ZVTExTQ1JFRU46ICgpID0+IFwiZXhpdCBmdWxsc2NyZWVuIG1vZGVcIixcbiAgRU5URVJfUElQOiAoKSA9PiBcImVudGVyIHBpY3R1cmUgaW4gcGljdHVyZSBtb2RlXCIsXG4gIEVYSVRfUElQOiAoKSA9PiBcImV4aXQgcGljdHVyZSBpbiBwaWN0dXJlIG1vZGVcIixcbiAgU0VFS19GT1JXQVJEX05fU0VDUzogKHsgc2Vla09mZnNldCA9IDMwIH0gPSB7fSkgPT4gYHNlZWsgZm9yd2FyZCAke3NlZWtPZmZzZXR9IHNlY29uZHNgLFxuICBTRUVLX0JBQ0tfTl9TRUNTOiAoeyBzZWVrT2Zmc2V0ID0gMzAgfSA9IHt9KSA9PiBgc2VlayBiYWNrICR7c2Vla09mZnNldH0gc2Vjb25kc2AsXG4gIFNFRUtfTElWRTogKCkgPT4gXCJzZWVrIHRvIGxpdmVcIixcbiAgUExBWUlOR19MSVZFOiAoKSA9PiBcInBsYXlpbmcgbGl2ZVwiXG59O1xudmFyIGxhYmVsc19kZWZhdWx0ID0ge1xuICAuLi5ub3VucyxcbiAgLi4udmVyYnNcbn07XG5leHBvcnQge1xuICBsYWJlbHNfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBub3VucyxcbiAgdmVyYnNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/labels/labels.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-airplay-button.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-airplay-button.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_airplay_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst airplayIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M22.13 3H3.87a.87.87 0 0 0-.87.87v13.26a.87.87 0 0 0 .87.87h3.4L9 16H5V5h16v11h-4l1.72 2h3.4a.87.87 0 0 0 .87-.87V3.87a.87.87 0 0 0-.86-.87Zm-8.75 11.44a.5.5 0 0 0-.76 0l-4.91 5.73a.5.5 0 0 0 .38.83h9.82a.501.501 0 0 0 .38-.83l-4.91-5.73Z\"/>\n</svg>\n`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <slot name=\"icon\">${airplayIcon}</slot>\n`;\nclass MediaAirplayButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.AIRPLAY());\n    super.connectedCallback();\n  }\n  get mediaAirplayUnavailable() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE);\n  }\n  set mediaAirplayUnavailable(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE, value);\n  }\n  handleClick() {\n    const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_AIRPLAY_REQUEST, {\n      composed: true,\n      bubbles: true\n    });\n    this.dispatchEvent(evt);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-airplay-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-airplay-button\", MediaAirplayButton);\n}\nvar media_airplay_button_default = MediaAirplayButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWFpcnBsYXktYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFDNkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVE7QUFDN0I7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLGlDQUFpQyxzRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0Esb0NBQW9DLG9EQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLG9CQUFvQixxRUFBVSxhQUFhLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWFpcnBsYXktYnV0dG9uLmpzPzVmZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7IGdldFN0cmluZ0F0dHIsIHNldFN0cmluZ0F0dHIgfSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBhaXJwbGF5SWNvbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjYgMjRcIj5cbiAgPHBhdGggZD1cIk0yMi4xMyAzSDMuODdhLjg3Ljg3IDAgMCAwLS44Ny44N3YxMy4yNmEuODcuODcgMCAwIDAgLjg3Ljg3aDMuNEw5IDE2SDVWNWgxNnYxMWgtNGwxLjcyIDJoMy40YS44Ny44NyAwIDAgMCAuODctLjg3VjMuODdhLjg3Ljg3IDAgMCAwLS44Ni0uODdabS04Ljc1IDExLjQ0YS41LjUgMCAwIDAtLjc2IDBsLTQuOTEgNS43M2EuNS41IDAgMCAwIC4zOC44M2g5LjgyYS41MDEuNTAxIDAgMCAwIC4zOC0uODNsLTQuOTEtNS43M1pcIi8+XG48L3N2Zz5cbmA7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c2xvdCBuYW1lPVwiaWNvblwiPiR7YWlycGxheUljb259PC9zbG90PlxuYDtcbmNsYXNzIE1lZGlhQWlycGxheUJ1dHRvbiBleHRlbmRzIE1lZGlhQ2hyb21lQnV0dG9uIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0FJUlBMQVlfVU5BVkFJTEFCTEVcbiAgICBdO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHsgc2xvdFRlbXBsYXRlLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB2ZXJicy5BSVJQTEFZKCkpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgZ2V0IG1lZGlhQWlycGxheVVuYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiBnZXRTdHJpbmdBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0FJUlBMQVlfVU5BVkFJTEFCTEUpO1xuICB9XG4gIHNldCBtZWRpYUFpcnBsYXlVbmF2YWlsYWJsZSh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQUlSUExBWV9VTkFWQUlMQUJMRSwgdmFsdWUpO1xuICB9XG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGV2dCA9IG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KE1lZGlhVUlFdmVudHMuTUVESUFfQUlSUExBWV9SRVFVRVNULCB7XG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWFpcnBsYXktYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtYWlycGxheS1idXR0b25cIiwgTWVkaWFBaXJwbGF5QnV0dG9uKTtcbn1cbnZhciBtZWRpYV9haXJwbGF5X2J1dHRvbl9kZWZhdWx0ID0gTWVkaWFBaXJwbGF5QnV0dG9uO1xuZXhwb3J0IHtcbiAgbWVkaWFfYWlycGxheV9idXR0b25fZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-airplay-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-captions-button.js":
/*!*****************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-captions-button.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_captions_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_captions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/captions.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/captions.js\");\n\n\n\n\n\nconst ccIconOn = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z\"/>\n</svg>`;\nconst ccIconOff = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M17.73 14.09a1.4 1.4 0 0 1-1 .37 1.579 1.579 0 0 1-1.27-.58A3 3 0 0 1 15 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34A2.89 2.89 0 0 0 19 9.07a3 3 0 0 0-2.14-.78 3.14 3.14 0 0 0-2.42 1 3.91 3.91 0 0 0-.93 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.17 3.17 0 0 0 1.07-1.74l-1.4-.45c-.083.43-.3.822-.62 1.12Zm-7.22 0a1.43 1.43 0 0 1-1 .37 1.58 1.58 0 0 1-1.27-.58A3 3 0 0 1 7.76 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34a2.81 2.81 0 0 0-.74-1.32 2.94 2.94 0 0 0-2.13-.78 3.18 3.18 0 0 0-2.43 1 4 4 0 0 0-.92 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.23 3.23 0 0 0 1.07-1.74l-1.4-.45a2.06 2.06 0 0 1-.6 1.07Zm12.32-8.41a2.59 2.59 0 0 0-2.3-2.51C18.72 3.05 15.86 3 13 3c-2.86 0-5.72.05-7.53.17a2.59 2.59 0 0 0-2.3 2.51c-.23 4.207-.23 8.423 0 12.63a2.57 2.57 0 0 0 2.3 2.5c1.81.13 4.67.19 7.53.19 2.86 0 5.72-.06 7.53-.19a2.57 2.57 0 0 0 2.3-2.5c.23-4.207.23-8.423 0-12.63Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.14-.21-8.29 0-12.43a1.11 1.11 0 0 1 .91-1.11C7.24 4.56 10 4.49 13 4.49s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.14.21 8.29 0 12.43Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n    :host([aria-checked=\"true\"]) slot[name=off] {\n      display: none !important;\n    }\n\n    ${\"\"}\n    :host(:not([aria-checked=\"true\"])) slot[name=on] {\n      display: none !important;\n    }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"on\">${ccIconOn}</slot>\n    <slot name=\"off\">${ccIconOff}</slot>\n  </slot>\n`;\nconst updateAriaChecked = (el) => {\n  el.setAttribute(\"aria-checked\", (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.areSubsOn)(el));\n};\nconst getSubtitlesListAttr = (el, attrName) => {\n  const attrVal = el.getAttribute(attrName);\n  return attrVal ? (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.parseTextTracksStr)(attrVal) : [];\n};\nconst setSubtitlesListAttr = (el, attrName, list) => {\n  if (!(list == null ? void 0 : list.length)) {\n    el.removeAttribute(attrName);\n    return;\n  }\n  const newValStr = (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.stringifyTextTrackList)(list);\n  const oldVal = el.getAttribute(attrName);\n  if (oldVal === newValStr)\n    return;\n  el.setAttribute(attrName, newValStr);\n};\nclass MediaCaptionsButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_LIST,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n    this._captionsReady = false;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.setAttribute(\"role\", \"switch\");\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.nouns.CLOSED_CAPTIONS());\n    updateAriaChecked(this);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING) {\n      updateAriaChecked(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaSubtitlesList() {\n    return getSubtitlesListAttr(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_LIST);\n  }\n  set mediaSubtitlesList(list) {\n    setSubtitlesListAttr(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_LIST, list);\n  }\n  get mediaSubtitlesShowing() {\n    return getSubtitlesListAttr(\n      this,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING\n    );\n  }\n  set mediaSubtitlesShowing(list) {\n    setSubtitlesListAttr(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING, list);\n  }\n  handleClick() {\n    (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.toggleSubsCaps)(this);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-captions-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-captions-button\", MediaCaptionsButton);\n}\nvar media_captions_button_default = MediaCaptionsButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNhcHRpb25zLWJ1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNkQ7QUFDUztBQUNuQjtBQUNSO0FBTWQ7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzRUFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBFQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNFQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFpQjtBQUN2QixNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0RBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDREQUFpQjtBQUN2RDtBQUNBO0FBQ0EsK0JBQStCLDREQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksa0VBQWM7QUFDbEI7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1jYXB0aW9ucy1idXR0b24uanM/MzI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZWRpYUNocm9tZUJ1dHRvbiB9IGZyb20gXCIuL21lZGlhLWNocm9tZS1idXR0b24uanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IG5vdW5zIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHtcbiAgYXJlU3Vic09uLFxuICBwYXJzZVRleHRUcmFja3NTdHIsXG4gIHN0cmluZ2lmeVRleHRUcmFja0xpc3QsXG4gIHRvZ2dsZVN1YnNDYXBzXG59IGZyb20gXCIuL3V0aWxzL2NhcHRpb25zLmpzXCI7XG5jb25zdCBjY0ljb25PbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjYgMjRcIj5cbiAgPHBhdGggZD1cIk0yMi44MyA1LjY4YTIuNTggMi41OCAwIDAgMC0yLjMtMi41Yy0zLjYyLS4yNC0xMS40NC0uMjQtMTUuMDYgMGEyLjU4IDIuNTggMCAwIDAtMi4zIDIuNWMtLjIzIDQuMjEtLjIzIDguNDMgMCAxMi42NGEyLjU4IDIuNTggMCAwIDAgMi4zIDIuNWMzLjYyLjI0IDExLjQ0LjI0IDE1LjA2IDBhMi41OCAyLjU4IDAgMCAwIDIuMy0yLjVjLjIzLTQuMjEuMjMtOC40MyAwLTEyLjY0Wm0tMTEuMzkgOS40NWEzLjA3IDMuMDcgMCAwIDEtMS45MS41NyAzLjA2IDMuMDYgMCAwIDEtMi4zNC0xIDMuNzUgMy43NSAwIDAgMS0uOTItMi42NyAzLjkyIDMuOTIgMCAwIDEgLjkyLTIuNzcgMy4xOCAzLjE4IDAgMCAxIDIuNDMtMSAyLjk0IDIuOTQgMCAwIDEgMi4xMy43OGMuMzY0LjM1OS42Mi44MTMuNzQgMS4zMWwtMS40My4zNWExLjQ5IDEuNDkgMCAwIDAtMS41MS0xLjE3IDEuNjEgMS42MSAwIDAgMC0xLjI5LjU4IDIuNzkgMi43OSAwIDAgMC0uNSAxLjg5IDMgMyAwIDAgMCAuNDkgMS45MyAxLjYxIDEuNjEgMCAwIDAgMS4yNy41OCAxLjQ4IDEuNDggMCAwIDAgMS0uMzcgMi4xIDIuMSAwIDAgMCAuNTktMS4xNGwxLjQuNDRhMy4yMyAzLjIzIDAgMCAxLTEuMDcgMS42OVptNy4yMiAwYTMuMDcgMy4wNyAwIDAgMS0xLjkxLjU3IDMuMDYgMy4wNiAwIDAgMS0yLjM0LTEgMy43NSAzLjc1IDAgMCAxLS45Mi0yLjY3IDMuODggMy44OCAwIDAgMSAuOTMtMi43NyAzLjE0IDMuMTQgMCAwIDEgMi40Mi0xIDMgMyAwIDAgMSAyLjE2LjgyIDIuOCAyLjggMCAwIDEgLjczIDEuMzFsLTEuNDMuMzVhMS40OSAxLjQ5IDAgMCAwLTEuNTEtMS4yMSAxLjYxIDEuNjEgMCAwIDAtMS4yOS41OEEyLjc5IDIuNzkgMCAwIDAgMTUgMTJhMyAzIDAgMCAwIC40OSAxLjkzIDEuNjEgMS42MSAwIDAgMCAxLjI3LjU4IDEuNDQgMS40NCAwIDAgMCAxLS4zNyAyLjEgMi4xIDAgMCAwIC42LTEuMTVsMS40LjQ0YTMuMTcgMy4xNyAwIDAgMS0xLjEgMS43WlwiLz5cbjwvc3ZnPmA7XG5jb25zdCBjY0ljb25PZmYgPSBgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI2IDI0XCI+XG4gIDxwYXRoIGQ9XCJNMTcuNzMgMTQuMDlhMS40IDEuNCAwIDAgMS0xIC4zNyAxLjU3OSAxLjU3OSAwIDAgMS0xLjI3LS41OEEzIDMgMCAwIDEgMTUgMTJhMi44IDIuOCAwIDAgMSAuNS0xLjg1IDEuNjMgMS42MyAwIDAgMSAxLjI5LS41NyAxLjQ3IDEuNDcgMCAwIDEgMS41MSAxLjJsMS40My0uMzRBMi44OSAyLjg5IDAgMCAwIDE5IDkuMDdhMyAzIDAgMCAwLTIuMTQtLjc4IDMuMTQgMy4xNCAwIDAgMC0yLjQyIDEgMy45MSAzLjkxIDAgMCAwLS45MyAyLjc4IDMuNzQgMy43NCAwIDAgMCAuOTIgMi42NiAzLjA3IDMuMDcgMCAwIDAgMi4zNCAxIDMuMDcgMy4wNyAwIDAgMCAxLjkxLS41NyAzLjE3IDMuMTcgMCAwIDAgMS4wNy0xLjc0bC0xLjQtLjQ1Yy0uMDgzLjQzLS4zLjgyMi0uNjIgMS4xMlptLTcuMjIgMGExLjQzIDEuNDMgMCAwIDEtMSAuMzcgMS41OCAxLjU4IDAgMCAxLTEuMjctLjU4QTMgMyAwIDAgMSA3Ljc2IDEyYTIuOCAyLjggMCAwIDEgLjUtMS44NSAxLjYzIDEuNjMgMCAwIDEgMS4yOS0uNTcgMS40NyAxLjQ3IDAgMCAxIDEuNTEgMS4ybDEuNDMtLjM0YTIuODEgMi44MSAwIDAgMC0uNzQtMS4zMiAyLjk0IDIuOTQgMCAwIDAtMi4xMy0uNzggMy4xOCAzLjE4IDAgMCAwLTIuNDMgMSA0IDQgMCAwIDAtLjkyIDIuNzggMy43NCAzLjc0IDAgMCAwIC45MiAyLjY2IDMuMDcgMy4wNyAwIDAgMCAyLjM0IDEgMy4wNyAzLjA3IDAgMCAwIDEuOTEtLjU3IDMuMjMgMy4yMyAwIDAgMCAxLjA3LTEuNzRsLTEuNC0uNDVhMi4wNiAyLjA2IDAgMCAxLS42IDEuMDdabTEyLjMyLTguNDFhMi41OSAyLjU5IDAgMCAwLTIuMy0yLjUxQzE4LjcyIDMuMDUgMTUuODYgMyAxMyAzYy0yLjg2IDAtNS43Mi4wNS03LjUzLjE3YTIuNTkgMi41OSAwIDAgMC0yLjMgMi41MWMtLjIzIDQuMjA3LS4yMyA4LjQyMyAwIDEyLjYzYTIuNTcgMi41NyAwIDAgMCAyLjMgMi41YzEuODEuMTMgNC42Ny4xOSA3LjUzLjE5IDIuODYgMCA1LjcyLS4wNiA3LjUzLS4xOWEyLjU3IDIuNTcgMCAwIDAgMi4zLTIuNWMuMjMtNC4yMDcuMjMtOC40MjMgMC0xMi42M1ptLTEuNDkgMTIuNTNhMS4xMSAxLjExIDAgMCAxLS45MSAxLjExYy0xLjY3LjExLTQuNDUuMTgtNy40My4xOC0yLjk4IDAtNS43Ni0uMDctNy40My0uMThhMS4xMSAxLjExIDAgMCAxLS45MS0xLjExYy0uMjEtNC4xNC0uMjEtOC4yOSAwLTEyLjQzYTEuMTEgMS4xMSAwIDAgMSAuOTEtMS4xMUM3LjI0IDQuNTYgMTAgNC40OSAxMyA0LjQ5czUuNzYuMDcgNy40My4xOGExLjExIDEuMTEgMCAwIDEgLjkxIDEuMTFjLjIxIDQuMTQuMjEgOC4yOSAwIDEyLjQzWlwiLz5cbjwvc3ZnPmA7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG4gICAgOmhvc3QoW2FyaWEtY2hlY2tlZD1cInRydWVcIl0pIHNsb3RbbmFtZT1vZmZdIHtcbiAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAke1wiXCJ9XG4gICAgOmhvc3QoOm5vdChbYXJpYS1jaGVja2VkPVwidHJ1ZVwiXSkpIHNsb3RbbmFtZT1vbl0ge1xuICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgIH1cbiAgPC9zdHlsZT5cblxuICA8c2xvdCBuYW1lPVwiaWNvblwiPlxuICAgIDxzbG90IG5hbWU9XCJvblwiPiR7Y2NJY29uT259PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJvZmZcIj4ke2NjSWNvbk9mZn08L3Nsb3Q+XG4gIDwvc2xvdD5cbmA7XG5jb25zdCB1cGRhdGVBcmlhQ2hlY2tlZCA9IChlbCkgPT4ge1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNoZWNrZWRcIiwgYXJlU3Vic09uKGVsKSk7XG59O1xuY29uc3QgZ2V0U3VidGl0bGVzTGlzdEF0dHIgPSAoZWwsIGF0dHJOYW1lKSA9PiB7XG4gIGNvbnN0IGF0dHJWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICByZXR1cm4gYXR0clZhbCA/IHBhcnNlVGV4dFRyYWNrc1N0cihhdHRyVmFsKSA6IFtdO1xufTtcbmNvbnN0IHNldFN1YnRpdGxlc0xpc3RBdHRyID0gKGVsLCBhdHRyTmFtZSwgbGlzdCkgPT4ge1xuICBpZiAoIShsaXN0ID09IG51bGwgPyB2b2lkIDAgOiBsaXN0Lmxlbmd0aCkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuZXdWYWxTdHIgPSBzdHJpbmdpZnlUZXh0VHJhY2tMaXN0KGxpc3QpO1xuICBjb25zdCBvbGRWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICBpZiAob2xkVmFsID09PSBuZXdWYWxTdHIpXG4gICAgcmV0dXJuO1xuICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5ld1ZhbFN0cik7XG59O1xuY2xhc3MgTWVkaWFDYXB0aW9uc0J1dHRvbiBleHRlbmRzIE1lZGlhQ2hyb21lQnV0dG9uIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NVQlRJVExFU19MSVNULFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX1NIT1dJTkdcbiAgICBdO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHsgc2xvdFRlbXBsYXRlLCAuLi5vcHRpb25zIH0pO1xuICAgIHRoaXMuX2NhcHRpb25zUmVhZHkgPSBmYWxzZTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN3aXRjaFwiKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbm91bnMuQ0xPU0VEX0NBUFRJT05TKCkpO1xuICAgIHVwZGF0ZUFyaWFDaGVja2VkKHRoaXMpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGF0dHJOYW1lID09PSBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TVUJUSVRMRVNfU0hPV0lORykge1xuICAgICAgdXBkYXRlQXJpYUNoZWNrZWQodGhpcyk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgfVxuICBnZXQgbWVkaWFTdWJ0aXRsZXNMaXN0KCkge1xuICAgIHJldHVybiBnZXRTdWJ0aXRsZXNMaXN0QXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TVUJUSVRMRVNfTElTVCk7XG4gIH1cbiAgc2V0IG1lZGlhU3VidGl0bGVzTGlzdChsaXN0KSB7XG4gICAgc2V0U3VidGl0bGVzTGlzdEF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX0xJU1QsIGxpc3QpO1xuICB9XG4gIGdldCBtZWRpYVN1YnRpdGxlc1Nob3dpbmcoKSB7XG4gICAgcmV0dXJuIGdldFN1YnRpdGxlc0xpc3RBdHRyKFxuICAgICAgdGhpcyxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NVQlRJVExFU19TSE9XSU5HXG4gICAgKTtcbiAgfVxuICBzZXQgbWVkaWFTdWJ0aXRsZXNTaG93aW5nKGxpc3QpIHtcbiAgICBzZXRTdWJ0aXRsZXNMaXN0QXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TVUJUSVRMRVNfU0hPV0lORywgbGlzdCk7XG4gIH1cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgdG9nZ2xlU3Vic0NhcHModGhpcyk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1jYXB0aW9ucy1idXR0b25cIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1jYXB0aW9ucy1idXR0b25cIiwgTWVkaWFDYXB0aW9uc0J1dHRvbik7XG59XG52YXIgbWVkaWFfY2FwdGlvbnNfYnV0dG9uX2RlZmF1bHQgPSBNZWRpYUNhcHRpb25zQnV0dG9uO1xuZXhwb3J0IHtcbiAgbWVkaWFfY2FwdGlvbnNfYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-captions-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-cast-button.js":
/*!*************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-cast-button.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_cast_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst enterIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\"><g><path class=\"cast_caf_icon_arch0\" d=\"M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z\"/><path class=\"cast_caf_icon_arch1\" d=\"M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z\"/><path class=\"cast_caf_icon_arch2\" d=\"M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z\"/><path class=\"cast_caf_icon_box\" d=\"M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z\"/></g></svg>`;\nconst exitIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\"><g><path class=\"cast_caf_icon_arch0\" d=\"M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z\"/><path class=\"cast_caf_icon_arch1\" d=\"M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z\"/><path class=\"cast_caf_icon_arch2\" d=\"M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z\"/><path class=\"cast_caf_icon_box\" d=\"M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z\"/><path class=\"cast_caf_icon_boxfill\" d=\"M5,7 L5,8.63 C8,8.6 13.37,14 13.37,17 L19,17 L19,7 Z\"/></g></svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n  :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  ${\"\"}\n  :host(:not([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"enter\">${enterIcon}</slot>\n    <slot name=\"exit\">${exitIcon}</slot>\n  </slot>\n`;\nconst updateAriaLabel = (el) => {\n  const isCast = el.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING) != null;\n  const label = isCast ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.EXIT_CAST() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.ENTER_CAST();\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaCastButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CAST_UNAVAILABLE\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    updateAriaLabel(this);\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING) {\n      updateAriaLabel(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaIsCasting() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING);\n  }\n  set mediaIsCasting(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_CASTING, value);\n  }\n  get mediaCastUnavailable() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CAST_UNAVAILABLE);\n  }\n  set mediaCastUnavailable(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CAST_UNAVAILABLE, value);\n  }\n  handleClick() {\n    const eventName = this.mediaIsCasting ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_EXIT_CAST_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_ENTER_CAST_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-cast-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-cast-button\", MediaCastButton);\n}\nvar media_cast_button_default = MediaCastButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNhc3QtYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFNVDtBQUNsQztBQUNBO0FBQ0EscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLDREQUFpQixrQkFBa0I7QUFDOUM7QUFDQTs7QUFFQSxJQUFJO0FBQ0osZ0JBQWdCLDREQUFpQixrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkMsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFpQjtBQUNsRCx5QkFBeUIsb0RBQUssZUFBZSxvREFBSztBQUNsRDtBQUNBO0FBQ0EsOEJBQThCLHNFQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFpQjtBQUN2QixNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLDRDQUE0Qyx3REFBYSwyQkFBMkIsd0RBQWE7QUFDakc7QUFDQSxVQUFVLHFFQUFVLDBCQUEwQiwrQkFBK0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNhc3QtYnV0dG9uLmpzPzBiMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7XG4gIGdldEJvb2xlYW5BdHRyLFxuICBzZXRCb29sZWFuQXR0cixcbiAgZ2V0U3RyaW5nQXR0cixcbiAgc2V0U3RyaW5nQXR0clxufSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBlbnRlckljb24gPSBgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGc+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2FyY2gwXCIgZD1cIk0xLDE4IEwxLDIxIEw0LDIxIEM0LDE5LjMgMi42NiwxOCAxLDE4IEwxLDE4IFpcIi8+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2FyY2gxXCIgZD1cIk0xLDE0IEwxLDE2IEMzLjc2LDE2IDYsMTguMiA2LDIxIEw4LDIxIEM4LDE3LjEzIDQuODcsMTQgMSwxNCBMMSwxNCBaXCIvPjxwYXRoIGNsYXNzPVwiY2FzdF9jYWZfaWNvbl9hcmNoMlwiIGQ9XCJNMSwxMCBMMSwxMiBDNS45NywxMiAxMCwxNi4wIDEwLDIxIEwxMiwyMSBDMTIsMTQuOTIgNy4wNywxMCAxLDEwIEwxLDEwIFpcIi8+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2JveFwiIGQ9XCJNMjEsMyBMMywzIEMxLjksMyAxLDMuOSAxLDUgTDEsOCBMMyw4IEwzLDUgTDIxLDUgTDIxLDE5IEwxNCwxOSBMMTQsMjEgTDIxLDIxIEMyMi4xLDIxIDIzLDIwLjEgMjMsMTkgTDIzLDUgQzIzLDMuOSAyMi4xLDMgMjEsMyBMMjEsMyBaXCIvPjwvZz48L3N2Zz5gO1xuY29uc3QgZXhpdEljb24gPSBgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGc+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2FyY2gwXCIgZD1cIk0xLDE4IEwxLDIxIEw0LDIxIEM0LDE5LjMgMi42NiwxOCAxLDE4IEwxLDE4IFpcIi8+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2FyY2gxXCIgZD1cIk0xLDE0IEwxLDE2IEMzLjc2LDE2IDYsMTguMiA2LDIxIEw4LDIxIEM4LDE3LjEzIDQuODcsMTQgMSwxNCBMMSwxNCBaXCIvPjxwYXRoIGNsYXNzPVwiY2FzdF9jYWZfaWNvbl9hcmNoMlwiIGQ9XCJNMSwxMCBMMSwxMiBDNS45NywxMiAxMCwxNi4wIDEwLDIxIEwxMiwyMSBDMTIsMTQuOTIgNy4wNywxMCAxLDEwIEwxLDEwIFpcIi8+PHBhdGggY2xhc3M9XCJjYXN0X2NhZl9pY29uX2JveFwiIGQ9XCJNMjEsMyBMMywzIEMxLjksMyAxLDMuOSAxLDUgTDEsOCBMMyw4IEwzLDUgTDIxLDUgTDIxLDE5IEwxNCwxOSBMMTQsMjEgTDIxLDIxIEMyMi4xLDIxIDIzLDIwLjEgMjMsMTkgTDIzLDUgQzIzLDMuOSAyMi4xLDMgMjEsMyBMMjEsMyBaXCIvPjxwYXRoIGNsYXNzPVwiY2FzdF9jYWZfaWNvbl9ib3hmaWxsXCIgZD1cIk01LDcgTDUsOC42MyBDOCw4LjYgMTMuMzcsMTQgMTMuMzcsMTcgTDE5LDE3IEwxOSw3IFpcIi8+PC9nPjwvc3ZnPmA7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG4gIDpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0NBU1RJTkd9XSkgc2xvdDpub3QoW25hbWU9ZXhpdF0pOm5vdChbbmFtZT1pY29uXSkge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuXG4gICR7XCJcIn1cbiAgOmhvc3QoOm5vdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19DQVNUSU5HfV0pKSBzbG90Om5vdChbbmFtZT1lbnRlcl0pOm5vdChbbmFtZT1pY29uXSkge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuICA8L3N0eWxlPlxuXG4gIDxzbG90IG5hbWU9XCJpY29uXCI+XG4gICAgPHNsb3QgbmFtZT1cImVudGVyXCI+JHtlbnRlckljb259PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJleGl0XCI+JHtleGl0SWNvbn08L3Nsb3Q+XG4gIDwvc2xvdD5cbmA7XG5jb25zdCB1cGRhdGVBcmlhTGFiZWwgPSAoZWwpID0+IHtcbiAgY29uc3QgaXNDYXN0ID0gZWwuZ2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0NBU1RJTkcpICE9IG51bGw7XG4gIGNvbnN0IGxhYmVsID0gaXNDYXN0ID8gdmVyYnMuRVhJVF9DQVNUKCkgOiB2ZXJicy5FTlRFUl9DQVNUKCk7XG4gIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xufTtcbmNsYXNzIE1lZGlhQ2FzdEJ1dHRvbiBleHRlbmRzIE1lZGlhQ2hyb21lQnV0dG9uIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0NBU1RJTkcsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9DQVNUX1VOQVZBSUxBQkxFXG4gICAgXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7IHNsb3RUZW1wbGF0ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB1cGRhdGVBcmlhTGFiZWwodGhpcyk7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfSVNfQ0FTVElORykge1xuICAgICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhSXNDYXN0aW5nKCkge1xuICAgIHJldHVybiBnZXRCb29sZWFuQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19DQVNUSU5HKTtcbiAgfVxuICBzZXQgbWVkaWFJc0Nhc3RpbmcodmFsdWUpIHtcbiAgICBzZXRCb29sZWFuQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19DQVNUSU5HLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhQ2FzdFVuYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiBnZXRTdHJpbmdBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NBU1RfVU5BVkFJTEFCTEUpO1xuICB9XG4gIHNldCBtZWRpYUNhc3RVbmF2YWlsYWJsZSh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ0FTVF9VTkFWQUlMQUJMRSwgdmFsdWUpO1xuICB9XG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHRoaXMubWVkaWFJc0Nhc3RpbmcgPyBNZWRpYVVJRXZlbnRzLk1FRElBX0VYSVRfQ0FTVF9SRVFVRVNUIDogTWVkaWFVSUV2ZW50cy5NRURJQV9FTlRFUl9DQVNUX1JFUVVFU1Q7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGNvbXBvc2VkOiB0cnVlLCBidWJibGVzOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxufVxuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWNhc3QtYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtY2FzdC1idXR0b25cIiwgTWVkaWFDYXN0QnV0dG9uKTtcbn1cbnZhciBtZWRpYV9jYXN0X2J1dHRvbl9kZWZhdWx0ID0gTWVkaWFDYXN0QnV0dG9uO1xuZXhwb3J0IHtcbiAgbWVkaWFfY2FzdF9idXR0b25fZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-cast-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js":
/*!***************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-chrome-button.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaChromeButton: function() { return /* binding */ MediaChromeButton; },\n/* harmony export */   \"default\": function() { return /* binding */ media_chrome_button_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController, _clickListener, _keyupListener, _keydownListener;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\n  :host {\n    font: var(--media-font,\n      var(--media-font-weight, bold)\n      var(--media-font-size, 14px) /\n      var(--media-text-content-height, var(--media-control-height, 24px))\n      var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n    color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n    background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));\n    padding: var(--media-control-padding, 10px);\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    vertical-align: middle;\n    box-sizing: border-box;\n    transition: background .15s linear;\n    pointer-events: auto;\n    cursor: pointer;\n  }\n\n  ${\"\"}\n  :host(:focus-visible) {\n    box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);\n    outline: 0;\n  }\n  ${\"\"}\n  :host(:where(:focus)) {\n    box-shadow: none;\n    outline: 0;\n  }\n\n  :host(:hover) {\n    background: var(--media-control-hover-background, rgba(50 50 70 / .7));\n  }\n\n  svg, img, ::slotted(svg), ::slotted(img) {\n    width: var(--media-button-icon-width);\n    height: var(--media-button-icon-height, var(--media-control-height, 24px));\n    transform: var(--media-button-icon-transform);\n    transition: var(--media-button-icon-transition);\n    fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n    vertical-align: middle;\n    max-width: 100%;\n    max-height: 100%;\n    min-width: 100%;\n  }\n</style>\n`;\nclass MediaChromeButton extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor(options = {}) {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    __publicField(this, \"preventClick\", false);\n    __privateAdd(this, _clickListener, (e) => {\n      if (!this.preventClick) {\n        this.handleClick(e);\n      }\n    });\n    __privateAdd(this, _keyupListener, (e) => {\n      const { key } = e;\n      if (!this.keysUsed.includes(key)) {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      if (!this.preventClick) {\n        this.handleClick(e);\n      }\n    });\n    __privateAdd(this, _keydownListener, (e) => {\n      const { metaKey, altKey, key } = e;\n      if (metaKey || altKey || !this.keysUsed.includes(key)) {\n        this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n        return;\n      }\n      this.addEventListener(\"keyup\", __privateGet(this, _keyupListener), { once: true });\n    });\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      const buttonHTML = template.content.cloneNode(true);\n      this.nativeEl = buttonHTML;\n      let slotTemplate = options.slotTemplate;\n      if (!slotTemplate) {\n        slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\n        slotTemplate.innerHTML = `<slot>${options.defaultContent || \"\"}</slot>`;\n      }\n      this.nativeEl.appendChild(slotTemplate.content.cloneNode(true));\n      this.shadowRoot.appendChild(buttonHTML);\n    }\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    style.setProperty(\"display\", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`);\n  }\n  static get observedAttributes() {\n    return [\"disabled\", _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER];\n  }\n  enable() {\n    this.addEventListener(\"click\", __privateGet(this, _clickListener));\n    this.addEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    this.tabIndex = 0;\n  }\n  disable() {\n    this.removeEventListener(\"click\", __privateGet(this, _clickListener));\n    this.removeEventListener(\"keydown\", __privateGet(this, _keydownListener));\n    this.removeEventListener(\"keyup\", __privateGet(this, _keyupListener));\n    this.tabIndex = -1;\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    this.setAttribute(\"role\", \"button\");\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    this.disable();\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n  }\n  get keysUsed() {\n    return [\"Enter\", \" \"];\n  }\n  handleClick(e) {\n  }\n}\n_mediaController = new WeakMap();\n_clickListener = new WeakMap();\n_keyupListener = new WeakMap();\n_keydownListener = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-chrome-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-chrome-button\", MediaChromeButton);\n}\nvar media_chrome_button_default = MediaChromeButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNocm9tZS1idXR0b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUNBO0FBQ1E7QUFDdEUsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxRUFBVTtBQUMxQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxZQUFZO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFRO0FBQy9CLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSwyRUFBa0I7QUFDeEMsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBLHdCQUF3Qix1RUFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzPzdhM2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX21lZGlhQ29udHJvbGxlciwgX2NsaWNrTGlzdGVuZXIsIF9rZXl1cExpc3RlbmVyLCBfa2V5ZG93bkxpc3RlbmVyO1xuaW1wb3J0IHsgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0T3JJbnNlcnRDU1NSdWxlIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGZvbnQ6IHZhcigtLW1lZGlhLWZvbnQsXG4gICAgICB2YXIoLS1tZWRpYS1mb250LXdlaWdodCwgYm9sZClcbiAgICAgIHZhcigtLW1lZGlhLWZvbnQtc2l6ZSwgMTRweCkgL1xuICAgICAgdmFyKC0tbWVkaWEtdGV4dC1jb250ZW50LWhlaWdodCwgdmFyKC0tbWVkaWEtY29udHJvbC1oZWlnaHQsIDI0cHgpKVxuICAgICAgdmFyKC0tbWVkaWEtZm9udC1mYW1pbHksIGhlbHZldGljYSBuZXVlLCBzZWdvZSB1aSwgcm9ib3RvLCBhcmlhbCwgc2Fucy1zZXJpZikpO1xuICAgIGNvbG9yOiB2YXIoLS1tZWRpYS10ZXh0LWNvbG9yLCB2YXIoLS1tZWRpYS1wcmltYXJ5LWNvbG9yLCByZ2IoMjM4IDIzOCAyMzgpKSk7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtY29udHJvbC1iYWNrZ3JvdW5kLCB2YXIoLS1tZWRpYS1zZWNvbmRhcnktY29sb3IsIHJnYigyMCAyMCAzMCAvIC43KSkpO1xuICAgIHBhZGRpbmc6IHZhcigtLW1lZGlhLWNvbnRyb2wtcGFkZGluZywgMTBweCk7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAuMTVzIGxpbmVhcjtcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cblxuICAke1wiXCJ9XG4gIDpob3N0KDpmb2N1cy12aXNpYmxlKSB7XG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMnB4IHJnYigyNyAxMjcgMjA0IC8gLjkpO1xuICAgIG91dGxpbmU6IDA7XG4gIH1cbiAgJHtcIlwifVxuICA6aG9zdCg6d2hlcmUoOmZvY3VzKSkge1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgb3V0bGluZTogMDtcbiAgfVxuXG4gIDpob3N0KDpob3Zlcikge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLW1lZGlhLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZCwgcmdiYSg1MCA1MCA3MCAvIC43KSk7XG4gIH1cblxuICBzdmcsIGltZywgOjpzbG90dGVkKHN2ZyksIDo6c2xvdHRlZChpbWcpIHtcbiAgICB3aWR0aDogdmFyKC0tbWVkaWEtYnV0dG9uLWljb24td2lkdGgpO1xuICAgIGhlaWdodDogdmFyKC0tbWVkaWEtYnV0dG9uLWljb24taGVpZ2h0LCB2YXIoLS1tZWRpYS1jb250cm9sLWhlaWdodCwgMjRweCkpO1xuICAgIHRyYW5zZm9ybTogdmFyKC0tbWVkaWEtYnV0dG9uLWljb24tdHJhbnNmb3JtKTtcbiAgICB0cmFuc2l0aW9uOiB2YXIoLS1tZWRpYS1idXR0b24taWNvbi10cmFuc2l0aW9uKTtcbiAgICBmaWxsOiB2YXIoLS1tZWRpYS1pY29uLWNvbG9yLCB2YXIoLS1tZWRpYS1wcmltYXJ5LWNvbG9yLCByZ2IoMjM4IDIzOCAyMzgpKSk7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgbWF4LWhlaWdodDogMTAwJTtcbiAgICBtaW4td2lkdGg6IDEwMCU7XG4gIH1cbjwvc3R5bGU+XG5gO1xuY2xhc3MgTWVkaWFDaHJvbWVCdXR0b24gZXh0ZW5kcyBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lZGlhQ29udHJvbGxlciwgdm9pZCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJldmVudENsaWNrXCIsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsaWNrTGlzdGVuZXIsIChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucHJldmVudENsaWNrKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9rZXl1cExpc3RlbmVyLCAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBrZXkgfSA9IGU7XG4gICAgICBpZiAoIXRoaXMua2V5c1VzZWQuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleXVwTGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByZXZlbnRDbGljaykge1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfa2V5ZG93bkxpc3RlbmVyLCAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBtZXRhS2V5LCBhbHRLZXksIGtleSB9ID0gZTtcbiAgICAgIGlmIChtZXRhS2V5IHx8IGFsdEtleSB8fCAhdGhpcy5rZXlzVXNlZC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5dXBMaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2tleXVwTGlzdGVuZXIpLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICBjb25zdCBidXR0b25IVE1MID0gdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0aGlzLm5hdGl2ZUVsID0gYnV0dG9uSFRNTDtcbiAgICAgIGxldCBzbG90VGVtcGxhdGUgPSBvcHRpb25zLnNsb3RUZW1wbGF0ZTtcbiAgICAgIGlmICghc2xvdFRlbXBsYXRlKSB7XG4gICAgICAgIHNsb3RUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgICAgc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGA8c2xvdD4ke29wdGlvbnMuZGVmYXVsdENvbnRlbnQgfHwgXCJcIn08L3Nsb3Q+YDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmF0aXZlRWwuYXBwZW5kQ2hpbGQoc2xvdFRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChidXR0b25IVE1MKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdFwiKTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgYHZhcigtLW1lZGlhLWNvbnRyb2wtZGlzcGxheSwgdmFyKC0tJHt0aGlzLmxvY2FsTmFtZX0tZGlzcGxheSwgaW5saW5lLWZsZXgpKWApO1xuICB9XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXCJkaXNhYmxlZFwiLCBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJdO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2NsaWNrTGlzdGVuZXIpKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5ZG93bkxpc3RlbmVyKSk7XG4gICAgdGhpcy50YWJJbmRleCA9IDA7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2NsaWNrTGlzdGVuZXIpKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfa2V5ZG93bkxpc3RlbmVyKSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9rZXl1cExpc3RlbmVyKSk7XG4gICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikge1xuICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYyA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmdldEVsZW1lbnRCeUlkKG5ld1ZhbHVlKSk7XG4gICAgICAgIChfZSA9IChfZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKF9kLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSBcImRpc2FibGVkXCIgJiYgbmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICApO1xuICAgIGlmIChtZWRpYUNvbnRyb2xsZXJJZCkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYSA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnRCeUlkKG1lZGlhQ29udHJvbGxlcklkKSk7XG4gICAgICAoX2MgPSAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChfYiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIG51bGwpO1xuICB9XG4gIGdldCBrZXlzVXNlZCgpIHtcbiAgICByZXR1cm4gW1wiRW50ZXJcIiwgXCIgXCJdO1xuICB9XG4gIGhhbmRsZUNsaWNrKGUpIHtcbiAgfVxufVxuX21lZGlhQ29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5fY2xpY2tMaXN0ZW5lciA9IG5ldyBXZWFrTWFwKCk7XG5fa2V5dXBMaXN0ZW5lciA9IG5ldyBXZWFrTWFwKCk7XG5fa2V5ZG93bkxpc3RlbmVyID0gbmV3IFdlYWtNYXAoKTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1jaHJvbWUtYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtY2hyb21lLWJ1dHRvblwiLCBNZWRpYUNocm9tZUJ1dHRvbik7XG59XG52YXIgbWVkaWFfY2hyb21lX2J1dHRvbl9kZWZhdWx0ID0gTWVkaWFDaHJvbWVCdXR0b247XG5leHBvcnQge1xuICBNZWRpYUNocm9tZUJ1dHRvbixcbiAgbWVkaWFfY2hyb21lX2J1dHRvbl9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-chrome-range.js":
/*!**************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-chrome-range.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaChromeRange: function() { return /* binding */ MediaChromeRange; },\n/* harmony export */   \"default\": function() { return /* binding */ media_chrome_range_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController, _onFocusIn, _onFocusOut;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nconst thumbStyles = `\n  height: var(--thumb-height);\n  width: var(--media-range-thumb-width, 10px);\n  border: var(--media-range-thumb-border, none);\n  border-radius: var(--media-range-thumb-border-radius, 10px);\n  background: var(--media-range-thumb-background, var(--media-primary-color, rgb(238 238 238)));\n  box-shadow: var(--media-range-thumb-box-shadow, 1px 1px 1px transparent);\n  cursor: pointer;\n  transition: var(--media-range-thumb-transition, none);\n  transform: var(--media-range-thumb-transform, none);\n  opacity: var(--media-range-thumb-opacity, 1);\n`;\nconst trackStyles = `\n  min-width: 40px;\n  height: var(--track-height);\n  border: var(--media-range-track-border, none);\n  outline: var(--media-range-track-outline);\n  outline-offset: var(--media-range-track-outline-offset);\n  border-radius: var(--media-range-track-border-radius, 1px);\n  background: var(--media-range-track-progress-internal, var(--media-range-track-background, rgb(255 255 255 / .2)));\n  backdrop-filter: var(--media-range-track-backdrop-filter);\n  box-shadow: var(--media-range-track-box-shadow, none);\n  transition: var(--media-range-track-transition, none);\n  transform: translate(var(--media-range-track-translate-x, 0), var(--media-range-track-translate-y, 0));\n  cursor: pointer;\n`;\ntemplate.innerHTML = `\n  <style>\n    :host {\n      --thumb-height: var(--media-range-thumb-height, 10px);\n      --track-height: var(--media-range-track-height, 4px);\n      --_focus-box-shadow: var(--media-focus-box-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));\n      --_media-range-padding: var(--media-range-padding, var(--media-control-padding, 10px));\n\n      vertical-align: middle;\n      box-sizing: border-box;\n      display: inline-block;\n      position: relative;\n      background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));\n      transition: background .15s linear;\n      width: 100px;\n      height: calc(var(--media-control-height, 24px) + 2 * var(--_media-range-padding));\n      padding-left: var(--media-range-padding-left, var(--_media-range-padding));\n      padding-right: var(--media-range-padding-right, var(--_media-range-padding));\n      pointer-events: auto;\n      ${\"\"}\n      font-size: 0;\n      box-shadow: var(--_focus-visible-box-shadow, none);\n    }\n\n    ${\"\"}\n    input[type=range]:focus {\n      outline: 0;\n    }\n    input[type=range]:focus::-webkit-slider-runnable-track {\n      outline: 0;\n    }\n\n    :host(:hover) {\n      background: var(--media-control-hover-background, rgb(50 50 70 / .7));\n    }\n\n    #container {\n      position: relative;\n      height: 100%;\n    }\n\n    input[type=range] {\n      ${\"\"}\n      -webkit-appearance: none; ${\"\"}\n      background: transparent; ${\"\"}\n\n      ${\"\"}\n      min-height: 100%;\n      width: var(--media-range-track-width, 100%); ${\"\"}\n\n      box-sizing: border-box;\n      padding: 0;\n      margin: 0;\n    }\n\n    ${\"\"}\n    input[type=range]::-webkit-slider-thumb {\n      -webkit-appearance: none;\n      ${thumbStyles}\n      ${\"\"}\n      margin-top: calc(calc(0px - var(--thumb-height) + var(--track-height)) / 2);\n    }\n\n    ${\"\"}\n    input[type=range]::-moz-range-thumb {\n      ${thumbStyles}\n      translate: var(--media-range-track-translate-x, 0) var(--media-range-track-translate-y, 0);\n    }\n\n    input[type=range]::-webkit-slider-runnable-track { ${trackStyles} }\n    input[type=range]::-moz-range-track { ${trackStyles} }\n    input[type=range]::-ms-track {\n      ${\"\"}\n      width: 100%;\n      cursor: pointer;\n      ${\"\"}\n      background: transparent;\n      border-color: transparent;\n      color: transparent;\n\n      ${trackStyles}\n    }\n\n    #background,\n    #pointer {\n      width: var(--media-range-track-width, 100%);\n      height: var(--track-height);\n      border-radius: var(--media-range-track-border-radius, 1px);\n      position: absolute;\n      top: 50%;\n      transform: translate(var(--media-range-track-translate-x, 0px), calc(var(--media-range-track-translate-y, 0px) - 50%));\n    }\n\n    #background {\n      min-width: 40px;\n      background: var(--media-range-track-background, rgb(255 255 255 / .2));\n      backdrop-filter: var(--media-range-track-background-backdrop-filter);\n    }\n\n    #pointer {\n      background: var(--media-range-track-pointer-background);\n      border-right: var(--media-range-track-pointer-border-right);\n      transition: visibility .25s, opacity .25s;\n      visibility: hidden;\n      opacity: 0;\n    }\n\n    :host(:hover) #pointer {\n      transition: visibility .5s, opacity .5s;\n      visibility: visible;\n      opacity: 1;\n    }\n\n    #hoverzone {\n      ${\"\"}\n      z-index: 1;\n      display: var(--media-time-range-hover-display, none);\n      position: absolute;\n      width: 100%;\n      bottom: var(--media-time-range-hover-bottom, -5px);\n      height: var(--media-time-range-hover-height, max(calc(100% + 5px), 20px));\n    }\n\n    #range {\n      z-index: 2;\n      position: relative;\n      height: var(--media-range-track-height, 4px);\n    }\n\n    input[type=range]:disabled::-webkit-slider-thumb {\n      background-color: #777;\n    }\n\n    input[type=range]:disabled::-webkit-slider-runnable-track {\n      background-color: #777;\n    }\n  </style>\n  <div id=\"container\">\n    <div id=\"background\"></div>\n    <div id=\"pointer\"></div>\n    <div id=\"hoverzone\"></div>\n    <input id=\"range\" type=\"range\" min=\"0\" max=\"1000\" step=\"any\" value=\"0\">\n  </div>\n`;\nclass MediaChromeRange extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __publicField(this, \"thumbWidth\");\n    __privateAdd(this, _mediaController, void 0);\n    __privateAdd(this, _onFocusIn, () => {\n      if (this.range.matches(\":focus-visible\")) {\n        const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n        style.setProperty(\"--_focus-visible-box-shadow\", \"var(--_focus-box-shadow)\");\n      }\n    });\n    __privateAdd(this, _onFocusOut, () => {\n      const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n      style.removeProperty(\"--_focus-visible-box-shadow\");\n    });\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    style.setProperty(\"display\", `var(--media-control-display, var(--${this.localName}-display, inline-block))`);\n    this.container = this.shadowRoot.querySelector(\"#container\");\n    this.range = this.shadowRoot.querySelector(\"#range\");\n    this.range.addEventListener(\"input\", this.updateBar.bind(this));\n    this.thumbWidth = parseInt(getComputedStyle(this).getPropertyValue(\"--media-range-thumb-width\") || \"10\", 10);\n  }\n  static get observedAttributes() {\n    return [\n      \"disabled\",\n      \"aria-disabled\",\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    ];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    } else if (attrName === \"disabled\" || attrName === \"aria-disabled\" && oldValue !== newValue) {\n      if (newValue == null) {\n        this.range.removeAttribute(attrName);\n      } else {\n        this.range.setAttribute(attrName, newValue);\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n    this.updateBar();\n    this.shadowRoot.addEventListener(\"focusin\", __privateGet(this, _onFocusIn));\n    this.shadowRoot.addEventListener(\"focusout\", __privateGet(this, _onFocusOut));\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n    this.shadowRoot.removeEventListener(\"focusin\", __privateGet(this, _onFocusIn));\n    this.shadowRoot.removeEventListener(\"focusout\", __privateGet(this, _onFocusOut));\n  }\n  updatePointerBar(evt) {\n    const rangeRect = this.range.getBoundingClientRect();\n    let mousePercent = (evt.clientX - rangeRect.left) / rangeRect.width;\n    mousePercent = Math.max(0, Math.min(1, mousePercent));\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \"#pointer\");\n    style.setProperty(\"width\", `${mousePercent * rangeRect.width}px`);\n  }\n  updateBar() {\n    const colorArray = this.getBarColors();\n    let gradientStr = \"linear-gradient(to right, \";\n    let prevPercent = 0;\n    colorArray.forEach((color) => {\n      if (color[1] < prevPercent)\n        return;\n      gradientStr = gradientStr + `${color[0]} ${prevPercent}%, ${color[0]} ${color[1]}%,`;\n      prevPercent = color[1];\n    });\n    gradientStr = gradientStr.slice(0, gradientStr.length - 1) + \")\";\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \"#range\");\n    style.setProperty(\"--media-range-track-progress-internal\", gradientStr);\n  }\n  getRelativeValues() {\n    const { range } = this;\n    return {\n      relativeValue: range.value - range.min,\n      relativeMax: range.max - range.min\n    };\n  }\n  getBarColors() {\n    const range = this.range;\n    const {\n      relativeValue,\n      relativeMax\n    } = this.getRelativeValues();\n    const rangePercent = relativeValue / relativeMax * 100;\n    let thumbPercent = 0;\n    if (!!relativeValue && relativeValue < relativeMax) {\n      const thumbOffset = this.thumbWidth * (0.5 - rangePercent / 100);\n      thumbPercent = thumbOffset / range.offsetWidth * 100;\n    }\n    let colorArray = [\n      [\"var(--media-range-bar-color, var(--media-primary-color, rgb(238 238 238)))\", rangePercent + thumbPercent],\n      [\"var(--media-range-track-color, transparent)\", 100]\n    ];\n    return colorArray;\n  }\n  get keysUsed() {\n    return [\"ArrowUp\", \"ArrowRight\", \"ArrowDown\", \"ArrowLeft\"];\n  }\n}\n_mediaController = new WeakMap();\n_onFocusIn = new WeakMap();\n_onFocusOut = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-chrome-range\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-chrome-range\", MediaChromeRange);\n}\nvar media_chrome_range_default = MediaChromeRange;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNocm9tZS1yYW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhEO0FBQ1E7QUFDUjtBQUM5RCxpQkFBaUIsbUVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLGdDQUFnQyxFQUFFO0FBQ2xDLCtCQUErQixFQUFFOztBQUVqQyxRQUFRO0FBQ1I7QUFDQSxtREFBbUQsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsdURBQXVELEVBQUU7QUFDekQsMENBQTBDLEVBQUU7QUFDNUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLDJFQUFrQjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxRQUFRLEVBQUUsMkVBQWtCO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBLFlBQVksUUFBUSxFQUFFLDJFQUFrQjtBQUN4Qyx1RUFBdUUsZUFBZTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxFQUFFLDJFQUFrQjtBQUN4QyxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVSxFQUFFLFlBQVksS0FBSyxVQUFVLEVBQUUsU0FBUztBQUN2RjtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksUUFBUSxFQUFFLDJFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtY2hyb21lLXJhbmdlLmpzPzc3NjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX21lZGlhQ29udHJvbGxlciwgX29uRm9jdXNJbiwgX29uRm9jdXNPdXQ7XG5pbXBvcnQgeyBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IGdldE9ySW5zZXJ0Q1NTUnVsZSB9IGZyb20gXCIuL3V0aWxzL2VsZW1lbnQtdXRpbHMuanNcIjtcbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3QgdGh1bWJTdHlsZXMgPSBgXG4gIGhlaWdodDogdmFyKC0tdGh1bWItaGVpZ2h0KTtcbiAgd2lkdGg6IHZhcigtLW1lZGlhLXJhbmdlLXRodW1iLXdpZHRoLCAxMHB4KTtcbiAgYm9yZGVyOiB2YXIoLS1tZWRpYS1yYW5nZS10aHVtYi1ib3JkZXIsIG5vbmUpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS1tZWRpYS1yYW5nZS10aHVtYi1ib3JkZXItcmFkaXVzLCAxMHB4KTtcbiAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtcmFuZ2UtdGh1bWItYmFja2dyb3VuZCwgdmFyKC0tbWVkaWEtcHJpbWFyeS1jb2xvciwgcmdiKDIzOCAyMzggMjM4KSkpO1xuICBib3gtc2hhZG93OiB2YXIoLS1tZWRpYS1yYW5nZS10aHVtYi1ib3gtc2hhZG93LCAxcHggMXB4IDFweCB0cmFuc3BhcmVudCk7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdHJhbnNpdGlvbjogdmFyKC0tbWVkaWEtcmFuZ2UtdGh1bWItdHJhbnNpdGlvbiwgbm9uZSk7XG4gIHRyYW5zZm9ybTogdmFyKC0tbWVkaWEtcmFuZ2UtdGh1bWItdHJhbnNmb3JtLCBub25lKTtcbiAgb3BhY2l0eTogdmFyKC0tbWVkaWEtcmFuZ2UtdGh1bWItb3BhY2l0eSwgMSk7XG5gO1xuY29uc3QgdHJhY2tTdHlsZXMgPSBgXG4gIG1pbi13aWR0aDogNDBweDtcbiAgaGVpZ2h0OiB2YXIoLS10cmFjay1oZWlnaHQpO1xuICBib3JkZXI6IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLWJvcmRlciwgbm9uZSk7XG4gIG91dGxpbmU6IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLW91dGxpbmUpO1xuICBvdXRsaW5lLW9mZnNldDogdmFyKC0tbWVkaWEtcmFuZ2UtdHJhY2stb3V0bGluZS1vZmZzZXQpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1ib3JkZXItcmFkaXVzLCAxcHgpO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1wcm9ncmVzcy1pbnRlcm5hbCwgdmFyKC0tbWVkaWEtcmFuZ2UtdHJhY2stYmFja2dyb3VuZCwgcmdiKDI1NSAyNTUgMjU1IC8gLjIpKSk7XG4gIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tbWVkaWEtcmFuZ2UtdHJhY2stYmFja2Ryb3AtZmlsdGVyKTtcbiAgYm94LXNoYWRvdzogdmFyKC0tbWVkaWEtcmFuZ2UtdHJhY2stYm94LXNoYWRvdywgbm9uZSk7XG4gIHRyYW5zaXRpb246IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLXRyYW5zaXRpb24sIG5vbmUpO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS1tZWRpYS1yYW5nZS10cmFjay10cmFuc2xhdGUteCwgMCksIHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLXRyYW5zbGF0ZS15LCAwKSk7XG4gIGN1cnNvcjogcG9pbnRlcjtcbmA7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAtLXRodW1iLWhlaWdodDogdmFyKC0tbWVkaWEtcmFuZ2UtdGh1bWItaGVpZ2h0LCAxMHB4KTtcbiAgICAgIC0tdHJhY2staGVpZ2h0OiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1oZWlnaHQsIDRweCk7XG4gICAgICAtLV9mb2N1cy1ib3gtc2hhZG93OiB2YXIoLS1tZWRpYS1mb2N1cy1ib3gtc2hhZG93LCBpbnNldCAwIDAgMCAycHggcmdiKDI3IDEyNyAyMDQgLyAuOSkpO1xuICAgICAgLS1fbWVkaWEtcmFuZ2UtcGFkZGluZzogdmFyKC0tbWVkaWEtcmFuZ2UtcGFkZGluZywgdmFyKC0tbWVkaWEtY29udHJvbC1wYWRkaW5nLCAxMHB4KSk7XG5cbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtY29udHJvbC1iYWNrZ3JvdW5kLCB2YXIoLS1tZWRpYS1zZWNvbmRhcnktY29sb3IsIHJnYigyMCAyMCAzMCAvIC43KSkpO1xuICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAuMTVzIGxpbmVhcjtcbiAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgIGhlaWdodDogY2FsYyh2YXIoLS1tZWRpYS1jb250cm9sLWhlaWdodCwgMjRweCkgKyAyICogdmFyKC0tX21lZGlhLXJhbmdlLXBhZGRpbmcpKTtcbiAgICAgIHBhZGRpbmctbGVmdDogdmFyKC0tbWVkaWEtcmFuZ2UtcGFkZGluZy1sZWZ0LCB2YXIoLS1fbWVkaWEtcmFuZ2UtcGFkZGluZykpO1xuICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tbWVkaWEtcmFuZ2UtcGFkZGluZy1yaWdodCwgdmFyKC0tX21lZGlhLXJhbmdlLXBhZGRpbmcpKTtcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgJHtcIlwifVxuICAgICAgZm9udC1zaXplOiAwO1xuICAgICAgYm94LXNoYWRvdzogdmFyKC0tX2ZvY3VzLXZpc2libGUtYm94LXNoYWRvdywgbm9uZSk7XG4gICAgfVxuXG4gICAgJHtcIlwifVxuICAgIGlucHV0W3R5cGU9cmFuZ2VdOmZvY3VzIHtcbiAgICAgIG91dGxpbmU6IDA7XG4gICAgfVxuICAgIGlucHV0W3R5cGU9cmFuZ2VdOmZvY3VzOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjayB7XG4gICAgICBvdXRsaW5lOiAwO1xuICAgIH1cblxuICAgIDpob3N0KDpob3Zlcikge1xuICAgICAgYmFja2dyb3VuZDogdmFyKC0tbWVkaWEtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLCByZ2IoNTAgNTAgNzAgLyAuNykpO1xuICAgIH1cblxuICAgICNjb250YWluZXIge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIGlucHV0W3R5cGU9cmFuZ2VdIHtcbiAgICAgICR7XCJcIn1cbiAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTsgJHtcIlwifVxuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7ICR7XCJcIn1cblxuICAgICAgJHtcIlwifVxuICAgICAgbWluLWhlaWdodDogMTAwJTtcbiAgICAgIHdpZHRoOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay13aWR0aCwgMTAwJSk7ICR7XCJcIn1cblxuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIHBhZGRpbmc6IDA7XG4gICAgICBtYXJnaW46IDA7XG4gICAgfVxuXG4gICAgJHtcIlwifVxuICAgIGlucHV0W3R5cGU9cmFuZ2VdOjotd2Via2l0LXNsaWRlci10aHVtYiB7XG4gICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAke3RodW1iU3R5bGVzfVxuICAgICAgJHtcIlwifVxuICAgICAgbWFyZ2luLXRvcDogY2FsYyhjYWxjKDBweCAtIHZhcigtLXRodW1iLWhlaWdodCkgKyB2YXIoLS10cmFjay1oZWlnaHQpKSAvIDIpO1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICBpbnB1dFt0eXBlPXJhbmdlXTo6LW1vei1yYW5nZS10aHVtYiB7XG4gICAgICAke3RodW1iU3R5bGVzfVxuICAgICAgdHJhbnNsYXRlOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay10cmFuc2xhdGUteCwgMCkgdmFyKC0tbWVkaWEtcmFuZ2UtdHJhY2stdHJhbnNsYXRlLXksIDApO1xuICAgIH1cblxuICAgIGlucHV0W3R5cGU9cmFuZ2VdOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjayB7ICR7dHJhY2tTdHlsZXN9IH1cbiAgICBpbnB1dFt0eXBlPXJhbmdlXTo6LW1vei1yYW5nZS10cmFjayB7ICR7dHJhY2tTdHlsZXN9IH1cbiAgICBpbnB1dFt0eXBlPXJhbmdlXTo6LW1zLXRyYWNrIHtcbiAgICAgICR7XCJcIn1cbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgJHtcIlwifVxuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAke3RyYWNrU3R5bGVzfVxuICAgIH1cblxuICAgICNiYWNrZ3JvdW5kLFxuICAgICNwb2ludGVyIHtcbiAgICAgIHdpZHRoOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay13aWR0aCwgMTAwJSk7XG4gICAgICBoZWlnaHQ6IHZhcigtLXRyYWNrLWhlaWdodCk7XG4gICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1ib3JkZXItcmFkaXVzLCAxcHgpO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS1tZWRpYS1yYW5nZS10cmFjay10cmFuc2xhdGUteCwgMHB4KSwgY2FsYyh2YXIoLS1tZWRpYS1yYW5nZS10cmFjay10cmFuc2xhdGUteSwgMHB4KSAtIDUwJSkpO1xuICAgIH1cblxuICAgICNiYWNrZ3JvdW5kIHtcbiAgICAgIG1pbi13aWR0aDogNDBweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLWJhY2tncm91bmQsIHJnYigyNTUgMjU1IDI1NSAvIC4yKSk7XG4gICAgICBiYWNrZHJvcC1maWx0ZXI6IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLWJhY2tncm91bmQtYmFja2Ryb3AtZmlsdGVyKTtcbiAgICB9XG5cbiAgICAjcG9pbnRlciB7XG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1wb2ludGVyLWJhY2tncm91bmQpO1xuICAgICAgYm9yZGVyLXJpZ2h0OiB2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1wb2ludGVyLWJvcmRlci1yaWdodCk7XG4gICAgICB0cmFuc2l0aW9uOiB2aXNpYmlsaXR5IC4yNXMsIG9wYWNpdHkgLjI1cztcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuXG4gICAgOmhvc3QoOmhvdmVyKSAjcG9pbnRlciB7XG4gICAgICB0cmFuc2l0aW9uOiB2aXNpYmlsaXR5IC41cywgb3BhY2l0eSAuNXM7XG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG5cbiAgICAjaG92ZXJ6b25lIHtcbiAgICAgICR7XCJcIn1cbiAgICAgIHotaW5kZXg6IDE7XG4gICAgICBkaXNwbGF5OiB2YXIoLS1tZWRpYS10aW1lLXJhbmdlLWhvdmVyLWRpc3BsYXksIG5vbmUpO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBib3R0b206IHZhcigtLW1lZGlhLXRpbWUtcmFuZ2UtaG92ZXItYm90dG9tLCAtNXB4KTtcbiAgICAgIGhlaWdodDogdmFyKC0tbWVkaWEtdGltZS1yYW5nZS1ob3Zlci1oZWlnaHQsIG1heChjYWxjKDEwMCUgKyA1cHgpLCAyMHB4KSk7XG4gICAgfVxuXG4gICAgI3JhbmdlIHtcbiAgICAgIHotaW5kZXg6IDI7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBoZWlnaHQ6IHZhcigtLW1lZGlhLXJhbmdlLXRyYWNrLWhlaWdodCwgNHB4KTtcbiAgICB9XG5cbiAgICBpbnB1dFt0eXBlPXJhbmdlXTpkaXNhYmxlZDo6LXdlYmtpdC1zbGlkZXItdGh1bWIge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzc3NztcbiAgICB9XG5cbiAgICBpbnB1dFt0eXBlPXJhbmdlXTpkaXNhYmxlZDo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2sge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzc3NztcbiAgICB9XG4gIDwvc3R5bGU+XG4gIDxkaXYgaWQ9XCJjb250YWluZXJcIj5cbiAgICA8ZGl2IGlkPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJwb2ludGVyXCI+PC9kaXY+XG4gICAgPGRpdiBpZD1cImhvdmVyem9uZVwiPjwvZGl2PlxuICAgIDxpbnB1dCBpZD1cInJhbmdlXCIgdHlwZT1cInJhbmdlXCIgbWluPVwiMFwiIG1heD1cIjEwMDBcIiBzdGVwPVwiYW55XCIgdmFsdWU9XCIwXCI+XG4gIDwvZGl2PlxuYDtcbmNsYXNzIE1lZGlhQ2hyb21lUmFuZ2UgZXh0ZW5kcyBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGh1bWJXaWR0aFwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lZGlhQ29udHJvbGxlciwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uRm9jdXNJbiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmFuZ2UubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IGdldE9ySW5zZXJ0Q1NTUnVsZSh0aGlzLnNoYWRvd1Jvb3QsIFwiOmhvc3RcIik7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFwiLS1fZm9jdXMtdmlzaWJsZS1ib3gtc2hhZG93XCIsIFwidmFyKC0tX2ZvY3VzLWJveC1zaGFkb3cpXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25Gb2N1c091dCwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdFwiKTtcbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS1fZm9jdXMtdmlzaWJsZS1ib3gtc2hhZG93XCIpO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdFwiKTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgYHZhcigtLW1lZGlhLWNvbnRyb2wtZGlzcGxheSwgdmFyKC0tJHt0aGlzLmxvY2FsTmFtZX0tZGlzcGxheSwgaW5saW5lLWJsb2NrKSlgKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiI2NvbnRhaW5lclwiKTtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjcmFuZ2VcIik7XG4gICAgdGhpcy5yYW5nZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy51cGRhdGVCYXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy50aHVtYldpZHRoID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1tZWRpYS1yYW5nZS10aHVtYi13aWR0aFwiKSB8fCBcIjEwXCIsIDEwKTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXNhYmxlZFwiLFxuICAgICAgXCJhcmlhLWRpc2FibGVkXCIsXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICBdO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikge1xuICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYyA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmdldEVsZW1lbnRCeUlkKG5ld1ZhbHVlKSk7XG4gICAgICAgIChfZSA9IChfZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKF9kLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSBcImRpc2FibGVkXCIgfHwgYXR0ck5hbWUgPT09IFwiYXJpYS1kaXNhYmxlZFwiICYmIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yYW5nZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYW5nZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbWVkaWFDb250cm9sbGVySWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUlxuICAgICk7XG4gICAgaWYgKG1lZGlhQ29udHJvbGxlcklkKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgKF9hID0gdGhpcy5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudEJ5SWQobWVkaWFDb250cm9sbGVySWQpKTtcbiAgICAgIChfYyA9IChfYiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCYXIoKTtcbiAgICB0aGlzLnNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkZvY3VzSW4pKTtcbiAgICB0aGlzLnNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Gb2N1c091dCkpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIG51bGwpO1xuICAgIHRoaXMuc2hhZG93Um9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uRm9jdXNJbikpO1xuICAgIHRoaXMuc2hhZG93Um9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkZvY3VzT3V0KSk7XG4gIH1cbiAgdXBkYXRlUG9pbnRlckJhcihldnQpIHtcbiAgICBjb25zdCByYW5nZVJlY3QgPSB0aGlzLnJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBtb3VzZVBlcmNlbnQgPSAoZXZ0LmNsaWVudFggLSByYW5nZVJlY3QubGVmdCkgLyByYW5nZVJlY3Qud2lkdGg7XG4gICAgbW91c2VQZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbW91c2VQZXJjZW50KSk7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCIjcG9pbnRlclwiKTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIGAke21vdXNlUGVyY2VudCAqIHJhbmdlUmVjdC53aWR0aH1weGApO1xuICB9XG4gIHVwZGF0ZUJhcigpIHtcbiAgICBjb25zdCBjb2xvckFycmF5ID0gdGhpcy5nZXRCYXJDb2xvcnMoKTtcbiAgICBsZXQgZ3JhZGllbnRTdHIgPSBcImxpbmVhci1ncmFkaWVudCh0byByaWdodCwgXCI7XG4gICAgbGV0IHByZXZQZXJjZW50ID0gMDtcbiAgICBjb2xvckFycmF5LmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICBpZiAoY29sb3JbMV0gPCBwcmV2UGVyY2VudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZ3JhZGllbnRTdHIgPSBncmFkaWVudFN0ciArIGAke2NvbG9yWzBdfSAke3ByZXZQZXJjZW50fSUsICR7Y29sb3JbMF19ICR7Y29sb3JbMV19JSxgO1xuICAgICAgcHJldlBlcmNlbnQgPSBjb2xvclsxXTtcbiAgICB9KTtcbiAgICBncmFkaWVudFN0ciA9IGdyYWRpZW50U3RyLnNsaWNlKDAsIGdyYWRpZW50U3RyLmxlbmd0aCAtIDEpICsgXCIpXCI7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCIjcmFuZ2VcIik7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoXCItLW1lZGlhLXJhbmdlLXRyYWNrLXByb2dyZXNzLWludGVybmFsXCIsIGdyYWRpZW50U3RyKTtcbiAgfVxuICBnZXRSZWxhdGl2ZVZhbHVlcygpIHtcbiAgICBjb25zdCB7IHJhbmdlIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICByZWxhdGl2ZVZhbHVlOiByYW5nZS52YWx1ZSAtIHJhbmdlLm1pbixcbiAgICAgIHJlbGF0aXZlTWF4OiByYW5nZS5tYXggLSByYW5nZS5taW5cbiAgICB9O1xuICB9XG4gIGdldEJhckNvbG9ycygpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVsYXRpdmVWYWx1ZSxcbiAgICAgIHJlbGF0aXZlTWF4XG4gICAgfSA9IHRoaXMuZ2V0UmVsYXRpdmVWYWx1ZXMoKTtcbiAgICBjb25zdCByYW5nZVBlcmNlbnQgPSByZWxhdGl2ZVZhbHVlIC8gcmVsYXRpdmVNYXggKiAxMDA7XG4gICAgbGV0IHRodW1iUGVyY2VudCA9IDA7XG4gICAgaWYgKCEhcmVsYXRpdmVWYWx1ZSAmJiByZWxhdGl2ZVZhbHVlIDwgcmVsYXRpdmVNYXgpIHtcbiAgICAgIGNvbnN0IHRodW1iT2Zmc2V0ID0gdGhpcy50aHVtYldpZHRoICogKDAuNSAtIHJhbmdlUGVyY2VudCAvIDEwMCk7XG4gICAgICB0aHVtYlBlcmNlbnQgPSB0aHVtYk9mZnNldCAvIHJhbmdlLm9mZnNldFdpZHRoICogMTAwO1xuICAgIH1cbiAgICBsZXQgY29sb3JBcnJheSA9IFtcbiAgICAgIFtcInZhcigtLW1lZGlhLXJhbmdlLWJhci1jb2xvciwgdmFyKC0tbWVkaWEtcHJpbWFyeS1jb2xvciwgcmdiKDIzOCAyMzggMjM4KSkpXCIsIHJhbmdlUGVyY2VudCArIHRodW1iUGVyY2VudF0sXG4gICAgICBbXCJ2YXIoLS1tZWRpYS1yYW5nZS10cmFjay1jb2xvciwgdHJhbnNwYXJlbnQpXCIsIDEwMF1cbiAgICBdO1xuICAgIHJldHVybiBjb2xvckFycmF5O1xuICB9XG4gIGdldCBrZXlzVXNlZCgpIHtcbiAgICByZXR1cm4gW1wiQXJyb3dVcFwiLCBcIkFycm93UmlnaHRcIiwgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd0xlZnRcIl07XG4gIH1cbn1cbl9tZWRpYUNvbnRyb2xsZXIgPSBuZXcgV2Vha01hcCgpO1xuX29uRm9jdXNJbiA9IG5ldyBXZWFrTWFwKCk7XG5fb25Gb2N1c091dCA9IG5ldyBXZWFrTWFwKCk7XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtY2hyb21lLXJhbmdlXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtY2hyb21lLXJhbmdlXCIsIE1lZGlhQ2hyb21lUmFuZ2UpO1xufVxudmFyIG1lZGlhX2Nocm9tZV9yYW5nZV9kZWZhdWx0ID0gTWVkaWFDaHJvbWVSYW5nZTtcbmV4cG9ydCB7XG4gIE1lZGlhQ2hyb21lUmFuZ2UsXG4gIG1lZGlhX2Nocm9tZV9yYW5nZV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-chrome-range.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-container.js":
/*!***********************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-container.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   MediaContainer: function() { return /* binding */ MediaContainer; },\n/* harmony export */   \"default\": function() { return /* binding */ media_container_default; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _media_gesture_receiver_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./media-gesture-receiver.js */ \"(app-client)/./node_modules/media-chrome/dist/media-gesture-receiver.js\");\n\n\n\n\nconst Attributes = {\n  AUDIO: \"audio\",\n  AUTOHIDE: \"autohide\",\n  BREAKPOINTS: \"breakpoints\",\n  GESTURES_DISABLED: \"gesturesdisabled\",\n  KEYBOARD_CONTROL: \"keyboardcontrol\",\n  NO_AUTOHIDE: \"noautohide\",\n  USER_INACTIVE: \"userinactive\"\n};\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    ${\"\"}\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_IS_FULLSCREEN}]) ::slotted([slot=media]) {\n      outline: none;\n    }\n\n    :host {\n      box-sizing: border-box;\n      position: relative;\n      display: inline-block;\n      line-height: 0;\n      background-color: var(--media-background-color, #000);\n    }\n\n    :host(:not([${Attributes.AUDIO}])) [part~=layer]:not([part~=media-layer]) {\n      position: absolute;\n      top: 0;\n      left: 0;\n      bottom: 0;\n      right: 0;\n      display: flex;\n      flex-flow: column nowrap;\n      align-items: start;\n      pointer-events: none;\n      background: none;\n    }\n\n    slot[name=media] {\n      display: var(--media-slot-display, contents);\n    }\n\n    ${\"\"}\n    :host([${Attributes.AUDIO}]) slot[name=media] {\n      display: var(--media-slot-display, none);\n    }\n\n    ${\"\"}\n    :host([${Attributes.AUDIO}]) [part~=layer][part~=gesture-layer] {\n      height: 0;\n      display: block;\n    }\n\n    ${\"\"}\n    :host(:not([${Attributes.AUDIO}])[${Attributes.GESTURES_DISABLED}]) ::slotted([slot=gestures-chrome]),\n    :host(:not([${Attributes.AUDIO}])[${Attributes.GESTURES_DISABLED}]) media-gesture-receiver[slot=gestures-chrome] {\n      display: none;\n    }\n\n    ${\"\"}\n    ::slotted(:not([slot=media]):not([slot=poster]):not(media-loading-indicator)) {\n      pointer-events: auto;\n    }\n\n    :host(:not([${Attributes.AUDIO}])) *[part~=layer][part~=centered-layer] {\n      align-items: center;\n      justify-content: center;\n    }\n\n    :host(:not([${Attributes.AUDIO}])) ::slotted(media-gesture-receiver[slot=gestures-chrome]),\n    :host(:not([${Attributes.AUDIO}])) media-gesture-receiver[slot=gestures-chrome] {\n      align-self: stretch;\n      flex-grow: 1;\n    }\n\n    slot[name=middle-chrome] {\n      display: inline;\n      flex-grow: 1;\n      pointer-events: none;\n      background: none;\n    }\n\n    ${\"\"}\n    ::slotted([slot=media]),\n    ::slotted([slot=poster]) {\n      width: 100%;\n      height: 100%;\n    }\n\n    ${\"\"}\n    :host(:not([${Attributes.AUDIO}])) .spacer {\n      flex-grow: 1;\n    }\n\n    ${\"\"}\n    :host(:-webkit-full-screen) {\n      ${\"\"}\n      width: 100% !important;\n      height: 100% !important;\n    }\n\n    ${\"\"}\n    ::slotted(:not([slot=media]):not([${Attributes.NO_AUTOHIDE}])) {\n      opacity: 1;\n      transition: opacity 0.25s;\n    }\n\n    ${\"\"}\n    :host([${Attributes.USER_INACTIVE}]:not([${_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PAUSED}]):not([${_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_IS_CASTING}]):not([${Attributes.AUDIO}])) ::slotted(:not([slot=media]):not([${Attributes.NO_AUTOHIDE}])) {\n      opacity: 0;\n      transition: opacity 1s;\n    }\n\n    ::slotted(media-control-bar)  {\n      align-self: stretch;\n    }\n\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_HAS_PLAYED}]) ::slotted([slot=poster]) {\n      display: none;\n    }\n  </style>\n\n  <slot name=\"media\" part=\"layer media-layer\"></slot>\n  <slot name=\"poster\" part=\"layer poster-layer\"></slot>\n  <slot name=\"gestures-chrome\" part=\"layer gesture-layer\">\n    <media-gesture-receiver slot=\"gestures-chrome\"></media-gesture-receiver>\n  </slot>\n  <span part=\"layer vertical-layer\">\n    <slot name=\"top-chrome\" part=\"top chrome\"></slot>\n    <slot name=\"middle-chrome\" part=\"middle chrome\"></slot>\n    <slot name=\"centered-chrome\" part=\"layer centered-layer center centered chrome\"></slot>\n    ${\"\"}\n    <slot part=\"bottom chrome\"></slot>\n  </span>\n`;\nconst MEDIA_UI_ATTRIBUTE_NAMES = Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes);\nconst defaultBreakpoints = \"sm:384 md:576 lg:768 xl:960\";\nconst resizeCallback = (entries) => {\n  var _a;\n  for (const entry of entries) {\n    const container = entry.target;\n    if (!container.isConnected)\n      continue;\n    const breakpoints = (_a = container.getAttribute(Attributes.BREAKPOINTS)) != null ? _a : defaultBreakpoints;\n    const ranges = createBreakpointMap(breakpoints);\n    const activeBreakpoints = getBreakpoints(ranges, entry.contentRect);\n    let changed = false;\n    Object.keys(ranges).forEach((name) => {\n      if (activeBreakpoints.includes(name)) {\n        if (!container.hasAttribute(`breakpoint${name}`)) {\n          container.setAttribute(`breakpoint${name}`, \"\");\n          changed = true;\n        }\n        return;\n      }\n      if (container.hasAttribute(`breakpoint${name}`)) {\n        container.removeAttribute(`breakpoint${name}`);\n        changed = true;\n      }\n    });\n    if (changed) {\n      const evt = new CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateChangeEvents.BREAKPOINTS_CHANGE, {\n        detail: activeBreakpoints\n      });\n      container.dispatchEvent(evt);\n    }\n  }\n};\nfunction createBreakpointMap(breakpoints) {\n  const pairs = breakpoints.split(/\\s+/);\n  return Object.fromEntries(pairs.map((pair) => pair.split(\":\")));\n}\nfunction getBreakpoints(breakpoints, rect) {\n  return Object.keys(breakpoints).filter((name) => {\n    return rect.width >= breakpoints[name];\n  });\n}\nclass MediaContainer extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    const mutationCallback = (mutationsList) => {\n      const media = this.media;\n      for (let mutation of mutationsList) {\n        if (mutation.type === \"childList\") {\n          mutation.removedNodes.forEach((node) => {\n            if (node.slot == \"media\" && mutation.target == this) {\n              let previousSibling = mutation.previousSibling && mutation.previousSibling.previousElementSibling;\n              if (!previousSibling || !media) {\n                this.mediaUnsetCallback(node);\n              } else {\n                let wasFirst = previousSibling.slot !== \"media\";\n                while ((previousSibling = previousSibling.previousSibling) !== null) {\n                  if (previousSibling.slot == \"media\")\n                    wasFirst = false;\n                }\n                if (wasFirst)\n                  this.mediaUnsetCallback(node);\n              }\n            }\n          });\n          if (media) {\n            mutation.addedNodes.forEach((node) => {\n              if (node == media) {\n                this.handleMediaUpdated(media).then(\n                  (media2) => this.mediaSetCallback(media2)\n                );\n              }\n            });\n          }\n        }\n      }\n    };\n    const mutationObserver = new MutationObserver(mutationCallback);\n    mutationObserver.observe(this, { childList: true, subtree: true });\n    let pendingResizeCb = false;\n    const deferResizeCallback = (entries) => {\n      if (pendingResizeCb)\n        return;\n      setTimeout(() => {\n        resizeCallback(entries);\n        pendingResizeCb = false;\n      }, 16);\n      pendingResizeCb = true;\n    };\n    const resizeObserver = new ResizeObserver(deferResizeCallback);\n    this.resizeObserver = resizeObserver;\n    resizeObserver.observe(this);\n    let currentMedia = this.media;\n    let chainedSlot = this.querySelector(\":scope > slot[slot=media]\");\n    if (chainedSlot) {\n      chainedSlot.addEventListener(\"slotchange\", () => {\n        const slotEls = chainedSlot.assignedElements({ flatten: true });\n        if (!slotEls.length) {\n          this.mediaUnsetCallback(currentMedia);\n          return;\n        }\n        if (this.media) {\n          currentMedia = this.media;\n          this.handleMediaUpdated(this.media).then(\n            (media) => this.mediaSetCallback(media)\n          );\n        }\n      });\n    }\n  }\n  static get observedAttributes() {\n    return [Attributes.AUTOHIDE, Attributes.GESTURES_DISABLED].concat(\n      MEDIA_UI_ATTRIBUTE_NAMES\n    );\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName.toLowerCase() == Attributes.AUTOHIDE) {\n      this.autohide = newValue;\n    }\n  }\n  get media() {\n    let media = this.querySelector(\":scope > [slot=media]\");\n    if ((media == null ? void 0 : media.nodeName) == \"SLOT\")\n      media = media.assignedElements({ flatten: true })[0];\n    return media;\n  }\n  mediaSetCallback(media) {\n    this._mediaClickPlayToggle = () => {\n      const eventName = media.paused ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIEvents.MEDIA_PLAY_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIEvents.MEDIA_PAUSE_REQUEST;\n      this.dispatchEvent(\n        new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n      );\n    };\n  }\n  handleMediaUpdated(media) {\n    const resolveMediaPromise = (media2) => {\n      return Promise.resolve(media2);\n    };\n    const rejectMediaPromise = (media2) => {\n      console.error(\n        '<media-chrome>: Media element set with slot=\"media\" does not appear to be compatible.',\n        media2\n      );\n      return Promise.reject(media2);\n    };\n    if (!media) {\n      return rejectMediaPromise(media);\n    }\n    const mediaName = media.nodeName.toLowerCase();\n    if (mediaName.includes(\"-\")) {\n      return _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.whenDefined(mediaName).then(() => {\n        return resolveMediaPromise(media);\n      });\n    }\n    return resolveMediaPromise(media);\n  }\n  mediaUnsetCallback(node) {\n  }\n  connectedCallback() {\n    var _a;\n    const isAudioChrome = this.getAttribute(Attributes.AUDIO) != null;\n    const label = isAudioChrome ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_2__.nouns.AUDIO_PLAYER() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_2__.nouns.VIDEO_PLAYER();\n    this.setAttribute(\"role\", \"region\");\n    this.setAttribute(\"aria-label\", label);\n    if (this.media) {\n      this.handleMediaUpdated(this.media).then(\n        (media) => this.mediaSetCallback(media)\n      );\n    }\n    this.setAttribute(Attributes.USER_INACTIVE, \"\");\n    const setInactive = () => {\n      if (this.autohide < 0)\n        return;\n      if (this.hasAttribute(Attributes.USER_INACTIVE))\n        return;\n      this.setAttribute(Attributes.USER_INACTIVE, \"\");\n      const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(\n        _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateChangeEvents.USER_INACTIVE,\n        { composed: true, bubbles: true, detail: true }\n      );\n      this.dispatchEvent(evt);\n    };\n    const setActive = () => {\n      if (!this.hasAttribute(Attributes.USER_INACTIVE))\n        return;\n      this.removeAttribute(Attributes.USER_INACTIVE);\n      const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(\n        _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateChangeEvents.USER_INACTIVE,\n        { composed: true, bubbles: true, detail: false }\n      );\n      this.dispatchEvent(evt);\n    };\n    const scheduleInactive = () => {\n      setActive();\n      clearTimeout(this._inactiveTimeout);\n      if (this.autohide < 0)\n        return;\n      this._inactiveTimeout = setTimeout(() => {\n        setInactive();\n      }, this.autohide * 1e3);\n    };\n    this.addEventListener(\"keyup\", () => {\n      scheduleInactive();\n    });\n    this.addEventListener(\"pointerup\", (e) => {\n      if (e.pointerType === \"touch\") {\n        if ([this, this.media].includes(e.target) && !this.hasAttribute(Attributes.USER_INACTIVE)) {\n          setInactive();\n        } else {\n          scheduleInactive();\n        }\n      } else if (e.composedPath().some(\n        (el) => {\n          var _a2;\n          return [\"media-play-button\", \"media-fullscreen-button\"].includes(\n            (_a2 = el == null ? void 0 : el.nodeName) == null ? void 0 : _a2.toLowerCase()\n          );\n        }\n      )) {\n        scheduleInactive();\n      }\n    });\n    this.addEventListener(\"pointermove\", (e) => {\n      if (e.pointerType !== \"mouse\")\n        return;\n      setActive();\n      clearTimeout(this._inactiveTimeout);\n      if ([this, this.media].includes(e.target)) {\n        scheduleInactive();\n      }\n    });\n    this.addEventListener(\"mouseleave\", () => {\n      setInactive();\n    });\n    this.addEventListener(\"keyup\", () => {\n      this.setAttribute(Attributes.KEYBOARD_CONTROL, \"\");\n    });\n    (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.window) == null ? void 0 : _a.addEventListener(\"mouseup\", () => {\n      this.removeAttribute(Attributes.KEYBOARD_CONTROL);\n    });\n  }\n  set autohide(seconds) {\n    seconds = Number(seconds);\n    this._autohide = isNaN(seconds) ? 0 : seconds;\n  }\n  get autohide() {\n    return this._autohide === void 0 ? 2 : this._autohide;\n  }\n}\nvar media_container_default = MediaContainer;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNvbnRhaW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNFO0FBSzlDO0FBQ21CO0FBQ047QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSw0REFBaUIscUJBQXFCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ04sYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQSxNQUFNO0FBQ04sYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTixrQkFBa0IsaUJBQWlCLEtBQUssNkJBQTZCO0FBQ3JFLGtCQUFrQixpQkFBaUIsS0FBSyw2QkFBNkI7QUFDckU7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTixrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ04sd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLGFBQWEseUJBQXlCLFNBQVMsNERBQWlCLGNBQWMsVUFBVSw0REFBaUIsa0JBQWtCLFVBQVUsaUJBQWlCLHdDQUF3Qyx1QkFBdUI7QUFDck47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDREQUFpQixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNERBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLGlFQUFzQjtBQUN4RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkJBQTZCLHFFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdEQUFhLHNCQUFzQix3REFBYTtBQUN2RjtBQUNBLFlBQVkscUVBQVUsMEJBQTBCLCtCQUErQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUVBQVU7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBSyxrQkFBa0Isb0RBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBVTtBQUNoQyxRQUFRLGlFQUFzQjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUVBQVU7QUFDaEMsUUFBUSxpRUFBc0I7QUFDOUIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxVQUFVLHFFQUFVO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNvbnRhaW5lci5qcz85MzAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHtcbiAgTWVkaWFVSUV2ZW50cyxcbiAgTWVkaWFVSUF0dHJpYnV0ZXMsXG4gIE1lZGlhU3RhdGVDaGFuZ2VFdmVudHNcbn0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBub3VucyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCBcIi4vbWVkaWEtZ2VzdHVyZS1yZWNlaXZlci5qc1wiO1xuY29uc3QgQXR0cmlidXRlcyA9IHtcbiAgQVVESU86IFwiYXVkaW9cIixcbiAgQVVUT0hJREU6IFwiYXV0b2hpZGVcIixcbiAgQlJFQUtQT0lOVFM6IFwiYnJlYWtwb2ludHNcIixcbiAgR0VTVFVSRVNfRElTQUJMRUQ6IFwiZ2VzdHVyZXNkaXNhYmxlZFwiLFxuICBLRVlCT0FSRF9DT05UUk9MOiBcImtleWJvYXJkY29udHJvbFwiLFxuICBOT19BVVRPSElERTogXCJub2F1dG9oaWRlXCIsXG4gIFVTRVJfSU5BQ1RJVkU6IFwidXNlcmluYWN0aXZlXCJcbn07XG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICAgICR7XCJcIn1cbiAgICA6aG9zdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19GVUxMU0NSRUVOfV0pIDo6c2xvdHRlZChbc2xvdD1tZWRpYV0pIHtcbiAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuXG4gICAgOmhvc3Qge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIGxpbmUtaGVpZ2h0OiAwO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWVkaWEtYmFja2dyb3VuZC1jb2xvciwgIzAwMCk7XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdChbJHtBdHRyaWJ1dGVzLkFVRElPfV0pKSBbcGFydH49bGF5ZXJdOm5vdChbcGFydH49bWVkaWEtbGF5ZXJdKSB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDA7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xuICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIH1cblxuICAgIHNsb3RbbmFtZT1tZWRpYV0ge1xuICAgICAgZGlzcGxheTogdmFyKC0tbWVkaWEtc2xvdC1kaXNwbGF5LCBjb250ZW50cyk7XG4gICAgfVxuXG4gICAgJHtcIlwifVxuICAgIDpob3N0KFske0F0dHJpYnV0ZXMuQVVESU99XSkgc2xvdFtuYW1lPW1lZGlhXSB7XG4gICAgICBkaXNwbGF5OiB2YXIoLS1tZWRpYS1zbG90LWRpc3BsYXksIG5vbmUpO1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICA6aG9zdChbJHtBdHRyaWJ1dGVzLkFVRElPfV0pIFtwYXJ0fj1sYXllcl1bcGFydH49Z2VzdHVyZS1sYXllcl0ge1xuICAgICAgaGVpZ2h0OiAwO1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuXG4gICAgJHtcIlwifVxuICAgIDpob3N0KDpub3QoWyR7QXR0cmlidXRlcy5BVURJT31dKVske0F0dHJpYnV0ZXMuR0VTVFVSRVNfRElTQUJMRUR9XSkgOjpzbG90dGVkKFtzbG90PWdlc3R1cmVzLWNocm9tZV0pLFxuICAgIDpob3N0KDpub3QoWyR7QXR0cmlidXRlcy5BVURJT31dKVske0F0dHJpYnV0ZXMuR0VTVFVSRVNfRElTQUJMRUR9XSkgbWVkaWEtZ2VzdHVyZS1yZWNlaXZlcltzbG90PWdlc3R1cmVzLWNocm9tZV0ge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAke1wiXCJ9XG4gICAgOjpzbG90dGVkKDpub3QoW3Nsb3Q9bWVkaWFdKTpub3QoW3Nsb3Q9cG9zdGVyXSk6bm90KG1lZGlhLWxvYWRpbmctaW5kaWNhdG9yKSkge1xuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdChbJHtBdHRyaWJ1dGVzLkFVRElPfV0pKSAqW3BhcnR+PWxheWVyXVtwYXJ0fj1jZW50ZXJlZC1sYXllcl0ge1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cblxuICAgIDpob3N0KDpub3QoWyR7QXR0cmlidXRlcy5BVURJT31dKSkgOjpzbG90dGVkKG1lZGlhLWdlc3R1cmUtcmVjZWl2ZXJbc2xvdD1nZXN0dXJlcy1jaHJvbWVdKSxcbiAgICA6aG9zdCg6bm90KFske0F0dHJpYnV0ZXMuQVVESU99XSkpIG1lZGlhLWdlc3R1cmUtcmVjZWl2ZXJbc2xvdD1nZXN0dXJlcy1jaHJvbWVdIHtcbiAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICBmbGV4LWdyb3c6IDE7XG4gICAgfVxuXG4gICAgc2xvdFtuYW1lPW1pZGRsZS1jaHJvbWVdIHtcbiAgICAgIGRpc3BsYXk6IGlubGluZTtcbiAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICB9XG5cbiAgICAke1wiXCJ9XG4gICAgOjpzbG90dGVkKFtzbG90PW1lZGlhXSksXG4gICAgOjpzbG90dGVkKFtzbG90PXBvc3Rlcl0pIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICA6aG9zdCg6bm90KFske0F0dHJpYnV0ZXMuQVVESU99XSkpIC5zcGFjZXIge1xuICAgICAgZmxleC1ncm93OiAxO1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICA6aG9zdCg6LXdlYmtpdC1mdWxsLXNjcmVlbikge1xuICAgICAgJHtcIlwifVxuICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICA6OnNsb3R0ZWQoOm5vdChbc2xvdD1tZWRpYV0pOm5vdChbJHtBdHRyaWJ1dGVzLk5PX0FVVE9ISURFfV0pKSB7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cztcbiAgICB9XG5cbiAgICAke1wiXCJ9XG4gICAgOmhvc3QoWyR7QXR0cmlidXRlcy5VU0VSX0lOQUNUSVZFfV06bm90KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRH1dKTpub3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfSVNfQ0FTVElOR31dKTpub3QoWyR7QXR0cmlidXRlcy5BVURJT31dKSkgOjpzbG90dGVkKDpub3QoW3Nsb3Q9bWVkaWFdKTpub3QoWyR7QXR0cmlidXRlcy5OT19BVVRPSElERX1dKSkge1xuICAgICAgb3BhY2l0eTogMDtcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XG4gICAgfVxuXG4gICAgOjpzbG90dGVkKG1lZGlhLWNvbnRyb2wtYmFyKSAge1xuICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICB9XG5cbiAgICA6aG9zdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9IQVNfUExBWUVEfV0pIDo6c2xvdHRlZChbc2xvdD1wb3N0ZXJdKSB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgPC9zdHlsZT5cblxuICA8c2xvdCBuYW1lPVwibWVkaWFcIiBwYXJ0PVwibGF5ZXIgbWVkaWEtbGF5ZXJcIj48L3Nsb3Q+XG4gIDxzbG90IG5hbWU9XCJwb3N0ZXJcIiBwYXJ0PVwibGF5ZXIgcG9zdGVyLWxheWVyXCI+PC9zbG90PlxuICA8c2xvdCBuYW1lPVwiZ2VzdHVyZXMtY2hyb21lXCIgcGFydD1cImxheWVyIGdlc3R1cmUtbGF5ZXJcIj5cbiAgICA8bWVkaWEtZ2VzdHVyZS1yZWNlaXZlciBzbG90PVwiZ2VzdHVyZXMtY2hyb21lXCI+PC9tZWRpYS1nZXN0dXJlLXJlY2VpdmVyPlxuICA8L3Nsb3Q+XG4gIDxzcGFuIHBhcnQ9XCJsYXllciB2ZXJ0aWNhbC1sYXllclwiPlxuICAgIDxzbG90IG5hbWU9XCJ0b3AtY2hyb21lXCIgcGFydD1cInRvcCBjaHJvbWVcIj48L3Nsb3Q+XG4gICAgPHNsb3QgbmFtZT1cIm1pZGRsZS1jaHJvbWVcIiBwYXJ0PVwibWlkZGxlIGNocm9tZVwiPjwvc2xvdD5cbiAgICA8c2xvdCBuYW1lPVwiY2VudGVyZWQtY2hyb21lXCIgcGFydD1cImxheWVyIGNlbnRlcmVkLWxheWVyIGNlbnRlciBjZW50ZXJlZCBjaHJvbWVcIj48L3Nsb3Q+XG4gICAgJHtcIlwifVxuICAgIDxzbG90IHBhcnQ9XCJib3R0b20gY2hyb21lXCI+PC9zbG90PlxuICA8L3NwYW4+XG5gO1xuY29uc3QgTUVESUFfVUlfQVRUUklCVVRFX05BTUVTID0gT2JqZWN0LnZhbHVlcyhNZWRpYVVJQXR0cmlidXRlcyk7XG5jb25zdCBkZWZhdWx0QnJlYWtwb2ludHMgPSBcInNtOjM4NCBtZDo1NzYgbGc6NzY4IHhsOjk2MFwiO1xuY29uc3QgcmVzaXplQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICB2YXIgX2E7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGVudHJ5LnRhcmdldDtcbiAgICBpZiAoIWNvbnRhaW5lci5pc0Nvbm5lY3RlZClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gKF9hID0gY29udGFpbmVyLmdldEF0dHJpYnV0ZShBdHRyaWJ1dGVzLkJSRUFLUE9JTlRTKSkgIT0gbnVsbCA/IF9hIDogZGVmYXVsdEJyZWFrcG9pbnRzO1xuICAgIGNvbnN0IHJhbmdlcyA9IGNyZWF0ZUJyZWFrcG9pbnRNYXAoYnJlYWtwb2ludHMpO1xuICAgIGNvbnN0IGFjdGl2ZUJyZWFrcG9pbnRzID0gZ2V0QnJlYWtwb2ludHMocmFuZ2VzLCBlbnRyeS5jb250ZW50UmVjdCk7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhyYW5nZXMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmIChhY3RpdmVCcmVha3BvaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoYGJyZWFrcG9pbnQke25hbWV9YCkpIHtcbiAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKGBicmVha3BvaW50JHtuYW1lfWAsIFwiXCIpO1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXIuaGFzQXR0cmlidXRlKGBicmVha3BvaW50JHtuYW1lfWApKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYGJyZWFrcG9pbnQke25hbWV9YCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICBjb25zdCBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoTWVkaWFTdGF0ZUNoYW5nZUV2ZW50cy5CUkVBS1BPSU5UU19DSEFOR0UsIHtcbiAgICAgICAgZGV0YWlsOiBhY3RpdmVCcmVha3BvaW50c1xuICAgICAgfSk7XG4gICAgICBjb250YWluZXIuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJyZWFrcG9pbnRNYXAoYnJlYWtwb2ludHMpIHtcbiAgY29uc3QgcGFpcnMgPSBicmVha3BvaW50cy5zcGxpdCgvXFxzKy8pO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHBhaXJzLm1hcCgocGFpcikgPT4gcGFpci5zcGxpdChcIjpcIikpKTtcbn1cbmZ1bmN0aW9uIGdldEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzLCByZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhicmVha3BvaW50cykuZmlsdGVyKChuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHJlY3Qud2lkdGggPj0gYnJlYWtwb2ludHNbbmFtZV07XG4gIH0pO1xufVxuY2xhc3MgTWVkaWFDb250YWluZXIgZXh0ZW5kcyBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICAgIGNvbnN0IG11dGF0aW9uQ2FsbGJhY2sgPSAobXV0YXRpb25zTGlzdCkgPT4ge1xuICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgZm9yIChsZXQgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgIG11dGF0aW9uLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5zbG90ID09IFwibWVkaWFcIiAmJiBtdXRhdGlvbi50YXJnZXQgPT0gdGhpcykge1xuICAgICAgICAgICAgICBsZXQgcHJldmlvdXNTaWJsaW5nID0gbXV0YXRpb24ucHJldmlvdXNTaWJsaW5nICYmIG11dGF0aW9uLnByZXZpb3VzU2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCAhbWVkaWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhVW5zZXRDYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd2FzRmlyc3QgPSBwcmV2aW91c1NpYmxpbmcuc2xvdCAhPT0gXCJtZWRpYVwiO1xuICAgICAgICAgICAgICAgIHdoaWxlICgocHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcuc2xvdCA9PSBcIm1lZGlhXCIpXG4gICAgICAgICAgICAgICAgICAgIHdhc0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YXNGaXJzdClcbiAgICAgICAgICAgICAgICAgIHRoaXMubWVkaWFVbnNldENhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gbWVkaWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lZGlhVXBkYXRlZChtZWRpYSkudGhlbihcbiAgICAgICAgICAgICAgICAgIChtZWRpYTIpID0+IHRoaXMubWVkaWFTZXRDYWxsYmFjayhtZWRpYTIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25DYWxsYmFjayk7XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIGxldCBwZW5kaW5nUmVzaXplQ2IgPSBmYWxzZTtcbiAgICBjb25zdCBkZWZlclJlc2l6ZUNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcbiAgICAgIGlmIChwZW5kaW5nUmVzaXplQ2IpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXNpemVDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgICAgcGVuZGluZ1Jlc2l6ZUNiID0gZmFsc2U7XG4gICAgICB9LCAxNik7XG4gICAgICBwZW5kaW5nUmVzaXplQ2IgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZGVmZXJSZXNpemVDYWxsYmFjayk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcyk7XG4gICAgbGV0IGN1cnJlbnRNZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgbGV0IGNoYWluZWRTbG90ID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gc2xvdFtzbG90PW1lZGlhXVwiKTtcbiAgICBpZiAoY2hhaW5lZFNsb3QpIHtcbiAgICAgIGNoYWluZWRTbG90LmFkZEV2ZW50TGlzdGVuZXIoXCJzbG90Y2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2xvdEVscyA9IGNoYWluZWRTbG90LmFzc2lnbmVkRWxlbWVudHMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIXNsb3RFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVVuc2V0Q2FsbGJhY2soY3VycmVudE1lZGlhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgICBjdXJyZW50TWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWVkaWFVcGRhdGVkKHRoaXMubWVkaWEpLnRoZW4oXG4gICAgICAgICAgICAobWVkaWEpID0+IHRoaXMubWVkaWFTZXRDYWxsYmFjayhtZWRpYSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtBdHRyaWJ1dGVzLkFVVE9ISURFLCBBdHRyaWJ1dGVzLkdFU1RVUkVTX0RJU0FCTEVEXS5jb25jYXQoXG4gICAgICBNRURJQV9VSV9BVFRSSUJVVEVfTkFNRVNcbiAgICApO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQXR0cmlidXRlcy5BVVRPSElERSkge1xuICAgICAgdGhpcy5hdXRvaGlkZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWEoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gW3Nsb3Q9bWVkaWFdXCIpO1xuICAgIGlmICgobWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLm5vZGVOYW1lKSA9PSBcIlNMT1RcIilcbiAgICAgIG1lZGlhID0gbWVkaWEuYXNzaWduZWRFbGVtZW50cyh7IGZsYXR0ZW46IHRydWUgfSlbMF07XG4gICAgcmV0dXJuIG1lZGlhO1xuICB9XG4gIG1lZGlhU2V0Q2FsbGJhY2sobWVkaWEpIHtcbiAgICB0aGlzLl9tZWRpYUNsaWNrUGxheVRvZ2dsZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG1lZGlhLnBhdXNlZCA/IE1lZGlhVUlFdmVudHMuTUVESUFfUExBWV9SRVFVRVNUIDogTWVkaWFVSUV2ZW50cy5NRURJQV9QQVVTRV9SRVFVRVNUO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChldmVudE5hbWUsIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUgfSlcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBoYW5kbGVNZWRpYVVwZGF0ZWQobWVkaWEpIHtcbiAgICBjb25zdCByZXNvbHZlTWVkaWFQcm9taXNlID0gKG1lZGlhMikgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZWRpYTIpO1xuICAgIH07XG4gICAgY29uc3QgcmVqZWN0TWVkaWFQcm9taXNlID0gKG1lZGlhMikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJzxtZWRpYS1jaHJvbWU+OiBNZWRpYSBlbGVtZW50IHNldCB3aXRoIHNsb3Q9XCJtZWRpYVwiIGRvZXMgbm90IGFwcGVhciB0byBiZSBjb21wYXRpYmxlLicsXG4gICAgICAgIG1lZGlhMlxuICAgICAgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtZWRpYTIpO1xuICAgIH07XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuIHJlamVjdE1lZGlhUHJvbWlzZShtZWRpYSk7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhTmFtZSA9IG1lZGlhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG1lZGlhTmFtZS5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKG1lZGlhTmFtZSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTWVkaWFQcm9taXNlKG1lZGlhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZU1lZGlhUHJvbWlzZShtZWRpYSk7XG4gIH1cbiAgbWVkaWFVbnNldENhbGxiYWNrKG5vZGUpIHtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaXNBdWRpb0Nocm9tZSA9IHRoaXMuZ2V0QXR0cmlidXRlKEF0dHJpYnV0ZXMuQVVESU8pICE9IG51bGw7XG4gICAgY29uc3QgbGFiZWwgPSBpc0F1ZGlvQ2hyb21lID8gbm91bnMuQVVESU9fUExBWUVSKCkgOiBub3Vucy5WSURFT19QTEFZRVIoKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJyZWdpb25cIik7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGxhYmVsKTtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5oYW5kbGVNZWRpYVVwZGF0ZWQodGhpcy5tZWRpYSkudGhlbihcbiAgICAgICAgKG1lZGlhKSA9PiB0aGlzLm1lZGlhU2V0Q2FsbGJhY2sobWVkaWEpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnNldEF0dHJpYnV0ZShBdHRyaWJ1dGVzLlVTRVJfSU5BQ1RJVkUsIFwiXCIpO1xuICAgIGNvbnN0IHNldEluYWN0aXZlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXV0b2hpZGUgPCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoQXR0cmlidXRlcy5VU0VSX0lOQUNUSVZFKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQXR0cmlidXRlcy5VU0VSX0lOQUNUSVZFLCBcIlwiKTtcbiAgICAgIGNvbnN0IGV2dCA9IG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KFxuICAgICAgICBNZWRpYVN0YXRlQ2hhbmdlRXZlbnRzLlVTRVJfSU5BQ1RJVkUsXG4gICAgICAgIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRBY3RpdmUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKEF0dHJpYnV0ZXMuVVNFUl9JTkFDVElWRSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKEF0dHJpYnV0ZXMuVVNFUl9JTkFDVElWRSk7XG4gICAgICBjb25zdCBldnQgPSBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChcbiAgICAgICAgTWVkaWFTdGF0ZUNoYW5nZUV2ZW50cy5VU0VSX0lOQUNUSVZFLFxuICAgICAgICB7IGNvbXBvc2VkOiB0cnVlLCBidWJibGVzOiB0cnVlLCBkZXRhaWw6IGZhbHNlIH1cbiAgICAgICk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9O1xuICAgIGNvbnN0IHNjaGVkdWxlSW5hY3RpdmUgPSAoKSA9PiB7XG4gICAgICBzZXRBY3RpdmUoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9pbmFjdGl2ZVRpbWVvdXQpO1xuICAgICAgaWYgKHRoaXMuYXV0b2hpZGUgPCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9pbmFjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0SW5hY3RpdmUoKTtcbiAgICAgIH0sIHRoaXMuYXV0b2hpZGUgKiAxZTMpO1xuICAgIH07XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKCkgPT4ge1xuICAgICAgc2NoZWR1bGVJbmFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICBpZiAoW3RoaXMsIHRoaXMubWVkaWFdLmluY2x1ZGVzKGUudGFyZ2V0KSAmJiAhdGhpcy5oYXNBdHRyaWJ1dGUoQXR0cmlidXRlcy5VU0VSX0lOQUNUSVZFKSkge1xuICAgICAgICAgIHNldEluYWN0aXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NoZWR1bGVJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUuY29tcG9zZWRQYXRoKCkuc29tZShcbiAgICAgICAgKGVsKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICByZXR1cm4gW1wibWVkaWEtcGxheS1idXR0b25cIiwgXCJtZWRpYS1mdWxsc2NyZWVuLWJ1dHRvblwiXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIChfYTIgPSBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwubm9kZU5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICkpIHtcbiAgICAgICAgc2NoZWR1bGVJbmFjdGl2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5wb2ludGVyVHlwZSAhPT0gXCJtb3VzZVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBzZXRBY3RpdmUoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9pbmFjdGl2ZVRpbWVvdXQpO1xuICAgICAgaWYgKFt0aGlzLCB0aGlzLm1lZGlhXS5pbmNsdWRlcyhlLnRhcmdldCkpIHtcbiAgICAgICAgc2NoZWR1bGVJbmFjdGl2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgc2V0SW5hY3RpdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShBdHRyaWJ1dGVzLktFWUJPQVJEX0NPTlRST0wsIFwiXCIpO1xuICAgIH0pO1xuICAgIChfYSA9IGdsb2JhbFRoaXMud2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoQXR0cmlidXRlcy5LRVlCT0FSRF9DT05UUk9MKTtcbiAgICB9KTtcbiAgfVxuICBzZXQgYXV0b2hpZGUoc2Vjb25kcykge1xuICAgIHNlY29uZHMgPSBOdW1iZXIoc2Vjb25kcyk7XG4gICAgdGhpcy5fYXV0b2hpZGUgPSBpc05hTihzZWNvbmRzKSA/IDAgOiBzZWNvbmRzO1xuICB9XG4gIGdldCBhdXRvaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b2hpZGUgPT09IHZvaWQgMCA/IDIgOiB0aGlzLl9hdXRvaGlkZTtcbiAgfVxufVxudmFyIG1lZGlhX2NvbnRhaW5lcl9kZWZhdWx0ID0gTWVkaWFDb250YWluZXI7XG5leHBvcnQge1xuICBBdHRyaWJ1dGVzLFxuICBNZWRpYUNvbnRhaW5lcixcbiAgbWVkaWFfY29udGFpbmVyX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-container.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-control-bar.js":
/*!*************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-control-bar.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_control_bar_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      ${\"\"}\n      box-sizing: border-box;\n      display: var(--media-control-display, var(--media-control-bar-display, inline-flex));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      --media-loading-indicator-icon-height: 44px;\n    }\n\n    media-time-range,\n    ::slotted(media-time-range),\n    ::slotted(media-clip-selector) {\n      flex-grow: 1;\n    }\n\n    media-time-range,\n    ::slotted(media-time-range),\n    ::slotted(media-clip-selector),\n    media-volume-range,\n    ::slotted(media-volume-range) {\n      height: var(--_range-auto-size, calc(var(--media-control-height, 24px) + 2 * var(--_media-range-padding)));\n    }\n  </style>\n\n  <slot></slot>\n`;\nclass MediaControlBar extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    this.shadowRoot.querySelector(\"slot\").addEventListener(\"slotchange\", ({ target }) => {\n      const onlyRanges = target.assignedElements({ flatten: true }).every((el) => [\"media-time-range\", \"media-volume-range\"].includes(el.nodeName.toLowerCase()));\n      const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n      const autoSizeHeight = onlyRanges ? \"unset\" : \"initial\";\n      style.setProperty(\"--_range-auto-size\", autoSizeHeight);\n    });\n  }\n  static get observedAttributes() {\n    return [_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n  }\n}\n_mediaController = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-control-bar\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-control-bar\", MediaControlBar);\n}\nvar media_control_bar_default = MediaControlBar;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNvbnRyb2wtYmFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUNBO0FBQ1E7QUFDdEUsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBLDRFQUE0RSxRQUFRO0FBQ3BGLG1EQUFtRCxlQUFlO0FBQ2xFLGNBQWMsUUFBUSxFQUFFLDJFQUFrQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLHVFQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUVBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtY29udHJvbC1iYXIuanM/YzAwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfbWVkaWFDb250cm9sbGVyO1xuaW1wb3J0IHsgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0T3JJbnNlcnRDU1NSdWxlIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICR7XCJcIn1cbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICBkaXNwbGF5OiB2YXIoLS1tZWRpYS1jb250cm9sLWRpc3BsYXksIHZhcigtLW1lZGlhLWNvbnRyb2wtYmFyLWRpc3BsYXksIGlubGluZS1mbGV4KSk7XG4gICAgICBjb2xvcjogdmFyKC0tbWVkaWEtdGV4dC1jb2xvciwgdmFyKC0tbWVkaWEtcHJpbWFyeS1jb2xvciwgcmdiKDIzOCAyMzggMjM4KSkpO1xuICAgICAgLS1tZWRpYS1sb2FkaW5nLWluZGljYXRvci1pY29uLWhlaWdodDogNDRweDtcbiAgICB9XG5cbiAgICBtZWRpYS10aW1lLXJhbmdlLFxuICAgIDo6c2xvdHRlZChtZWRpYS10aW1lLXJhbmdlKSxcbiAgICA6OnNsb3R0ZWQobWVkaWEtY2xpcC1zZWxlY3Rvcikge1xuICAgICAgZmxleC1ncm93OiAxO1xuICAgIH1cblxuICAgIG1lZGlhLXRpbWUtcmFuZ2UsXG4gICAgOjpzbG90dGVkKG1lZGlhLXRpbWUtcmFuZ2UpLFxuICAgIDo6c2xvdHRlZChtZWRpYS1jbGlwLXNlbGVjdG9yKSxcbiAgICBtZWRpYS12b2x1bWUtcmFuZ2UsXG4gICAgOjpzbG90dGVkKG1lZGlhLXZvbHVtZS1yYW5nZSkge1xuICAgICAgaGVpZ2h0OiB2YXIoLS1fcmFuZ2UtYXV0by1zaXplLCBjYWxjKHZhcigtLW1lZGlhLWNvbnRyb2wtaGVpZ2h0LCAyNHB4KSArIDIgKiB2YXIoLS1fbWVkaWEtcmFuZ2UtcGFkZGluZykpKTtcbiAgICB9XG4gIDwvc3R5bGU+XG5cbiAgPHNsb3Q+PC9zbG90PlxuYDtcbmNsYXNzIE1lZGlhQ29udHJvbEJhciBleHRlbmRzIGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCB2b2lkIDApO1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzbG90XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJzbG90Y2hhbmdlXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICBjb25zdCBvbmx5UmFuZ2VzID0gdGFyZ2V0LmFzc2lnbmVkRWxlbWVudHMoeyBmbGF0dGVuOiB0cnVlIH0pLmV2ZXJ5KChlbCkgPT4gW1wibWVkaWEtdGltZS1yYW5nZVwiLCBcIm1lZGlhLXZvbHVtZS1yYW5nZVwiXS5pbmNsdWRlcyhlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICBjb25zdCB7IHN0eWxlIH0gPSBnZXRPckluc2VydENTU1J1bGUodGhpcy5zaGFkb3dSb290LCBcIjpob3N0XCIpO1xuICAgICAgY29uc3QgYXV0b1NpemVIZWlnaHQgPSBvbmx5UmFuZ2VzID8gXCJ1bnNldFwiIDogXCJpbml0aWFsXCI7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcIi0tX3JhbmdlLWF1dG8tc2l6ZVwiLCBhdXRvU2l6ZUhlaWdodCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJdO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikge1xuICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYyA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmdldEVsZW1lbnRCeUlkKG5ld1ZhbHVlKSk7XG4gICAgICAgIChfZSA9IChfZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKF9kLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbWVkaWFDb250cm9sbGVySWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUlxuICAgICk7XG4gICAgaWYgKG1lZGlhQ29udHJvbGxlcklkKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgKF9hID0gdGhpcy5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudEJ5SWQobWVkaWFDb250cm9sbGVySWQpKTtcbiAgICAgIChfYyA9IChfYiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2IgPSAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS51bmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgbnVsbCk7XG4gIH1cbn1cbl9tZWRpYUNvbnRyb2xsZXIgPSBuZXcgV2Vha01hcCgpO1xuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWNvbnRyb2wtYmFyXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtY29udHJvbC1iYXJcIiwgTWVkaWFDb250cm9sQmFyKTtcbn1cbnZhciBtZWRpYV9jb250cm9sX2Jhcl9kZWZhdWx0ID0gTWVkaWFDb250cm9sQmFyO1xuZXhwb3J0IHtcbiAgbWVkaWFfY29udHJvbF9iYXJfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-control-bar.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-controller.js":
/*!************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-controller.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_controller_default; }\n/* harmony export */ });\n/* harmony import */ var _media_container_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-container.js */ \"(app-client)/./node_modules/media-chrome/dist/media-container.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_attribute_token_list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/attribute-token-list.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/attribute-token-list.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/utils.js\");\n/* harmony import */ var _utils_captions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/captions.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/captions.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controller.js */ \"(app-client)/./node_modules/media-chrome/dist/controller.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _hotKeys, _fullscreenElement, _keyUpHandler, keyUpHandler_fn, _keyDownHandler, keyDownHandler_fn;\n\n\n\n\n\n\n\n\nconst ButtonPressedKeys = [\"ArrowLeft\", \"ArrowRight\", \"Enter\", \" \", \"f\", \"m\", \"k\", \"c\"];\nconst DEFAULT_SEEK_OFFSET = 10;\nconst DEFAULT_TIME = 0;\nconst Attributes = {\n  DEFAULT_SUBTITLES: \"defaultsubtitles\",\n  DEFAULT_STREAM_TYPE: \"defaultstreamtype\",\n  FULLSCREEN_ELEMENT: \"fullscreenelement\",\n  HOTKEYS: \"hotkeys\",\n  KEYS_USED: \"keysused\",\n  LIVE_EDGE_OFFSET: \"liveedgeoffset\",\n  NO_AUTO_SEEK_TO_LIVE: \"noautoseektolive\",\n  NO_HOTKEYS: \"nohotkeys\"\n};\nclass MediaController extends _media_container_js__WEBPACK_IMPORTED_MODULE_0__.MediaContainer {\n  constructor() {\n    super();\n    __privateAdd(this, _keyUpHandler);\n    __privateAdd(this, _keyDownHandler);\n    __privateAdd(this, _hotKeys, new _utils_attribute_token_list_js__WEBPACK_IMPORTED_MODULE_2__.AttributeTokenList(this, Attributes.HOTKEYS));\n    __privateAdd(this, _fullscreenElement, void 0);\n    if (_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates.MEDIA_VOLUME_UNAVAILABLE.get(this) === void 0) {\n      _controller_js__WEBPACK_IMPORTED_MODULE_6__.volumeSupportPromise.then(() => {\n        this.propagateMediaState(\n          _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE,\n          _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates.MEDIA_VOLUME_UNAVAILABLE.get(this)\n        );\n      });\n    }\n    this.mediaStateReceivers = [];\n    this.associatedElementSubscriptions = /* @__PURE__ */ new Map();\n    this.associateElement(this);\n    Object.keys(_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIRequestHandlers).forEach((key) => {\n      const handlerName = `_handle${(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.constToCamel)(key, true)}`;\n      this[handlerName] = (e) => {\n        e.stopPropagation();\n        if (!this.media) {\n          console.warn(\"MediaController: No media available.\");\n          return;\n        }\n        _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIRequestHandlers[key](this.media, e, this);\n      };\n      this.addEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents[key], this[handlerName]);\n    });\n    this._mediaStatePropagators = {};\n    Object.keys(_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates).forEach((key) => {\n      this._mediaStatePropagators[key] = (e) => {\n        this.propagateMediaState(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIProps[key], _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates[key].get(this, e));\n      };\n    });\n    this.enableHotkeys();\n  }\n  static get observedAttributes() {\n    return super.observedAttributes.concat(\n      Attributes.NO_HOTKEYS,\n      Attributes.HOTKEYS,\n      Attributes.DEFAULT_STREAM_TYPE,\n      Attributes.DEFAULT_SUBTITLES\n    );\n  }\n  get fullscreenElement() {\n    var _a;\n    return (_a = __privateGet(this, _fullscreenElement)) != null ? _a : this;\n  }\n  set fullscreenElement(element) {\n    if (this.hasAttribute(Attributes.FULLSCREEN_ELEMENT)) {\n      this.removeAttribute(Attributes.FULLSCREEN_ELEMENT);\n    }\n    __privateSet(this, _fullscreenElement, element);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a;\n    if (attrName === Attributes.NO_HOTKEYS) {\n      if (newValue !== oldValue && newValue === \"\") {\n        if (this.hasAttribute(Attributes.HOTKEYS)) {\n          console.warn(\"Both `hotkeys` and `nohotkeys` have been set. All hotkeys will be disabled.\");\n        }\n        this.disableHotkeys();\n      } else if (newValue !== oldValue && newValue === null) {\n        this.enableHotkeys();\n      }\n    } else if (attrName === Attributes.HOTKEYS) {\n      __privateGet(this, _hotKeys).value = newValue;\n    } else if (attrName === Attributes.DEFAULT_SUBTITLES && newValue !== oldValue && newValue === \"\") {\n      (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.toggleSubsCaps)(this, true);\n    } else if (attrName === Attributes.DEFAULT_STREAM_TYPE) {\n      this.propagateMediaState(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIProps.MEDIA_STREAM_TYPE);\n    } else if (attrName === Attributes.FULLSCREEN_ELEMENT) {\n      const el = newValue ? (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(newValue) : void 0;\n      __privateSet(this, _fullscreenElement, el);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  mediaSetCallback(media) {\n    super.mediaSetCallback(media);\n    if (!media.hasAttribute(\"tabindex\")) {\n      media.tabIndex = -1;\n    }\n    Object.keys(_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates).forEach((key) => {\n      const {\n        mediaEvents,\n        rootEvents,\n        trackListEvents\n      } = _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates[key];\n      const handler = this._mediaStatePropagators[key];\n      mediaEvents == null ? void 0 : mediaEvents.forEach((eventName) => {\n        media.addEventListener(eventName, handler);\n        handler();\n      });\n      rootEvents == null ? void 0 : rootEvents.forEach((eventName) => {\n        this.getRootNode().addEventListener(eventName, handler);\n        handler();\n      });\n      trackListEvents == null ? void 0 : trackListEvents.forEach((eventName) => {\n        var _a;\n        (_a = media.textTracks) == null ? void 0 : _a.addEventListener(eventName, handler);\n        handler();\n      });\n    });\n    if (!this.hasAttribute(\"novolumepref\")) {\n      try {\n        const volPref = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volPref !== null)\n          media.volume = volPref;\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }\n  }\n  mediaUnsetCallback(media) {\n    super.mediaUnsetCallback(media);\n    Object.keys(_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates).forEach((key) => {\n      const {\n        mediaEvents,\n        rootEvents,\n        trackListEvents\n      } = _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates[key];\n      const handler = this._mediaStatePropagators[key];\n      mediaEvents == null ? void 0 : mediaEvents.forEach((eventName) => {\n        media.removeEventListener(eventName, handler);\n      });\n      rootEvents == null ? void 0 : rootEvents.forEach((eventName) => {\n        this.getRootNode().removeEventListener(eventName, handler);\n      });\n      trackListEvents == null ? void 0 : trackListEvents.forEach((eventName) => {\n        var _a;\n        (_a = media.textTracks) == null ? void 0 : _a.removeEventListener(eventName, handler);\n      });\n    });\n    this.propagateMediaState(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIProps.MEDIA_PAUSED, true);\n  }\n  propagateMediaState(stateName, state) {\n    const attrName = stateName.toLowerCase();\n    const previousState = this.getAttribute(attrName);\n    propagateMediaState(this.mediaStateReceivers, stateName, state);\n    if (previousState === this.getAttribute(attrName))\n      return;\n    const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(\n      _constants_js__WEBPACK_IMPORTED_MODULE_5__.AttributeToStateChangeEventMap[attrName],\n      { composed: true, bubbles: true, detail: state }\n    );\n    this.dispatchEvent(evt);\n  }\n  associateElement(element) {\n    if (!element)\n      return;\n    const { associatedElementSubscriptions } = this;\n    if (associatedElementSubscriptions.has(element))\n      return;\n    const registerMediaStateReceiver = this.registerMediaStateReceiver.bind(this);\n    const unregisterMediaStateReceiver = this.unregisterMediaStateReceiver.bind(this);\n    const unsubscribe = monitorForMediaStateReceivers(\n      element,\n      registerMediaStateReceiver,\n      unregisterMediaStateReceiver\n    );\n    Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents).forEach((key) => {\n      element.addEventListener(\n        _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents[key],\n        this[`_handle${(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.constToCamel)(key, true)}`]\n      );\n    });\n    associatedElementSubscriptions.set(element, unsubscribe);\n  }\n  unassociateElement(element) {\n    if (!element)\n      return;\n    const { associatedElementSubscriptions } = this;\n    if (!associatedElementSubscriptions.has(element))\n      return;\n    const unsubscribe = associatedElementSubscriptions.get(element);\n    unsubscribe();\n    associatedElementSubscriptions.delete(element);\n    Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents).forEach((key) => {\n      element.removeEventListener(\n        _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents[key],\n        this[`_handle${(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.constToCamel)(key, true)}`]\n      );\n    });\n  }\n  registerMediaStateReceiver(el) {\n    if (!el)\n      return;\n    const els = this.mediaStateReceivers;\n    const index = els.indexOf(el);\n    if (index > -1)\n      return;\n    els.push(el);\n    Object.keys(_controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates).forEach((stateConstName) => {\n      const stateDetails = _controller_js__WEBPACK_IMPORTED_MODULE_6__.MediaUIStates[stateConstName];\n      propagateMediaState(\n        [el],\n        _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIProps[stateConstName],\n        stateDetails.get(this)\n      );\n    });\n  }\n  unregisterMediaStateReceiver(el) {\n    const els = this.mediaStateReceivers;\n    const index = els.indexOf(el);\n    if (index < 0)\n      return;\n    els.splice(index, 1);\n  }\n  enableHotkeys() {\n    this.addEventListener(\"keydown\", __privateMethod(this, _keyDownHandler, keyDownHandler_fn));\n  }\n  disableHotkeys() {\n    this.removeEventListener(\"keydown\", __privateMethod(this, _keyDownHandler, keyDownHandler_fn));\n    this.removeEventListener(\"keyup\", __privateMethod(this, _keyUpHandler, keyUpHandler_fn));\n  }\n  get hotkeys() {\n    return __privateGet(this, _hotKeys);\n  }\n  keyboardShortcutHandler(e) {\n    var _a, _b, _c, _d;\n    const keysUsed = ((_d = (_c = (_a = e.target.getAttribute(Attributes.KEYS_USED)) == null ? void 0 : _a.split(\" \")) != null ? _c : (_b = e.target) == null ? void 0 : _b.keysUsed) != null ? _d : []).map((key) => key === \"Space\" ? \" \" : key).filter(Boolean);\n    if (keysUsed.includes(e.key)) {\n      return;\n    }\n    let eventName, currentTimeStr, currentTime, detail, evt;\n    const seekOffset = DEFAULT_SEEK_OFFSET;\n    if (__privateGet(this, _hotKeys).contains(`no${e.key.toLowerCase()}`))\n      return;\n    if (e.key === \" \" && __privateGet(this, _hotKeys).contains(`nospace`))\n      return;\n    switch (e.key) {\n      case \" \":\n      case \"k\":\n        eventName = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_PAUSED) != null ? _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_PLAY_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_PAUSE_REQUEST;\n        this.dispatchEvent(\n          new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n        );\n        break;\n      case \"m\":\n        eventName = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_VOLUME_LEVEL) === \"off\" ? _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_UNMUTE_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_MUTE_REQUEST;\n        this.dispatchEvent(\n          new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n        );\n        break;\n      case \"f\":\n        eventName = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_IS_FULLSCREEN) != null ? _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_EXIT_FULLSCREEN_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_ENTER_FULLSCREEN_REQUEST;\n        this.dispatchEvent(\n          new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n        );\n        break;\n      case \"c\":\n        (0,_utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.toggleSubsCaps)(this);\n        break;\n      case \"ArrowLeft\":\n        currentTimeStr = this.getAttribute(\n          _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_CURRENT_TIME\n        );\n        currentTime = currentTimeStr && !Number.isNaN(+currentTimeStr) ? +currentTimeStr : DEFAULT_TIME;\n        detail = Math.max(currentTime - seekOffset, 0);\n        evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_SEEK_REQUEST, {\n          composed: true,\n          bubbles: true,\n          detail\n        });\n        this.dispatchEvent(evt);\n        break;\n      case \"ArrowRight\":\n        currentTimeStr = this.getAttribute(\n          _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_CURRENT_TIME\n        );\n        currentTime = currentTimeStr && !Number.isNaN(+currentTimeStr) ? +currentTimeStr : DEFAULT_TIME;\n        detail = Math.max(currentTime + seekOffset, 0);\n        evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.MEDIA_SEEK_REQUEST, {\n          composed: true,\n          bubbles: true,\n          detail\n        });\n        this.dispatchEvent(evt);\n        break;\n      default:\n        break;\n    }\n  }\n}\n_hotKeys = new WeakMap();\n_fullscreenElement = new WeakMap();\n_keyUpHandler = new WeakSet();\nkeyUpHandler_fn = function(e) {\n  const { key } = e;\n  if (!ButtonPressedKeys.includes(key)) {\n    this.removeEventListener(\"keyup\", __privateMethod(this, _keyUpHandler, keyUpHandler_fn));\n    return;\n  }\n  this.keyboardShortcutHandler(e);\n};\n_keyDownHandler = new WeakSet();\nkeyDownHandler_fn = function(e) {\n  const { metaKey, altKey, key } = e;\n  if (metaKey || altKey || !ButtonPressedKeys.includes(key)) {\n    this.removeEventListener(\"keyup\", __privateMethod(this, _keyUpHandler, keyUpHandler_fn));\n    return;\n  }\n  if ([\" \", \"ArrowLeft\", \"ArrowRight\"].includes(key) && !(__privateGet(this, _hotKeys).contains(`no${key.toLowerCase()}`) || key === \" \" && __privateGet(this, _hotKeys).contains(\"nospace\"))) {\n    e.preventDefault();\n  }\n  this.addEventListener(\"keyup\", __privateMethod(this, _keyUpHandler, keyUpHandler_fn), { once: true });\n};\nconst MEDIA_UI_ATTRIBUTE_NAMES = Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes);\nconst MEDIA_UI_PROP_NAMES = Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIProps);\nconst getMediaUIAttributesFrom = (child) => {\n  var _a, _b, _c, _d;\n  let { observedAttributes } = child.constructor;\n  if (!observedAttributes && ((_a = child.nodeName) == null ? void 0 : _a.includes(\"-\"))) {\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.upgrade(child);\n    ({ observedAttributes } = child.constructor);\n  }\n  const mediaChromeAttributesList = (_d = (_c = (_b = child == null ? void 0 : child.getAttribute) == null ? void 0 : _b.call(child, _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaStateReceiverAttributes.MEDIA_CHROME_ATTRIBUTES)) == null ? void 0 : _c.split) == null ? void 0 : _d.call(_c, /\\s+/);\n  if (!Array.isArray(observedAttributes || mediaChromeAttributesList))\n    return [];\n  return (observedAttributes || mediaChromeAttributesList).filter(\n    (attrName) => MEDIA_UI_ATTRIBUTE_NAMES.includes(attrName)\n  );\n};\nconst hasMediaUIProps = (mediaStateReceiverCandidate) => {\n  var _a, _b;\n  if (((_a = mediaStateReceiverCandidate.nodeName) == null ? void 0 : _a.includes(\"-\")) && !!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get((_b = mediaStateReceiverCandidate.nodeName) == null ? void 0 : _b.toLowerCase()) && !(mediaStateReceiverCandidate instanceof _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(mediaStateReceiverCandidate.nodeName.toLowerCase()))) {\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.upgrade(mediaStateReceiverCandidate);\n  }\n  return MEDIA_UI_PROP_NAMES.some((propName) => propName in mediaStateReceiverCandidate);\n};\nconst isMediaStateReceiver = (child) => {\n  return hasMediaUIProps(child) || !!getMediaUIAttributesFrom(child).length;\n};\nconst serializeTuple = (tuple) => {\n  var _a;\n  return (_a = tuple == null ? void 0 : tuple.join) == null ? void 0 : _a.call(tuple, \":\");\n};\nconst CustomAttrSerializer = {\n  [_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_SUBTITLES_LIST]: _utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.stringifyTextTrackList,\n  [_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING]: _utils_captions_js__WEBPACK_IMPORTED_MODULE_4__.stringifyTextTrackList,\n  [_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_SEEKABLE]: serializeTuple,\n  [_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_BUFFERED]: (tuples) => tuples == null ? void 0 : tuples.map(serializeTuple).join(\" \"),\n  [_constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIAttributes.MEDIA_PREVIEW_COORDS]: (coords) => coords == null ? void 0 : coords.join(\" \")\n};\nconst setAttr = async (child, attrName, attrValue) => {\n  var _a, _b;\n  if (!child.isConnected) {\n    await (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.delay)(0);\n  }\n  if (typeof attrValue === \"boolean\" || attrValue == null) {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_7__.setBooleanAttr)(child, attrName, attrValue);\n  }\n  if (typeof attrValue === \"number\") {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_7__.setNumericAttr)(child, attrName, attrValue);\n  }\n  if (typeof attrValue === \"string\") {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_7__.setStringAttr)(child, attrName, attrValue);\n  }\n  if (Array.isArray(attrValue) && !attrValue.length) {\n    return child.removeAttribute(attrName);\n  }\n  const val = (_b = (_a = CustomAttrSerializer[attrName]) == null ? void 0 : _a.call(CustomAttrSerializer, attrValue)) != null ? _b : attrValue;\n  return child.setAttribute(attrName, val);\n};\nconst isMediaSlotElementDescendant = (el) => {\n  var _a;\n  return !!((_a = el.closest) == null ? void 0 : _a.call(el, '*[slot=\"media\"]'));\n};\nconst traverseForMediaStateReceivers = (rootNode, mediaStateReceiverCallback) => {\n  if (isMediaSlotElementDescendant(rootNode)) {\n    return;\n  }\n  const traverseForMediaStateReceiversSync = (rootNode2, mediaStateReceiverCallback2) => {\n    var _a, _b;\n    if (isMediaStateReceiver(rootNode2)) {\n      mediaStateReceiverCallback2(rootNode2);\n    }\n    const { children = [] } = rootNode2 != null ? rootNode2 : {};\n    const shadowChildren = (_b = (_a = rootNode2 == null ? void 0 : rootNode2.shadowRoot) == null ? void 0 : _a.children) != null ? _b : [];\n    const allChildren = [...children, ...shadowChildren];\n    allChildren.forEach(\n      (child) => traverseForMediaStateReceivers(child, mediaStateReceiverCallback2)\n    );\n  };\n  const name = rootNode == null ? void 0 : rootNode.nodeName.toLowerCase();\n  if (name.includes(\"-\") && !isMediaStateReceiver(rootNode)) {\n    _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.whenDefined(name).then(() => {\n      traverseForMediaStateReceiversSync(rootNode, mediaStateReceiverCallback);\n    });\n    return;\n  }\n  traverseForMediaStateReceiversSync(rootNode, mediaStateReceiverCallback);\n};\nconst propagateMediaState = (els, stateName, val) => {\n  els.forEach((el) => {\n    if (stateName in el) {\n      el[stateName] = val;\n      return;\n    }\n    const relevantAttrs = getMediaUIAttributesFrom(el);\n    const attrName = stateName.toLowerCase();\n    if (!relevantAttrs.includes(attrName))\n      return;\n    setAttr(el, attrName, val);\n  });\n};\nconst monitorForMediaStateReceivers = (rootNode, registerMediaStateReceiver, unregisterMediaStateReceiver) => {\n  traverseForMediaStateReceivers(rootNode, registerMediaStateReceiver);\n  const registerMediaStateReceiverHandler = (evt) => {\n    var _a;\n    const el = (_a = evt == null ? void 0 : evt.composedPath()[0]) != null ? _a : evt.target;\n    registerMediaStateReceiver(el);\n  };\n  const unregisterMediaStateReceiverHandler = (evt) => {\n    var _a;\n    const el = (_a = evt == null ? void 0 : evt.composedPath()[0]) != null ? _a : evt.target;\n    unregisterMediaStateReceiver(el);\n  };\n  rootNode.addEventListener(\n    _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.REGISTER_MEDIA_STATE_RECEIVER,\n    registerMediaStateReceiverHandler\n  );\n  rootNode.addEventListener(\n    _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.UNREGISTER_MEDIA_STATE_RECEIVER,\n    unregisterMediaStateReceiverHandler\n  );\n  const mutationCallback = (mutationsList) => {\n    mutationsList.forEach((mutationRecord) => {\n      const {\n        addedNodes = [],\n        removedNodes = [],\n        type,\n        target,\n        attributeName\n      } = mutationRecord;\n      if (type === \"childList\") {\n        Array.prototype.forEach.call(\n          addedNodes,\n          (node) => traverseForMediaStateReceivers(node, registerMediaStateReceiver)\n        );\n        Array.prototype.forEach.call(\n          removedNodes,\n          (node) => traverseForMediaStateReceivers(node, unregisterMediaStateReceiver)\n        );\n      } else if (type === \"attributes\" && attributeName === _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaStateReceiverAttributes.MEDIA_CHROME_ATTRIBUTES) {\n        if (isMediaStateReceiver(target)) {\n          registerMediaStateReceiver(target);\n        } else {\n          unregisterMediaStateReceiver(target);\n        }\n      }\n    });\n  };\n  let prevSlotted = [];\n  const slotChangeHandler = (event) => {\n    const slotEl = event.target;\n    if (slotEl.name === \"media\")\n      return;\n    prevSlotted.forEach(\n      (node) => traverseForMediaStateReceivers(node, unregisterMediaStateReceiver)\n    );\n    prevSlotted = [...slotEl.assignedElements({ flatten: true })];\n    prevSlotted.forEach(\n      (node) => traverseForMediaStateReceivers(node, registerMediaStateReceiver)\n    );\n  };\n  rootNode.addEventListener(\"slotchange\", slotChangeHandler);\n  const observer = new MutationObserver(mutationCallback);\n  observer.observe(rootNode, {\n    childList: true,\n    attributes: true,\n    subtree: true\n  });\n  const unsubscribe = () => {\n    traverseForMediaStateReceivers(rootNode, unregisterMediaStateReceiver);\n    rootNode.removeEventListener(\"slotchange\", slotChangeHandler);\n    observer.disconnect();\n    rootNode.removeEventListener(\n      _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.REGISTER_MEDIA_STATE_RECEIVER,\n      registerMediaStateReceiverHandler\n    );\n    rootNode.removeEventListener(\n      _constants_js__WEBPACK_IMPORTED_MODULE_5__.MediaUIEvents.UNREGISTER_MEDIA_STATE_RECEIVER,\n      unregisterMediaStateReceiverHandler\n    );\n  };\n  return unsubscribe;\n};\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-controller\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-controller\", MediaController);\n}\nvar media_controller_default = MediaController;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWNvbnRyb2xsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDTTtBQUNTO0FBQ2Q7QUFDc0I7QUFPckQ7QUFDc0U7QUFDTDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrREFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4RUFBa0I7QUFDdkQ7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLE1BQU0sZ0VBQW9CO0FBQzFCO0FBQ0EsVUFBVSw0REFBaUI7QUFDM0IsVUFBVSx5REFBYTtBQUN2QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBc0I7QUFDdEMsb0NBQW9DLDZEQUFZLFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBc0I7QUFDOUI7QUFDQSw0QkFBNEIsd0RBQWE7QUFDekMsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHlEQUFhO0FBQzdCO0FBQ0EsaUNBQWlDLHVEQUFZLE9BQU8seURBQWE7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixNQUFNLGtFQUFjO0FBQ3BCLE1BQU07QUFDTiwrQkFBK0IsdURBQVk7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxFQUFFLHlEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixxRUFBVTtBQUNsQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsRUFBRSx5REFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDZCQUE2Qix1REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxRUFBVTtBQUM5QixNQUFNLHlFQUE4QjtBQUNwQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFhO0FBQzdCO0FBQ0EsUUFBUSx3REFBYTtBQUNyQix1QkFBdUIsNkRBQVksWUFBWTtBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBYTtBQUM3QjtBQUNBLFFBQVEsd0RBQWE7QUFDckIsdUJBQXVCLDZEQUFZLFlBQVk7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFhO0FBQzdCLDJCQUEyQix5REFBYTtBQUN4QztBQUNBO0FBQ0EsUUFBUSx1REFBWTtBQUNwQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0JBQW9CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0REFBaUIseUJBQXlCLHdEQUFhLHNCQUFzQix3REFBYTtBQUNoSTtBQUNBLGNBQWMscUVBQVUsMEJBQTBCLCtCQUErQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNERBQWlCLGlDQUFpQyx3REFBYSx3QkFBd0Isd0RBQWE7QUFDMUk7QUFDQSxjQUFjLHFFQUFVLDBCQUEwQiwrQkFBK0I7QUFDakY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDREQUFpQixnQ0FBZ0Msd0RBQWEsaUNBQWlDLHdEQUFhO0FBQ2xKO0FBQ0EsY0FBYyxxRUFBVSwwQkFBMEIsK0JBQStCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFVLGFBQWEsd0RBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFVLGFBQWEsd0RBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGtCQUFrQjtBQUN2SDtBQUNBO0FBQ0EsMEZBQTBGLFlBQVk7QUFDdEc7QUFDQSwrQ0FBK0MsNERBQWlCO0FBQ2hFLDBDQUEwQyx1REFBWTtBQUN0RDtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQSxJQUFJLHFFQUFVO0FBQ2QsT0FBTyxxQkFBcUI7QUFDNUI7QUFDQSxxSUFBcUksdUVBQTRCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYscUVBQVUsaUpBQWlKLHFFQUFVO0FBQ2xRLElBQUkscUVBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0REFBaUIsd0JBQXdCLHNFQUFzQjtBQUNsRSxHQUFHLDREQUFpQiwyQkFBMkIsc0VBQXNCO0FBQ3JFLEdBQUcsNERBQWlCO0FBQ3BCLEdBQUcsNERBQWlCO0FBQ3BCLEdBQUcsNERBQWlCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBSztBQUNmO0FBQ0E7QUFDQSxXQUFXLHVFQUFjO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLHVFQUFjO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxRUFBVTtBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQW9ELHVFQUE0QjtBQUN4RjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtY29udHJvbGxlci5qcz80YmQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpO1xuICByZXR1cm4gbWV0aG9kO1xufTtcbnZhciBfaG90S2V5cywgX2Z1bGxzY3JlZW5FbGVtZW50LCBfa2V5VXBIYW5kbGVyLCBrZXlVcEhhbmRsZXJfZm4sIF9rZXlEb3duSGFuZGxlciwga2V5RG93bkhhbmRsZXJfZm47XG5pbXBvcnQgeyBNZWRpYUNvbnRhaW5lciB9IGZyb20gXCIuL21lZGlhLWNvbnRhaW5lci5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcyB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IEF0dHJpYnV0ZVRva2VuTGlzdCB9IGZyb20gXCIuL3V0aWxzL2F0dHJpYnV0ZS10b2tlbi1saXN0LmpzXCI7XG5pbXBvcnQgeyBjb25zdFRvQ2FtZWwsIGRlbGF5IH0gZnJvbSBcIi4vdXRpbHMvdXRpbHMuanNcIjtcbmltcG9ydCB7IHN0cmluZ2lmeVRleHRUcmFja0xpc3QsIHRvZ2dsZVN1YnNDYXBzIH0gZnJvbSBcIi4vdXRpbHMvY2FwdGlvbnMuanNcIjtcbmltcG9ydCB7XG4gIE1lZGlhVUlFdmVudHMsXG4gIE1lZGlhVUlBdHRyaWJ1dGVzLFxuICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLFxuICBBdHRyaWJ1dGVUb1N0YXRlQ2hhbmdlRXZlbnRNYXAsXG4gIE1lZGlhVUlQcm9wc1xufSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlSZXF1ZXN0SGFuZGxlcnMsIE1lZGlhVUlTdGF0ZXMsIHZvbHVtZVN1cHBvcnRQcm9taXNlIH0gZnJvbSBcIi4vY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgc2V0Qm9vbGVhbkF0dHIsIHNldE51bWVyaWNBdHRyLCBzZXRTdHJpbmdBdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgQnV0dG9uUHJlc3NlZEtleXMgPSBbXCJBcnJvd0xlZnRcIiwgXCJBcnJvd1JpZ2h0XCIsIFwiRW50ZXJcIiwgXCIgXCIsIFwiZlwiLCBcIm1cIiwgXCJrXCIsIFwiY1wiXTtcbmNvbnN0IERFRkFVTFRfU0VFS19PRkZTRVQgPSAxMDtcbmNvbnN0IERFRkFVTFRfVElNRSA9IDA7XG5jb25zdCBBdHRyaWJ1dGVzID0ge1xuICBERUZBVUxUX1NVQlRJVExFUzogXCJkZWZhdWx0c3VidGl0bGVzXCIsXG4gIERFRkFVTFRfU1RSRUFNX1RZUEU6IFwiZGVmYXVsdHN0cmVhbXR5cGVcIixcbiAgRlVMTFNDUkVFTl9FTEVNRU5UOiBcImZ1bGxzY3JlZW5lbGVtZW50XCIsXG4gIEhPVEtFWVM6IFwiaG90a2V5c1wiLFxuICBLRVlTX1VTRUQ6IFwia2V5c3VzZWRcIixcbiAgTElWRV9FREdFX09GRlNFVDogXCJsaXZlZWRnZW9mZnNldFwiLFxuICBOT19BVVRPX1NFRUtfVE9fTElWRTogXCJub2F1dG9zZWVrdG9saXZlXCIsXG4gIE5PX0hPVEtFWVM6IFwibm9ob3RrZXlzXCJcbn07XG5jbGFzcyBNZWRpYUNvbnRyb2xsZXIgZXh0ZW5kcyBNZWRpYUNvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9rZXlVcEhhbmRsZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfa2V5RG93bkhhbmRsZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaG90S2V5cywgbmV3IEF0dHJpYnV0ZVRva2VuTGlzdCh0aGlzLCBBdHRyaWJ1dGVzLkhPVEtFWVMpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Z1bGxzY3JlZW5FbGVtZW50LCB2b2lkIDApO1xuICAgIGlmIChNZWRpYVVJU3RhdGVzLk1FRElBX1ZPTFVNRV9VTkFWQUlMQUJMRS5nZXQodGhpcykgPT09IHZvaWQgMCkge1xuICAgICAgdm9sdW1lU3VwcG9ydFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcGFnYXRlTWVkaWFTdGF0ZShcbiAgICAgICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9WT0xVTUVfVU5BVkFJTEFCTEUsXG4gICAgICAgICAgTWVkaWFVSVN0YXRlcy5NRURJQV9WT0xVTUVfVU5BVkFJTEFCTEUuZ2V0KHRoaXMpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYVN0YXRlUmVjZWl2ZXJzID0gW107XG4gICAgdGhpcy5hc3NvY2lhdGVkRWxlbWVudFN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXNzb2NpYXRlRWxlbWVudCh0aGlzKTtcbiAgICBPYmplY3Qua2V5cyhNZWRpYVVJUmVxdWVzdEhhbmRsZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXJOYW1lID0gYF9oYW5kbGUke2NvbnN0VG9DYW1lbChrZXksIHRydWUpfWA7XG4gICAgICB0aGlzW2hhbmRsZXJOYW1lXSA9IChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk1lZGlhQ29udHJvbGxlcjogTm8gbWVkaWEgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgTWVkaWFVSVJlcXVlc3RIYW5kbGVyc1trZXldKHRoaXMubWVkaWEsIGUsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNZWRpYVVJRXZlbnRzW2tleV0sIHRoaXNbaGFuZGxlck5hbWVdKTtcbiAgICB9KTtcbiAgICB0aGlzLl9tZWRpYVN0YXRlUHJvcGFnYXRvcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhNZWRpYVVJU3RhdGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuX21lZGlhU3RhdGVQcm9wYWdhdG9yc1trZXldID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVNZWRpYVN0YXRlKE1lZGlhVUlQcm9wc1trZXldLCBNZWRpYVVJU3RhdGVzW2tleV0uZ2V0KHRoaXMsIGUpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5lbmFibGVIb3RrZXlzKCk7XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9ic2VydmVkQXR0cmlidXRlcy5jb25jYXQoXG4gICAgICBBdHRyaWJ1dGVzLk5PX0hPVEtFWVMsXG4gICAgICBBdHRyaWJ1dGVzLkhPVEtFWVMsXG4gICAgICBBdHRyaWJ1dGVzLkRFRkFVTFRfU1RSRUFNX1RZUEUsXG4gICAgICBBdHRyaWJ1dGVzLkRFRkFVTFRfU1VCVElUTEVTXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbHNjcmVlbkVsZW1lbnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX2Z1bGxzY3JlZW5FbGVtZW50KSkgIT0gbnVsbCA/IF9hIDogdGhpcztcbiAgfVxuICBzZXQgZnVsbHNjcmVlbkVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShBdHRyaWJ1dGVzLkZVTExTQ1JFRU5fRUxFTUVOVCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKEF0dHJpYnV0ZXMuRlVMTFNDUkVFTl9FTEVNRU5UKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mdWxsc2NyZWVuRWxlbWVudCwgZWxlbWVudCk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGF0dHJOYW1lID09PSBBdHRyaWJ1dGVzLk5PX0hPVEtFWVMpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKEF0dHJpYnV0ZXMuSE9US0VZUykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJCb3RoIGBob3RrZXlzYCBhbmQgYG5vaG90a2V5c2AgaGF2ZSBiZWVuIHNldC4gQWxsIGhvdGtleXMgd2lsbCBiZSBkaXNhYmxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlSG90a2V5cygpO1xuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmFibGVIb3RrZXlzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gQXR0cmlidXRlcy5IT1RLRVlTKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2hvdEtleXMpLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gQXR0cmlidXRlcy5ERUZBVUxUX1NVQlRJVExFUyAmJiBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHRvZ2dsZVN1YnNDYXBzKHRoaXMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuREVGQVVMVF9TVFJFQU1fVFlQRSkge1xuICAgICAgdGhpcy5wcm9wYWdhdGVNZWRpYVN0YXRlKE1lZGlhVUlQcm9wcy5NRURJQV9TVFJFQU1fVFlQRSk7XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gQXR0cmlidXRlcy5GVUxMU0NSRUVOX0VMRU1FTlQpIHtcbiAgICAgIGNvbnN0IGVsID0gbmV3VmFsdWUgPyAoX2EgPSB0aGlzLmdldFJvb3ROb2RlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRFbGVtZW50QnlJZChuZXdWYWx1ZSkgOiB2b2lkIDA7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Z1bGxzY3JlZW5FbGVtZW50LCBlbCk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgfVxuICBtZWRpYVNldENhbGxiYWNrKG1lZGlhKSB7XG4gICAgc3VwZXIubWVkaWFTZXRDYWxsYmFjayhtZWRpYSk7XG4gICAgaWYgKCFtZWRpYS5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSkge1xuICAgICAgbWVkaWEudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoTWVkaWFVSVN0YXRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhRXZlbnRzLFxuICAgICAgICByb290RXZlbnRzLFxuICAgICAgICB0cmFja0xpc3RFdmVudHNcbiAgICAgIH0gPSBNZWRpYVVJU3RhdGVzW2tleV07XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fbWVkaWFTdGF0ZVByb3BhZ2F0b3JzW2tleV07XG4gICAgICBtZWRpYUV2ZW50cyA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFFdmVudHMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfSk7XG4gICAgICByb290RXZlbnRzID09IG51bGwgPyB2b2lkIDAgOiByb290RXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9KTtcbiAgICAgIHRyYWNrTGlzdEV2ZW50cyA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tMaXN0RXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IG1lZGlhLnRleHRUcmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoXCJub3ZvbHVtZXByZWZcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZvbFByZWYgPSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWVkaWEtY2hyb21lLXByZWYtdm9sdW1lXCIpO1xuICAgICAgICBpZiAodm9sUHJlZiAhPT0gbnVsbClcbiAgICAgICAgICBtZWRpYS52b2x1bWUgPSB2b2xQcmVmO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwiRXJyb3IgZ2V0dGluZyB2b2x1bWUgcHJlZlwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbWVkaWFVbnNldENhbGxiYWNrKG1lZGlhKSB7XG4gICAgc3VwZXIubWVkaWFVbnNldENhbGxiYWNrKG1lZGlhKTtcbiAgICBPYmplY3Qua2V5cyhNZWRpYVVJU3RhdGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVkaWFFdmVudHMsXG4gICAgICAgIHJvb3RFdmVudHMsXG4gICAgICAgIHRyYWNrTGlzdEV2ZW50c1xuICAgICAgfSA9IE1lZGlhVUlTdGF0ZXNba2V5XTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9tZWRpYVN0YXRlUHJvcGFnYXRvcnNba2V5XTtcbiAgICAgIG1lZGlhRXZlbnRzID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICByb290RXZlbnRzID09IG51bGwgPyB2b2lkIDAgOiByb290RXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICB0cmFja0xpc3RFdmVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrTGlzdEV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBtZWRpYS50ZXh0VHJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wYWdhdGVNZWRpYVN0YXRlKE1lZGlhVUlQcm9wcy5NRURJQV9QQVVTRUQsIHRydWUpO1xuICB9XG4gIHByb3BhZ2F0ZU1lZGlhU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZSkge1xuICAgIGNvbnN0IGF0dHJOYW1lID0gc3RhdGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICBwcm9wYWdhdGVNZWRpYVN0YXRlKHRoaXMubWVkaWFTdGF0ZVJlY2VpdmVycywgc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBldnQgPSBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChcbiAgICAgIEF0dHJpYnV0ZVRvU3RhdGVDaGFuZ2VFdmVudE1hcFthdHRyTmFtZV0sXG4gICAgICB7IGNvbXBvc2VkOiB0cnVlLCBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHN0YXRlIH1cbiAgICApO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG4gIGFzc29jaWF0ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGFzc29jaWF0ZWRFbGVtZW50U3Vic2NyaXB0aW9ucyB9ID0gdGhpcztcbiAgICBpZiAoYXNzb2NpYXRlZEVsZW1lbnRTdWJzY3JpcHRpb25zLmhhcyhlbGVtZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlciA9IHRoaXMucmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXIuYmluZCh0aGlzKTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyID0gdGhpcy51bnJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyLmJpbmQodGhpcyk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBtb25pdG9yRm9yTWVkaWFTdGF0ZVJlY2VpdmVycyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICByZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcixcbiAgICAgIHVucmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXJcbiAgICApO1xuICAgIE9iamVjdC5rZXlzKE1lZGlhVUlFdmVudHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBNZWRpYVVJRXZlbnRzW2tleV0sXG4gICAgICAgIHRoaXNbYF9oYW5kbGUke2NvbnN0VG9DYW1lbChrZXksIHRydWUpfWBdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFzc29jaWF0ZWRFbGVtZW50U3Vic2NyaXB0aW9ucy5zZXQoZWxlbWVudCwgdW5zdWJzY3JpYmUpO1xuICB9XG4gIHVuYXNzb2NpYXRlRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYXNzb2NpYXRlZEVsZW1lbnRTdWJzY3JpcHRpb25zIH0gPSB0aGlzO1xuICAgIGlmICghYXNzb2NpYXRlZEVsZW1lbnRTdWJzY3JpcHRpb25zLmhhcyhlbGVtZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGFzc29jaWF0ZWRFbGVtZW50U3Vic2NyaXB0aW9ucy5nZXQoZWxlbWVudCk7XG4gICAgdW5zdWJzY3JpYmUoKTtcbiAgICBhc3NvY2lhdGVkRWxlbWVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgIE9iamVjdC5rZXlzKE1lZGlhVUlFdmVudHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBNZWRpYVVJRXZlbnRzW2tleV0sXG4gICAgICAgIHRoaXNbYF9oYW5kbGUke2NvbnN0VG9DYW1lbChrZXksIHRydWUpfWBdXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyKGVsKSB7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbHMgPSB0aGlzLm1lZGlhU3RhdGVSZWNlaXZlcnM7XG4gICAgY29uc3QgaW5kZXggPSBlbHMuaW5kZXhPZihlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICByZXR1cm47XG4gICAgZWxzLnB1c2goZWwpO1xuICAgIE9iamVjdC5rZXlzKE1lZGlhVUlTdGF0ZXMpLmZvckVhY2goKHN0YXRlQ29uc3ROYW1lKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZURldGFpbHMgPSBNZWRpYVVJU3RhdGVzW3N0YXRlQ29uc3ROYW1lXTtcbiAgICAgIHByb3BhZ2F0ZU1lZGlhU3RhdGUoXG4gICAgICAgIFtlbF0sXG4gICAgICAgIE1lZGlhVUlQcm9wc1tzdGF0ZUNvbnN0TmFtZV0sXG4gICAgICAgIHN0YXRlRGV0YWlscy5nZXQodGhpcylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcihlbCkge1xuICAgIGNvbnN0IGVscyA9IHRoaXMubWVkaWFTdGF0ZVJlY2VpdmVycztcbiAgICBjb25zdCBpbmRleCA9IGVscy5pbmRleE9mKGVsKTtcbiAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIGVuYWJsZUhvdGtleXMoKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX2tleURvd25IYW5kbGVyLCBrZXlEb3duSGFuZGxlcl9mbikpO1xuICB9XG4gIGRpc2FibGVIb3RrZXlzKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9rZXlEb3duSGFuZGxlciwga2V5RG93bkhhbmRsZXJfZm4pKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX2tleVVwSGFuZGxlciwga2V5VXBIYW5kbGVyX2ZuKSk7XG4gIH1cbiAgZ2V0IGhvdGtleXMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaG90S2V5cyk7XG4gIH1cbiAga2V5Ym9hcmRTaG9ydGN1dEhhbmRsZXIoZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBrZXlzVXNlZCA9ICgoX2QgPSAoX2MgPSAoX2EgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoQXR0cmlidXRlcy5LRVlTX1VTRUQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3BsaXQoXCIgXCIpKSAhPSBudWxsID8gX2MgOiAoX2IgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmtleXNVc2VkKSAhPSBudWxsID8gX2QgOiBbXSkubWFwKChrZXkpID0+IGtleSA9PT0gXCJTcGFjZVwiID8gXCIgXCIgOiBrZXkpLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoa2V5c1VzZWQuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBldmVudE5hbWUsIGN1cnJlbnRUaW1lU3RyLCBjdXJyZW50VGltZSwgZGV0YWlsLCBldnQ7XG4gICAgY29uc3Qgc2Vla09mZnNldCA9IERFRkFVTFRfU0VFS19PRkZTRVQ7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaG90S2V5cykuY29udGFpbnMoYG5vJHtlLmtleS50b0xvd2VyQ2FzZSgpfWApKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlLmtleSA9PT0gXCIgXCIgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9ob3RLZXlzKS5jb250YWlucyhgbm9zcGFjZWApKVxuICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgIGNhc2UgXCIgXCI6XG4gICAgICBjYXNlIFwia1wiOlxuICAgICAgICBldmVudE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUQpICE9IG51bGwgPyBNZWRpYVVJRXZlbnRzLk1FRElBX1BMQVlfUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfUEFVU0VfUkVRVUVTVDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIGV2ZW50TmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1ZPTFVNRV9MRVZFTCkgPT09IFwib2ZmXCIgPyBNZWRpYVVJRXZlbnRzLk1FRElBX1VOTVVURV9SRVFVRVNUIDogTWVkaWFVSUV2ZW50cy5NRURJQV9NVVRFX1JFUVVFU1Q7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChldmVudE5hbWUsIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUgfSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBldmVudE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19GVUxMU0NSRUVOKSAhPSBudWxsID8gTWVkaWFVSUV2ZW50cy5NRURJQV9FWElUX0ZVTExTQ1JFRU5fUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfRU5URVJfRlVMTFNDUkVFTl9SRVFVRVNUO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGNvbXBvc2VkOiB0cnVlLCBidWJibGVzOiB0cnVlIH0pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgdG9nZ2xlU3Vic0NhcHModGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBjdXJyZW50VGltZVN0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKFxuICAgICAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lU3RyICYmICFOdW1iZXIuaXNOYU4oK2N1cnJlbnRUaW1lU3RyKSA/ICtjdXJyZW50VGltZVN0ciA6IERFRkFVTFRfVElNRTtcbiAgICAgICAgZGV0YWlsID0gTWF0aC5tYXgoY3VycmVudFRpbWUgLSBzZWVrT2Zmc2V0LCAwKTtcbiAgICAgICAgZXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoTWVkaWFVSUV2ZW50cy5NRURJQV9TRUVLX1JFUVVFU1QsIHtcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY3VycmVudFRpbWVTdHIgPSB0aGlzLmdldEF0dHJpYnV0ZShcbiAgICAgICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9DVVJSRU5UX1RJTUVcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZVN0ciAmJiAhTnVtYmVyLmlzTmFOKCtjdXJyZW50VGltZVN0cikgPyArY3VycmVudFRpbWVTdHIgOiBERUZBVUxUX1RJTUU7XG4gICAgICAgIGRldGFpbCA9IE1hdGgubWF4KGN1cnJlbnRUaW1lICsgc2Vla09mZnNldCwgMCk7XG4gICAgICAgIGV2dCA9IG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KE1lZGlhVUlFdmVudHMuTUVESUFfU0VFS19SRVFVRVNULCB7XG4gICAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuX2hvdEtleXMgPSBuZXcgV2Vha01hcCgpO1xuX2Z1bGxzY3JlZW5FbGVtZW50ID0gbmV3IFdlYWtNYXAoKTtcbl9rZXlVcEhhbmRsZXIgPSBuZXcgV2Vha1NldCgpO1xua2V5VXBIYW5kbGVyX2ZuID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCB7IGtleSB9ID0gZTtcbiAgaWYgKCFCdXR0b25QcmVzc2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9rZXlVcEhhbmRsZXIsIGtleVVwSGFuZGxlcl9mbikpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmtleWJvYXJkU2hvcnRjdXRIYW5kbGVyKGUpO1xufTtcbl9rZXlEb3duSGFuZGxlciA9IG5ldyBXZWFrU2V0KCk7XG5rZXlEb3duSGFuZGxlcl9mbiA9IGZ1bmN0aW9uKGUpIHtcbiAgY29uc3QgeyBtZXRhS2V5LCBhbHRLZXksIGtleSB9ID0gZTtcbiAgaWYgKG1ldGFLZXkgfHwgYWx0S2V5IHx8ICFCdXR0b25QcmVzc2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9rZXlVcEhhbmRsZXIsIGtleVVwSGFuZGxlcl9mbikpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoW1wiIFwiLCBcIkFycm93TGVmdFwiLCBcIkFycm93UmlnaHRcIl0uaW5jbHVkZXMoa2V5KSAmJiAhKF9fcHJpdmF0ZUdldCh0aGlzLCBfaG90S2V5cykuY29udGFpbnMoYG5vJHtrZXkudG9Mb3dlckNhc2UoKX1gKSB8fCBrZXkgPT09IFwiIFwiICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfaG90S2V5cykuY29udGFpbnMoXCJub3NwYWNlXCIpKSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX2tleVVwSGFuZGxlciwga2V5VXBIYW5kbGVyX2ZuKSwgeyBvbmNlOiB0cnVlIH0pO1xufTtcbmNvbnN0IE1FRElBX1VJX0FUVFJJQlVURV9OQU1FUyA9IE9iamVjdC52YWx1ZXMoTWVkaWFVSUF0dHJpYnV0ZXMpO1xuY29uc3QgTUVESUFfVUlfUFJPUF9OQU1FUyA9IE9iamVjdC52YWx1ZXMoTWVkaWFVSVByb3BzKTtcbmNvbnN0IGdldE1lZGlhVUlBdHRyaWJ1dGVzRnJvbSA9IChjaGlsZCkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGxldCB7IG9ic2VydmVkQXR0cmlidXRlcyB9ID0gY2hpbGQuY29uc3RydWN0b3I7XG4gIGlmICghb2JzZXJ2ZWRBdHRyaWJ1dGVzICYmICgoX2EgPSBjaGlsZC5ub2RlTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiLVwiKSkpIHtcbiAgICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoY2hpbGQpO1xuICAgICh7IG9ic2VydmVkQXR0cmlidXRlcyB9ID0gY2hpbGQuY29uc3RydWN0b3IpO1xuICB9XG4gIGNvbnN0IG1lZGlhQ2hyb21lQXR0cmlidXRlc0xpc3QgPSAoX2QgPSAoX2MgPSAoX2IgPSBjaGlsZCA9PSBudWxsID8gdm9pZCAwIDogY2hpbGQuZ2V0QXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChjaGlsZCwgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DSFJPTUVfQVRUUklCVVRFUykpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zcGxpdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIC9cXHMrLyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShvYnNlcnZlZEF0dHJpYnV0ZXMgfHwgbWVkaWFDaHJvbWVBdHRyaWJ1dGVzTGlzdCkpXG4gICAgcmV0dXJuIFtdO1xuICByZXR1cm4gKG9ic2VydmVkQXR0cmlidXRlcyB8fCBtZWRpYUNocm9tZUF0dHJpYnV0ZXNMaXN0KS5maWx0ZXIoXG4gICAgKGF0dHJOYW1lKSA9PiBNRURJQV9VSV9BVFRSSUJVVEVfTkFNRVMuaW5jbHVkZXMoYXR0ck5hbWUpXG4gICk7XG59O1xuY29uc3QgaGFzTWVkaWFVSVByb3BzID0gKG1lZGlhU3RhdGVSZWNlaXZlckNhbmRpZGF0ZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoKChfYSA9IG1lZGlhU3RhdGVSZWNlaXZlckNhbmRpZGF0ZS5ub2RlTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiLVwiKSkgJiYgISFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldCgoX2IgPSBtZWRpYVN0YXRlUmVjZWl2ZXJDYW5kaWRhdGUubm9kZU5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpKSAmJiAhKG1lZGlhU3RhdGVSZWNlaXZlckNhbmRpZGF0ZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KG1lZGlhU3RhdGVSZWNlaXZlckNhbmRpZGF0ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkpIHtcbiAgICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUobWVkaWFTdGF0ZVJlY2VpdmVyQ2FuZGlkYXRlKTtcbiAgfVxuICByZXR1cm4gTUVESUFfVUlfUFJPUF9OQU1FUy5zb21lKChwcm9wTmFtZSkgPT4gcHJvcE5hbWUgaW4gbWVkaWFTdGF0ZVJlY2VpdmVyQ2FuZGlkYXRlKTtcbn07XG5jb25zdCBpc01lZGlhU3RhdGVSZWNlaXZlciA9IChjaGlsZCkgPT4ge1xuICByZXR1cm4gaGFzTWVkaWFVSVByb3BzKGNoaWxkKSB8fCAhIWdldE1lZGlhVUlBdHRyaWJ1dGVzRnJvbShjaGlsZCkubGVuZ3RoO1xufTtcbmNvbnN0IHNlcmlhbGl6ZVR1cGxlID0gKHR1cGxlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHR1cGxlID09IG51bGwgPyB2b2lkIDAgOiB0dXBsZS5qb2luKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0dXBsZSwgXCI6XCIpO1xufTtcbmNvbnN0IEN1c3RvbUF0dHJTZXJpYWxpemVyID0ge1xuICBbTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX0xJU1RdOiBzdHJpbmdpZnlUZXh0VHJhY2tMaXN0LFxuICBbTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX1NIT1dJTkddOiBzdHJpbmdpZnlUZXh0VHJhY2tMaXN0LFxuICBbTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU0VFS0FCTEVdOiBzZXJpYWxpemVUdXBsZSxcbiAgW01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0JVRkZFUkVEXTogKHR1cGxlcykgPT4gdHVwbGVzID09IG51bGwgPyB2b2lkIDAgOiB0dXBsZXMubWFwKHNlcmlhbGl6ZVR1cGxlKS5qb2luKFwiIFwiKSxcbiAgW01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfQ09PUkRTXTogKGNvb3JkcykgPT4gY29vcmRzID09IG51bGwgPyB2b2lkIDAgOiBjb29yZHMuam9pbihcIiBcIilcbn07XG5jb25zdCBzZXRBdHRyID0gYXN5bmMgKGNoaWxkLCBhdHRyTmFtZSwgYXR0clZhbHVlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICghY2hpbGQuaXNDb25uZWN0ZWQpIHtcbiAgICBhd2FpdCBkZWxheSgwKTtcbiAgfVxuICBpZiAodHlwZW9mIGF0dHJWYWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgYXR0clZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gc2V0Qm9vbGVhbkF0dHIoY2hpbGQsIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgYXR0clZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHNldE51bWVyaWNBdHRyKGNoaWxkLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIGF0dHJWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXRTdHJpbmdBdHRyKGNoaWxkLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyVmFsdWUpICYmICFhdHRyVmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNoaWxkLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gIH1cbiAgY29uc3QgdmFsID0gKF9iID0gKF9hID0gQ3VzdG9tQXR0clNlcmlhbGl6ZXJbYXR0ck5hbWVdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChDdXN0b21BdHRyU2VyaWFsaXplciwgYXR0clZhbHVlKSkgIT0gbnVsbCA/IF9iIDogYXR0clZhbHVlO1xuICByZXR1cm4gY2hpbGQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWwpO1xufTtcbmNvbnN0IGlzTWVkaWFTbG90RWxlbWVudERlc2NlbmRhbnQgPSAoZWwpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gISEoKF9hID0gZWwuY2xvc2VzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZWwsICcqW3Nsb3Q9XCJtZWRpYVwiXScpKTtcbn07XG5jb25zdCB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnMgPSAocm9vdE5vZGUsIG1lZGlhU3RhdGVSZWNlaXZlckNhbGxiYWNrKSA9PiB7XG4gIGlmIChpc01lZGlhU2xvdEVsZW1lbnREZXNjZW5kYW50KHJvb3ROb2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnNTeW5jID0gKHJvb3ROb2RlMiwgbWVkaWFTdGF0ZVJlY2VpdmVyQ2FsbGJhY2syKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoaXNNZWRpYVN0YXRlUmVjZWl2ZXIocm9vdE5vZGUyKSkge1xuICAgICAgbWVkaWFTdGF0ZVJlY2VpdmVyQ2FsbGJhY2syKHJvb3ROb2RlMik7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGRyZW4gPSBbXSB9ID0gcm9vdE5vZGUyICE9IG51bGwgPyByb290Tm9kZTIgOiB7fTtcbiAgICBjb25zdCBzaGFkb3dDaGlsZHJlbiA9IChfYiA9IChfYSA9IHJvb3ROb2RlMiA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUyLnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbikgIT0gbnVsbCA/IF9iIDogW107XG4gICAgY29uc3QgYWxsQ2hpbGRyZW4gPSBbLi4uY2hpbGRyZW4sIC4uLnNoYWRvd0NoaWxkcmVuXTtcbiAgICBhbGxDaGlsZHJlbi5mb3JFYWNoKFxuICAgICAgKGNoaWxkKSA9PiB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnMoY2hpbGQsIG1lZGlhU3RhdGVSZWNlaXZlckNhbGxiYWNrMilcbiAgICApO1xuICB9O1xuICBjb25zdCBuYW1lID0gcm9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3ROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChuYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAhaXNNZWRpYVN0YXRlUmVjZWl2ZXIocm9vdE5vZGUpKSB7XG4gICAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChuYW1lKS50aGVuKCgpID0+IHtcbiAgICAgIHRyYXZlcnNlRm9yTWVkaWFTdGF0ZVJlY2VpdmVyc1N5bmMocm9vdE5vZGUsIG1lZGlhU3RhdGVSZWNlaXZlckNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJhdmVyc2VGb3JNZWRpYVN0YXRlUmVjZWl2ZXJzU3luYyhyb290Tm9kZSwgbWVkaWFTdGF0ZVJlY2VpdmVyQ2FsbGJhY2spO1xufTtcbmNvbnN0IHByb3BhZ2F0ZU1lZGlhU3RhdGUgPSAoZWxzLCBzdGF0ZU5hbWUsIHZhbCkgPT4ge1xuICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoc3RhdGVOYW1lIGluIGVsKSB7XG4gICAgICBlbFtzdGF0ZU5hbWVdID0gdmFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxldmFudEF0dHJzID0gZ2V0TWVkaWFVSUF0dHJpYnV0ZXNGcm9tKGVsKTtcbiAgICBjb25zdCBhdHRyTmFtZSA9IHN0YXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghcmVsZXZhbnRBdHRycy5pbmNsdWRlcyhhdHRyTmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgc2V0QXR0cihlbCwgYXR0ck5hbWUsIHZhbCk7XG4gIH0pO1xufTtcbmNvbnN0IG1vbml0b3JGb3JNZWRpYVN0YXRlUmVjZWl2ZXJzID0gKHJvb3ROb2RlLCByZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlciwgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcikgPT4ge1xuICB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnMocm9vdE5vZGUsIHJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyKTtcbiAgY29uc3QgcmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXJIYW5kbGVyID0gKGV2dCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlbCA9IChfYSA9IGV2dCA9PSBudWxsID8gdm9pZCAwIDogZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSAhPSBudWxsID8gX2EgOiBldnQudGFyZ2V0O1xuICAgIHJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyKGVsKTtcbiAgfTtcbiAgY29uc3QgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlckhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVsID0gKF9hID0gZXZ0ID09IG51bGwgPyB2b2lkIDAgOiBldnQuY29tcG9zZWRQYXRoKClbMF0pICE9IG51bGwgPyBfYSA6IGV2dC50YXJnZXQ7XG4gICAgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcihlbCk7XG4gIH07XG4gIHJvb3ROb2RlLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgTWVkaWFVSUV2ZW50cy5SRUdJU1RFUl9NRURJQV9TVEFURV9SRUNFSVZFUixcbiAgICByZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlckhhbmRsZXJcbiAgKTtcbiAgcm9vdE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBNZWRpYVVJRXZlbnRzLlVOUkVHSVNURVJfTUVESUFfU1RBVEVfUkVDRUlWRVIsXG4gICAgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlckhhbmRsZXJcbiAgKTtcbiAgY29uc3QgbXV0YXRpb25DYWxsYmFjayA9IChtdXRhdGlvbnNMaXN0KSA9PiB7XG4gICAgbXV0YXRpb25zTGlzdC5mb3JFYWNoKChtdXRhdGlvblJlY29yZCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZGRlZE5vZGVzID0gW10sXG4gICAgICAgIHJlbW92ZWROb2RlcyA9IFtdLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVcbiAgICAgIH0gPSBtdXRhdGlvblJlY29yZDtcbiAgICAgIGlmICh0eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoXG4gICAgICAgICAgYWRkZWROb2RlcyxcbiAgICAgICAgICAobm9kZSkgPT4gdHJhdmVyc2VGb3JNZWRpYVN0YXRlUmVjZWl2ZXJzKG5vZGUsIHJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyKVxuICAgICAgICApO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgICAgICAgIHJlbW92ZWROb2RlcyxcbiAgICAgICAgICAobm9kZSkgPT4gdHJhdmVyc2VGb3JNZWRpYVN0YXRlUmVjZWl2ZXJzKG5vZGUsIHVucmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXIpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIGF0dHJpYnV0ZU5hbWUgPT09IE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ0hST01FX0FUVFJJQlVURVMpIHtcbiAgICAgICAgaWYgKGlzTWVkaWFTdGF0ZVJlY2VpdmVyKHRhcmdldCkpIHtcbiAgICAgICAgICByZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcih0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVucmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXIodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBsZXQgcHJldlNsb3R0ZWQgPSBbXTtcbiAgY29uc3Qgc2xvdENoYW5nZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzbG90RWwgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKHNsb3RFbC5uYW1lID09PSBcIm1lZGlhXCIpXG4gICAgICByZXR1cm47XG4gICAgcHJldlNsb3R0ZWQuZm9yRWFjaChcbiAgICAgIChub2RlKSA9PiB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnMobm9kZSwgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlcilcbiAgICApO1xuICAgIHByZXZTbG90dGVkID0gWy4uLnNsb3RFbC5hc3NpZ25lZEVsZW1lbnRzKHsgZmxhdHRlbjogdHJ1ZSB9KV07XG4gICAgcHJldlNsb3R0ZWQuZm9yRWFjaChcbiAgICAgIChub2RlKSA9PiB0cmF2ZXJzZUZvck1lZGlhU3RhdGVSZWNlaXZlcnMobm9kZSwgcmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXIpXG4gICAgKTtcbiAgfTtcbiAgcm9vdE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInNsb3RjaGFuZ2VcIiwgc2xvdENoYW5nZUhhbmRsZXIpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9uQ2FsbGJhY2spO1xuICBvYnNlcnZlci5vYnNlcnZlKHJvb3ROb2RlLCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgdHJhdmVyc2VGb3JNZWRpYVN0YXRlUmVjZWl2ZXJzKHJvb3ROb2RlLCB1bnJlZ2lzdGVyTWVkaWFTdGF0ZVJlY2VpdmVyKTtcbiAgICByb290Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2xvdGNoYW5nZVwiLCBzbG90Q2hhbmdlSGFuZGxlcik7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHJvb3ROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBNZWRpYVVJRXZlbnRzLlJFR0lTVEVSX01FRElBX1NUQVRFX1JFQ0VJVkVSLFxuICAgICAgcmVnaXN0ZXJNZWRpYVN0YXRlUmVjZWl2ZXJIYW5kbGVyXG4gICAgKTtcbiAgICByb290Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgTWVkaWFVSUV2ZW50cy5VTlJFR0lTVEVSX01FRElBX1NUQVRFX1JFQ0VJVkVSLFxuICAgICAgdW5yZWdpc3Rlck1lZGlhU3RhdGVSZWNlaXZlckhhbmRsZXJcbiAgICApO1xuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmU7XG59O1xuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWNvbnRyb2xsZXJcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1jb250cm9sbGVyXCIsIE1lZGlhQ29udHJvbGxlcik7XG59XG52YXIgbWVkaWFfY29udHJvbGxlcl9kZWZhdWx0ID0gTWVkaWFDb250cm9sbGVyO1xuZXhwb3J0IHtcbiAgQXR0cmlidXRlcyxcbiAgbWVkaWFfY29udHJvbGxlcl9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-controller.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-duration-display.js":
/*!******************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-duration-display.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_duration_display_default; }\n/* harmony export */ });\n/* harmony import */ var _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-text-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-text-display.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_time_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/time.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/time.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _slot;\n\n\n\n\n\nclass MediaDurationDisplay extends _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__.MediaTextDisplay {\n  constructor() {\n    super();\n    __privateAdd(this, _slot, void 0);\n    __privateSet(this, _slot, this.shadowRoot.querySelector(\"slot\"));\n    __privateGet(this, _slot).textContent = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_2__.formatTime)(0);\n  }\n  static get observedAttributes() {\n    return [...super.observedAttributes, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_DURATION];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_DURATION) {\n      __privateGet(this, _slot).textContent = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_2__.formatTime)(newValue);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaDuration() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_DURATION);\n  }\n  set mediaDuration(time) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_DURATION, time);\n  }\n}\n_slot = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-duration-display\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-duration-display\", MediaDurationDisplay);\n}\nvar media_duration_display_default = MediaDurationDisplay;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWR1cmF0aW9uLWRpc3BsYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDQztBQUNmO0FBQ007QUFDdUI7QUFDMUUsbUNBQW1DLG9FQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwREFBVTtBQUN0RDtBQUNBO0FBQ0EseUNBQXlDLDREQUFpQjtBQUMxRDtBQUNBO0FBQ0EscUJBQXFCLDREQUFpQjtBQUN0Qyw4Q0FBOEMsMERBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1kdXJhdGlvbi1kaXNwbGF5LmpzP2RiYTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX3Nsb3Q7XG5pbXBvcnQgeyBNZWRpYVRleHREaXNwbGF5IH0gZnJvbSBcIi4vbWVkaWEtdGV4dC1kaXNwbGF5LmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzIH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0VGltZSB9IGZyb20gXCIuL3V0aWxzL3RpbWUuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1lcmljQXR0ciwgc2V0TnVtZXJpY0F0dHIgfSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jbGFzcyBNZWRpYUR1cmF0aW9uRGlzcGxheSBleHRlbmRzIE1lZGlhVGV4dERpc3BsYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2xvdCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Nsb3QsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic2xvdFwiKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zbG90KS50ZXh0Q29udGVudCA9IGZvcm1hdFRpbWUoMCk7XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0RVUkFUSU9OXTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRFVSQVRJT04pIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2xvdCkudGV4dENvbnRlbnQgPSBmb3JtYXRUaW1lKG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYUR1cmF0aW9uKCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9EVVJBVElPTik7XG4gIH1cbiAgc2V0IG1lZGlhRHVyYXRpb24odGltZSkge1xuICAgIHNldE51bWVyaWNBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0RVUkFUSU9OLCB0aW1lKTtcbiAgfVxufVxuX3Nsb3QgPSBuZXcgV2Vha01hcCgpO1xuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWR1cmF0aW9uLWRpc3BsYXlcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1kdXJhdGlvbi1kaXNwbGF5XCIsIE1lZGlhRHVyYXRpb25EaXNwbGF5KTtcbn1cbnZhciBtZWRpYV9kdXJhdGlvbl9kaXNwbGF5X2RlZmF1bHQgPSBNZWRpYUR1cmF0aW9uRGlzcGxheTtcbmV4cG9ydCB7XG4gIG1lZGlhX2R1cmF0aW9uX2Rpc3BsYXlfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-duration-display.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-fullscreen-button.js":
/*!*******************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-fullscreen-button.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_fullscreen_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst enterFullscreenIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M16 3v2.5h3.5V9H22V3h-6ZM4 9h2.5V5.5H10V3H4v6Zm15.5 9.5H16V21h6v-6h-2.5v3.5ZM6.5 15H4v6h6v-2.5H6.5V15Z\"/>\n</svg>`;\nconst exitFullscreenIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M18.5 6.5V3H16v6h6V6.5h-3.5ZM16 21h2.5v-3.5H22V15h-6v6ZM4 17.5h3.5V21H10v-6H4v2.5Zm3.5-11H4V9h6V3H7.5v3.5Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n  :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  ${\"\"}\n  :host(:not([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"enter\">${enterFullscreenIcon}</slot>\n    <slot name=\"exit\">${exitFullscreenIcon}</slot>\n  </slot>\n`;\nconst updateAriaLabel = (el) => {\n  const label = el.mediaIsFullscreen ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.EXIT_FULLSCREEN() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.ENTER_FULLSCREEN();\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaFullscreenButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_FULLSCREEN_UNAVAILABLE\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    updateAriaLabel(this);\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN) {\n      updateAriaLabel(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaFullscreenUnavailable() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_FULLSCREEN_UNAVAILABLE);\n  }\n  set mediaFullscreenUnavailable(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_FULLSCREEN_UNAVAILABLE, value);\n  }\n  get mediaIsFullscreen() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN);\n  }\n  set mediaIsFullscreen(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_FULLSCREEN, value);\n  }\n  handleClick() {\n    const eventName = this.mediaIsFullscreen ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_EXIT_FULLSCREEN_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_ENTER_FULLSCREEN_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-fullscreen-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\n    \"media-fullscreen-button\",\n    MediaFullscreenButton\n  );\n}\nvar media_fullscreen_button_default = MediaFullscreenButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFNVDtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVE7QUFDN0I7QUFDQTtBQUNBLFdBQVcsNERBQWlCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBLElBQUk7QUFDSixnQkFBZ0IsNERBQWlCLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFLLHFCQUFxQixvREFBSztBQUN0RTtBQUNBO0FBQ0Esb0NBQW9DLHNFQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFpQjtBQUN2QixNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLCtDQUErQyx3REFBYSxpQ0FBaUMsd0RBQWE7QUFDMUc7QUFDQSxVQUFVLHFFQUFVLDBCQUEwQiwrQkFBK0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uLmpzPzhiZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7XG4gIGdldEJvb2xlYW5BdHRyLFxuICBnZXRTdHJpbmdBdHRyLFxuICBzZXRCb29sZWFuQXR0cixcbiAgc2V0U3RyaW5nQXR0clxufSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBlbnRlckZ1bGxzY3JlZW5JY29uID0gYDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNiAyNFwiPlxuICA8cGF0aCBkPVwiTTE2IDN2Mi41aDMuNVY5SDIyVjNoLTZaTTQgOWgyLjVWNS41SDEwVjNINHY2Wm0xNS41IDkuNUgxNlYyMWg2di02aC0yLjV2My41Wk02LjUgMTVINHY2aDZ2LTIuNUg2LjVWMTVaXCIvPlxuPC9zdmc+YDtcbmNvbnN0IGV4aXRGdWxsc2NyZWVuSWNvbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjYgMjRcIj5cbiAgPHBhdGggZD1cIk0xOC41IDYuNVYzSDE2djZoNlY2LjVoLTMuNVpNMTYgMjFoMi41di0zLjVIMjJWMTVoLTZ2NlpNNCAxNy41aDMuNVYyMUgxMHYtNkg0djIuNVptMy41LTExSDRWOWg2VjNINy41djMuNVpcIi8+XG48L3N2Zz5gO1xuY29uc3Qgc2xvdFRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICA6aG9zdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19GVUxMU0NSRUVOfV0pIHNsb3Q6bm90KFtuYW1lPWV4aXRdKTpub3QoW25hbWU9aWNvbl0pIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICAke1wiXCJ9XG4gIDpob3N0KDpub3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfSVNfRlVMTFNDUkVFTn1dKSkgc2xvdDpub3QoW25hbWU9ZW50ZXJdKTpub3QoW25hbWU9aWNvbl0pIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cbiAgPC9zdHlsZT5cblxuICA8c2xvdCBuYW1lPVwiaWNvblwiPlxuICAgIDxzbG90IG5hbWU9XCJlbnRlclwiPiR7ZW50ZXJGdWxsc2NyZWVuSWNvbn08L3Nsb3Q+XG4gICAgPHNsb3QgbmFtZT1cImV4aXRcIj4ke2V4aXRGdWxsc2NyZWVuSWNvbn08L3Nsb3Q+XG4gIDwvc2xvdD5cbmA7XG5jb25zdCB1cGRhdGVBcmlhTGFiZWwgPSAoZWwpID0+IHtcbiAgY29uc3QgbGFiZWwgPSBlbC5tZWRpYUlzRnVsbHNjcmVlbiA/IHZlcmJzLkVYSVRfRlVMTFNDUkVFTigpIDogdmVyYnMuRU5URVJfRlVMTFNDUkVFTigpO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGxhYmVsKTtcbn07XG5jbGFzcyBNZWRpYUZ1bGxzY3JlZW5CdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19GVUxMU0NSRUVOLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRlVMTFNDUkVFTl9VTkFWQUlMQUJMRVxuICAgIF07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0ZVTExTQ1JFRU4pIHtcbiAgICAgIHVwZGF0ZUFyaWFMYWJlbCh0aGlzKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYUZ1bGxzY3JlZW5VbmF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gZ2V0U3RyaW5nQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9GVUxMU0NSRUVOX1VOQVZBSUxBQkxFKTtcbiAgfVxuICBzZXQgbWVkaWFGdWxsc2NyZWVuVW5hdmFpbGFibGUodmFsdWUpIHtcbiAgICBzZXRTdHJpbmdBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0ZVTExTQ1JFRU5fVU5BVkFJTEFCTEUsIHZhbHVlKTtcbiAgfVxuICBnZXQgbWVkaWFJc0Z1bGxzY3JlZW4oKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0ZVTExTQ1JFRU4pO1xuICB9XG4gIHNldCBtZWRpYUlzRnVsbHNjcmVlbih2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX0ZVTExTQ1JFRU4sIHZhbHVlKTtcbiAgfVxuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBldmVudE5hbWUgPSB0aGlzLm1lZGlhSXNGdWxsc2NyZWVuID8gTWVkaWFVSUV2ZW50cy5NRURJQV9FWElUX0ZVTExTQ1JFRU5fUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfRU5URVJfRlVMTFNDUkVFTl9SRVFVRVNUO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1mdWxsc2NyZWVuLWJ1dHRvblwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcIm1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uXCIsXG4gICAgTWVkaWFGdWxsc2NyZWVuQnV0dG9uXG4gICk7XG59XG52YXIgbWVkaWFfZnVsbHNjcmVlbl9idXR0b25fZGVmYXVsdCA9IE1lZGlhRnVsbHNjcmVlbkJ1dHRvbjtcbmV4cG9ydCB7XG4gIG1lZGlhX2Z1bGxzY3JlZW5fYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-fullscreen-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-gesture-receiver.js":
/*!******************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-gesture-receiver.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_gesture_receiver_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\n  :host {\n    display: var(--media-control-display, var(--media-gesture-receiver-display, inline-block));\n    box-sizing: border-box;\n  }\n</style>\n`;\nclass MediaGestureReceiver extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor(options = {}) {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    if (!this.shadowRoot) {\n      const shadow = this.attachShadow({ mode: \"open\" });\n      const buttonHTML = template.content.cloneNode(true);\n      this.nativeEl = buttonHTML;\n      let slotTemplate = options.slotTemplate;\n      if (!slotTemplate) {\n        slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\n        slotTemplate.innerHTML = `<slot>${options.defaultContent || \"\"}</slot>`;\n      }\n      this.nativeEl.appendChild(slotTemplate.content.cloneNode(true));\n      shadow.appendChild(buttonHTML);\n    }\n  }\n  static get observedAttributes() {\n    return [\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER,\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED\n    ];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c, _d;\n    this.tabIndex = -1;\n    this.setAttribute(\"aria-hidden\", \"true\");\n    __privateSet(this, _mediaController, getMediaControllerEl(this));\n    if (this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER)) {\n      (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.associateElement) == null ? void 0 : _b.call(_a, this);\n    }\n    (_c = __privateGet(this, _mediaController)) == null ? void 0 : _c.addEventListener(\"pointerdown\", this);\n    (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.addEventListener(\"click\", this);\n  }\n  disconnectedCallback() {\n    var _a, _b, _c, _d;\n    if (this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER)) {\n      (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    }\n    (_c = __privateGet(this, _mediaController)) == null ? void 0 : _c.removeEventListener(\"pointerdown\", this);\n    (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.removeEventListener(\"click\", this);\n    __privateSet(this, _mediaController, null);\n  }\n  handleEvent(event) {\n    var _a;\n    const composedTarget = (_a = event.composedPath()) == null ? void 0 : _a[0];\n    const allowList = [\"video\", \"media-controller\"];\n    if (!allowList.includes(composedTarget == null ? void 0 : composedTarget.localName))\n      return;\n    if (event.type === \"pointerdown\") {\n      this._pointerType = event.pointerType;\n    } else if (event.type === \"click\") {\n      const { clientX, clientY } = event;\n      const { left, top, width, height } = this.getBoundingClientRect();\n      const x = clientX - left;\n      const y = clientY - top;\n      if (x < 0 || y < 0 || x > width || y > height || width === 0 && height === 0) {\n        return;\n      }\n      const { pointerType = this._pointerType } = event;\n      this._pointerType = void 0;\n      if (pointerType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PointerTypes.TOUCH) {\n        this.handleTap(event);\n        return;\n      } else if (pointerType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PointerTypes.MOUSE) {\n        this.handleMouseClick(event);\n        return;\n      }\n    }\n  }\n  get mediaPaused() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED);\n  }\n  set mediaPaused(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED, value);\n  }\n  handleTap(e) {\n  }\n  handleMouseClick(e) {\n    const eventName = this.mediaPaused ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIEvents.MEDIA_PLAY_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIEvents.MEDIA_PAUSE_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\n_mediaController = new WeakMap();\nfunction getMediaControllerEl(controlEl) {\n  var _a;\n  const mediaControllerId = controlEl.getAttribute(\n    _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n  );\n  if (mediaControllerId) {\n    return (_a = controlEl.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId);\n  }\n  return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.closestComposedNode)(controlEl, \"media-controller\");\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-gesture-receiver\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-gesture-receiver\", MediaGestureReceiver);\n}\nvar media_gesture_receiver_default = MediaGestureReceiver;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWdlc3R1cmUtcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTXdCO0FBS1U7QUFDb0M7QUFDdEUsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQVU7QUFDN0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFRO0FBQy9CLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQyxNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVFQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1RUFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQSwwQkFBMEIsdURBQVk7QUFDdEM7QUFDQTtBQUNBLFFBQVEseUJBQXlCLHVEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0RBQWEsc0JBQXNCLHdEQUFhO0FBQ3pGO0FBQ0EsVUFBVSxxRUFBVSwwQkFBMEIsK0JBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1RUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRFQUFtQjtBQUM1QjtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1nZXN0dXJlLXJlY2VpdmVyLmpzPzg1ODkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX21lZGlhQ29udHJvbGxlcjtcbmltcG9ydCB7XG4gIE1lZGlhVUlBdHRyaWJ1dGVzLFxuICBNZWRpYVVJRXZlbnRzLFxuICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLFxuICBQb2ludGVyVHlwZXNcbn0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICBjbG9zZXN0Q29tcG9zZWROb2RlLFxuICBnZXRCb29sZWFuQXR0cixcbiAgc2V0Qm9vbGVhbkF0dHJcbn0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IHZhcigtLW1lZGlhLWNvbnRyb2wtZGlzcGxheSwgdmFyKC0tbWVkaWEtZ2VzdHVyZS1yZWNlaXZlci1kaXNwbGF5LCBpbmxpbmUtYmxvY2spKTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG48L3N0eWxlPlxuYDtcbmNsYXNzIE1lZGlhR2VzdHVyZVJlY2VpdmVyIGV4dGVuZHMgZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIHZvaWQgMCk7XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGNvbnN0IHNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICBjb25zdCBidXR0b25IVE1MID0gdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0aGlzLm5hdGl2ZUVsID0gYnV0dG9uSFRNTDtcbiAgICAgIGxldCBzbG90VGVtcGxhdGUgPSBvcHRpb25zLnNsb3RUZW1wbGF0ZTtcbiAgICAgIGlmICghc2xvdFRlbXBsYXRlKSB7XG4gICAgICAgIHNsb3RUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgICAgc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGA8c2xvdD4ke29wdGlvbnMuZGVmYXVsdENvbnRlbnQgfHwgXCJcIn08L3Nsb3Q+YDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmF0aXZlRWwuYXBwZW5kQ2hpbGQoc2xvdFRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChidXR0b25IVE1MKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUixcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRFxuICAgIF07XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKSB7XG4gICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgKF9jID0gdGhpcy5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZ2V0RWxlbWVudEJ5SWQobmV3VmFsdWUpKTtcbiAgICAgICAgKF9lID0gKF9kID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2QuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBnZXRNZWRpYUNvbnRyb2xsZXJFbCh0aGlzKSk7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikpIHtcbiAgICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzKTtcbiAgICB9XG4gICAgKF9jID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMpO1xuICAgIChfZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUikpIHtcbiAgICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgIH1cbiAgICAoX2MgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcyk7XG4gICAgKF9kID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBudWxsKTtcbiAgfVxuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb21wb3NlZFRhcmdldCA9IChfYSA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF07XG4gICAgY29uc3QgYWxsb3dMaXN0ID0gW1widmlkZW9cIiwgXCJtZWRpYS1jb250cm9sbGVyXCJdO1xuICAgIGlmICghYWxsb3dMaXN0LmluY2x1ZGVzKGNvbXBvc2VkVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBjb21wb3NlZFRhcmdldC5sb2NhbE5hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC50eXBlID09PSBcInBvaW50ZXJkb3duXCIpIHtcbiAgICAgIHRoaXMuX3BvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPiB3aWR0aCB8fCB5ID4gaGVpZ2h0IHx8IHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHBvaW50ZXJUeXBlID0gdGhpcy5fcG9pbnRlclR5cGUgfSA9IGV2ZW50O1xuICAgICAgdGhpcy5fcG9pbnRlclR5cGUgPSB2b2lkIDA7XG4gICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5UT1VDSCkge1xuICAgICAgICB0aGlzLmhhbmRsZVRhcChldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5NT1VTRSkge1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlQ2xpY2soZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYVBhdXNlZCgpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VEKTtcbiAgfVxuICBzZXQgbWVkaWFQYXVzZWQodmFsdWUpIHtcbiAgICBzZXRCb29sZWFuQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUQsIHZhbHVlKTtcbiAgfVxuICBoYW5kbGVUYXAoZSkge1xuICB9XG4gIGhhbmRsZU1vdXNlQ2xpY2soZSkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHRoaXMubWVkaWFQYXVzZWQgPyBNZWRpYVVJRXZlbnRzLk1FRElBX1BMQVlfUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfUEFVU0VfUkVRVUVTVDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChldmVudE5hbWUsIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUgfSlcbiAgICApO1xuICB9XG59XG5fbWVkaWFDb250cm9sbGVyID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE1lZGlhQ29udHJvbGxlckVsKGNvbnRyb2xFbCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gY29udHJvbEVsLmdldEF0dHJpYnV0ZShcbiAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgKTtcbiAgaWYgKG1lZGlhQ29udHJvbGxlcklkKSB7XG4gICAgcmV0dXJuIChfYSA9IGNvbnRyb2xFbC5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudEJ5SWQobWVkaWFDb250cm9sbGVySWQpO1xuICB9XG4gIHJldHVybiBjbG9zZXN0Q29tcG9zZWROb2RlKGNvbnRyb2xFbCwgXCJtZWRpYS1jb250cm9sbGVyXCIpO1xufVxuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLWdlc3R1cmUtcmVjZWl2ZXJcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1nZXN0dXJlLXJlY2VpdmVyXCIsIE1lZGlhR2VzdHVyZVJlY2VpdmVyKTtcbn1cbnZhciBtZWRpYV9nZXN0dXJlX3JlY2VpdmVyX2RlZmF1bHQgPSBNZWRpYUdlc3R1cmVSZWNlaXZlcjtcbmV4cG9ydCB7XG4gIG1lZGlhX2dlc3R1cmVfcmVjZWl2ZXJfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-gesture-receiver.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-live-button.js":
/*!*************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-live-button.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_live_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst { MEDIA_TIME_IS_LIVE, MEDIA_PAUSED } = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes;\nconst { MEDIA_SEEK_TO_LIVE_REQUEST, MEDIA_PLAY_REQUEST } = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents;\nconst indicatorSVG = '<svg viewBox=\"0 0 6 12\"><circle cx=\"3\" cy=\"6\" r=\"2\"></circle></svg>';\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n\n  slot[name=indicator] > *,\n  :host ::slotted([slot=indicator]) {\n    ${\"\"}\n    min-width: auto;\n    fill: var(--media-live-button-icon-color, rgb(140, 140, 140));\n    color: var(--media-live-button-icon-color, rgb(140, 140, 140));\n  }\n\n  :host([${MEDIA_TIME_IS_LIVE}]:not([${MEDIA_PAUSED}])) slot[name=indicator] > *,\n  :host([${MEDIA_TIME_IS_LIVE}]:not([${MEDIA_PAUSED}])) ::slotted([slot=indicator]) {\n    fill: var(--media-live-button-indicator-color, rgb(255, 0, 0));\n    color: var(--media-live-button-indicator-color, rgb(255, 0, 0));\n  }\n\n  :host([${MEDIA_TIME_IS_LIVE}]:not([${MEDIA_PAUSED}])) {\n    cursor: not-allowed;\n  }\n\n  </style>\n\n  <slot name=\"indicator\">${indicatorSVG}</slot>\n  ${\"\"}\n  <slot name=\"spacer\">&nbsp;</slot><slot name=\"text\">LIVE</slot>\n`;\nclass MediaLiveButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [...super.observedAttributes, MEDIA_PAUSED, MEDIA_TIME_IS_LIVE];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.SEEK_LIVE());\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n    if (this.mediaPaused || !this.mediaTimeIsLive) {\n      this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.SEEK_LIVE());\n      this.removeAttribute(\"aria-disabled\");\n    } else {\n      this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.PLAYING_LIVE());\n      this.setAttribute(\"aria-disabled\", \"true\");\n    }\n  }\n  get mediaPaused() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED);\n  }\n  set mediaPaused(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED, value);\n  }\n  get mediaTimeIsLive() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_TIME_IS_LIVE);\n  }\n  set mediaTimeIsLive(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_TIME_IS_LIVE, value);\n  }\n  handleClick() {\n    if (!this.mediaPaused && this.mediaTimeIsLive)\n      return;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(MEDIA_SEEK_TO_LIVE_REQUEST, {\n        composed: true,\n        bubbles: true\n      })\n    );\n    if (this.hasAttribute(MEDIA_PAUSED)) {\n      this.dispatchEvent(\n        new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(MEDIA_PLAY_REQUEST, {\n          composed: true,\n          bubbles: true\n        })\n      );\n    }\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-live-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-live-button\", MediaLiveButton);\n}\nvar media_live_button_default = MediaLiveButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWxpdmUtYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFDK0I7QUFDMUUsUUFBUSxtQ0FBbUMsRUFBRSw0REFBaUI7QUFDOUQsUUFBUSxpREFBaUQsRUFBRSx3REFBYTtBQUN4RTtBQUNBLHFCQUFxQixtRUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBbUIsU0FBUyxhQUFhO0FBQ3BELFdBQVcsbUJBQW1CLFNBQVMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBbUIsU0FBUyxhQUFhO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLGFBQWE7QUFDeEMsSUFBSTtBQUNKLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QixzRUFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVksMEJBQTBCO0FBQ3RDLG9DQUFvQyxvREFBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvREFBSztBQUMzQztBQUNBLE1BQU07QUFDTixzQ0FBc0Msb0RBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFFQUFVO0FBQ3BCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBVTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWxpdmUtYnV0dG9uLmpzPzJjNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7IGdldEJvb2xlYW5BdHRyLCBzZXRCb29sZWFuQXR0ciB9IGZyb20gXCIuL3V0aWxzL2VsZW1lbnQtdXRpbHMuanNcIjtcbmNvbnN0IHsgTUVESUFfVElNRV9JU19MSVZFLCBNRURJQV9QQVVTRUQgfSA9IE1lZGlhVUlBdHRyaWJ1dGVzO1xuY29uc3QgeyBNRURJQV9TRUVLX1RPX0xJVkVfUkVRVUVTVCwgTUVESUFfUExBWV9SRVFVRVNUIH0gPSBNZWRpYVVJRXZlbnRzO1xuY29uc3QgaW5kaWNhdG9yU1ZHID0gJzxzdmcgdmlld0JveD1cIjAgMCA2IDEyXCI+PGNpcmNsZSBjeD1cIjNcIiBjeT1cIjZcIiByPVwiMlwiPjwvY2lyY2xlPjwvc3ZnPic7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG5cbiAgc2xvdFtuYW1lPWluZGljYXRvcl0gPiAqLFxuICA6aG9zdCA6OnNsb3R0ZWQoW3Nsb3Q9aW5kaWNhdG9yXSkge1xuICAgICR7XCJcIn1cbiAgICBtaW4td2lkdGg6IGF1dG87XG4gICAgZmlsbDogdmFyKC0tbWVkaWEtbGl2ZS1idXR0b24taWNvbi1jb2xvciwgcmdiKDE0MCwgMTQwLCAxNDApKTtcbiAgICBjb2xvcjogdmFyKC0tbWVkaWEtbGl2ZS1idXR0b24taWNvbi1jb2xvciwgcmdiKDE0MCwgMTQwLCAxNDApKTtcbiAgfVxuXG4gIDpob3N0KFske01FRElBX1RJTUVfSVNfTElWRX1dOm5vdChbJHtNRURJQV9QQVVTRUR9XSkpIHNsb3RbbmFtZT1pbmRpY2F0b3JdID4gKixcbiAgOmhvc3QoWyR7TUVESUFfVElNRV9JU19MSVZFfV06bm90KFske01FRElBX1BBVVNFRH1dKSkgOjpzbG90dGVkKFtzbG90PWluZGljYXRvcl0pIHtcbiAgICBmaWxsOiB2YXIoLS1tZWRpYS1saXZlLWJ1dHRvbi1pbmRpY2F0b3ItY29sb3IsIHJnYigyNTUsIDAsIDApKTtcbiAgICBjb2xvcjogdmFyKC0tbWVkaWEtbGl2ZS1idXR0b24taW5kaWNhdG9yLWNvbG9yLCByZ2IoMjU1LCAwLCAwKSk7XG4gIH1cblxuICA6aG9zdChbJHtNRURJQV9USU1FX0lTX0xJVkV9XTpub3QoWyR7TUVESUFfUEFVU0VEfV0pKSB7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuXG4gIDwvc3R5bGU+XG5cbiAgPHNsb3QgbmFtZT1cImluZGljYXRvclwiPiR7aW5kaWNhdG9yU1ZHfTwvc2xvdD5cbiAgJHtcIlwifVxuICA8c2xvdCBuYW1lPVwic3BhY2VyXCI+Jm5ic3A7PC9zbG90PjxzbG90IG5hbWU9XCJ0ZXh0XCI+TElWRTwvc2xvdD5cbmA7XG5jbGFzcyBNZWRpYUxpdmVCdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCBNRURJQV9QQVVTRUQsIE1FRElBX1RJTUVfSVNfTElWRV07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUsIC4uLm9wdGlvbnMgfSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHZlcmJzLlNFRUtfTElWRSgpKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBpZiAodGhpcy5tZWRpYVBhdXNlZCB8fCAhdGhpcy5tZWRpYVRpbWVJc0xpdmUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB2ZXJicy5TRUVLX0xJVkUoKSk7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB2ZXJicy5QTEFZSU5HX0xJVkUoKSk7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFQYXVzZWQoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCk7XG4gIH1cbiAgc2V0IG1lZGlhUGF1c2VkKHZhbHVlKSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VELCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhVGltZUlzTGl2ZSgpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVElNRV9JU19MSVZFKTtcbiAgfVxuICBzZXQgbWVkaWFUaW1lSXNMaXZlKHZhbHVlKSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVElNRV9JU19MSVZFLCB2YWx1ZSk7XG4gIH1cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhUGF1c2VkICYmIHRoaXMubWVkaWFUaW1lSXNMaXZlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KE1FRElBX1NFRUtfVE9fTElWRV9SRVFVRVNULCB7XG4gICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKE1FRElBX1BBVVNFRCkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoTUVESUFfUExBWV9SRVFVRVNULCB7XG4gICAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1saXZlLWJ1dHRvblwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLWxpdmUtYnV0dG9uXCIsIE1lZGlhTGl2ZUJ1dHRvbik7XG59XG52YXIgbWVkaWFfbGl2ZV9idXR0b25fZGVmYXVsdCA9IE1lZGlhTGl2ZUJ1dHRvbjtcbmV4cG9ydCB7XG4gIG1lZGlhX2xpdmVfYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-live-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-loading-indicator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-loading-indicator.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_loading_indicator_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController, _delay, _style;\n\n\n\n\nconst Attributes = {\n  LOADING_DELAY: \"loadingdelay\"\n};\nconst DEFAULT_LOADING_DELAY = 500;\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\nconst loadingIndicatorIcon = `\n<svg aria-hidden=\"true\" viewBox=\"0 0 100 100\">\n  <path d=\"M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50\">\n    <animateTransform\n       attributeName=\"transform\"\n       attributeType=\"XML\"\n       type=\"rotate\"\n       dur=\"1s\"\n       from=\"0 50 50\"\n       to=\"360 50 50\"\n       repeatCount=\"indefinite\" />\n  </path>\n</svg>\n`;\ntemplate.innerHTML = `\n<style>\n:host {\n  display: var(--media-control-display, var(--media-loading-indicator-display, inline-block));\n  vertical-align: middle;\n  box-sizing: border-box;\n  --_loading-indicator-delay: var(--media-loading-indicator-transition-delay, ${DEFAULT_LOADING_DELAY}ms);\n}\n\n#status {\n  color: rgba(0,0,0,0);\n  width: 0px;\n  height: 0px;\n}\n\n:host slot[name=icon] > *,\n:host ::slotted([slot=icon]) {\n  opacity: var(--media-loading-indicator-opacity, 0);\n  transition: opacity 0.15s;\n}\n\n:host([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING}]:not([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED}])) slot[name=icon] > *,\n:host([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING}]:not([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED}])) ::slotted([slot=icon]) {\n  opacity: var(--media-loading-indicator-opacity, 1);\n  transition: opacity 0.15s var(--_loading-indicator-delay);\n}\n\n:host #status {\n  visibility: var(--media-loading-indicator-opacity, hidden);\n  transition: visibility 0.15s;\n}\n\n:host([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING}]:not([${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED}])) #status {\n  visibility: var(--media-loading-indicator-opacity, visible);\n  transition: visibility 0.15s var(--_loading-indicator-delay);\n}\n\nsvg, img, ::slotted(svg), ::slotted(img) {\n  width: var(--media-loading-indicator-icon-width);\n  height: var(--media-loading-indicator-icon-height, 100px);\n  fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n  vertical-align: middle;\n}\n</style>\n\n<slot name=\"icon\">${loadingIndicatorIcon}</slot>\n<div id=\"status\" role=\"status\" aria-live=\"polite\">${_labels_labels_js__WEBPACK_IMPORTED_MODULE_1__.nouns.MEDIA_LOADING()}</div>\n`;\nclass MediaLoadingIndicator extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    __privateAdd(this, _delay, DEFAULT_LOADING_DELAY);\n    __privateAdd(this, _style, void 0);\n    if (!this.shadowRoot) {\n      const shadow = this.attachShadow({ mode: \"open\" });\n      const indicatorHTML = template.content.cloneNode(true);\n      shadow.appendChild(indicatorHTML);\n    }\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    __privateSet(this, _style, style);\n  }\n  static get observedAttributes() {\n    return [\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER,\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED,\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING,\n      Attributes.LOADING_DELAY\n    ];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === Attributes.LOADING_DELAY && oldValue !== newValue) {\n      this.loadingDelay = Number(newValue);\n    } else if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n  }\n  get loadingDelay() {\n    return __privateGet(this, _delay);\n  }\n  set loadingDelay(delay) {\n    __privateSet(this, _delay, delay);\n    __privateGet(this, _style).setProperty(\n      \"--_loading-indicator-delay\",\n      `var(--media-loading-indicator-transition-delay, ${delay}ms)`\n    );\n  }\n  get mediaPaused() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED);\n  }\n  set mediaPaused(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_PAUSED, value);\n  }\n  get mediaLoading() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING);\n  }\n  set mediaLoading(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaUIAttributes.MEDIA_LOADING, value);\n  }\n}\n_mediaController = new WeakMap();\n_delay = new WeakMap();\n_style = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-loading-indicator\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-loading-indicator\", MediaLoadingIndicator);\n}\nvar media_loading_indicator_default = MediaLoadingIndicator;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLWxvYWRpbmctaW5kaWNhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lGO0FBQ3RDO0FBQzJCO0FBS3BDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysc0JBQXNCO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDREQUFpQixlQUFlLFNBQVMsNERBQWlCLGNBQWM7QUFDakYsU0FBUyw0REFBaUIsZUFBZSxTQUFTLDREQUFpQixjQUFjO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDREQUFpQixlQUFlLFNBQVMsNERBQWlCLGNBQWM7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekMsb0RBQW9ELG9EQUFLLGlCQUFpQjtBQUMxRTtBQUNBLG9DQUFvQyxxRUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSwyRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQyxNQUFNLDREQUFpQjtBQUN2QixNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQXNCLHVFQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUVBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1sb2FkaW5nLWluZGljYXRvci5qcz84MjI3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9tZWRpYUNvbnRyb2xsZXIsIF9kZWxheSwgX3N0eWxlO1xuaW1wb3J0IHsgTWVkaWFVSUF0dHJpYnV0ZXMsIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IG5vdW5zIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQge1xuICBnZXRCb29sZWFuQXR0cixcbiAgc2V0Qm9vbGVhbkF0dHIsXG4gIGdldE9ySW5zZXJ0Q1NTUnVsZVxufSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBBdHRyaWJ1dGVzID0ge1xuICBMT0FESU5HX0RFTEFZOiBcImxvYWRpbmdkZWxheVwiXG59O1xuY29uc3QgREVGQVVMVF9MT0FESU5HX0RFTEFZID0gNTAwO1xuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBsb2FkaW5nSW5kaWNhdG9ySWNvbiA9IGBcbjxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gIDxwYXRoIGQ9XCJNNzMsNTBjMC0xMi43LTEwLjMtMjMtMjMtMjNTMjcsMzcuMywyNyw1MCBNMzAuOSw1MGMwLTEwLjUsOC41LTE5LjEsMTkuMS0xOS4xUzY5LjEsMzkuNSw2OS4xLDUwXCI+XG4gICAgPGFuaW1hdGVUcmFuc2Zvcm1cbiAgICAgICBhdHRyaWJ1dGVOYW1lPVwidHJhbnNmb3JtXCJcbiAgICAgICBhdHRyaWJ1dGVUeXBlPVwiWE1MXCJcbiAgICAgICB0eXBlPVwicm90YXRlXCJcbiAgICAgICBkdXI9XCIxc1wiXG4gICAgICAgZnJvbT1cIjAgNTAgNTBcIlxuICAgICAgIHRvPVwiMzYwIDUwIDUwXCJcbiAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICA8L3BhdGg+XG48L3N2Zz5cbmA7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gIGRpc3BsYXk6IHZhcigtLW1lZGlhLWNvbnRyb2wtZGlzcGxheSwgdmFyKC0tbWVkaWEtbG9hZGluZy1pbmRpY2F0b3ItZGlzcGxheSwgaW5saW5lLWJsb2NrKSk7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIC0tX2xvYWRpbmctaW5kaWNhdG9yLWRlbGF5OiB2YXIoLS1tZWRpYS1sb2FkaW5nLWluZGljYXRvci10cmFuc2l0aW9uLWRlbGF5LCAke0RFRkFVTFRfTE9BRElOR19ERUxBWX1tcyk7XG59XG5cbiNzdGF0dXMge1xuICBjb2xvcjogcmdiYSgwLDAsMCwwKTtcbiAgd2lkdGg6IDBweDtcbiAgaGVpZ2h0OiAwcHg7XG59XG5cbjpob3N0IHNsb3RbbmFtZT1pY29uXSA+ICosXG46aG9zdCA6OnNsb3R0ZWQoW3Nsb3Q9aWNvbl0pIHtcbiAgb3BhY2l0eTogdmFyKC0tbWVkaWEtbG9hZGluZy1pbmRpY2F0b3Itb3BhY2l0eSwgMCk7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xNXM7XG59XG5cbjpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0xPQURJTkd9XTpub3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VEfV0pKSBzbG90W25hbWU9aWNvbl0gPiAqLFxuOmhvc3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTE9BRElOR31dOm5vdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUR9XSkpIDo6c2xvdHRlZChbc2xvdD1pY29uXSkge1xuICBvcGFjaXR5OiB2YXIoLS1tZWRpYS1sb2FkaW5nLWluZGljYXRvci1vcGFjaXR5LCAxKTtcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjE1cyB2YXIoLS1fbG9hZGluZy1pbmRpY2F0b3ItZGVsYXkpO1xufVxuXG46aG9zdCAjc3RhdHVzIHtcbiAgdmlzaWJpbGl0eTogdmFyKC0tbWVkaWEtbG9hZGluZy1pbmRpY2F0b3Itb3BhY2l0eSwgaGlkZGVuKTtcbiAgdHJhbnNpdGlvbjogdmlzaWJpbGl0eSAwLjE1cztcbn1cblxuOmhvc3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTE9BRElOR31dOm5vdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUR9XSkpICNzdGF0dXMge1xuICB2aXNpYmlsaXR5OiB2YXIoLS1tZWRpYS1sb2FkaW5nLWluZGljYXRvci1vcGFjaXR5LCB2aXNpYmxlKTtcbiAgdHJhbnNpdGlvbjogdmlzaWJpbGl0eSAwLjE1cyB2YXIoLS1fbG9hZGluZy1pbmRpY2F0b3ItZGVsYXkpO1xufVxuXG5zdmcsIGltZywgOjpzbG90dGVkKHN2ZyksIDo6c2xvdHRlZChpbWcpIHtcbiAgd2lkdGg6IHZhcigtLW1lZGlhLWxvYWRpbmctaW5kaWNhdG9yLWljb24td2lkdGgpO1xuICBoZWlnaHQ6IHZhcigtLW1lZGlhLWxvYWRpbmctaW5kaWNhdG9yLWljb24taGVpZ2h0LCAxMDBweCk7XG4gIGZpbGw6IHZhcigtLW1lZGlhLWljb24tY29sb3IsIHZhcigtLW1lZGlhLXByaW1hcnktY29sb3IsIHJnYigyMzggMjM4IDIzOCkpKTtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cbjwvc3R5bGU+XG5cbjxzbG90IG5hbWU9XCJpY29uXCI+JHtsb2FkaW5nSW5kaWNhdG9ySWNvbn08L3Nsb3Q+XG48ZGl2IGlkPVwic3RhdHVzXCIgcm9sZT1cInN0YXR1c1wiIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPiR7bm91bnMuTUVESUFfTE9BRElORygpfTwvZGl2PlxuYDtcbmNsYXNzIE1lZGlhTG9hZGluZ0luZGljYXRvciBleHRlbmRzIGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGVsYXksIERFRkFVTFRfTE9BRElOR19ERUxBWSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zdHlsZSwgdm9pZCAwKTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgY29uc3Qgc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIGNvbnN0IGluZGljYXRvckhUTUwgPSB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChpbmRpY2F0b3JIVE1MKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdFwiKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3N0eWxlLCBzdHlsZSk7XG4gIH1cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUixcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0xPQURJTkcsXG4gICAgICBBdHRyaWJ1dGVzLkxPQURJTkdfREVMQVlcbiAgICBdO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuTE9BRElOR19ERUxBWSAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMubG9hZGluZ0RlbGF5ID0gTnVtYmVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVIpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAoX2IgPSAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS51bmFzc29jaWF0ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzKTtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCAoX2MgPSB0aGlzLmdldFJvb3ROb2RlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5nZXRFbGVtZW50QnlJZChuZXdWYWx1ZSkpO1xuICAgICAgICAoX2UgPSAoX2QgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfZC5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FsbChfZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICApO1xuICAgIGlmIChtZWRpYUNvbnRyb2xsZXJJZCkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYSA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnRCeUlkKG1lZGlhQ29udHJvbGxlcklkKSk7XG4gICAgICAoX2MgPSAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChfYiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIG51bGwpO1xuICB9XG4gIGdldCBsb2FkaW5nRGVsYXkoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVsYXkpO1xuICB9XG4gIHNldCBsb2FkaW5nRGVsYXkoZGVsYXkpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RlbGF5LCBkZWxheSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdHlsZSkuc2V0UHJvcGVydHkoXG4gICAgICBcIi0tX2xvYWRpbmctaW5kaWNhdG9yLWRlbGF5XCIsXG4gICAgICBgdmFyKC0tbWVkaWEtbG9hZGluZy1pbmRpY2F0b3ItdHJhbnNpdGlvbi1kZWxheSwgJHtkZWxheX1tcylgXG4gICAgKTtcbiAgfVxuICBnZXQgbWVkaWFQYXVzZWQoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCk7XG4gIH1cbiAgc2V0IG1lZGlhUGF1c2VkKHZhbHVlKSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VELCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhTG9hZGluZygpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTE9BRElORyk7XG4gIH1cbiAgc2V0IG1lZGlhTG9hZGluZyh2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0xPQURJTkcsIHZhbHVlKTtcbiAgfVxufVxuX21lZGlhQ29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5fZGVsYXkgPSBuZXcgV2Vha01hcCgpO1xuX3N0eWxlID0gbmV3IFdlYWtNYXAoKTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1sb2FkaW5nLWluZGljYXRvclwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLWxvYWRpbmctaW5kaWNhdG9yXCIsIE1lZGlhTG9hZGluZ0luZGljYXRvcik7XG59XG52YXIgbWVkaWFfbG9hZGluZ19pbmRpY2F0b3JfZGVmYXVsdCA9IE1lZGlhTG9hZGluZ0luZGljYXRvcjtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZXMsXG4gIG1lZGlhX2xvYWRpbmdfaW5kaWNhdG9yX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-loading-indicator.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-mute-button.js":
/*!*************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-mute-button.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_mute_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst { MEDIA_VOLUME_LEVEL } = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes;\nconst offIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\">\n  <path d=\"M16.5 12A4.5 4.5 0 0 0 14 8v2.18l2.45 2.45a4.22 4.22 0 0 0 .05-.63Zm2.5 0a6.84 6.84 0 0 1-.54 2.64L20 16.15A8.8 8.8 0 0 0 21 12a9 9 0 0 0-7-8.77v2.06A7 7 0 0 1 19 12ZM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25A6.92 6.92 0 0 1 14 18.7v2.06A9 9 0 0 0 17.69 19l2 2.05L21 19.73l-9-9L4.27 3ZM12 4 9.91 6.09 12 8.18V4Z\"/>\n</svg>`;\nconst lowIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\">\n  <path d=\"M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4Z\"/>\n</svg>`;\nconst highIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\">\n  <path d=\"M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4ZM14 3.23v2.06a7 7 0 0 1 0 13.42v2.06a9 9 0 0 0 0-17.54Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n  ${\"\"}\n  :host(:not([${MEDIA_VOLUME_LEVEL}])) slot:not([name=high]):not([name=icon]), \n  :host([${MEDIA_VOLUME_LEVEL}=high]) slot:not([name=high]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${MEDIA_VOLUME_LEVEL}=off]) slot:not([name=off]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${MEDIA_VOLUME_LEVEL}=low]) slot:not([name=low]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${MEDIA_VOLUME_LEVEL}=medium]) slot:not([name=medium]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"off\">${offIcon}</slot>\n    <slot name=\"low\">${lowIcon}</slot>\n    <slot name=\"medium\">${lowIcon}</slot>\n    <slot name=\"high\">${highIcon}</slot>\n  </slot>\n`;\nconst updateAriaLabel = (el) => {\n  const muted = el.mediaVolumeLevel === \"off\";\n  const label = muted ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.UNMUTE() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.MUTE();\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaMuteButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [...super.observedAttributes, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_LEVEL];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    updateAriaLabel(this);\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_LEVEL) {\n      updateAriaLabel(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaVolumeLevel() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_LEVEL);\n  }\n  set mediaVolumeLevel(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_LEVEL, value);\n  }\n  handleClick() {\n    const eventName = this.mediaVolumeLevel === \"off\" ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_UNMUTE_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_MUTE_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-mute-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-mute-button\", MediaMuteButton);\n}\nvar media_mute_button_default = MediaMuteButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLW11dGUtYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFDNkI7QUFDeEUsUUFBUSxxQkFBcUIsRUFBRSw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLG1CQUFtQjtBQUNuQyxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBOztBQUVBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7O0FBRUEsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTs7QUFFQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQiwwQkFBMEIsUUFBUTtBQUNsQyx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBSyxZQUFZLG9EQUFLO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsc0VBQWlCO0FBQy9DO0FBQ0EseUNBQXlDLDREQUFpQjtBQUMxRDtBQUNBLDBCQUEwQjtBQUMxQixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFhLE9BQU8sNERBQWlCO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJLHNFQUFhLE9BQU8sNERBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx3REFBd0Qsd0RBQWEsd0JBQXdCLHdEQUFhO0FBQzFHO0FBQ0EsVUFBVSxxRUFBVSwwQkFBMEIsK0JBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1tdXRlLWJ1dHRvbi5qcz9hNTdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lZGlhQ2hyb21lQnV0dG9uIH0gZnJvbSBcIi4vbWVkaWEtY2hyb21lLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBNZWRpYVVJRXZlbnRzLCBNZWRpYVVJQXR0cmlidXRlcyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgdmVyYnMgfSBmcm9tIFwiLi9sYWJlbHMvbGFiZWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRTdHJpbmdBdHRyLCBzZXRTdHJpbmdBdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgeyBNRURJQV9WT0xVTUVfTEVWRUwgfSA9IE1lZGlhVUlBdHRyaWJ1dGVzO1xuY29uc3Qgb2ZmSWNvbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgPHBhdGggZD1cIk0xNi41IDEyQTQuNSA0LjUgMCAwIDAgMTQgOHYyLjE4bDIuNDUgMi40NWE0LjIyIDQuMjIgMCAwIDAgLjA1LS42M1ptMi41IDBhNi44NCA2Ljg0IDAgMCAxLS41NCAyLjY0TDIwIDE2LjE1QTguOCA4LjggMCAwIDAgMjEgMTJhOSA5IDAgMCAwLTctOC43N3YyLjA2QTcgNyAwIDAgMSAxOSAxMlpNNC4yNyAzIDMgNC4yNyA3LjczIDlIM3Y2aDRsNSA1di02LjczbDQuMjUgNC4yNUE2LjkyIDYuOTIgMCAwIDEgMTQgMTguN3YyLjA2QTkgOSAwIDAgMCAxNy42OSAxOWwyIDIuMDVMMjEgMTkuNzNsLTktOUw0LjI3IDNaTTEyIDQgOS45MSA2LjA5IDEyIDguMThWNFpcIi8+XG48L3N2Zz5gO1xuY29uc3QgbG93SWNvbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgPHBhdGggZD1cIk0zIDl2Nmg0bDUgNVY0TDcgOUgzWm0xMy41IDNBNC41IDQuNSAwIDAgMCAxNCA4djhhNC40NyA0LjQ3IDAgMCAwIDIuNS00WlwiLz5cbjwvc3ZnPmA7XG5jb25zdCBoaWdoSWNvbiA9IGA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgPHBhdGggZD1cIk0zIDl2Nmg0bDUgNVY0TDcgOUgzWm0xMy41IDNBNC41IDQuNSAwIDAgMCAxNCA4djhhNC40NyA0LjQ3IDAgMCAwIDIuNS00Wk0xNCAzLjIzdjIuMDZhNyA3IDAgMCAxIDAgMTMuNDJ2Mi4wNmE5IDkgMCAwIDAgMC0xNy41NFpcIi8+XG48L3N2Zz5gO1xuY29uc3Qgc2xvdFRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICAke1wiXCJ9XG4gIDpob3N0KDpub3QoWyR7TUVESUFfVk9MVU1FX0xFVkVMfV0pKSBzbG90Om5vdChbbmFtZT1oaWdoXSk6bm90KFtuYW1lPWljb25dKSwgXG4gIDpob3N0KFske01FRElBX1ZPTFVNRV9MRVZFTH09aGlnaF0pIHNsb3Q6bm90KFtuYW1lPWhpZ2hdKTpub3QoW25hbWU9aWNvbl0pIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICA6aG9zdChbJHtNRURJQV9WT0xVTUVfTEVWRUx9PW9mZl0pIHNsb3Q6bm90KFtuYW1lPW9mZl0pOm5vdChbbmFtZT1pY29uXSkge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuXG4gIDpob3N0KFske01FRElBX1ZPTFVNRV9MRVZFTH09bG93XSkgc2xvdDpub3QoW25hbWU9bG93XSk6bm90KFtuYW1lPWljb25dKSB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICB9XG5cbiAgOmhvc3QoWyR7TUVESUFfVk9MVU1FX0xFVkVMfT1tZWRpdW1dKSBzbG90Om5vdChbbmFtZT1tZWRpdW1dKTpub3QoW25hbWU9aWNvbl0pIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cbiAgPC9zdHlsZT5cblxuICA8c2xvdCBuYW1lPVwiaWNvblwiPlxuICAgIDxzbG90IG5hbWU9XCJvZmZcIj4ke29mZkljb259PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJsb3dcIj4ke2xvd0ljb259PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJtZWRpdW1cIj4ke2xvd0ljb259PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJoaWdoXCI+JHtoaWdoSWNvbn08L3Nsb3Q+XG4gIDwvc2xvdD5cbmA7XG5jb25zdCB1cGRhdGVBcmlhTGFiZWwgPSAoZWwpID0+IHtcbiAgY29uc3QgbXV0ZWQgPSBlbC5tZWRpYVZvbHVtZUxldmVsID09PSBcIm9mZlwiO1xuICBjb25zdCBsYWJlbCA9IG11dGVkID8gdmVyYnMuVU5NVVRFKCkgOiB2ZXJicy5NVVRFKCk7XG4gIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xufTtcbmNsYXNzIE1lZGlhTXV0ZUJ1dHRvbiBleHRlbmRzIE1lZGlhQ2hyb21lQnV0dG9uIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1ZPTFVNRV9MRVZFTF07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1ZPTFVNRV9MRVZFTCkge1xuICAgICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhVm9sdW1lTGV2ZWwoKSB7XG4gICAgcmV0dXJuIGdldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FX0xFVkVMKTtcbiAgfVxuICBzZXQgbWVkaWFWb2x1bWVMZXZlbCh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FX0xFVkVMLCB2YWx1ZSk7XG4gIH1cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgY29uc3QgZXZlbnROYW1lID0gdGhpcy5tZWRpYVZvbHVtZUxldmVsID09PSBcIm9mZlwiID8gTWVkaWFVSUV2ZW50cy5NRURJQV9VTk1VVEVfUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfTVVURV9SRVFVRVNUO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1tdXRlLWJ1dHRvblwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLW11dGUtYnV0dG9uXCIsIE1lZGlhTXV0ZUJ1dHRvbik7XG59XG52YXIgbWVkaWFfbXV0ZV9idXR0b25fZGVmYXVsdCA9IE1lZGlhTXV0ZUJ1dHRvbjtcbmV4cG9ydCB7XG4gIG1lZGlhX211dGVfYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-mute-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-pip-button.js":
/*!************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-pip-button.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_pip_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst pipIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 28 24\">\n  <path d=\"M24 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Zm-1 16H5V5h18v14Zm-3-8h-7v5h7v-5Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n  :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  ${\"\"}\n  :host(:not([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"enter\">${pipIcon}</slot>\n    <slot name=\"exit\">${pipIcon}</slot>\n  </slot>\n`;\nconst updateAriaLabel = (el) => {\n  const label = el.mediaIsPip ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.EXIT_PIP() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.ENTER_PIP();\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaPipButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PIP_UNAVAILABLE\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    updateAriaLabel(this);\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP) {\n      updateAriaLabel(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaPipUnavailable() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PIP_UNAVAILABLE);\n  }\n  set mediaPipUnavailable(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PIP_UNAVAILABLE, value);\n  }\n  get mediaIsPip() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP);\n  }\n  set mediaIsPip(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_IS_PIP, value);\n  }\n  handleClick() {\n    const eventName = this.mediaIsPip ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_EXIT_PIP_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_ENTER_PIP_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-pip-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-pip-button\", MediaPipButton);\n}\nvar media_pip_button_default = MediaPipButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXBpcC1idXR0b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZEO0FBQ1M7QUFDSjtBQUN2QjtBQU1UO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBUTtBQUM3QjtBQUNBO0FBQ0EsV0FBVyw0REFBaUIsY0FBYztBQUMxQztBQUNBOztBQUVBLElBQUk7QUFDSixnQkFBZ0IsNERBQWlCLGNBQWM7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFLLGNBQWMsb0RBQUs7QUFDeEQ7QUFDQTtBQUNBLDZCQUE2QixzRUFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkIsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFhLE9BQU8sNERBQWlCO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJLHNFQUFhLE9BQU8sNERBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSx3Q0FBd0Msd0RBQWEsMEJBQTBCLHdEQUFhO0FBQzVGO0FBQ0EsVUFBVSxxRUFBVSwwQkFBMEIsK0JBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS1waXAtYnV0dG9uLmpzPzlhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7XG4gIGdldEJvb2xlYW5BdHRyLFxuICBnZXRTdHJpbmdBdHRyLFxuICBzZXRCb29sZWFuQXR0cixcbiAgc2V0U3RyaW5nQXR0clxufSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBwaXBJY29uID0gYDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyOCAyNFwiPlxuICA8cGF0aCBkPVwiTTI0IDNINGExIDEgMCAwIDAtMSAxdjE2YTEgMSAwIDAgMCAxIDFoMjBhMSAxIDAgMCAwIDEtMVY0YTEgMSAwIDAgMC0xLTFabS0xIDE2SDVWNWgxOHYxNFptLTMtOGgtN3Y1aDd2LTVaXCIvPlxuPC9zdmc+YDtcbmNvbnN0IHNsb3RUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnNsb3RUZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzdHlsZT5cbiAgOmhvc3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfSVNfUElQfV0pIHNsb3Q6bm90KFtuYW1lPWV4aXRdKTpub3QoW25hbWU9aWNvbl0pIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICAke1wiXCJ9XG4gIDpob3N0KDpub3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfSVNfUElQfV0pKSBzbG90Om5vdChbbmFtZT1lbnRlcl0pOm5vdChbbmFtZT1pY29uXSkge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuICA8L3N0eWxlPlxuXG4gIDxzbG90IG5hbWU9XCJpY29uXCI+XG4gICAgPHNsb3QgbmFtZT1cImVudGVyXCI+JHtwaXBJY29ufTwvc2xvdD5cbiAgICA8c2xvdCBuYW1lPVwiZXhpdFwiPiR7cGlwSWNvbn08L3Nsb3Q+XG4gIDwvc2xvdD5cbmA7XG5jb25zdCB1cGRhdGVBcmlhTGFiZWwgPSAoZWwpID0+IHtcbiAgY29uc3QgbGFiZWwgPSBlbC5tZWRpYUlzUGlwID8gdmVyYnMuRVhJVF9QSVAoKSA6IHZlcmJzLkVOVEVSX1BJUCgpO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGxhYmVsKTtcbn07XG5jbGFzcyBNZWRpYVBpcEJ1dHRvbiBleHRlbmRzIE1lZGlhQ2hyb21lQnV0dG9uIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX1BJUCxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BJUF9VTkFWQUlMQUJMRVxuICAgIF07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX1BJUCkge1xuICAgICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhUGlwVW5hdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIGdldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUElQX1VOQVZBSUxBQkxFKTtcbiAgfVxuICBzZXQgbWVkaWFQaXBVbmF2YWlsYWJsZSh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUElQX1VOQVZBSUxBQkxFLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhSXNQaXAoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0lTX1BJUCk7XG4gIH1cbiAgc2V0IG1lZGlhSXNQaXAodmFsdWUpIHtcbiAgICBzZXRCb29sZWFuQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9JU19QSVAsIHZhbHVlKTtcbiAgfVxuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBldmVudE5hbWUgPSB0aGlzLm1lZGlhSXNQaXAgPyBNZWRpYVVJRXZlbnRzLk1FRElBX0VYSVRfUElQX1JFUVVFU1QgOiBNZWRpYVVJRXZlbnRzLk1FRElBX0VOVEVSX1BJUF9SRVFVRVNUO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1waXAtYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtcGlwLWJ1dHRvblwiLCBNZWRpYVBpcEJ1dHRvbik7XG59XG52YXIgbWVkaWFfcGlwX2J1dHRvbl9kZWZhdWx0ID0gTWVkaWFQaXBCdXR0b247XG5leHBvcnQge1xuICBtZWRpYV9waXBfYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-pip-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-play-button.js":
/*!*************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-play-button.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_play_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst playIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\">\n  <path d=\"m6 21 15-9L6 3v18Z\"/>\n</svg>`;\nconst pauseIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\">\n  <path d=\"M6 20h4V4H6v16Zm8-16v16h4V4h-4Z\"/>\n</svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <style>\n  :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED}]) slot[name=pause] {\n    display: none !important;\n  }\n\n  :host(:not([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED}])) slot[name=play] {\n    display: none !important;\n  }\n  </style>\n\n  <slot name=\"icon\">\n    <slot name=\"play\">${playIcon}</slot>\n    <slot name=\"pause\">${pauseIcon}</slot>\n  </slot>\n`;\nconst updateAriaLabel = (el) => {\n  const label = el.mediaPaused ? _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.PLAY() : _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.verbs.PAUSE();\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaPlayButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_ENDED\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n  }\n  connectedCallback() {\n    updateAriaLabel(this);\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED) {\n      updateAriaLabel(this);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaPaused() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED);\n  }\n  set mediaPaused(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED, value);\n  }\n  handleClick() {\n    const eventName = this.mediaPaused ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_PLAY_REQUEST : _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_PAUSE_REQUEST;\n    this.dispatchEvent(\n      new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(eventName, { composed: true, bubbles: true })\n    );\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-play-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-play-button\", MediaPlayButton);\n}\nvar media_play_button_default = MediaPlayButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXBsYXktYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDdkI7QUFDK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLDREQUFpQixjQUFjO0FBQzFDO0FBQ0E7O0FBRUEsZ0JBQWdCLDREQUFpQixjQUFjO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBSyxVQUFVLG9EQUFLO0FBQ3JEO0FBQ0E7QUFDQSw4QkFBOEIsc0VBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1RUFBYyxPQUFPLDREQUFpQjtBQUNqRDtBQUNBO0FBQ0EsSUFBSSx1RUFBYyxPQUFPLDREQUFpQjtBQUMxQztBQUNBO0FBQ0EseUNBQXlDLHdEQUFhLHNCQUFzQix3REFBYTtBQUN6RjtBQUNBLFVBQVUscUVBQVUsMEJBQTBCLCtCQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtcGxheS1idXR0b24uanM/ZDU0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZWRpYUNocm9tZUJ1dHRvbiB9IGZyb20gXCIuL21lZGlhLWNocm9tZS1idXR0b24uanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUV2ZW50cywgTWVkaWFVSUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IHZlcmJzIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qm9vbGVhbkF0dHIsIHNldEJvb2xlYW5BdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgcGxheUljb24gPSBgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gIDxwYXRoIGQ9XCJtNiAyMSAxNS05TDYgM3YxOFpcIi8+XG48L3N2Zz5gO1xuY29uc3QgcGF1c2VJY29uID0gYDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICA8cGF0aCBkPVwiTTYgMjBoNFY0SDZ2MTZabTgtMTZ2MTZoNFY0aC00WlwiLz5cbjwvc3ZnPmA7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG4gIDpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRH1dKSBzbG90W25hbWU9cGF1c2VdIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICA6aG9zdCg6bm90KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRH1dKSkgc2xvdFtuYW1lPXBsYXldIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cbiAgPC9zdHlsZT5cblxuICA8c2xvdCBuYW1lPVwiaWNvblwiPlxuICAgIDxzbG90IG5hbWU9XCJwbGF5XCI+JHtwbGF5SWNvbn08L3Nsb3Q+XG4gICAgPHNsb3QgbmFtZT1cInBhdXNlXCI+JHtwYXVzZUljb259PC9zbG90PlxuICA8L3Nsb3Q+XG5gO1xuY29uc3QgdXBkYXRlQXJpYUxhYmVsID0gKGVsKSA9PiB7XG4gIGNvbnN0IGxhYmVsID0gZWwubWVkaWFQYXVzZWQgPyB2ZXJicy5QTEFZKCkgOiB2ZXJicy5QQVVTRSgpO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGxhYmVsKTtcbn07XG5jbGFzcyBNZWRpYVBsYXlCdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUQsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9FTkRFRFxuICAgIF07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoeyBzbG90VGVtcGxhdGUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCkge1xuICAgICAgdXBkYXRlQXJpYUxhYmVsKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhUGF1c2VkKCkge1xuICAgIHJldHVybiBnZXRCb29sZWFuQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QQVVTRUQpO1xuICB9XG4gIHNldCBtZWRpYVBhdXNlZCh2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCwgdmFsdWUpO1xuICB9XG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHRoaXMubWVkaWFQYXVzZWQgPyBNZWRpYVVJRXZlbnRzLk1FRElBX1BMQVlfUkVRVUVTVCA6IE1lZGlhVUlFdmVudHMuTUVESUFfUEFVU0VfUkVRVUVTVDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChldmVudE5hbWUsIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUgfSlcbiAgICApO1xuICB9XG59XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtcGxheS1idXR0b25cIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1wbGF5LWJ1dHRvblwiLCBNZWRpYVBsYXlCdXR0b24pO1xufVxudmFyIG1lZGlhX3BsYXlfYnV0dG9uX2RlZmF1bHQgPSBNZWRpYVBsYXlCdXR0b247XG5leHBvcnQge1xuICBtZWRpYV9wbGF5X2J1dHRvbl9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-play-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-playback-rate-button.js":
/*!**********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-playback-rate-button.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   DEFAULT_RATE: function() { return /* binding */ DEFAULT_RATE; },\n/* harmony export */   DEFAULT_RATES: function() { return /* binding */ DEFAULT_RATES; },\n/* harmony export */   \"default\": function() { return /* binding */ media_playback_rate_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_attribute_token_list_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/attribute-token-list.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/attribute-token-list.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar _rates;\n\n\n\n\n\n\nconst Attributes = {\n  RATES: \"rates\"\n};\nconst DEFAULT_RATES = [1, 1.25, 1.5, 1.75, 2];\nconst DEFAULT_RATE = 1;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <span id=\"container\"></span>\n`;\nclass MediaPlaybackRateButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n    __privateAdd(this, _rates, new _utils_attribute_token_list_js__WEBPACK_IMPORTED_MODULE_5__.AttributeTokenList(this, Attributes.RATES, { defaultValue: DEFAULT_RATES }));\n    this.container = this.shadowRoot.querySelector(\"#container\");\n    this.container.innerHTML = `${DEFAULT_RATE}x`;\n  }\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE,\n      Attributes.RATES\n    ];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === Attributes.RATES) {\n      __privateGet(this, _rates).value = newValue;\n    }\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE) {\n      const newPlaybackRate = newValue ? +newValue : Number.NaN;\n      const playbackRate = !Number.isNaN(newPlaybackRate) ? newPlaybackRate : DEFAULT_RATE;\n      this.container.innerHTML = `${playbackRate}x`;\n      this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.nouns.PLAYBACK_RATE({ playbackRate }));\n      return;\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get rates() {\n    return __privateGet(this, _rates);\n  }\n  set rates(value) {\n    if (!value) {\n      __privateGet(this, _rates).value = \"\";\n    } else if (Array.isArray(value)) {\n      __privateGet(this, _rates).value = value.join(\" \");\n    }\n  }\n  get mediaPlaybackRate() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE, DEFAULT_RATE);\n  }\n  set mediaPlaybackRate(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE, value);\n  }\n  handleClick() {\n    var _a, _b;\n    const availableRates = Array.from(this.rates.values(), (str) => +str).sort((a, b) => a - b);\n    const detail = (_b = (_a = availableRates.find((r) => r > this.mediaPlaybackRate)) != null ? _a : availableRates[0]) != null ? _b : DEFAULT_RATE;\n    const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_PLAYBACK_RATE_REQUEST,\n      { composed: true, bubbles: true, detail }\n    );\n    this.dispatchEvent(evt);\n  }\n}\n_rates = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-playback-rate-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\n    \"media-playback-rate-button\",\n    MediaPlaybackRateButton\n  );\n}\nvar media_playback_rate_button_default = MediaPlaybackRateButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXBsYXliYWNrLXJhdGUtYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1M7QUFDSjtBQUN2QjtBQUMrQjtBQUNMO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNFQUFpQjtBQUN2RCwwQkFBMEI7QUFDMUIsWUFBWSwwQkFBMEI7QUFDdEMsbUNBQW1DLDhFQUFrQiwyQkFBMkIsNkJBQTZCO0FBQzdHO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pELHNDQUFzQyxvREFBSyxpQkFBaUIsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxRUFBVTtBQUM5QixNQUFNLHdEQUFhO0FBQ25CLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXBsYXliYWNrLXJhdGUtYnV0dG9uLmpzPzRlYTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfcmF0ZXM7XG5pbXBvcnQgeyBNZWRpYUNocm9tZUJ1dHRvbiB9IGZyb20gXCIuL21lZGlhLWNocm9tZS1idXR0b24uanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUV2ZW50cywgTWVkaWFVSUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IG5vdW5zIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHsgZ2V0TnVtZXJpY0F0dHIsIHNldE51bWVyaWNBdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgQXR0cmlidXRlVG9rZW5MaXN0IH0gZnJvbSBcIi4vdXRpbHMvYXR0cmlidXRlLXRva2VuLWxpc3QuanNcIjtcbmNvbnN0IEF0dHJpYnV0ZXMgPSB7XG4gIFJBVEVTOiBcInJhdGVzXCJcbn07XG5jb25zdCBERUZBVUxUX1JBVEVTID0gWzEsIDEuMjUsIDEuNSwgMS43NSwgMl07XG5jb25zdCBERUZBVUxUX1JBVEUgPSAxO1xuY29uc3Qgc2xvdFRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuc2xvdFRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHNwYW4gaWQ9XCJjb250YWluZXJcIj48L3NwYW4+XG5gO1xuY2xhc3MgTWVkaWFQbGF5YmFja1JhdGVCdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHsgc2xvdFRlbXBsYXRlLCAuLi5vcHRpb25zIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmF0ZXMsIG5ldyBBdHRyaWJ1dGVUb2tlbkxpc3QodGhpcywgQXR0cmlidXRlcy5SQVRFUywgeyBkZWZhdWx0VmFsdWU6IERFRkFVTFRfUkFURVMgfSkpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjY29udGFpbmVyXCIpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGAke0RFRkFVTFRfUkFURX14YDtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUExBWUJBQ0tfUkFURSxcbiAgICAgIEF0dHJpYnV0ZXMuUkFURVNcbiAgICBdO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGF0dHJOYW1lID09PSBBdHRyaWJ1dGVzLlJBVEVTKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3JhdGVzKS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BMQVlCQUNLX1JBVEUpIHtcbiAgICAgIGNvbnN0IG5ld1BsYXliYWNrUmF0ZSA9IG5ld1ZhbHVlID8gK25ld1ZhbHVlIDogTnVtYmVyLk5hTjtcbiAgICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9ICFOdW1iZXIuaXNOYU4obmV3UGxheWJhY2tSYXRlKSA/IG5ld1BsYXliYWNrUmF0ZSA6IERFRkFVTFRfUkFURTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGAke3BsYXliYWNrUmF0ZX14YDtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBub3Vucy5QTEFZQkFDS19SQVRFKHsgcGxheWJhY2tSYXRlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCByYXRlcygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9yYXRlcyk7XG4gIH1cbiAgc2V0IHJhdGVzKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9yYXRlcykudmFsdWUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmF0ZXMpLnZhbHVlID0gdmFsdWUuam9pbihcIiBcIik7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYVBsYXliYWNrUmF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUExBWUJBQ0tfUkFURSwgREVGQVVMVF9SQVRFKTtcbiAgfVxuICBzZXQgbWVkaWFQbGF5YmFja1JhdGUodmFsdWUpIHtcbiAgICBzZXROdW1lcmljQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QTEFZQkFDS19SQVRFLCB2YWx1ZSk7XG4gIH1cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBhdmFpbGFibGVSYXRlcyA9IEFycmF5LmZyb20odGhpcy5yYXRlcy52YWx1ZXMoKSwgKHN0cikgPT4gK3N0cikuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGNvbnN0IGRldGFpbCA9IChfYiA9IChfYSA9IGF2YWlsYWJsZVJhdGVzLmZpbmQoKHIpID0+IHIgPiB0aGlzLm1lZGlhUGxheWJhY2tSYXRlKSkgIT0gbnVsbCA/IF9hIDogYXZhaWxhYmxlUmF0ZXNbMF0pICE9IG51bGwgPyBfYiA6IERFRkFVTFRfUkFURTtcbiAgICBjb25zdCBldnQgPSBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChcbiAgICAgIE1lZGlhVUlFdmVudHMuTUVESUFfUExBWUJBQ0tfUkFURV9SRVFVRVNULFxuICAgICAgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSwgZGV0YWlsIH1cbiAgICApO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5fcmF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLXBsYXliYWNrLXJhdGUtYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFxuICAgIFwibWVkaWEtcGxheWJhY2stcmF0ZS1idXR0b25cIixcbiAgICBNZWRpYVBsYXliYWNrUmF0ZUJ1dHRvblxuICApO1xufVxudmFyIG1lZGlhX3BsYXliYWNrX3JhdGVfYnV0dG9uX2RlZmF1bHQgPSBNZWRpYVBsYXliYWNrUmF0ZUJ1dHRvbjtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZXMsXG4gIERFRkFVTFRfUkFURSxcbiAgREVGQVVMVF9SQVRFUyxcbiAgbWVkaWFfcGxheWJhY2tfcmF0ZV9idXR0b25fZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-playback-rate-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-poster-image.js":
/*!**************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-poster-image.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_poster_image_default; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\nconst Attributes = {\n  PLACEHOLDER_SRC: \"placeholdersrc\",\n  SRC: \"src\"\n};\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      pointer-events: none;\n      display: var(--media-poster-image-display, inline-block);\n      box-sizing: border-box;\n    }\n\n    img {\n      max-width: 100%;\n      max-height: 100%;\n      min-width: 100%;\n      min-height: 100%;\n      background-repeat: no-repeat;\n      background-position: var(--media-poster-image-background-position, var(--media-object-position, center));\n      background-size: var(--media-poster-image-background-size, var(--media-object-fit, contain));\n      object-fit: var(--media-object-fit, contain);\n      object-position: var(--media-object-position, center);\n    }\n  </style>\n\n  <img aria-hidden=\"true\" id=\"image\"/>\n`;\nconst unsetBackgroundImage = (el) => {\n  el.style.removeProperty(\"background-image\");\n};\nconst setBackgroundImage = (el, image) => {\n  el.style[\"background-image\"] = `url('${image}')`;\n};\nclass MediaPosterImage extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.HTMLElement {\n  static get observedAttributes() {\n    return [Attributes.PLACEHOLDER_SRC, Attributes.SRC];\n  }\n  constructor() {\n    super();\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    this.image = this.shadowRoot.querySelector(\"#image\");\n  }\n  attributeChangedCallback(attrName, _oldValue, newValue) {\n    if (attrName === Attributes.SRC) {\n      if (newValue == null) {\n        this.image.removeAttribute(Attributes.SRC);\n      } else {\n        this.image.setAttribute(Attributes.SRC, newValue);\n      }\n    }\n    if (attrName === Attributes.PLACEHOLDER_SRC) {\n      if (newValue == null) {\n        unsetBackgroundImage(this.image);\n      } else {\n        setBackgroundImage(this.image, newValue);\n      }\n    }\n  }\n  get placeholderSrc() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getStringAttr)(this, Attributes.PLACEHOLDER_SRC);\n  }\n  set placeholderSrc(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setStringAttr)(this, Attributes.SRC, value);\n  }\n  get src() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getStringAttr)(this, Attributes.SRC);\n  }\n  set src(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setStringAttr)(this, Attributes.SRC, value);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.get(\"media-poster-image\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.define(\"media-poster-image\", MediaPosterImage);\n}\nvar media_poster_image_default = MediaPosterImage;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXBvc3Rlci1pbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNFO0FBQ0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0EsK0JBQStCLHFFQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJLHNFQUFhO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXLHNFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJLHNFQUFhO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtcG9zdGVyLWltYWdlLmpzP2I5YmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRTdHJpbmdBdHRyLCBzZXRTdHJpbmdBdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgQXR0cmlidXRlcyA9IHtcbiAgUExBQ0VIT0xERVJfU1JDOiBcInBsYWNlaG9sZGVyc3JjXCIsXG4gIFNSQzogXCJzcmNcIlxufTtcbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICBkaXNwbGF5OiB2YXIoLS1tZWRpYS1wb3N0ZXItaW1hZ2UtZGlzcGxheSwgaW5saW5lLWJsb2NrKTtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuXG4gICAgaW1nIHtcbiAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gICAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgICBtaW4taGVpZ2h0OiAxMDAlO1xuICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IHZhcigtLW1lZGlhLXBvc3Rlci1pbWFnZS1iYWNrZ3JvdW5kLXBvc2l0aW9uLCB2YXIoLS1tZWRpYS1vYmplY3QtcG9zaXRpb24sIGNlbnRlcikpO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiB2YXIoLS1tZWRpYS1wb3N0ZXItaW1hZ2UtYmFja2dyb3VuZC1zaXplLCB2YXIoLS1tZWRpYS1vYmplY3QtZml0LCBjb250YWluKSk7XG4gICAgICBvYmplY3QtZml0OiB2YXIoLS1tZWRpYS1vYmplY3QtZml0LCBjb250YWluKTtcbiAgICAgIG9iamVjdC1wb3NpdGlvbjogdmFyKC0tbWVkaWEtb2JqZWN0LXBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIH1cbiAgPC9zdHlsZT5cblxuICA8aW1nIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGlkPVwiaW1hZ2VcIi8+XG5gO1xuY29uc3QgdW5zZXRCYWNrZ3JvdW5kSW1hZ2UgPSAoZWwpID0+IHtcbiAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJiYWNrZ3JvdW5kLWltYWdlXCIpO1xufTtcbmNvbnN0IHNldEJhY2tncm91bmRJbWFnZSA9IChlbCwgaW1hZ2UpID0+IHtcbiAgZWwuc3R5bGVbXCJiYWNrZ3JvdW5kLWltYWdlXCJdID0gYHVybCgnJHtpbWFnZX0nKWA7XG59O1xuY2xhc3MgTWVkaWFQb3N0ZXJJbWFnZSBleHRlbmRzIGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW0F0dHJpYnV0ZXMuUExBQ0VIT0xERVJfU1JDLCBBdHRyaWJ1dGVzLlNSQ107XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICAgIHRoaXMuaW1hZ2UgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNpbWFnZVwiKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuU1JDKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmltYWdlLnJlbW92ZUF0dHJpYnV0ZShBdHRyaWJ1dGVzLlNSQyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlLnNldEF0dHJpYnV0ZShBdHRyaWJ1dGVzLlNSQywgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuUExBQ0VIT0xERVJfU1JDKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB1bnNldEJhY2tncm91bmRJbWFnZSh0aGlzLmltYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJhY2tncm91bmRJbWFnZSh0aGlzLmltYWdlLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwbGFjZWhvbGRlclNyYygpIHtcbiAgICByZXR1cm4gZ2V0U3RyaW5nQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlBMQUNFSE9MREVSX1NSQyk7XG4gIH1cbiAgc2V0IHBsYWNlaG9sZGVyU3JjKHZhbHVlKSB7XG4gICAgc2V0U3RyaW5nQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlNSQywgdmFsdWUpO1xuICB9XG4gIGdldCBzcmMoKSB7XG4gICAgcmV0dXJuIGdldFN0cmluZ0F0dHIodGhpcywgQXR0cmlidXRlcy5TUkMpO1xuICB9XG4gIHNldCBzcmModmFsdWUpIHtcbiAgICBzZXRTdHJpbmdBdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU1JDLCB2YWx1ZSk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1wb3N0ZXItaW1hZ2VcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS1wb3N0ZXItaW1hZ2VcIiwgTWVkaWFQb3N0ZXJJbWFnZSk7XG59XG52YXIgbWVkaWFfcG9zdGVyX2ltYWdlX2RlZmF1bHQgPSBNZWRpYVBvc3RlckltYWdlO1xuZXhwb3J0IHtcbiAgQXR0cmlidXRlcyxcbiAgbWVkaWFfcG9zdGVyX2ltYWdlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-poster-image.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-preview-thumbnail.js":
/*!*******************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-preview-thumbnail.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_preview_thumbnail_default; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      box-sizing: border-box;\n      display: var(--media-control-display, var(--media-preview-thumbnail-display, inline-block));\n      overflow: hidden;\n    }\n\n    img {\n      display: none;\n      position: relative;\n    }\n  </style>\n  <img crossorigin loading=\"eager\" decoding=\"async\">\n`;\nclass MediaPreviewThumbnail extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n  }\n  static get observedAttributes() {\n    return [\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateReceiverAttributes.MEDIA_CONTROLLER,\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_COORDS\n    ];\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if ([\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_COORDS\n    ].includes(attrName)) {\n      this.update();\n    }\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    }\n  }\n  get mediaPreviewImage() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE);\n  }\n  set mediaPreviewImage(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE, value);\n  }\n  get mediaPreviewCoords() {\n    const attrVal = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_COORDS);\n    if (!attrVal)\n      return void 0;\n    return attrVal.split(/\\s+/).map((coord) => +coord);\n  }\n  set mediaPreviewCoords(value) {\n    if (!value) {\n      this.removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_COORDS);\n      return;\n    }\n    this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_PREVIEW_COORDS, value.join(\" \"));\n  }\n  update() {\n    const coords = this.mediaPreviewCoords;\n    const previewImage = this.mediaPreviewImage;\n    if (!(coords && previewImage))\n      return;\n    const [x, y, w, h] = coords;\n    const src = previewImage.split(\"#\")[0];\n    const computedStyle = getComputedStyle(this);\n    const { maxWidth, maxHeight, minWidth, minHeight } = computedStyle;\n    const maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h);\n    const minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h);\n    const isScalingDown = maxRatio < 1;\n    const scale = isScalingDown ? maxRatio : minRatio > 1 ? minRatio : 1;\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    const imgStyle = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_2__.getOrInsertCSSRule)(this.shadowRoot, \"img\").style;\n    const img = this.shadowRoot.querySelector(\"img\");\n    const extremum = isScalingDown ? \"min\" : \"max\";\n    style.setProperty(`${extremum}-width`, \"initial\", \"important\");\n    style.setProperty(`${extremum}-height`, \"initial\", \"important\");\n    style.width = `${w * scale}px`;\n    style.height = `${h * scale}px`;\n    const resize = () => {\n      imgStyle.width = `${this.imgWidth * scale}px`;\n      imgStyle.height = `${this.imgHeight * scale}px`;\n      imgStyle.display = \"block\";\n    };\n    if (img.src !== src) {\n      img.onload = () => {\n        this.imgWidth = img.naturalWidth;\n        this.imgHeight = img.naturalHeight;\n        resize();\n      };\n      img.src = src;\n      resize();\n    }\n    resize();\n    imgStyle.transform = `translate(-${x * scale}px, -${y * scale}px)`;\n  }\n}\n_mediaController = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.get(\"media-preview-thumbnail\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.define(\n    \"media-preview-thumbnail\",\n    MediaPreviewThumbnail\n  );\n}\nvar media_preview_thumbnail_default = MediaPreviewThumbnail;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXByZXZpZXctdGh1bWJuYWlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRTtBQUk5QztBQUtVO0FBQ2xDLGlCQUFpQixtRUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxRUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQyxNQUFNLDREQUFpQjtBQUN2QixNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLHNDQUFzQyw0REFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFpQjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLDREQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxFQUFFLDJFQUFrQjtBQUN4QyxxQkFBcUIsMkVBQWtCO0FBQ3ZDO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsU0FBUztBQUNsQyxxQkFBcUIsVUFBVTtBQUMvQixzQkFBc0IsVUFBVTtBQUNoQztBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSxPQUFPLFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXByZXZpZXctdGh1bWJuYWlsLmpzPzU5M2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX21lZGlhQ29udHJvbGxlcjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHtcbiAgTWVkaWFVSUF0dHJpYnV0ZXMsXG4gIE1lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXNcbn0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICBnZXRPckluc2VydENTU1J1bGUsXG4gIGdldFN0cmluZ0F0dHIsXG4gIHNldFN0cmluZ0F0dHJcbn0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgZGlzcGxheTogdmFyKC0tbWVkaWEtY29udHJvbC1kaXNwbGF5LCB2YXIoLS1tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC1kaXNwbGF5LCBpbmxpbmUtYmxvY2spKTtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgaW1nIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICA8L3N0eWxlPlxuICA8aW1nIGNyb3Nzb3JpZ2luIGxvYWRpbmc9XCJlYWdlclwiIGRlY29kaW5nPVwiYXN5bmNcIj5cbmA7XG5jbGFzcyBNZWRpYVByZXZpZXdUaHVtYm5haWwgZXh0ZW5kcyBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lZGlhQ29udHJvbGxlciwgdm9pZCAwKTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVIsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0lNQUdFLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19DT09SRFNcbiAgICBdO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG1lZGlhQ29udHJvbGxlcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICBNZWRpYVN0YXRlUmVjZWl2ZXJBdHRyaWJ1dGVzLk1FRElBX0NPTlRST0xMRVJcbiAgICApO1xuICAgIGlmIChtZWRpYUNvbnRyb2xsZXJJZCkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIChfYSA9IHRoaXMuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnRCeUlkKG1lZGlhQ29udHJvbGxlcklkKSk7XG4gICAgICAoX2MgPSAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhQ29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChfYiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIsIG51bGwpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoW1xuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRSxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfQ09PUkRTXG4gICAgXS5pbmNsdWRlcyhhdHRyTmFtZSkpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKSB7XG4gICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgKF9jID0gdGhpcy5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZ2V0RWxlbWVudEJ5SWQobmV3VmFsdWUpKTtcbiAgICAgICAgKF9lID0gKF9kID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2QuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFQcmV2aWV3SW1hZ2UoKSB7XG4gICAgcmV0dXJuIGdldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRSk7XG4gIH1cbiAgc2V0IG1lZGlhUHJldmlld0ltYWdlKHZhbHVlKSB7XG4gICAgc2V0U3RyaW5nQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0lNQUdFLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhUHJldmlld0Nvb3JkcygpIHtcbiAgICBjb25zdCBhdHRyVmFsID0gdGhpcy5nZXRBdHRyaWJ1dGUoTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19DT09SRFMpO1xuICAgIGlmICghYXR0clZhbClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIGF0dHJWYWwuc3BsaXQoL1xccysvKS5tYXAoKGNvb3JkKSA9PiArY29vcmQpO1xuICB9XG4gIHNldCBtZWRpYVByZXZpZXdDb29yZHModmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0NPT1JEUyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfQ09PUkRTLCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMubWVkaWFQcmV2aWV3Q29vcmRzO1xuICAgIGNvbnN0IHByZXZpZXdJbWFnZSA9IHRoaXMubWVkaWFQcmV2aWV3SW1hZ2U7XG4gICAgaWYgKCEoY29vcmRzICYmIHByZXZpZXdJbWFnZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW3gsIHksIHcsIGhdID0gY29vcmRzO1xuICAgIGNvbnN0IHNyYyA9IHByZXZpZXdJbWFnZS5zcGxpdChcIiNcIilbMF07XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgY29uc3QgeyBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtaW5XaWR0aCwgbWluSGVpZ2h0IH0gPSBjb21wdXRlZFN0eWxlO1xuICAgIGNvbnN0IG1heFJhdGlvID0gTWF0aC5taW4ocGFyc2VJbnQobWF4V2lkdGgpIC8gdywgcGFyc2VJbnQobWF4SGVpZ2h0KSAvIGgpO1xuICAgIGNvbnN0IG1pblJhdGlvID0gTWF0aC5tYXgocGFyc2VJbnQobWluV2lkdGgpIC8gdywgcGFyc2VJbnQobWluSGVpZ2h0KSAvIGgpO1xuICAgIGNvbnN0IGlzU2NhbGluZ0Rvd24gPSBtYXhSYXRpbyA8IDE7XG4gICAgY29uc3Qgc2NhbGUgPSBpc1NjYWxpbmdEb3duID8gbWF4UmF0aW8gOiBtaW5SYXRpbyA+IDEgPyBtaW5SYXRpbyA6IDE7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdFwiKTtcbiAgICBjb25zdCBpbWdTdHlsZSA9IGdldE9ySW5zZXJ0Q1NTUnVsZSh0aGlzLnNoYWRvd1Jvb3QsIFwiaW1nXCIpLnN0eWxlO1xuICAgIGNvbnN0IGltZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpO1xuICAgIGNvbnN0IGV4dHJlbXVtID0gaXNTY2FsaW5nRG93biA/IFwibWluXCIgOiBcIm1heFwiO1xuICAgIHN0eWxlLnNldFByb3BlcnR5KGAke2V4dHJlbXVtfS13aWR0aGAsIFwiaW5pdGlhbFwiLCBcImltcG9ydGFudFwiKTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShgJHtleHRyZW11bX0taGVpZ2h0YCwgXCJpbml0aWFsXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgIHN0eWxlLndpZHRoID0gYCR7dyAqIHNjYWxlfXB4YDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHtoICogc2NhbGV9cHhgO1xuICAgIGNvbnN0IHJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGltZ1N0eWxlLndpZHRoID0gYCR7dGhpcy5pbWdXaWR0aCAqIHNjYWxlfXB4YDtcbiAgICAgIGltZ1N0eWxlLmhlaWdodCA9IGAke3RoaXMuaW1nSGVpZ2h0ICogc2NhbGV9cHhgO1xuICAgICAgaW1nU3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIGlmIChpbWcuc3JjICE9PSBzcmMpIHtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuaW1nV2lkdGggPSBpbWcubmF0dXJhbFdpZHRoO1xuICAgICAgICB0aGlzLmltZ0hlaWdodCA9IGltZy5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICByZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICAgIHJlc2l6ZSgpO1xuICAgIGltZ1N0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLSR7eCAqIHNjYWxlfXB4LCAtJHt5ICogc2NhbGV9cHgpYDtcbiAgfVxufVxuX21lZGlhQ29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtcHJldmlldy10aHVtYm5haWxcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICAgXCJtZWRpYS1wcmV2aWV3LXRodW1ibmFpbFwiLFxuICAgIE1lZGlhUHJldmlld1RodW1ibmFpbFxuICApO1xufVxudmFyIG1lZGlhX3ByZXZpZXdfdGh1bWJuYWlsX2RlZmF1bHQgPSBNZWRpYVByZXZpZXdUaHVtYm5haWw7XG5leHBvcnQge1xuICBtZWRpYV9wcmV2aWV3X3RodW1ibmFpbF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-preview-thumbnail.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-preview-time-display.js":
/*!**********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-preview-time-display.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_preview_time_display_default; }\n/* harmony export */ });\n/* harmony import */ var _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-text-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-text-display.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_time_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/time.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/time.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _slot;\n\n\n\n\n\nclass MediaPreviewTimeDisplay extends _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__.MediaTextDisplay {\n  constructor() {\n    super();\n    __privateAdd(this, _slot, void 0);\n    __privateSet(this, _slot, this.shadowRoot.querySelector(\"slot\"));\n    __privateGet(this, _slot).textContent = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_2__.formatTime)(0);\n  }\n  static get observedAttributes() {\n    return [...super.observedAttributes, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_PREVIEW_TIME];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_PREVIEW_TIME && newValue != null) {\n      __privateGet(this, _slot).textContent = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_2__.formatTime)(newValue);\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaPreviewTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_PREVIEW_TIME);\n  }\n  set mediaPreviewTime(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_3__.MediaUIAttributes.MEDIA_PREVIEW_TIME, value);\n  }\n}\n_slot = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-preview-time-display\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\n    \"media-preview-time-display\",\n    MediaPreviewTimeDisplay\n  );\n}\nvar media_preview_time_display_default = MediaPreviewTimeDisplay;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBQ0M7QUFDZjtBQUNNO0FBQ3VCO0FBQzFFLHNDQUFzQyxvRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQVU7QUFDdEQ7QUFDQTtBQUNBLHlDQUF5Qyw0REFBaUI7QUFDMUQ7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEMsOENBQThDLDBEQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1RUFBYyxPQUFPLDREQUFpQjtBQUNqRDtBQUNBO0FBQ0EsSUFBSSx1RUFBYyxPQUFPLDREQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtcHJldmlldy10aW1lLWRpc3BsYXkuanM/ZWRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfc2xvdDtcbmltcG9ydCB7IE1lZGlhVGV4dERpc3BsYXkgfSBmcm9tIFwiLi9tZWRpYS10ZXh0LWRpc3BsYXkuanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRUaW1lIH0gZnJvbSBcIi4vdXRpbHMvdGltZS5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGdldE51bWVyaWNBdHRyLCBzZXROdW1lcmljQXR0ciB9IGZyb20gXCIuL3V0aWxzL2VsZW1lbnQtdXRpbHMuanNcIjtcbmNsYXNzIE1lZGlhUHJldmlld1RpbWVEaXNwbGF5IGV4dGVuZHMgTWVkaWFUZXh0RGlzcGxheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zbG90LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2xvdCwgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzbG90XCIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nsb3QpLnRleHRDb250ZW50ID0gZm9ybWF0VGltZSgwKTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19USU1FXTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19USU1FICYmIG5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2xvdCkudGV4dENvbnRlbnQgPSBmb3JtYXRUaW1lKG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYVByZXZpZXdUaW1lKCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX1RJTUUpO1xuICB9XG4gIHNldCBtZWRpYVByZXZpZXdUaW1lKHZhbHVlKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19USU1FLCB2YWx1ZSk7XG4gIH1cbn1cbl9zbG90ID0gbmV3IFdlYWtNYXAoKTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS1wcmV2aWV3LXRpbWUtZGlzcGxheVwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcIm1lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5XCIsXG4gICAgTWVkaWFQcmV2aWV3VGltZURpc3BsYXlcbiAgKTtcbn1cbnZhciBtZWRpYV9wcmV2aWV3X3RpbWVfZGlzcGxheV9kZWZhdWx0ID0gTWVkaWFQcmV2aWV3VGltZURpc3BsYXk7XG5leHBvcnQge1xuICBtZWRpYV9wcmV2aWV3X3RpbWVfZGlzcGxheV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-preview-time-display.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-seek-backward-button.js":
/*!**********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-seek-backward-button.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_seek_backward_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n\n\n\n\n\n\nconst Attributes = {\n  SEEK_OFFSET: \"seekoffset\"\n};\nconst DEFAULT_SEEK_OFFSET = 30;\nconst backwardIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 20 24\"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class=\"text value\" transform=\"translate(2.18 19.87)\">${DEFAULT_SEEK_OFFSET}</text><path d=\"M10 6V3L4.37 7 10 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 10 6Z\"/></svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <slot name=\"icon\">${backwardIcon}</slot>\n`;\nconst DEFAULT_TIME = 0;\nclass MediaSeekBackwardButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME,\n      Attributes.SEEK_OFFSET\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n    this.seekOffset = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n  }\n  attributeChangedCallback(attrName, _oldValue, newValue) {\n    if (attrName === Attributes.SEEK_OFFSET) {\n      this.seekOffset = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n    }\n    super.attributeChangedCallback(attrName, _oldValue, newValue);\n  }\n  get seekOffset() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n  }\n  set seekOffset(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setNumericAttr)(this, Attributes.SEEK_OFFSET, value);\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_4__.verbs.SEEK_BACK_N_SECS({ seekOffset: this.seekOffset }));\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.updateIconText)((0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getSlotted)(this, \"icon\"), this.seekOffset);\n  }\n  get mediaCurrentTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME, DEFAULT_TIME);\n  }\n  set mediaCurrentTime(time) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME, time);\n  }\n  handleClick() {\n    const detail = Math.max(this.mediaCurrentTime - this.seekOffset, 0);\n    const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_SEEK_REQUEST, {\n      composed: true,\n      bubbles: true,\n      detail\n    });\n    this.dispatchEvent(evt);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-seek-backward-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\n    \"media-seek-backward-button\",\n    MediaSeekBackwardButton\n  );\n}\nvar media_seek_backward_button_default = MediaSeekBackwardButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkQ7QUFDUztBQUNKO0FBQ1E7QUFDL0I7QUFDMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsY0FBYyxnQ0FBZ0MsaUJBQWlCLDRFQUE0RSxvQkFBb0I7QUFDcFAscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLHNDQUFzQyxzRUFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVksMEJBQTBCO0FBQ3RDLHNCQUFzQix1RUFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUVBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVFQUFjO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLHVFQUFjO0FBQ2xCLG9DQUFvQyxvREFBSyxvQkFBb0IsNkJBQTZCO0FBQzFGLElBQUksdUVBQWMsQ0FBQyxtRUFBVTtBQUM3QjtBQUNBO0FBQ0EsV0FBVyx1RUFBYyxPQUFPLDREQUFpQjtBQUNqRDtBQUNBO0FBQ0EsSUFBSSx1RUFBYyxPQUFPLDREQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUVBQVUsYUFBYSx3REFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uLmpzP2E1N2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVkaWFDaHJvbWVCdXR0b24gfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtYnV0dG9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzLCBkb2N1bWVudCB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1lcmljQXR0ciwgc2V0TnVtZXJpY0F0dHIgfSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJicyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmltcG9ydCB7IGdldFNsb3R0ZWQsIHVwZGF0ZUljb25UZXh0IH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgQXR0cmlidXRlcyA9IHtcbiAgU0VFS19PRkZTRVQ6IFwic2Vla29mZnNldFwiXG59O1xuY29uc3QgREVGQVVMVF9TRUVLX09GRlNFVCA9IDMwO1xuY29uc3QgYmFja3dhcmRJY29uID0gYDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyMCAyNFwiPjxkZWZzPjxzdHlsZT4udGV4dHtmb250LXNpemU6OHB4O2ZvbnQtZmFtaWx5OkFyaWFsLUJvbGRNVCwgQXJpYWw7Zm9udC13ZWlnaHQ6NzAwO308L3N0eWxlPjwvZGVmcz48dGV4dCBjbGFzcz1cInRleHQgdmFsdWVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMi4xOCAxOS44NylcIj4ke0RFRkFVTFRfU0VFS19PRkZTRVR9PC90ZXh0PjxwYXRoIGQ9XCJNMTAgNlYzTDQuMzcgNyAxMCAxMC45NFY4YTUuNTQgNS41NCAwIDAgMSAxLjkgMTAuNDh2Mi4xMkE3LjUgNy41IDAgMCAwIDEwIDZaXCIvPjwvc3ZnPmA7XG5jb25zdCBzbG90VGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5zbG90VGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c2xvdCBuYW1lPVwiaWNvblwiPiR7YmFja3dhcmRJY29ufTwvc2xvdD5cbmA7XG5jb25zdCBERUZBVUxUX1RJTUUgPSAwO1xuY2xhc3MgTWVkaWFTZWVrQmFja3dhcmRCdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9DVVJSRU5UX1RJTUUsXG4gICAgICBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VUXG4gICAgXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7IHNsb3RUZW1wbGF0ZSwgLi4ub3B0aW9ucyB9KTtcbiAgICB0aGlzLnNlZWtPZmZzZXQgPSBnZXROdW1lcmljQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VULCBERUZBVUxUX1NFRUtfT0ZGU0VUKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQpIHtcbiAgICAgIHRoaXMuc2Vla09mZnNldCA9IGdldE51bWVyaWNBdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQsIERFRkFVTFRfU0VFS19PRkZTRVQpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBzZWVrT2Zmc2V0KCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VULCBERUZBVUxUX1NFRUtfT0ZGU0VUKTtcbiAgfVxuICBzZXQgc2Vla09mZnNldCh2YWx1ZSkge1xuICAgIHNldE51bWVyaWNBdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQsIHZhbHVlKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdmVyYnMuU0VFS19CQUNLX05fU0VDUyh7IHNlZWtPZmZzZXQ6IHRoaXMuc2Vla09mZnNldCB9KSk7XG4gICAgdXBkYXRlSWNvblRleHQoZ2V0U2xvdHRlZCh0aGlzLCBcImljb25cIiksIHRoaXMuc2Vla09mZnNldCk7XG4gIH1cbiAgZ2V0IG1lZGlhQ3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIGdldE51bWVyaWNBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSwgREVGQVVMVF9USU1FKTtcbiAgfVxuICBzZXQgbWVkaWFDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ1VSUkVOVF9USU1FLCB0aW1lKTtcbiAgfVxuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBkZXRhaWwgPSBNYXRoLm1heCh0aGlzLm1lZGlhQ3VycmVudFRpbWUgLSB0aGlzLnNlZWtPZmZzZXQsIDApO1xuICAgIGNvbnN0IGV2dCA9IG5ldyBnbG9iYWxUaGlzLkN1c3RvbUV2ZW50KE1lZGlhVUlFdmVudHMuTUVESUFfU0VFS19SRVFVRVNULCB7XG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBkZXRhaWxcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuaWYgKCFnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmdldChcIm1lZGlhLXNlZWstYmFja3dhcmQtYnV0dG9uXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFxuICAgIFwibWVkaWEtc2Vlay1iYWNrd2FyZC1idXR0b25cIixcbiAgICBNZWRpYVNlZWtCYWNrd2FyZEJ1dHRvblxuICApO1xufVxudmFyIG1lZGlhX3NlZWtfYmFja3dhcmRfYnV0dG9uX2RlZmF1bHQgPSBNZWRpYVNlZWtCYWNrd2FyZEJ1dHRvbjtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZXMsXG4gIG1lZGlhX3NlZWtfYmFja3dhcmRfYnV0dG9uX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-seek-backward-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-seek-forward-button.js":
/*!*********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-seek-forward-button.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_seek_forward_button_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-button.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-button.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n\n\n\n\n\n\nconst Attributes = {\n  SEEK_OFFSET: \"seekoffset\"\n};\nconst DEFAULT_SEEK_OFFSET = 30;\nconst forwardIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 20 24\"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class=\"text value\" transform=\"translate(8.9 19.87)\">${DEFAULT_SEEK_OFFSET}</text><path d=\"M10 6V3l5.61 4L10 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 10 6Z\"/></svg>`;\nconst slotTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\nslotTemplate.innerHTML = `\n  <slot name=\"icon\">${forwardIcon}</slot>\n`;\nconst DEFAULT_TIME = 0;\nclass MediaSeekForwardButton extends _media_chrome_button_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeButton {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME,\n      Attributes.SEEK_OFFSET\n    ];\n  }\n  constructor(options = {}) {\n    super({ slotTemplate, ...options });\n    this.seekOffset = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n  }\n  attributeChangedCallback(attrName, _oldValue, newValue) {\n    if (attrName === Attributes.SEEK_OFFSET) {\n      this.seekOffset = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n    }\n    super.attributeChangedCallback(attrName, _oldValue, newValue);\n  }\n  get seekOffset() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, Attributes.SEEK_OFFSET, DEFAULT_SEEK_OFFSET);\n  }\n  set seekOffset(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setNumericAttr)(this, Attributes.SEEK_OFFSET, value);\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_4__.verbs.SEEK_FORWARD_N_SECS({ seekOffset: this.seekOffset }));\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.updateIconText)((0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getSlotted)(this, \"icon\"), this.seekOffset);\n  }\n  get mediaCurrentTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME, DEFAULT_TIME);\n  }\n  set mediaCurrentTime(time) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_3__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME, time);\n  }\n  handleClick() {\n    const detail = this.mediaCurrentTime + this.seekOffset;\n    const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_SEEK_REQUEST, {\n      composed: true,\n      bubbles: true,\n      detail\n    });\n    this.dispatchEvent(evt);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-seek-forward-button\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\n    \"media-seek-forward-button\",\n    MediaSeekForwardButton\n  );\n}\nvar media_seek_forward_button_default = MediaSeekForwardButton;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXNlZWstZm9yd2FyZC1idXR0b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2RDtBQUNTO0FBQ0o7QUFDUTtBQUMvQjtBQUMyQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjLGdDQUFnQyxpQkFBaUIsMkVBQTJFLG9CQUFvQjtBQUNsUCxxQkFBcUIsbUVBQVE7QUFDN0I7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EscUNBQXFDLHNFQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLHVFQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1RUFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWM7QUFDekI7QUFDQTtBQUNBLElBQUksdUVBQWM7QUFDbEIsb0NBQW9DLG9EQUFLLHVCQUF1Qiw2QkFBNkI7QUFDN0YsSUFBSSx1RUFBYyxDQUFDLG1FQUFVO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxRUFBVSxhQUFhLHdEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvbWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvbi5qcz9hZTI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lZGlhQ2hyb21lQnV0dG9uIH0gZnJvbSBcIi4vbWVkaWEtY2hyb21lLWJ1dHRvbi5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBNZWRpYVVJRXZlbnRzLCBNZWRpYVVJQXR0cmlidXRlcyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0TnVtZXJpY0F0dHIsIHNldE51bWVyaWNBdHRyIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyYnMgfSBmcm9tIFwiLi9sYWJlbHMvbGFiZWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRTbG90dGVkLCB1cGRhdGVJY29uVGV4dCB9IGZyb20gXCIuL3V0aWxzL2VsZW1lbnQtdXRpbHMuanNcIjtcbmNvbnN0IEF0dHJpYnV0ZXMgPSB7XG4gIFNFRUtfT0ZGU0VUOiBcInNlZWtvZmZzZXRcIlxufTtcbmNvbnN0IERFRkFVTFRfU0VFS19PRkZTRVQgPSAzMDtcbmNvbnN0IGZvcndhcmRJY29uID0gYDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdmlld0JveD1cIjAgMCAyMCAyNFwiPjxkZWZzPjxzdHlsZT4udGV4dHtmb250LXNpemU6OHB4O2ZvbnQtZmFtaWx5OkFyaWFsLUJvbGRNVCwgQXJpYWw7Zm9udC13ZWlnaHQ6NzAwO308L3N0eWxlPjwvZGVmcz48dGV4dCBjbGFzcz1cInRleHQgdmFsdWVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoOC45IDE5Ljg3KVwiPiR7REVGQVVMVF9TRUVLX09GRlNFVH08L3RleHQ+PHBhdGggZD1cIk0xMCA2VjNsNS42MSA0TDEwIDEwLjk0VjhhNS41NCA1LjU0IDAgMCAwLTEuOSAxMC40OHYyLjEyQTcuNSA3LjUgMCAwIDEgMTAgNlpcIi8+PC9zdmc+YDtcbmNvbnN0IHNsb3RUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnNsb3RUZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzbG90IG5hbWU9XCJpY29uXCI+JHtmb3J3YXJkSWNvbn08L3Nsb3Q+XG5gO1xuY29uc3QgREVGQVVMVF9USU1FID0gMDtcbmNsYXNzIE1lZGlhU2Vla0ZvcndhcmRCdXR0b24gZXh0ZW5kcyBNZWRpYUNocm9tZUJ1dHRvbiB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9DVVJSRU5UX1RJTUUsXG4gICAgICBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VUXG4gICAgXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7IHNsb3RUZW1wbGF0ZSwgLi4ub3B0aW9ucyB9KTtcbiAgICB0aGlzLnNlZWtPZmZzZXQgPSBnZXROdW1lcmljQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VULCBERUZBVUxUX1NFRUtfT0ZGU0VUKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT09IEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQpIHtcbiAgICAgIHRoaXMuc2Vla09mZnNldCA9IGdldE51bWVyaWNBdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQsIERFRkFVTFRfU0VFS19PRkZTRVQpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBzZWVrT2Zmc2V0KCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlNFRUtfT0ZGU0VULCBERUZBVUxUX1NFRUtfT0ZGU0VUKTtcbiAgfVxuICBzZXQgc2Vla09mZnNldCh2YWx1ZSkge1xuICAgIHNldE51bWVyaWNBdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU0VFS19PRkZTRVQsIHZhbHVlKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdmVyYnMuU0VFS19GT1JXQVJEX05fU0VDUyh7IHNlZWtPZmZzZXQ6IHRoaXMuc2Vla09mZnNldCB9KSk7XG4gICAgdXBkYXRlSWNvblRleHQoZ2V0U2xvdHRlZCh0aGlzLCBcImljb25cIiksIHRoaXMuc2Vla09mZnNldCk7XG4gIH1cbiAgZ2V0IG1lZGlhQ3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIGdldE51bWVyaWNBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSwgREVGQVVMVF9USU1FKTtcbiAgfVxuICBzZXQgbWVkaWFDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ1VSUkVOVF9USU1FLCB0aW1lKTtcbiAgfVxuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBkZXRhaWwgPSB0aGlzLm1lZGlhQ3VycmVudFRpbWUgKyB0aGlzLnNlZWtPZmZzZXQ7XG4gICAgY29uc3QgZXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoTWVkaWFVSUV2ZW50cy5NRURJQV9TRUVLX1JFUVVFU1QsIHtcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGRldGFpbFxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvblwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcIm1lZGlhLXNlZWstZm9yd2FyZC1idXR0b25cIixcbiAgICBNZWRpYVNlZWtGb3J3YXJkQnV0dG9uXG4gICk7XG59XG52YXIgbWVkaWFfc2Vla19mb3J3YXJkX2J1dHRvbl9kZWZhdWx0ID0gTWVkaWFTZWVrRm9yd2FyZEJ1dHRvbjtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZXMsXG4gIG1lZGlhX3NlZWtfZm9yd2FyZF9idXR0b25fZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-seek-forward-button.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-text-display.js":
/*!**************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-text-display.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaTextDisplay: function() { return /* binding */ MediaTextDisplay; },\n/* harmony export */   \"default\": function() { return /* binding */ media_text_display_default; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _mediaController;\n\n\n\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      font: var(--media-font,\n        var(--media-font-weight, normal)\n        var(--media-font-size, 14px) /\n        var(--media-text-content-height, var(--media-control-height, 24px))\n        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      background: var(--media-text-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7))));\n      padding: var(--media-control-padding, 10px);\n      display: inline-flex;\n      justify-content: center;\n      align-items: center;\n      vertical-align: middle;\n      box-sizing: border-box;\n      text-align: center;\n      pointer-events: auto;\n    }\n\n    ${\"\"}\n    :host(:focus-visible) {\n      box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);\n      outline: 0;\n    }\n\n    ${\"\"}\n    :host(:where(:focus)) {\n      box-shadow: none;\n      outline: 0;\n    }\n  </style>\n  <slot></slot>\n`;\nclass MediaTextDisplay extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _mediaController, void 0);\n    if (!this.shadowRoot) {\n      this.attachShadow({ mode: \"open\" });\n      this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOrInsertCSSRule)(this.shadowRoot, \":host\");\n    style.setProperty(\"display\", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`);\n  }\n  static get observedAttributes() {\n    return [_constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER];\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {\n      if (oldValue) {\n        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n        __privateSet(this, _mediaController, null);\n      }\n      if (newValue) {\n        __privateSet(this, _mediaController, (_c = this.getRootNode()) == null ? void 0 : _c.getElementById(newValue));\n        (_e = (_d = __privateGet(this, _mediaController)) == null ? void 0 : _d.associateElement) == null ? void 0 : _e.call(_d, this);\n      }\n    }\n  }\n  connectedCallback() {\n    var _a, _b, _c;\n    const mediaControllerId = this.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_0__.MediaStateReceiverAttributes.MEDIA_CONTROLLER\n    );\n    if (mediaControllerId) {\n      __privateSet(this, _mediaController, (_a = this.getRootNode()) == null ? void 0 : _a.getElementById(mediaControllerId));\n      (_c = (_b = __privateGet(this, _mediaController)) == null ? void 0 : _b.associateElement) == null ? void 0 : _c.call(_b, this);\n    }\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);\n    __privateSet(this, _mediaController, null);\n  }\n}\n_mediaController = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-text-display\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-text-display\", MediaTextDisplay);\n}\nvar media_text_display_default = MediaTextDisplay;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRleHQtZGlzcGxheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhEO0FBQ0E7QUFDUTtBQUN0RSxpQkFBaUIsbUVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSwyRUFBa0I7QUFDeEMsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBLFlBQVksdUVBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RUFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS10ZXh0LWRpc3BsYXkuanM/OGQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfbWVkaWFDb250cm9sbGVyO1xuaW1wb3J0IHsgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0T3JJbnNlcnRDU1NSdWxlIH0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbiAgPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgIGZvbnQ6IHZhcigtLW1lZGlhLWZvbnQsXG4gICAgICAgIHZhcigtLW1lZGlhLWZvbnQtd2VpZ2h0LCBub3JtYWwpXG4gICAgICAgIHZhcigtLW1lZGlhLWZvbnQtc2l6ZSwgMTRweCkgL1xuICAgICAgICB2YXIoLS1tZWRpYS10ZXh0LWNvbnRlbnQtaGVpZ2h0LCB2YXIoLS1tZWRpYS1jb250cm9sLWhlaWdodCwgMjRweCkpXG4gICAgICAgIHZhcigtLW1lZGlhLWZvbnQtZmFtaWx5LCBoZWx2ZXRpY2EgbmV1ZSwgc2Vnb2UgdWksIHJvYm90bywgYXJpYWwsIHNhbnMtc2VyaWYpKTtcbiAgICAgIGNvbG9yOiB2YXIoLS1tZWRpYS10ZXh0LWNvbG9yLCB2YXIoLS1tZWRpYS1wcmltYXJ5LWNvbG9yLCByZ2IoMjM4IDIzOCAyMzgpKSk7XG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS10ZXh0LWJhY2tncm91bmQsIHZhcigtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZCwgdmFyKC0tbWVkaWEtc2Vjb25kYXJ5LWNvbG9yLCByZ2IoMjAgMjAgMzAgLyAuNykpKSk7XG4gICAgICBwYWRkaW5nOiB2YXIoLS1tZWRpYS1jb250cm9sLXBhZGRpbmcsIDEwcHgpO1xuICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgIH1cblxuICAgICR7XCJcIn1cbiAgICA6aG9zdCg6Zm9jdXMtdmlzaWJsZSkge1xuICAgICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMnB4IHJnYigyNyAxMjcgMjA0IC8gLjkpO1xuICAgICAgb3V0bGluZTogMDtcbiAgICB9XG5cbiAgICAke1wiXCJ9XG4gICAgOmhvc3QoOndoZXJlKDpmb2N1cykpIHtcbiAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICBvdXRsaW5lOiAwO1xuICAgIH1cbiAgPC9zdHlsZT5cbiAgPHNsb3Q+PC9zbG90PlxuYDtcbmNsYXNzIE1lZGlhVGV4dERpc3BsYXkgZXh0ZW5kcyBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lZGlhQ29udHJvbGxlciwgdm9pZCAwKTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3R5bGUgfSA9IGdldE9ySW5zZXJ0Q1NTUnVsZSh0aGlzLnNoYWRvd1Jvb3QsIFwiOmhvc3RcIik7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIGB2YXIoLS1tZWRpYS1jb250cm9sLWRpc3BsYXksIHZhcigtLSR7dGhpcy5sb2NhbE5hbWV9LWRpc3BsYXksIGlubGluZS1mbGV4KSlgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW01lZGlhU3RhdGVSZWNlaXZlckF0dHJpYnV0ZXMuTUVESUFfQ09OVFJPTExFUl07XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSKSB7XG4gICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgKF9iID0gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5hc3NvY2lhdGVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcyk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lZGlhQ29udHJvbGxlciwgKF9jID0gdGhpcy5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZ2V0RWxlbWVudEJ5SWQobmV3VmFsdWUpKTtcbiAgICAgICAgKF9lID0gKF9kID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2QuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBtZWRpYUNvbnRyb2xsZXJJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKFxuICAgICAgTWVkaWFTdGF0ZVJlY2VpdmVyQXR0cmlidXRlcy5NRURJQV9DT05UUk9MTEVSXG4gICAgKTtcbiAgICBpZiAobWVkaWFDb250cm9sbGVySWQpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCAoX2EgPSB0aGlzLmdldFJvb3ROb2RlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRFbGVtZW50QnlJZChtZWRpYUNvbnRyb2xsZXJJZCkpO1xuICAgICAgKF9jID0gKF9iID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYUNvbnRyb2xsZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYiA9IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuYXNzb2NpYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVkaWFDb250cm9sbGVyLCBudWxsKTtcbiAgfVxufVxuX21lZGlhQ29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5pZiAoIWdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWVkaWEtdGV4dC1kaXNwbGF5XCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtdGV4dC1kaXNwbGF5XCIsIE1lZGlhVGV4dERpc3BsYXkpO1xufVxudmFyIG1lZGlhX3RleHRfZGlzcGxheV9kZWZhdWx0ID0gTWVkaWFUZXh0RGlzcGxheTtcbmV4cG9ydCB7XG4gIE1lZGlhVGV4dERpc3BsYXksXG4gIG1lZGlhX3RleHRfZGlzcGxheV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-text-display.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-theme-element.js":
/*!***************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-theme-element.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttrPart: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.AttrPart; },\n/* harmony export */   AttrPartList: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.AttrPartList; },\n/* harmony export */   ChildNodePart: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.ChildNodePart; },\n/* harmony export */   InnerTemplatePart: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.InnerTemplatePart; },\n/* harmony export */   MediaThemeElement: function() { return /* binding */ MediaThemeElement; },\n/* harmony export */   Part: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.Part; },\n/* harmony export */   TemplateInstance: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.TemplateInstance; },\n/* harmony export */   defaultProcessor: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.defaultProcessor; },\n/* harmony export */   parse: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.parse; },\n/* harmony export */   tokenize: function() { return /* reexport safe */ _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.tokenize; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/template-parts.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/template-parts.js\");\n/* harmony import */ var _utils_template_processor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/template-processor.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/template-processor.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/utils.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _template, _prevTemplate, _prevTemplateId, _upgradeProperty, upgradeProperty_fn, _updateTemplate, updateTemplate_fn;\n\n\n\n\n\nconst observedMediaAttributes = {\n  mediatargetlivewindow: \"targetlivewindow\",\n  mediastreamtype: \"streamtype\"\n};\nconst prependTemplate = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.createElement(\"template\");\nprependTemplate.innerHTML = `\n  <style>\n    :host {\n      display: inline-block;\n      line-height: 0;\n    }\n\n    media-controller {\n      width: 100%;\n      height: 100%;\n    }\n\n    media-controller:not([mediasubtitleslist]) media-captions-selectmenu,\n    media-captions-button:not([mediasubtitleslist]),\n    media-volume-range[mediavolumeunavailable],\n    media-airplay-button[mediaairplayunavailable],\n    media-fullscreen-button[mediafullscreenunavailable],\n    media-cast-button[mediacastunavailable],\n    media-pip-button[mediapipunavailable] {\n      display: none;\n    }\n  </style>\n`;\nclass MediaThemeElement extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _upgradeProperty);\n    __privateAdd(this, _updateTemplate);\n    __publicField(this, \"renderRoot\");\n    __publicField(this, \"renderer\");\n    __privateAdd(this, _template, void 0);\n    __privateAdd(this, _prevTemplate, void 0);\n    __privateAdd(this, _prevTemplateId, void 0);\n    if (this.shadowRoot) {\n      this.renderRoot = this.shadowRoot;\n    } else {\n      this.renderRoot = this.attachShadow({ mode: \"open\" });\n      this.createRenderer();\n    }\n    const observer = new MutationObserver((mutationList) => {\n      if (mutationList.some((mutation) => {\n        const target = mutation.target;\n        if (target === this)\n          return true;\n        if (target.localName !== \"media-controller\")\n          return false;\n        if (observedMediaAttributes[mutation.attributeName])\n          return true;\n        if (mutation.attributeName.startsWith(\"breakpoint\"))\n          return true;\n        return false;\n      })) {\n        this.render();\n      }\n    });\n    observer.observe(this, { attributes: true });\n    observer.observe(this.renderRoot, {\n      attributes: true,\n      subtree: true\n    });\n    __privateMethod(this, _upgradeProperty, upgradeProperty_fn).call(this, \"template\");\n  }\n  get mediaController() {\n    return this.renderRoot.querySelector(\"media-controller\");\n  }\n  get template() {\n    var _a;\n    return (_a = __privateGet(this, _template)) != null ? _a : this.constructor.template;\n  }\n  set template(element) {\n    __privateSet(this, _prevTemplateId, null);\n    __privateSet(this, _template, element);\n    this.createRenderer();\n  }\n  get props() {\n    var _a, _b, _c;\n    const observedAttributes = [\n      ...Array.from((_b = (_a = this.mediaController) == null ? void 0 : _a.attributes) != null ? _b : []).filter(({ name }) => {\n        return observedMediaAttributes[name] || name.startsWith(\"breakpoint\");\n      }),\n      ...Array.from(this.attributes)\n    ];\n    const props = {};\n    for (let attr of observedAttributes) {\n      const name = (_c = observedMediaAttributes[attr.name]) != null ? _c : (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.camelCase)(attr.name);\n      let { value } = attr;\n      if (value != null) {\n        if ((0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.isNumericString)(value)) {\n          value = parseFloat(value);\n        }\n        props[name] = value === \"\" ? true : value;\n      } else {\n        props[name] = false;\n      }\n    }\n    return props;\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === \"template\" && oldValue != newValue) {\n      __privateMethod(this, _updateTemplate, updateTemplate_fn).call(this);\n    }\n  }\n  connectedCallback() {\n    __privateMethod(this, _updateTemplate, updateTemplate_fn).call(this);\n  }\n  createRenderer() {\n    if (this.template && this.template !== __privateGet(this, _prevTemplate)) {\n      __privateSet(this, _prevTemplate, this.template);\n      this.renderer = new _utils_template_parts_js__WEBPACK_IMPORTED_MODULE_1__.TemplateInstance(\n        this.template,\n        this.props,\n        this.constructor.processor\n      );\n      this.renderRoot.textContent = \"\";\n      this.renderRoot.append(\n        prependTemplate.content.cloneNode(true),\n        this.renderer\n      );\n    }\n  }\n  render() {\n    var _a;\n    (_a = this.renderer) == null ? void 0 : _a.update(this.props);\n  }\n}\n_template = new WeakMap();\n_prevTemplate = new WeakMap();\n_prevTemplateId = new WeakMap();\n_upgradeProperty = new WeakSet();\nupgradeProperty_fn = function(prop) {\n  if (Object.prototype.hasOwnProperty.call(this, prop)) {\n    const value = this[prop];\n    delete this[prop];\n    this[prop] = value;\n  }\n};\n_updateTemplate = new WeakSet();\nupdateTemplate_fn = function() {\n  var _a;\n  const templateId = this.getAttribute(\"template\");\n  if (!templateId || templateId === __privateGet(this, _prevTemplateId))\n    return;\n  const rootNode = this.getRootNode();\n  const template = (_a = rootNode == null ? void 0 : rootNode.getElementById) == null ? void 0 : _a.call(rootNode, templateId);\n  if (template) {\n    __privateSet(this, _prevTemplateId, templateId);\n    __privateSet(this, _template, template);\n    this.createRenderer();\n    return;\n  }\n  if (isValidUrl(templateId)) {\n    __privateSet(this, _prevTemplateId, templateId);\n    request(templateId).then((data) => {\n      const template2 = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.createElement(\"template\");\n      template2.innerHTML = data;\n      __privateSet(this, _template, template2);\n      this.createRenderer();\n    }).catch(console.error);\n  }\n};\n__publicField(MediaThemeElement, \"template\");\n__publicField(MediaThemeElement, \"observedAttributes\", [\"template\"]);\n__publicField(MediaThemeElement, \"processor\", _utils_template_processor_js__WEBPACK_IMPORTED_MODULE_2__.processor);\nfunction isValidUrl(url) {\n  if (!/^(\\/|\\.\\/|https?:\\/\\/)/.test(url))\n    return false;\n  const base = /^https?:\\/\\//.test(url) ? void 0 : location.origin;\n  try {\n    new URL(url, base);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nasync function request(resource) {\n  const response = await fetch(resource);\n  if (response.status !== 200) {\n    throw new Error(`Failed to load resource: the server responded with a status of ${response.status}`);\n  }\n  return response.text();\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.get(\"media-theme\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.define(\"media-theme\", MediaThemeElement);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRoZW1lLWVsZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NFO0FBQ1Q7QUFDSDtBQUNJO0FBQ3BCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFFQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUgsTUFBTTtBQUMzSDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwwREFBUztBQUNyRixZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLGdFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUVBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdCQUFnQjtBQUN0RztBQUNBO0FBQ0E7QUFDQSxLQUFLLHFFQUFVO0FBQ2YsRUFBRSxxRUFBVTtBQUNaO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRoZW1lLWVsZW1lbnQuanM/MjA5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX3RlbXBsYXRlLCBfcHJldlRlbXBsYXRlLCBfcHJldlRlbXBsYXRlSWQsIF91cGdyYWRlUHJvcGVydHksIHVwZ3JhZGVQcm9wZXJ0eV9mbiwgX3VwZGF0ZVRlbXBsYXRlLCB1cGRhdGVUZW1wbGF0ZV9mbjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gXCIuL3V0aWxzL3RlbXBsYXRlLXBhcnRzLmpzXCI7XG5pbXBvcnQgeyBwcm9jZXNzb3IgfSBmcm9tIFwiLi91dGlscy90ZW1wbGF0ZS1wcm9jZXNzb3IuanNcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSwgaXNOdW1lcmljU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3V0aWxzL3RlbXBsYXRlLXBhcnRzLmpzXCI7XG5jb25zdCBvYnNlcnZlZE1lZGlhQXR0cmlidXRlcyA9IHtcbiAgbWVkaWF0YXJnZXRsaXZld2luZG93OiBcInRhcmdldGxpdmV3aW5kb3dcIixcbiAgbWVkaWFzdHJlYW10eXBlOiBcInN0cmVhbXR5cGVcIlxufTtcbmNvbnN0IHByZXBlbmRUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbnByZXBlbmRUZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG4gIDxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICBsaW5lLWhlaWdodDogMDtcbiAgICB9XG5cbiAgICBtZWRpYS1jb250cm9sbGVyIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIG1lZGlhLWNvbnRyb2xsZXI6bm90KFttZWRpYXN1YnRpdGxlc2xpc3RdKSBtZWRpYS1jYXB0aW9ucy1zZWxlY3RtZW51LFxuICAgIG1lZGlhLWNhcHRpb25zLWJ1dHRvbjpub3QoW21lZGlhc3VidGl0bGVzbGlzdF0pLFxuICAgIG1lZGlhLXZvbHVtZS1yYW5nZVttZWRpYXZvbHVtZXVuYXZhaWxhYmxlXSxcbiAgICBtZWRpYS1haXJwbGF5LWJ1dHRvblttZWRpYWFpcnBsYXl1bmF2YWlsYWJsZV0sXG4gICAgbWVkaWEtZnVsbHNjcmVlbi1idXR0b25bbWVkaWFmdWxsc2NyZWVudW5hdmFpbGFibGVdLFxuICAgIG1lZGlhLWNhc3QtYnV0dG9uW21lZGlhY2FzdHVuYXZhaWxhYmxlXSxcbiAgICBtZWRpYS1waXAtYnV0dG9uW21lZGlhcGlwdW5hdmFpbGFibGVdIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICA8L3N0eWxlPlxuYDtcbmNsYXNzIE1lZGlhVGhlbWVFbGVtZW50IGV4dGVuZHMgZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cGdyYWRlUHJvcGVydHkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlVGVtcGxhdGUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW5kZXJSb290XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW5kZXJlclwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RlbXBsYXRlLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcHJldlRlbXBsYXRlLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcHJldlRlbXBsYXRlSWQsIHZvaWQgMCk7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5yZW5kZXJSb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgdGhpcy5jcmVhdGVSZW5kZXJlcigpO1xuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbkxpc3QpID0+IHtcbiAgICAgIGlmIChtdXRhdGlvbkxpc3Quc29tZSgobXV0YXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGFyZ2V0LmxvY2FsTmFtZSAhPT0gXCJtZWRpYS1jb250cm9sbGVyXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JzZXJ2ZWRNZWRpYUF0dHJpYnV0ZXNbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0pXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lLnN0YXJ0c1dpdGgoXCJicmVha3BvaW50XCIpKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGhpcy5yZW5kZXJSb290LCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfdXBncmFkZVByb3BlcnR5LCB1cGdyYWRlUHJvcGVydHlfZm4pLmNhbGwodGhpcywgXCJ0ZW1wbGF0ZVwiKTtcbiAgfVxuICBnZXQgbWVkaWFDb250cm9sbGVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3QucXVlcnlTZWxlY3RvcihcIm1lZGlhLWNvbnRyb2xsZXJcIik7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF90ZW1wbGF0ZSkpICE9IG51bGwgPyBfYSA6IHRoaXMuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gIH1cbiAgc2V0IHRlbXBsYXRlKGVsZW1lbnQpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3ByZXZUZW1wbGF0ZUlkLCBudWxsKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RlbXBsYXRlLCBlbGVtZW50KTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gIH1cbiAgZ2V0IHByb3BzKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IFtcbiAgICAgIC4uLkFycmF5LmZyb20oKF9iID0gKF9hID0gdGhpcy5tZWRpYUNvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRyaWJ1dGVzKSAhPSBudWxsID8gX2IgOiBbXSkuZmlsdGVyKCh7IG5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZWRNZWRpYUF0dHJpYnV0ZXNbbmFtZV0gfHwgbmFtZS5zdGFydHNXaXRoKFwiYnJlYWtwb2ludFwiKTtcbiAgICAgIH0pLFxuICAgICAgLi4uQXJyYXkuZnJvbSh0aGlzLmF0dHJpYnV0ZXMpXG4gICAgXTtcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IGF0dHIgb2Ygb2JzZXJ2ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBuYW1lID0gKF9jID0gb2JzZXJ2ZWRNZWRpYUF0dHJpYnV0ZXNbYXR0ci5uYW1lXSkgIT0gbnVsbCA/IF9jIDogY2FtZWxDYXNlKGF0dHIubmFtZSk7XG4gICAgICBsZXQgeyB2YWx1ZSB9ID0gYXR0cjtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc051bWVyaWNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlID09PSBcIlwiID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHNbbmFtZV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGF0dHJOYW1lID09PSBcInRlbXBsYXRlXCIgJiYgb2xkVmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfdXBkYXRlVGVtcGxhdGUsIHVwZGF0ZVRlbXBsYXRlX2ZuKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3VwZGF0ZVRlbXBsYXRlLCB1cGRhdGVUZW1wbGF0ZV9mbikuY2FsbCh0aGlzKTtcbiAgfVxuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICBpZiAodGhpcy50ZW1wbGF0ZSAmJiB0aGlzLnRlbXBsYXRlICE9PSBfX3ByaXZhdGVHZXQodGhpcywgX3ByZXZUZW1wbGF0ZSkpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcHJldlRlbXBsYXRlLCB0aGlzLnRlbXBsYXRlKTtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZShcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSxcbiAgICAgICAgdGhpcy5wcm9wcyxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcm9jZXNzb3JcbiAgICAgICk7XG4gICAgICB0aGlzLnJlbmRlclJvb3QudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgdGhpcy5yZW5kZXJSb290LmFwcGVuZChcbiAgICAgICAgcHJlcGVuZFRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICB0aGlzLnJlbmRlcmVyXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMucmVuZGVyZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS51cGRhdGUodGhpcy5wcm9wcyk7XG4gIH1cbn1cbl90ZW1wbGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5fcHJldlRlbXBsYXRlID0gbmV3IFdlYWtNYXAoKTtcbl9wcmV2VGVtcGxhdGVJZCA9IG5ldyBXZWFrTWFwKCk7XG5fdXBncmFkZVByb3BlcnR5ID0gbmV3IFdlYWtTZXQoKTtcbnVwZ3JhZGVQcm9wZXJ0eV9mbiA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wKSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1twcm9wXTtcbiAgICBkZWxldGUgdGhpc1twcm9wXTtcbiAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG4gIH1cbn07XG5fdXBkYXRlVGVtcGxhdGUgPSBuZXcgV2Vha1NldCgpO1xudXBkYXRlVGVtcGxhdGVfZm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0ZW1wbGF0ZVwiKTtcbiAgaWYgKCF0ZW1wbGF0ZUlkIHx8IHRlbXBsYXRlSWQgPT09IF9fcHJpdmF0ZUdldCh0aGlzLCBfcHJldlRlbXBsYXRlSWQpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gIGNvbnN0IHRlbXBsYXRlID0gKF9hID0gcm9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3ROb2RlLmdldEVsZW1lbnRCeUlkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChyb290Tm9kZSwgdGVtcGxhdGVJZCk7XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcHJldlRlbXBsYXRlSWQsIHRlbXBsYXRlSWQpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGVtcGxhdGUsIHRlbXBsYXRlKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1ZhbGlkVXJsKHRlbXBsYXRlSWQpKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wcmV2VGVtcGxhdGVJZCwgdGVtcGxhdGVJZCk7XG4gICAgcmVxdWVzdCh0ZW1wbGF0ZUlkKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZTIuaW5uZXJIVE1MID0gZGF0YTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGVtcGxhdGUsIHRlbXBsYXRlMik7XG4gICAgICB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIH1cbn07XG5fX3B1YmxpY0ZpZWxkKE1lZGlhVGhlbWVFbGVtZW50LCBcInRlbXBsYXRlXCIpO1xuX19wdWJsaWNGaWVsZChNZWRpYVRoZW1lRWxlbWVudCwgXCJvYnNlcnZlZEF0dHJpYnV0ZXNcIiwgW1widGVtcGxhdGVcIl0pO1xuX19wdWJsaWNGaWVsZChNZWRpYVRoZW1lRWxlbWVudCwgXCJwcm9jZXNzb3JcIiwgcHJvY2Vzc29yKTtcbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsKSB7XG4gIGlmICghL14oXFwvfFxcLlxcL3xodHRwcz86XFwvXFwvKS8udGVzdCh1cmwpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgYmFzZSA9IC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmwpID8gdm9pZCAwIDogbG9jYXRpb24ub3JpZ2luO1xuICB0cnkge1xuICAgIG5ldyBVUkwodXJsLCBiYXNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QocmVzb3VyY2UpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZSk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2U6IHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBzdGF0dXMgb2YgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS10aGVtZVwiKSkge1xuICBnbG9iYWxUaGlzLmN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1lZGlhLXRoZW1lXCIsIE1lZGlhVGhlbWVFbGVtZW50KTtcbn1cbmV4cG9ydCB7XG4gIE1lZGlhVGhlbWVFbGVtZW50XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-theme-element.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-time-display.js":
/*!**************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-time-display.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   \"default\": function() { return /* binding */ media_time_display_default; }\n/* harmony export */ });\n/* harmony import */ var _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-text-display.js */ \"(app-client)/./node_modules/media-chrome/dist/media-text-display.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_time_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/time.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/time.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _slot;\n\n\n\n\n\n\nconst Attributes = {\n  REMAINING: \"remaining\",\n  SHOW_DURATION: \"showduration\",\n  NO_TOGGLE: \"notoggle\"\n};\nconst CombinedAttributes = [\n  ...Object.values(Attributes),\n  _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_CURRENT_TIME,\n  _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_DURATION,\n  _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_SEEKABLE\n];\nconst ButtonPressedKeys = [\"Enter\", \" \"];\nconst DEFAULT_TIMES_SEP = \"&nbsp;/&nbsp;\";\nconst formatTimesLabel = (el, { timesSep = DEFAULT_TIMES_SEP } = {}) => {\n  var _a, _b, _c, _d;\n  const showRemaining = el.hasAttribute(Attributes.REMAINING);\n  const showDuration = el.hasAttribute(Attributes.SHOW_DURATION);\n  const currentTime = (_a = el.mediaCurrentTime) != null ? _a : 0;\n  const [, seekableEnd] = (_b = el.mediaSeekable) != null ? _b : [];\n  const endTime = (_d = (_c = el.mediaDuration) != null ? _c : seekableEnd) != null ? _d : 0;\n  const timeLabel = showRemaining ? (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatTime)(0 - (endTime - currentTime)) : (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatTime)(currentTime);\n  if (!showDuration)\n    return timeLabel;\n  return `${timeLabel}${timesSep}${(0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatTime)(endTime)}`;\n};\nconst DEFAULT_MISSING_TIME_PHRASE = \"video not loaded, unknown time.\";\nconst updateAriaValueText = (el) => {\n  var _a;\n  const currentTime = el.mediaCurrentTime;\n  const [, seekableEnd] = (_a = el.mediaSeekable) != null ? _a : [];\n  const endTime = el.mediaDuration || seekableEnd;\n  if (currentTime == null || endTime == null) {\n    el.setAttribute(\"aria-valuetext\", DEFAULT_MISSING_TIME_PHRASE);\n    return;\n  }\n  const showRemaining = el.hasAttribute(Attributes.REMAINING);\n  const showDuration = el.hasAttribute(Attributes.SHOW_DURATION);\n  const currentTimePhrase = showRemaining ? (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatAsTimePhrase)(0 - (endTime - currentTime)) : (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatAsTimePhrase)(currentTime);\n  if (!showDuration) {\n    el.setAttribute(\"aria-valuetext\", currentTimePhrase);\n    return;\n  }\n  const totalTimePhrase = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_3__.formatAsTimePhrase)(endTime);\n  const fullPhrase = `${currentTimePhrase} of ${totalTimePhrase}`;\n  el.setAttribute(\"aria-valuetext\", fullPhrase);\n};\nclass MediaTimeDisplay extends _media_text_display_js__WEBPACK_IMPORTED_MODULE_0__.MediaTextDisplay {\n  constructor() {\n    super();\n    __privateAdd(this, _slot, void 0);\n    __privateSet(this, _slot, this.shadowRoot.querySelector(\"slot\"));\n    __privateGet(this, _slot).innerHTML = `${formatTimesLabel(this)}`;\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOrInsertCSSRule)(this.shadowRoot, \":host:not([notoggle])\");\n    style.setProperty(\"cursor\", \"pointer\");\n    const { style: hoverStyle } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOrInsertCSSRule)(\n      this.shadowRoot,\n      \":host(:hover:not([notoggle]))\"\n    );\n    hoverStyle.setProperty(\n      \"background\",\n      \"var(--media-control-hover-background, rgba(50 50 70 / .7))\"\n    );\n  }\n  static get observedAttributes() {\n    return [...super.observedAttributes, ...CombinedAttributes, \"disabled\"];\n  }\n  connectedCallback() {\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    this.setAttribute(\"role\", \"progressbar\");\n    this.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_5__.nouns.PLAYBACK_TIME());\n    const keyUpHandler = (evt) => {\n      const { key } = evt;\n      if (!ButtonPressedKeys.includes(key)) {\n        this.removeEventListener(\"keyup\", keyUpHandler);\n        return;\n      }\n      this.toggleTimeDisplay();\n    };\n    this.addEventListener(\"keydown\", (evt) => {\n      const { metaKey, altKey, key } = evt;\n      if (metaKey || altKey || !ButtonPressedKeys.includes(key)) {\n        this.removeEventListener(\"keyup\", keyUpHandler);\n        return;\n      }\n      this.addEventListener(\"keyup\", keyUpHandler);\n    });\n    this.addEventListener(\"click\", this.toggleTimeDisplay);\n    super.connectedCallback();\n  }\n  toggleTimeDisplay() {\n    if (this.noToggle) {\n      return;\n    }\n    if (this.hasAttribute(\"remaining\")) {\n      this.removeAttribute(\"remaining\");\n    } else {\n      this.setAttribute(\"remaining\", \"\");\n    }\n  }\n  disconnectedCallback() {\n    this.disable();\n    super.disconnectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (CombinedAttributes.includes(attrName)) {\n      this.update();\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  enable() {\n    this.tabIndex = 0;\n  }\n  disable() {\n    this.tabIndex = -1;\n  }\n  get remaining() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getBooleanAttr)(this, Attributes.REMAINING);\n  }\n  set remaining(show) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBooleanAttr)(this, Attributes.REMAINING, show);\n  }\n  get showDuration() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getBooleanAttr)(this, Attributes.SHOW_DURATION);\n  }\n  set showDuration(show) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBooleanAttr)(this, Attributes.SHOW_DURATION, show);\n  }\n  get noToggle() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getBooleanAttr)(this, Attributes.NO_TOGGLE);\n  }\n  set noToggle(notoggle) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBooleanAttr)(this, Attributes.NO_TOGGLE, notoggle);\n  }\n  get mediaDuration() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_DURATION);\n  }\n  set mediaDuration(time) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_DURATION, time);\n  }\n  get mediaCurrentTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_CURRENT_TIME);\n  }\n  set mediaCurrentTime(time) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_1__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_CURRENT_TIME, time);\n  }\n  get mediaSeekable() {\n    const seekable = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_SEEKABLE);\n    if (!seekable)\n      return void 0;\n    return seekable.split(\":\").map((time) => +time);\n  }\n  set mediaSeekable(range) {\n    if (range == null) {\n      this.removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_SEEKABLE);\n      return;\n    }\n    this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MediaUIAttributes.MEDIA_SEEKABLE, range.join(\":\"));\n  }\n  update() {\n    const timesLabel = formatTimesLabel(this);\n    updateAriaValueText(this);\n    if (timesLabel !== __privateGet(this, _slot).innerHTML) {\n      __privateGet(this, _slot).innerHTML = timesLabel;\n    }\n  }\n}\n_slot = new WeakMap();\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.get(\"media-time-display\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_2__.globalThis.customElements.define(\"media-time-display\", MediaTimeDisplay);\n}\nvar media_time_display_default = MediaTimeDisplay;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRpbWUtZGlzcGxheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBT3pCO0FBQzBCO0FBQ0s7QUFDZDtBQUNSO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0REFBaUI7QUFDbkIsRUFBRSw0REFBaUI7QUFDbkIsRUFBRSw0REFBaUI7QUFDbkI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDLGdDQUFnQywrQkFBK0IsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMERBQVUsZ0NBQWdDLDBEQUFVO0FBQ3hGO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSxTQUFTLEVBQUUsMERBQVUsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrRUFBa0IsZ0NBQWdDLGtFQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBa0I7QUFDNUMsd0JBQXdCLG1CQUFtQixLQUFLLGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0EsK0JBQStCLG9FQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEUsWUFBWSxRQUFRLEVBQUUsMkVBQWtCO0FBQ3hDO0FBQ0EsWUFBWSxvQkFBb0IsRUFBRSwyRUFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0RBQUs7QUFDekM7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWM7QUFDekI7QUFDQTtBQUNBLElBQUksdUVBQWM7QUFDbEI7QUFDQTtBQUNBLFdBQVcsdUVBQWM7QUFDekI7QUFDQTtBQUNBLElBQUksdUVBQWM7QUFDbEI7QUFDQTtBQUNBLFdBQVcsdUVBQWM7QUFDekI7QUFDQTtBQUNBLElBQUksdUVBQWM7QUFDbEI7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLHVDQUF1Qyw0REFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFpQjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLDREQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS10aW1lLWRpc3BsYXkuanM/YjU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfc2xvdDtcbmltcG9ydCB7IE1lZGlhVGV4dERpc3BsYXkgfSBmcm9tIFwiLi9tZWRpYS10ZXh0LWRpc3BsYXkuanNcIjtcbmltcG9ydCB7XG4gIGdldEJvb2xlYW5BdHRyLFxuICBnZXROdW1lcmljQXR0cixcbiAgZ2V0T3JJbnNlcnRDU1NSdWxlLFxuICBzZXRCb29sZWFuQXR0cixcbiAgc2V0TnVtZXJpY0F0dHJcbn0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcyB9IGZyb20gXCIuL3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IGZvcm1hdEFzVGltZVBocmFzZSwgZm9ybWF0VGltZSB9IGZyb20gXCIuL3V0aWxzL3RpbWUuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBub3VucyB9IGZyb20gXCIuL2xhYmVscy9sYWJlbHMuanNcIjtcbmNvbnN0IEF0dHJpYnV0ZXMgPSB7XG4gIFJFTUFJTklORzogXCJyZW1haW5pbmdcIixcbiAgU0hPV19EVVJBVElPTjogXCJzaG93ZHVyYXRpb25cIixcbiAgTk9fVE9HR0xFOiBcIm5vdG9nZ2xlXCJcbn07XG5jb25zdCBDb21iaW5lZEF0dHJpYnV0ZXMgPSBbXG4gIC4uLk9iamVjdC52YWx1ZXMoQXR0cmlidXRlcyksXG4gIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSxcbiAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRFVSQVRJT04sXG4gIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NFRUtBQkxFXG5dO1xuY29uc3QgQnV0dG9uUHJlc3NlZEtleXMgPSBbXCJFbnRlclwiLCBcIiBcIl07XG5jb25zdCBERUZBVUxUX1RJTUVTX1NFUCA9IFwiJm5ic3A7LyZuYnNwO1wiO1xuY29uc3QgZm9ybWF0VGltZXNMYWJlbCA9IChlbCwgeyB0aW1lc1NlcCA9IERFRkFVTFRfVElNRVNfU0VQIH0gPSB7fSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHNob3dSZW1haW5pbmcgPSBlbC5oYXNBdHRyaWJ1dGUoQXR0cmlidXRlcy5SRU1BSU5JTkcpO1xuICBjb25zdCBzaG93RHVyYXRpb24gPSBlbC5oYXNBdHRyaWJ1dGUoQXR0cmlidXRlcy5TSE9XX0RVUkFUSU9OKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSAoX2EgPSBlbC5tZWRpYUN1cnJlbnRUaW1lKSAhPSBudWxsID8gX2EgOiAwO1xuICBjb25zdCBbLCBzZWVrYWJsZUVuZF0gPSAoX2IgPSBlbC5tZWRpYVNlZWthYmxlKSAhPSBudWxsID8gX2IgOiBbXTtcbiAgY29uc3QgZW5kVGltZSA9IChfZCA9IChfYyA9IGVsLm1lZGlhRHVyYXRpb24pICE9IG51bGwgPyBfYyA6IHNlZWthYmxlRW5kKSAhPSBudWxsID8gX2QgOiAwO1xuICBjb25zdCB0aW1lTGFiZWwgPSBzaG93UmVtYWluaW5nID8gZm9ybWF0VGltZSgwIC0gKGVuZFRpbWUgLSBjdXJyZW50VGltZSkpIDogZm9ybWF0VGltZShjdXJyZW50VGltZSk7XG4gIGlmICghc2hvd0R1cmF0aW9uKVxuICAgIHJldHVybiB0aW1lTGFiZWw7XG4gIHJldHVybiBgJHt0aW1lTGFiZWx9JHt0aW1lc1NlcH0ke2Zvcm1hdFRpbWUoZW5kVGltZSl9YDtcbn07XG5jb25zdCBERUZBVUxUX01JU1NJTkdfVElNRV9QSFJBU0UgPSBcInZpZGVvIG5vdCBsb2FkZWQsIHVua25vd24gdGltZS5cIjtcbmNvbnN0IHVwZGF0ZUFyaWFWYWx1ZVRleHQgPSAoZWwpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBjdXJyZW50VGltZSA9IGVsLm1lZGlhQ3VycmVudFRpbWU7XG4gIGNvbnN0IFssIHNlZWthYmxlRW5kXSA9IChfYSA9IGVsLm1lZGlhU2Vla2FibGUpICE9IG51bGwgPyBfYSA6IFtdO1xuICBjb25zdCBlbmRUaW1lID0gZWwubWVkaWFEdXJhdGlvbiB8fCBzZWVrYWJsZUVuZDtcbiAgaWYgKGN1cnJlbnRUaW1lID09IG51bGwgfHwgZW5kVGltZSA9PSBudWxsKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgREVGQVVMVF9NSVNTSU5HX1RJTUVfUEhSQVNFKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2hvd1JlbWFpbmluZyA9IGVsLmhhc0F0dHJpYnV0ZShBdHRyaWJ1dGVzLlJFTUFJTklORyk7XG4gIGNvbnN0IHNob3dEdXJhdGlvbiA9IGVsLmhhc0F0dHJpYnV0ZShBdHRyaWJ1dGVzLlNIT1dfRFVSQVRJT04pO1xuICBjb25zdCBjdXJyZW50VGltZVBocmFzZSA9IHNob3dSZW1haW5pbmcgPyBmb3JtYXRBc1RpbWVQaHJhc2UoMCAtIChlbmRUaW1lIC0gY3VycmVudFRpbWUpKSA6IGZvcm1hdEFzVGltZVBocmFzZShjdXJyZW50VGltZSk7XG4gIGlmICghc2hvd0R1cmF0aW9uKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgY3VycmVudFRpbWVQaHJhc2UpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0b3RhbFRpbWVQaHJhc2UgPSBmb3JtYXRBc1RpbWVQaHJhc2UoZW5kVGltZSk7XG4gIGNvbnN0IGZ1bGxQaHJhc2UgPSBgJHtjdXJyZW50VGltZVBocmFzZX0gb2YgJHt0b3RhbFRpbWVQaHJhc2V9YDtcbiAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgZnVsbFBocmFzZSk7XG59O1xuY2xhc3MgTWVkaWFUaW1lRGlzcGxheSBleHRlbmRzIE1lZGlhVGV4dERpc3BsYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2xvdCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Nsb3QsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic2xvdFwiKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zbG90KS5pbm5lckhUTUwgPSBgJHtmb3JtYXRUaW1lc0xhYmVsKHRoaXMpfWA7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCI6aG9zdDpub3QoW25vdG9nZ2xlXSlcIik7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xuICAgIGNvbnN0IHsgc3R5bGU6IGhvdmVyU3R5bGUgfSA9IGdldE9ySW5zZXJ0Q1NTUnVsZShcbiAgICAgIHRoaXMuc2hhZG93Um9vdCxcbiAgICAgIFwiOmhvc3QoOmhvdmVyOm5vdChbbm90b2dnbGVdKSlcIlxuICAgICk7XG4gICAgaG92ZXJTdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIFwiYmFja2dyb3VuZFwiLFxuICAgICAgXCJ2YXIoLS1tZWRpYS1jb250cm9sLWhvdmVyLWJhY2tncm91bmQsIHJnYmEoNTAgNTAgNzAgLyAuNykpXCJcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAuLi5Db21iaW5lZEF0dHJpYnV0ZXMsIFwiZGlzYWJsZWRcIl07XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcm9ncmVzc2JhclwiKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbm91bnMuUExBWUJBQ0tfVElNRSgpKTtcbiAgICBjb25zdCBrZXlVcEhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICBjb25zdCB7IGtleSB9ID0gZXZ0O1xuICAgICAgaWYgKCFCdXR0b25QcmVzc2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleVVwSGFuZGxlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9nZ2xlVGltZURpc3BsYXkoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2dCkgPT4ge1xuICAgICAgY29uc3QgeyBtZXRhS2V5LCBhbHRLZXksIGtleSB9ID0gZXZ0O1xuICAgICAgaWYgKG1ldGFLZXkgfHwgYWx0S2V5IHx8ICFCdXR0b25QcmVzc2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleVVwSGFuZGxlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleVVwSGFuZGxlcik7XG4gICAgfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGVUaW1lRGlzcGxheSk7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuICB0b2dnbGVUaW1lRGlzcGxheSgpIHtcbiAgICBpZiAodGhpcy5ub1RvZ2dsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoXCJyZW1haW5pbmdcIikpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwicmVtYWluaW5nXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcInJlbWFpbmluZ1wiLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChDb21iaW5lZEF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09IFwiZGlzYWJsZWRcIiAmJiBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLnRhYkluZGV4ID0gMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMudGFiSW5kZXggPSAtMTtcbiAgfVxuICBnZXQgcmVtYWluaW5nKCkge1xuICAgIHJldHVybiBnZXRCb29sZWFuQXR0cih0aGlzLCBBdHRyaWJ1dGVzLlJFTUFJTklORyk7XG4gIH1cbiAgc2V0IHJlbWFpbmluZyhzaG93KSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgQXR0cmlidXRlcy5SRU1BSU5JTkcsIHNob3cpO1xuICB9XG4gIGdldCBzaG93RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIEF0dHJpYnV0ZXMuU0hPV19EVVJBVElPTik7XG4gIH1cbiAgc2V0IHNob3dEdXJhdGlvbihzaG93KSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgQXR0cmlidXRlcy5TSE9XX0RVUkFUSU9OLCBzaG93KTtcbiAgfVxuICBnZXQgbm9Ub2dnbGUoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIEF0dHJpYnV0ZXMuTk9fVE9HR0xFKTtcbiAgfVxuICBzZXQgbm9Ub2dnbGUobm90b2dnbGUpIHtcbiAgICBzZXRCb29sZWFuQXR0cih0aGlzLCBBdHRyaWJ1dGVzLk5PX1RPR0dMRSwgbm90b2dnbGUpO1xuICB9XG4gIGdldCBtZWRpYUR1cmF0aW9uKCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9EVVJBVElPTik7XG4gIH1cbiAgc2V0IG1lZGlhRHVyYXRpb24odGltZSkge1xuICAgIHNldE51bWVyaWNBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0RVUkFUSU9OLCB0aW1lKTtcbiAgfVxuICBnZXQgbWVkaWFDdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ1VSUkVOVF9USU1FKTtcbiAgfVxuICBzZXQgbWVkaWFDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ1VSUkVOVF9USU1FLCB0aW1lKTtcbiAgfVxuICBnZXQgbWVkaWFTZWVrYWJsZSgpIHtcbiAgICBjb25zdCBzZWVrYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NFRUtBQkxFKTtcbiAgICBpZiAoIXNlZWthYmxlKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gc2Vla2FibGUuc3BsaXQoXCI6XCIpLm1hcCgodGltZSkgPT4gK3RpbWUpO1xuICB9XG4gIHNldCBtZWRpYVNlZWthYmxlKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NFRUtBQkxFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU0VFS0FCTEUsIHJhbmdlLmpvaW4oXCI6XCIpKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGltZXNMYWJlbCA9IGZvcm1hdFRpbWVzTGFiZWwodGhpcyk7XG4gICAgdXBkYXRlQXJpYVZhbHVlVGV4dCh0aGlzKTtcbiAgICBpZiAodGltZXNMYWJlbCAhPT0gX19wcml2YXRlR2V0KHRoaXMsIF9zbG90KS5pbm5lckhUTUwpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2xvdCkuaW5uZXJIVE1MID0gdGltZXNMYWJlbDtcbiAgICB9XG4gIH1cbn1cbl9zbG90ID0gbmV3IFdlYWtNYXAoKTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS10aW1lLWRpc3BsYXlcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS10aW1lLWRpc3BsYXlcIiwgTWVkaWFUaW1lRGlzcGxheSk7XG59XG52YXIgbWVkaWFfdGltZV9kaXNwbGF5X2RlZmF1bHQgPSBNZWRpYVRpbWVEaXNwbGF5O1xuZXhwb3J0IHtcbiAgQXR0cmlidXRlcyxcbiAgbWVkaWFfdGltZV9kaXNwbGF5X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-time-display.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-time-range.js":
/*!************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-time-range.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_time_range_default; }\n/* harmony export */ });\n/* harmony import */ var _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-chrome-range.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-range.js\");\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_time_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/time.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/time.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _boxes, _previewBox, _currentBox, _boxPaddingLeft, _boxPaddingRight, _mediaSeekableEnd, mediaSeekableEnd_get, _mediaSeekableStart, mediaSeekableStart_get, _getBoxPosition, getBoxPosition_fn, _pointermoveHandler, _rangeEntered, _offRangeHandler, _trackMouse, _stopTrackingMouse, _rangepointermoveHandler, _enableBoxes, enableBoxes_fn, _disableBoxes, disableBoxes_fn;\n\n\n\n\n\n\nconst DEFAULT_MISSING_TIME_PHRASE = \"video not loaded, unknown time.\";\nconst updateAriaValueText = (el) => {\n  const range = el.range;\n  const currentTimePhrase = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_4__.formatAsTimePhrase)(+range.value);\n  const totalTimePhrase = (0,_utils_time_js__WEBPACK_IMPORTED_MODULE_4__.formatAsTimePhrase)(+range.max);\n  const fullPhrase = !(currentTimePhrase && totalTimePhrase) ? DEFAULT_MISSING_TIME_PHRASE : `${currentTimePhrase} of ${totalTimePhrase}`;\n  range.setAttribute(\"aria-valuetext\", fullPhrase);\n};\nconst template = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      --media-preview-border-radius: 3px;\n      --media-box-padding-left: 10px;\n      --media-box-padding-right: 10px;\n    }\n\n    #preview-rail,\n    #current-rail {\n      ${\"\"}\n      width: 1%;\n      position: absolute;\n      left: 0;\n      bottom: 100%;\n      pointer-events: none;\n    }\n\n    [part~=\"box\"] {\n      ${\"\"}\n      position: absolute;\n      bottom: 100%;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      transform: translateX(-50%);\n    }\n\n    [part~=\"preview-box\"] {\n      transition-property: var(--media-preview-transition-property, visibility, opacity);\n      transition-duration: var(--media-preview-transition-duration-out, .25s);\n      transition-delay: var(--media-preview-transition-delay-out, 0s);\n      visibility: hidden;\n      opacity: 0;\n    }\n\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE}]:hover) [part~=\"preview-box\"],\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_TIME}]:hover) [part~=\"preview-box\"] {\n      transition-duration: var(--media-preview-transition-duration-in, .5s);\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      visibility: visible;\n      opacity: 1;\n    }\n\n    media-preview-thumbnail,\n    ::slotted(media-preview-thumbnail) {\n      visibility: hidden;\n      ${\"\"}\n      transition: visibility 0s .25s;\n      transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));\n      background: var(--media-preview-thumbnail-background, var(--media-preview-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)))));\n      box-shadow: var(--media-preview-thumbnail-box-shadow, 0 0 4px rgb(0 0 0 / .2));\n      max-width: var(--media-preview-thumbnail-max-width, 180px);\n      max-height: var(--media-preview-thumbnail-max-height, 160px);\n      min-width: var(--media-preview-thumbnail-min-width, 120px);\n      min-height: var(--media-preview-thumbnail-min-height, 80px);\n      border: var(--media-preview-thumbnail-border);\n      border-radius: var(--media-preview-thumbnail-border-radius,\n        var(--media-preview-border-radius) var(--media-preview-border-radius) 0 0);\n    }\n\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE}]:hover) media-preview-thumbnail,\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE}]:hover) ::slotted(media-preview-thumbnail) {\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      visibility: visible;\n    }\n\n    media-preview-time-display,\n    ::slotted(media-preview-time-display) {\n      min-width: 0;\n      ${\"\"}\n      transition: min-width 0s, border-radius 0s;\n      transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));\n      background: var(--media-preview-time-background, var(--media-preview-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)))));\n      border-radius: var(--media-preview-time-border-radius,\n        var(--media-preview-border-radius) var(--media-preview-border-radius)\n        var(--media-preview-border-radius) var(--media-preview-border-radius));\n      padding: var(--media-preview-time-padding, 1px 10px 0);\n      margin: var(--media-preview-time-margin, 0 0 10px);\n      text-shadow: var(--media-preview-time-text-shadow, 0 0 4px rgb(0 0 0 / .75));\n    }\n\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE}]) media-preview-time-display,\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE}]) ::slotted(media-preview-time-display) {\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      min-width: 100%;\n      border-radius: var(--media-preview-time-border-radius,\n        0 0 var(--media-preview-border-radius) var(--media-preview-border-radius));\n    }\n\n    :host([${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_TIME}]:hover) {\n      --media-time-range-hover-display: block;\n    }\n  </style>\n  <div id=\"preview-rail\">\n    <slot name=\"preview\" part=\"box preview-box\">\n      <media-preview-thumbnail></media-preview-thumbnail>\n      <media-preview-time-display></media-preview-time-display>\n    </slot>\n  </div>\n  <div id=\"current-rail\">\n    <slot name=\"current\" part=\"box current-box\">\n      ${\"\"}\n    </slot>\n  </div>\n`;\nclass MediaTimeRange extends _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_0__.MediaChromeRange {\n  constructor() {\n    super();\n    __privateAdd(this, _mediaSeekableEnd);\n    __privateAdd(this, _mediaSeekableStart);\n    __privateAdd(this, _getBoxPosition);\n    __privateAdd(this, _enableBoxes);\n    __privateAdd(this, _disableBoxes);\n    __privateAdd(this, _boxes, void 0);\n    __privateAdd(this, _previewBox, void 0);\n    __privateAdd(this, _currentBox, void 0);\n    __privateAdd(this, _boxPaddingLeft, void 0);\n    __privateAdd(this, _boxPaddingRight, void 0);\n    __privateAdd(this, _pointermoveHandler, (evt) => {\n      if ([...__privateGet(this, _boxes)].some((b) => evt.composedPath().includes(b)))\n        return;\n      this.updatePointerBar(evt);\n      const duration = this.mediaDuration;\n      if (!duration)\n        return;\n      const rangeRect = this.range.getBoundingClientRect();\n      let mouseRatio = (evt.clientX - rangeRect.left - this.thumbWidth / 2) / (rangeRect.width - this.thumbWidth);\n      mouseRatio = Math.max(0, Math.min(1, mouseRatio));\n      const boxPos = __privateMethod(this, _getBoxPosition, getBoxPosition_fn).call(this, __privateGet(this, _previewBox), mouseRatio);\n      const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getOrInsertCSSRule)(this.shadowRoot, \"#preview-rail\");\n      style.transform = `translateX(${boxPos})`;\n      const detail = mouseRatio * duration;\n      const mediaPreviewEvt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(\n        _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_PREVIEW_REQUEST,\n        { composed: true, bubbles: true, detail }\n      );\n      this.dispatchEvent(mediaPreviewEvt);\n    });\n    __privateAdd(this, _rangeEntered, false);\n    __privateAdd(this, _offRangeHandler, (evt) => {\n      var _a;\n      if (!evt.composedPath().includes(this) || [...__privateGet(this, _boxes)].some((b) => evt.composedPath().includes(b))) {\n        (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.window) == null ? void 0 : _a.removeEventListener(\"pointermove\", __privateGet(this, _offRangeHandler));\n        __privateSet(this, _rangeEntered, false);\n        __privateGet(this, _stopTrackingMouse).call(this);\n      }\n    });\n    __privateAdd(this, _trackMouse, () => {\n      var _a;\n      (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.window) == null ? void 0 : _a.addEventListener(\"pointermove\", __privateGet(this, _pointermoveHandler), false);\n    });\n    __privateAdd(this, _stopTrackingMouse, () => {\n      var _a;\n      (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.window) == null ? void 0 : _a.removeEventListener(\"pointermove\", __privateGet(this, _pointermoveHandler));\n      const endEvt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_PREVIEW_REQUEST, {\n        composed: true,\n        bubbles: true,\n        detail: null\n      });\n      this.dispatchEvent(endEvt);\n    });\n    __privateAdd(this, _rangepointermoveHandler, () => {\n      var _a;\n      const mediaDurationStr = this.getAttribute(\n        _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_DURATION\n      );\n      if (!__privateGet(this, _rangeEntered) && mediaDurationStr) {\n        __privateSet(this, _rangeEntered, true);\n        __privateGet(this, _trackMouse).call(this);\n        (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.window) == null ? void 0 : _a.addEventListener(\"pointermove\", __privateGet(this, _offRangeHandler), false);\n      }\n    });\n    this.container.appendChild(template.content.cloneNode(true));\n    this.range.addEventListener(\"input\", () => {\n      cancelAnimationFrame(this._refreshId);\n      const newTime = this.range.value;\n      const detail = newTime;\n      const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_SEEK_REQUEST, {\n        composed: true,\n        bubbles: true,\n        detail\n      });\n      this.dispatchEvent(evt);\n    });\n    this._refreshBar = () => {\n      const delta = (performance.now() - this._updateTimestamp) / 1e3;\n      this.range.value = this.mediaCurrentTime + delta * this.mediaPlaybackRate;\n      this.updateBar();\n      this.updateCurrentBox();\n      this._refreshId = requestAnimationFrame(this._refreshBar);\n    };\n    __privateSet(this, _boxes, this.shadowRoot.querySelectorAll('[part~=\"box\"]'));\n    __privateSet(this, _previewBox, this.shadowRoot.querySelector('[part~=\"preview-box\"]'));\n    __privateSet(this, _currentBox, this.shadowRoot.querySelector('[part~=\"current-box\"]'));\n    const computedStyle = getComputedStyle(this);\n    __privateSet(this, _boxPaddingLeft, parseInt(\n      computedStyle.getPropertyValue(\"--media-box-padding-left\")\n    ));\n    __privateSet(this, _boxPaddingRight, parseInt(\n      computedStyle.getPropertyValue(\"--media-box-padding-right\")\n    ));\n    __privateMethod(this, _enableBoxes, enableBoxes_fn).call(this);\n  }\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_DURATION,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SEEKABLE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_TIME,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_BUFFERED,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_LOADING,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_ENDED\n    ];\n  }\n  connectedCallback() {\n    this.range.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.nouns.SEEK());\n    super.connectedCallback();\n  }\n  disconnectedCallback() {\n    cancelAnimationFrame(this._refreshId);\n    super.disconnectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    var _a, _b, _c, _d, _e;\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME || attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED || attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_ENDED || attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_LOADING) {\n      this._updateTimestamp = performance.now();\n      this.range.value = this.mediaCurrentTime;\n      updateAriaValueText(this);\n      this.updateBar();\n      this.updateCurrentBox();\n      cancelAnimationFrame(this._refreshId);\n      if (!this.mediaPaused && !this.mediaLoading) {\n        this._refreshId = requestAnimationFrame(this._refreshBar);\n      }\n    }\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_DURATION) {\n      this.range.max = (_b = (_a = __privateGet(this, _mediaSeekableEnd, mediaSeekableEnd_get)) != null ? _a : this.mediaDuration) != null ? _b : 1e3;\n      updateAriaValueText(this);\n      this.updateBar();\n      this.updateCurrentBox();\n    }\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SEEKABLE) {\n      this.range.min = (_c = __privateGet(this, _mediaSeekableStart, mediaSeekableStart_get)) != null ? _c : 0;\n      this.range.max = (_e = (_d = __privateGet(this, _mediaSeekableEnd, mediaSeekableEnd_get)) != null ? _d : this.mediaDuration) != null ? _e : 1e3;\n      updateAriaValueText(this);\n      this.updateBar();\n    }\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_BUFFERED) {\n      this.updateBar();\n    }\n    if (attrName === \"disabled\") {\n      if (newValue == null) {\n        __privateMethod(this, _enableBoxes, enableBoxes_fn).call(this);\n      } else {\n        __privateMethod(this, _disableBoxes, disableBoxes_fn).call(this);\n      }\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaPaused() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED);\n  }\n  set mediaPaused(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PAUSED, value);\n  }\n  get mediaLoading() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_LOADING);\n  }\n  set mediaLoading(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_LOADING, value);\n  }\n  get mediaDuration() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_DURATION);\n  }\n  set mediaDuration(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_DURATION, value);\n  }\n  get mediaCurrentTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME);\n  }\n  set mediaCurrentTime(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_CURRENT_TIME, value);\n  }\n  get mediaPlaybackRate() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE, 1);\n  }\n  set mediaPlaybackRate(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PLAYBACK_RATE, value);\n  }\n  get mediaBuffered() {\n    const buffered = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_BUFFERED);\n    if (!buffered)\n      return [];\n    return buffered.split(\" \").map((timePair) => timePair.split(\":\").map((timeStr) => +timeStr));\n  }\n  set mediaBuffered(list) {\n    if (!list) {\n      this.removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_BUFFERED);\n      return;\n    }\n    const strVal = list.map((n1, n2) => `${n1}:${n2}`).join(\" \");\n    this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_BUFFERED, strVal);\n  }\n  get mediaSeekable() {\n    const seekable = this.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SEEKABLE);\n    if (!seekable)\n      return void 0;\n    return seekable.split(\":\").map((time) => +time);\n  }\n  set mediaSeekable(range) {\n    if (range == null) {\n      this.removeAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SEEKABLE);\n      return;\n    }\n    this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_SEEKABLE, range.join(\":\"));\n  }\n  get mediaPreviewImage() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE);\n  }\n  set mediaPreviewImage(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_IMAGE, value);\n  }\n  get mediaPreviewTime() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_TIME);\n  }\n  set mediaPreviewTime(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_PREVIEW_TIME, value);\n  }\n  get mediaEnded() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_ENDED);\n  }\n  set mediaEnded(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_ENDED, value);\n  }\n  getRelativeValues() {\n    const defaultRelativeValues = super.getRelativeValues();\n    if (!this.mediaEnded)\n      return defaultRelativeValues;\n    return {\n      ...defaultRelativeValues,\n      relativeValue: defaultRelativeValues.relativeMax\n    };\n  }\n  getBarColors() {\n    var _a;\n    let colorsArray = super.getBarColors();\n    const { range } = this;\n    const relativeMax = range.max - range.min;\n    const buffered = this.mediaBuffered;\n    if (!buffered.length || !Number.isFinite(relativeMax) || relativeMax <= 0) {\n      return colorsArray;\n    }\n    let relativeBufferedEnd;\n    if (!this.mediaEnded) {\n      const currentTime = this.mediaCurrentTime;\n      const [, bufferedEnd = range.min] = (_a = buffered.find(\n        ([start, end]) => start <= currentTime && currentTime <= end\n      )) != null ? _a : [];\n      relativeBufferedEnd = bufferedEnd - range.min;\n    } else {\n      relativeBufferedEnd = relativeMax;\n    }\n    const buffPercent = relativeBufferedEnd / relativeMax * 100;\n    colorsArray.splice(1, 0, [\n      \"var(--media-time-range-buffered-color, rgb(255 255 255 / .4))\",\n      buffPercent\n    ]);\n    return colorsArray;\n  }\n  updateCurrentBox() {\n    if (!__privateGet(this, _currentBox).assignedElements().length)\n      return;\n    const boxRatio = this.range.value / (this.range.max - this.range.min);\n    const boxPos = __privateMethod(this, _getBoxPosition, getBoxPosition_fn).call(this, __privateGet(this, _currentBox), boxRatio);\n    const { style } = (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.getOrInsertCSSRule)(this.shadowRoot, \"#current-rail\");\n    style.transform = `translateX(${boxPos})`;\n  }\n}\n_boxes = new WeakMap();\n_previewBox = new WeakMap();\n_currentBox = new WeakMap();\n_boxPaddingLeft = new WeakMap();\n_boxPaddingRight = new WeakMap();\n_mediaSeekableEnd = new WeakSet();\nmediaSeekableEnd_get = function() {\n  var _a;\n  const [, end] = (_a = this.mediaSeekable) != null ? _a : [];\n  return end;\n};\n_mediaSeekableStart = new WeakSet();\nmediaSeekableStart_get = function() {\n  var _a;\n  const [start] = (_a = this.mediaSeekable) != null ? _a : [];\n  return start;\n};\n_getBoxPosition = new WeakSet();\ngetBoxPosition_fn = function(box, ratio) {\n  var _a;\n  let position = `${ratio * 100 * 100}%`;\n  const boxWidth = box.offsetWidth;\n  if (!boxWidth)\n    return position;\n  const bounds = (_a = this.getAttribute(\"bounds\") ? (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_5__.closestComposedNode)(this, `#${this.getAttribute(\"bounds\")}`) : this.parentElement) != null ? _a : this;\n  const rangeRect = this.range.getBoundingClientRect();\n  const mediaBoundsRect = bounds.getBoundingClientRect();\n  const boxMin = (__privateGet(this, _boxPaddingLeft) - (rangeRect.left - mediaBoundsRect.left - boxWidth / 2)) / rangeRect.width * 100;\n  const boxMax = (mediaBoundsRect.right - rangeRect.left - boxWidth / 2 - __privateGet(this, _boxPaddingRight)) / rangeRect.width * 100;\n  if (!Number.isNaN(boxMin))\n    position = `max(${boxMin * 100}%, ${position})`;\n  if (!Number.isNaN(boxMax))\n    position = `min(${position}, ${boxMax * 100}%)`;\n  return position;\n};\n_pointermoveHandler = new WeakMap();\n_rangeEntered = new WeakMap();\n_offRangeHandler = new WeakMap();\n_trackMouse = new WeakMap();\n_stopTrackingMouse = new WeakMap();\n_rangepointermoveHandler = new WeakMap();\n_enableBoxes = new WeakSet();\nenableBoxes_fn = function() {\n  this.addEventListener(\"pointermove\", __privateGet(this, _rangepointermoveHandler), false);\n};\n_disableBoxes = new WeakSet();\ndisableBoxes_fn = function() {\n  var _a;\n  (_a = _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.window) == null ? void 0 : _a.removeEventListener(\"pointermove\", __privateGet(this, _offRangeHandler));\n  this.removeEventListener(\"pointermove\", __privateGet(this, _rangepointermoveHandler));\n  __privateSet(this, _rangeEntered, false);\n  __privateGet(this, _stopTrackingMouse).call(this);\n};\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.get(\"media-time-range\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_1__.globalThis.customElements.define(\"media-time-range\", MediaTimeRange);\n}\nvar media_time_range_default = MediaTimeRange;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRpbWUtcmFuZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDVztBQUNKO0FBQ3ZCO0FBQ1U7QUFVbkI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQjtBQUM5QywwQkFBMEIsa0VBQWtCO0FBQzVDLGdHQUFnRyxtQkFBbUIsS0FBSyxnQkFBZ0I7QUFDeEk7QUFDQTtBQUNBLGlCQUFpQixtRUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDREQUFpQixxQkFBcUI7QUFDbkQsYUFBYSw0REFBaUIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDREQUFpQixxQkFBcUI7QUFDbkQsYUFBYSw0REFBaUIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSw0REFBaUIscUJBQXFCO0FBQ25ELGFBQWEsNERBQWlCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsNERBQWlCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvRUFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxFQUFFLDJFQUFrQjtBQUMxQyxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLGtDQUFrQyxxRUFBVTtBQUM1QyxRQUFRLHdEQUFhO0FBQ3JCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxRUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVkscUVBQVU7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLHFFQUFVO0FBQ3RCLHlCQUF5QixxRUFBVSxhQUFhLHdEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUVBQVU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBVSxhQUFhLHdEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFpQixvQ0FBb0MsNERBQWlCLDhCQUE4Qiw0REFBaUIsNkJBQTZCLDREQUFpQjtBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHVFQUFjLE9BQU8sNERBQWlCO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJLHVFQUFjLE9BQU8sNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBaUI7QUFDNUM7QUFDQTtBQUNBLDJDQUEyQyxHQUFHLEdBQUcsR0FBRztBQUNwRCxzQkFBc0IsNERBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBaUI7QUFDNUM7QUFDQTtBQUNBLHNCQUFzQiw0REFBaUI7QUFDdkM7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSwyRUFBa0I7QUFDeEMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0RUFBbUIsV0FBVyw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhLEtBQUssU0FBUztBQUNqRDtBQUNBLHNCQUFzQixTQUFTLElBQUksYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBVTtBQUNmLEVBQUUscUVBQVU7QUFDWjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXRpbWUtcmFuZ2UuanM/MjM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX2JveGVzLCBfcHJldmlld0JveCwgX2N1cnJlbnRCb3gsIF9ib3hQYWRkaW5nTGVmdCwgX2JveFBhZGRpbmdSaWdodCwgX21lZGlhU2Vla2FibGVFbmQsIG1lZGlhU2Vla2FibGVFbmRfZ2V0LCBfbWVkaWFTZWVrYWJsZVN0YXJ0LCBtZWRpYVNlZWthYmxlU3RhcnRfZ2V0LCBfZ2V0Qm94UG9zaXRpb24sIGdldEJveFBvc2l0aW9uX2ZuLCBfcG9pbnRlcm1vdmVIYW5kbGVyLCBfcmFuZ2VFbnRlcmVkLCBfb2ZmUmFuZ2VIYW5kbGVyLCBfdHJhY2tNb3VzZSwgX3N0b3BUcmFja2luZ01vdXNlLCBfcmFuZ2Vwb2ludGVybW92ZUhhbmRsZXIsIF9lbmFibGVCb3hlcywgZW5hYmxlQm94ZXNfZm4sIF9kaXNhYmxlQm94ZXMsIGRpc2FibGVCb3hlc19mbjtcbmltcG9ydCB7IE1lZGlhQ2hyb21lUmFuZ2UgfSBmcm9tIFwiLi9tZWRpYS1jaHJvbWUtcmFuZ2UuanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXMsIGRvY3VtZW50IH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUV2ZW50cywgTWVkaWFVSUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IG5vdW5zIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0QXNUaW1lUGhyYXNlIH0gZnJvbSBcIi4vdXRpbHMvdGltZS5qc1wiO1xuaW1wb3J0IHtcbiAgZ2V0T3JJbnNlcnRDU1NSdWxlLFxuICBjbG9zZXN0Q29tcG9zZWROb2RlLFxuICBnZXRCb29sZWFuQXR0cixcbiAgc2V0Qm9vbGVhbkF0dHIsXG4gIGdldE51bWVyaWNBdHRyLFxuICBzZXROdW1lcmljQXR0cixcbiAgZ2V0U3RyaW5nQXR0cixcbiAgc2V0U3RyaW5nQXR0clxufSBmcm9tIFwiLi91dGlscy9lbGVtZW50LXV0aWxzLmpzXCI7XG5jb25zdCBERUZBVUxUX01JU1NJTkdfVElNRV9QSFJBU0UgPSBcInZpZGVvIG5vdCBsb2FkZWQsIHVua25vd24gdGltZS5cIjtcbmNvbnN0IHVwZGF0ZUFyaWFWYWx1ZVRleHQgPSAoZWwpID0+IHtcbiAgY29uc3QgcmFuZ2UgPSBlbC5yYW5nZTtcbiAgY29uc3QgY3VycmVudFRpbWVQaHJhc2UgPSBmb3JtYXRBc1RpbWVQaHJhc2UoK3JhbmdlLnZhbHVlKTtcbiAgY29uc3QgdG90YWxUaW1lUGhyYXNlID0gZm9ybWF0QXNUaW1lUGhyYXNlKCtyYW5nZS5tYXgpO1xuICBjb25zdCBmdWxsUGhyYXNlID0gIShjdXJyZW50VGltZVBocmFzZSAmJiB0b3RhbFRpbWVQaHJhc2UpID8gREVGQVVMVF9NSVNTSU5HX1RJTUVfUEhSQVNFIDogYCR7Y3VycmVudFRpbWVQaHJhc2V9IG9mICR7dG90YWxUaW1lUGhyYXNlfWA7XG4gIHJhbmdlLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWV0ZXh0XCIsIGZ1bGxQaHJhc2UpO1xufTtcbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuICA8c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgLS1tZWRpYS1wcmV2aWV3LWJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgIC0tbWVkaWEtYm94LXBhZGRpbmctbGVmdDogMTBweDtcbiAgICAgIC0tbWVkaWEtYm94LXBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gICAgfVxuXG4gICAgI3ByZXZpZXctcmFpbCxcbiAgICAjY3VycmVudC1yYWlsIHtcbiAgICAgICR7XCJcIn1cbiAgICAgIHdpZHRoOiAxJTtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICBib3R0b206IDEwMCU7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICBbcGFydH49XCJib3hcIl0ge1xuICAgICAgJHtcIlwifVxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm90dG9tOiAxMDAlO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIH1cblxuICAgIFtwYXJ0fj1cInByZXZpZXctYm94XCJdIHtcbiAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHZhcigtLW1lZGlhLXByZXZpZXctdHJhbnNpdGlvbi1wcm9wZXJ0eSwgdmlzaWJpbGl0eSwgb3BhY2l0eSk7XG4gICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZHVyYXRpb24tb3V0LCAuMjVzKTtcbiAgICAgIHRyYW5zaXRpb24tZGVsYXk6IHZhcigtLW1lZGlhLXByZXZpZXctdHJhbnNpdGlvbi1kZWxheS1vdXQsIDBzKTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuXG4gICAgOmhvc3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRX1dOmhvdmVyKSBbcGFydH49XCJwcmV2aWV3LWJveFwiXSxcbiAgICA6aG9zdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX1RJTUV9XTpob3ZlcikgW3BhcnR+PVwicHJldmlldy1ib3hcIl0ge1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tbWVkaWEtcHJldmlldy10cmFuc2l0aW9uLWR1cmF0aW9uLWluLCAuNXMpO1xuICAgICAgdHJhbnNpdGlvbi1kZWxheTogdmFyKC0tbWVkaWEtcHJldmlldy10cmFuc2l0aW9uLWRlbGF5LWluLCAuMjVzKTtcbiAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgIH1cblxuICAgIG1lZGlhLXByZXZpZXctdGh1bWJuYWlsLFxuICAgIDo6c2xvdHRlZChtZWRpYS1wcmV2aWV3LXRodW1ibmFpbCkge1xuICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgJHtcIlwifVxuICAgICAgdHJhbnNpdGlvbjogdmlzaWJpbGl0eSAwcyAuMjVzO1xuICAgICAgdHJhbnNpdGlvbi1kZWxheTogY2FsYyh2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZGVsYXktb3V0LCAwcykgKyB2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZHVyYXRpb24tb3V0LCAuMjVzKSk7XG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC1iYWNrZ3JvdW5kLCB2YXIoLS1tZWRpYS1wcmV2aWV3LWJhY2tncm91bmQsIHZhcigtLW1lZGlhLWNvbnRyb2wtYmFja2dyb3VuZCwgdmFyKC0tbWVkaWEtc2Vjb25kYXJ5LWNvbG9yLCByZ2IoMjAgMjAgMzAgLyAuNykpKSkpO1xuICAgICAgYm94LXNoYWRvdzogdmFyKC0tbWVkaWEtcHJldmlldy10aHVtYm5haWwtYm94LXNoYWRvdywgMCAwIDRweCByZ2IoMCAwIDAgLyAuMikpO1xuICAgICAgbWF4LXdpZHRoOiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC1tYXgtd2lkdGgsIDE4MHB4KTtcbiAgICAgIG1heC1oZWlnaHQ6IHZhcigtLW1lZGlhLXByZXZpZXctdGh1bWJuYWlsLW1heC1oZWlnaHQsIDE2MHB4KTtcbiAgICAgIG1pbi13aWR0aDogdmFyKC0tbWVkaWEtcHJldmlldy10aHVtYm5haWwtbWluLXdpZHRoLCAxMjBweCk7XG4gICAgICBtaW4taGVpZ2h0OiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRodW1ibmFpbC1taW4taGVpZ2h0LCA4MHB4KTtcbiAgICAgIGJvcmRlcjogdmFyKC0tbWVkaWEtcHJldmlldy10aHVtYm5haWwtYm9yZGVyKTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLW1lZGlhLXByZXZpZXctdGh1bWJuYWlsLWJvcmRlci1yYWRpdXMsXG4gICAgICAgIHZhcigtLW1lZGlhLXByZXZpZXctYm9yZGVyLXJhZGl1cykgdmFyKC0tbWVkaWEtcHJldmlldy1ib3JkZXItcmFkaXVzKSAwIDApO1xuICAgIH1cblxuICAgIDpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfSU1BR0V9XTpob3ZlcikgbWVkaWEtcHJldmlldy10aHVtYm5haWwsXG4gICAgOmhvc3QoWyR7TWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRX1dOmhvdmVyKSA6OnNsb3R0ZWQobWVkaWEtcHJldmlldy10aHVtYm5haWwpIHtcbiAgICAgIHRyYW5zaXRpb24tZGVsYXk6IHZhcigtLW1lZGlhLXByZXZpZXctdHJhbnNpdGlvbi1kZWxheS1pbiwgLjI1cyk7XG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgIH1cblxuICAgIG1lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5LFxuICAgIDo6c2xvdHRlZChtZWRpYS1wcmV2aWV3LXRpbWUtZGlzcGxheSkge1xuICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgJHtcIlwifVxuICAgICAgdHJhbnNpdGlvbjogbWluLXdpZHRoIDBzLCBib3JkZXItcmFkaXVzIDBzO1xuICAgICAgdHJhbnNpdGlvbi1kZWxheTogY2FsYyh2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZGVsYXktb3V0LCAwcykgKyB2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZHVyYXRpb24tb3V0LCAuMjVzKSk7XG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRpbWUtYmFja2dyb3VuZCwgdmFyKC0tbWVkaWEtcHJldmlldy1iYWNrZ3JvdW5kLCB2YXIoLS1tZWRpYS1jb250cm9sLWJhY2tncm91bmQsIHZhcigtLW1lZGlhLXNlY29uZGFyeS1jb2xvciwgcmdiKDIwIDIwIDMwIC8gLjcpKSkpKTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLW1lZGlhLXByZXZpZXctdGltZS1ib3JkZXItcmFkaXVzLFxuICAgICAgICB2YXIoLS1tZWRpYS1wcmV2aWV3LWJvcmRlci1yYWRpdXMpIHZhcigtLW1lZGlhLXByZXZpZXctYm9yZGVyLXJhZGl1cylcbiAgICAgICAgdmFyKC0tbWVkaWEtcHJldmlldy1ib3JkZXItcmFkaXVzKSB2YXIoLS1tZWRpYS1wcmV2aWV3LWJvcmRlci1yYWRpdXMpKTtcbiAgICAgIHBhZGRpbmc6IHZhcigtLW1lZGlhLXByZXZpZXctdGltZS1wYWRkaW5nLCAxcHggMTBweCAwKTtcbiAgICAgIG1hcmdpbjogdmFyKC0tbWVkaWEtcHJldmlldy10aW1lLW1hcmdpbiwgMCAwIDEwcHgpO1xuICAgICAgdGV4dC1zaGFkb3c6IHZhcigtLW1lZGlhLXByZXZpZXctdGltZS10ZXh0LXNoYWRvdywgMCAwIDRweCByZ2IoMCAwIDAgLyAuNzUpKTtcbiAgICB9XG5cbiAgICA6aG9zdChbJHtNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX0lNQUdFfV0pIG1lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5LFxuICAgIDpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfSU1BR0V9XSkgOjpzbG90dGVkKG1lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5KSB7XG4gICAgICB0cmFuc2l0aW9uLWRlbGF5OiB2YXIoLS1tZWRpYS1wcmV2aWV3LXRyYW5zaXRpb24tZGVsYXktaW4sIC4yNXMpO1xuICAgICAgbWluLXdpZHRoOiAxMDAlO1xuICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tbWVkaWEtcHJldmlldy10aW1lLWJvcmRlci1yYWRpdXMsXG4gICAgICAgIDAgMCB2YXIoLS1tZWRpYS1wcmV2aWV3LWJvcmRlci1yYWRpdXMpIHZhcigtLW1lZGlhLXByZXZpZXctYm9yZGVyLXJhZGl1cykpO1xuICAgIH1cblxuICAgIDpob3N0KFske01lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfVElNRX1dOmhvdmVyKSB7XG4gICAgICAtLW1lZGlhLXRpbWUtcmFuZ2UtaG92ZXItZGlzcGxheTogYmxvY2s7XG4gICAgfVxuICA8L3N0eWxlPlxuICA8ZGl2IGlkPVwicHJldmlldy1yYWlsXCI+XG4gICAgPHNsb3QgbmFtZT1cInByZXZpZXdcIiBwYXJ0PVwiYm94IHByZXZpZXctYm94XCI+XG4gICAgICA8bWVkaWEtcHJldmlldy10aHVtYm5haWw+PC9tZWRpYS1wcmV2aWV3LXRodW1ibmFpbD5cbiAgICAgIDxtZWRpYS1wcmV2aWV3LXRpbWUtZGlzcGxheT48L21lZGlhLXByZXZpZXctdGltZS1kaXNwbGF5PlxuICAgIDwvc2xvdD5cbiAgPC9kaXY+XG4gIDxkaXYgaWQ9XCJjdXJyZW50LXJhaWxcIj5cbiAgICA8c2xvdCBuYW1lPVwiY3VycmVudFwiIHBhcnQ9XCJib3ggY3VycmVudC1ib3hcIj5cbiAgICAgICR7XCJcIn1cbiAgICA8L3Nsb3Q+XG4gIDwvZGl2PlxuYDtcbmNsYXNzIE1lZGlhVGltZVJhbmdlIGV4dGVuZHMgTWVkaWFDaHJvbWVSYW5nZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZWRpYVNlZWthYmxlRW5kKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21lZGlhU2Vla2FibGVTdGFydCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRCb3hQb3NpdGlvbik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbmFibGVCb3hlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kaXNhYmxlQm94ZXMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYm94ZXMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcmV2aWV3Qm94LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VycmVudEJveCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2JveFBhZGRpbmdMZWZ0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYm94UGFkZGluZ1JpZ2h0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcG9pbnRlcm1vdmVIYW5kbGVyLCAoZXZ0KSA9PiB7XG4gICAgICBpZiAoWy4uLl9fcHJpdmF0ZUdldCh0aGlzLCBfYm94ZXMpXS5zb21lKChiKSA9PiBldnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoYikpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZVBvaW50ZXJCYXIoZXZ0KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5tZWRpYUR1cmF0aW9uO1xuICAgICAgaWYgKCFkdXJhdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcmFuZ2VSZWN0ID0gdGhpcy5yYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxldCBtb3VzZVJhdGlvID0gKGV2dC5jbGllbnRYIC0gcmFuZ2VSZWN0LmxlZnQgLSB0aGlzLnRodW1iV2lkdGggLyAyKSAvIChyYW5nZVJlY3Qud2lkdGggLSB0aGlzLnRodW1iV2lkdGgpO1xuICAgICAgbW91c2VSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG1vdXNlUmF0aW8pKTtcbiAgICAgIGNvbnN0IGJveFBvcyA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0Qm94UG9zaXRpb24sIGdldEJveFBvc2l0aW9uX2ZuKS5jYWxsKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfcHJldmlld0JveCksIG1vdXNlUmF0aW8pO1xuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCIjcHJldmlldy1yYWlsXCIpO1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtib3hQb3N9KWA7XG4gICAgICBjb25zdCBkZXRhaWwgPSBtb3VzZVJhdGlvICogZHVyYXRpb247XG4gICAgICBjb25zdCBtZWRpYVByZXZpZXdFdnQgPSBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChcbiAgICAgICAgTWVkaWFVSUV2ZW50cy5NRURJQV9QUkVWSUVXX1JFUVVFU1QsXG4gICAgICAgIHsgY29tcG9zZWQ6IHRydWUsIGJ1YmJsZXM6IHRydWUsIGRldGFpbCB9XG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG1lZGlhUHJldmlld0V2dCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yYW5nZUVudGVyZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29mZlJhbmdlSGFuZGxlciwgKGV2dCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFldnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXModGhpcykgfHwgWy4uLl9fcHJpdmF0ZUdldCh0aGlzLCBfYm94ZXMpXS5zb21lKChiKSA9PiBldnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoYikpKSB7XG4gICAgICAgIChfYSA9IGdsb2JhbFRoaXMud2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb2ZmUmFuZ2VIYW5kbGVyKSk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmFuZ2VFbnRlcmVkLCBmYWxzZSk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RvcFRyYWNraW5nTW91c2UpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90cmFja01vdXNlLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBnbG9iYWxUaGlzLndpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX3BvaW50ZXJtb3ZlSGFuZGxlciksIGZhbHNlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N0b3BUcmFja2luZ01vdXNlLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBnbG9iYWxUaGlzLndpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX3BvaW50ZXJtb3ZlSGFuZGxlcikpO1xuICAgICAgY29uc3QgZW5kRXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoTWVkaWFVSUV2ZW50cy5NRURJQV9QUkVWSUVXX1JFUVVFU1QsIHtcbiAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGRldGFpbDogbnVsbFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZ0KTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JhbmdlcG9pbnRlcm1vdmVIYW5kbGVyLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtZWRpYUR1cmF0aW9uU3RyID0gdGhpcy5nZXRBdHRyaWJ1dGUoXG4gICAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0RVUkFUSU9OXG4gICAgICApO1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX3JhbmdlRW50ZXJlZCkgJiYgbWVkaWFEdXJhdGlvblN0cikge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3JhbmdlRW50ZXJlZCwgdHJ1ZSk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHJhY2tNb3VzZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgKF9hID0gZ2xvYmFsVGhpcy53aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vZmZSYW5nZUhhbmRsZXIpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHRoaXMucmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlZnJlc2hJZCk7XG4gICAgICBjb25zdCBuZXdUaW1lID0gdGhpcy5yYW5nZS52YWx1ZTtcbiAgICAgIGNvbnN0IGRldGFpbCA9IG5ld1RpbWU7XG4gICAgICBjb25zdCBldnQgPSBuZXcgZ2xvYmFsVGhpcy5DdXN0b21FdmVudChNZWRpYVVJRXZlbnRzLk1FRElBX1NFRUtfUkVRVUVTVCwge1xuICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgZGV0YWlsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlZnJlc2hCYXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3VwZGF0ZVRpbWVzdGFtcCkgLyAxZTM7XG4gICAgICB0aGlzLnJhbmdlLnZhbHVlID0gdGhpcy5tZWRpYUN1cnJlbnRUaW1lICsgZGVsdGEgKiB0aGlzLm1lZGlhUGxheWJhY2tSYXRlO1xuICAgICAgdGhpcy51cGRhdGVCYXIoKTtcbiAgICAgIHRoaXMudXBkYXRlQ3VycmVudEJveCgpO1xuICAgICAgdGhpcy5fcmVmcmVzaElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlZnJlc2hCYXIpO1xuICAgIH07XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9ib3hlcywgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0fj1cImJveFwiXScpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3ByZXZpZXdCb3gsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdbcGFydH49XCJwcmV2aWV3LWJveFwiXScpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2N1cnJlbnRCb3gsIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdbcGFydH49XCJjdXJyZW50LWJveFwiXScpKTtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2JveFBhZGRpbmdMZWZ0LCBwYXJzZUludChcbiAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tbWVkaWEtYm94LXBhZGRpbmctbGVmdFwiKVxuICAgICkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYm94UGFkZGluZ1JpZ2h0LCBwYXJzZUludChcbiAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tbWVkaWEtYm94LXBhZGRpbmctcmlnaHRcIilcbiAgICApKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2VuYWJsZUJveGVzLCBlbmFibGVCb3hlc19mbikuY2FsbCh0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VELFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRFVSQVRJT04sXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TRUVLQUJMRSxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfSU1BR0UsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX1RJTUUsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9CVUZGRVJFRCxcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BMQVlCQUNLX1JBVEUsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9MT0FESU5HLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRU5ERURcbiAgICBdO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmFuZ2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBub3Vucy5TRUVLKCkpO1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVmcmVzaElkKTtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSB8fCBhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VEIHx8IGF0dHJOYW1lID09PSBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9FTkRFRCB8fCBhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTE9BRElORykge1xuICAgICAgdGhpcy5fdXBkYXRlVGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnJhbmdlLnZhbHVlID0gdGhpcy5tZWRpYUN1cnJlbnRUaW1lO1xuICAgICAgdXBkYXRlQXJpYVZhbHVlVGV4dCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlQmFyKCk7XG4gICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRCb3goKTtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlZnJlc2hJZCk7XG4gICAgICBpZiAoIXRoaXMubWVkaWFQYXVzZWQgJiYgIXRoaXMubWVkaWFMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZWZyZXNoQmFyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJOYW1lID09PSBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9EVVJBVElPTikge1xuICAgICAgdGhpcy5yYW5nZS5tYXggPSAoX2IgPSAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX21lZGlhU2Vla2FibGVFbmQsIG1lZGlhU2Vla2FibGVFbmRfZ2V0KSkgIT0gbnVsbCA/IF9hIDogdGhpcy5tZWRpYUR1cmF0aW9uKSAhPSBudWxsID8gX2IgOiAxZTM7XG4gICAgICB1cGRhdGVBcmlhVmFsdWVUZXh0KHRoaXMpO1xuICAgICAgdGhpcy51cGRhdGVCYXIoKTtcbiAgICAgIHRoaXMudXBkYXRlQ3VycmVudEJveCgpO1xuICAgIH1cbiAgICBpZiAoYXR0ck5hbWUgPT09IE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NFRUtBQkxFKSB7XG4gICAgICB0aGlzLnJhbmdlLm1pbiA9IChfYyA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVkaWFTZWVrYWJsZVN0YXJ0LCBtZWRpYVNlZWthYmxlU3RhcnRfZ2V0KSkgIT0gbnVsbCA/IF9jIDogMDtcbiAgICAgIHRoaXMucmFuZ2UubWF4ID0gKF9lID0gKF9kID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZWRpYVNlZWthYmxlRW5kLCBtZWRpYVNlZWthYmxlRW5kX2dldCkpICE9IG51bGwgPyBfZCA6IHRoaXMubWVkaWFEdXJhdGlvbikgIT0gbnVsbCA/IF9lIDogMWUzO1xuICAgICAgdXBkYXRlQXJpYVZhbHVlVGV4dCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlQmFyKCk7XG4gICAgfVxuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQlVGRkVSRUQpIHtcbiAgICAgIHRoaXMudXBkYXRlQmFyKCk7XG4gICAgfVxuICAgIGlmIChhdHRyTmFtZSA9PT0gXCJkaXNhYmxlZFwiKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2VuYWJsZUJveGVzLCBlbmFibGVCb3hlc19mbikuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZGlzYWJsZUJveGVzLCBkaXNhYmxlQm94ZXNfZm4pLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgfVxuICBnZXQgbWVkaWFQYXVzZWQoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BBVVNFRCk7XG4gIH1cbiAgc2V0IG1lZGlhUGF1c2VkKHZhbHVlKSB7XG4gICAgc2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUEFVU0VELCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhTG9hZGluZygpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkF0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTE9BRElORyk7XG4gIH1cbiAgc2V0IG1lZGlhTG9hZGluZyh2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0xPQURJTkcsIHZhbHVlKTtcbiAgfVxuICBnZXQgbWVkaWFEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRFVSQVRJT04pO1xuICB9XG4gIHNldCBtZWRpYUR1cmF0aW9uKHZhbHVlKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfRFVSQVRJT04sIHZhbHVlKTtcbiAgfVxuICBnZXQgbWVkaWFDdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQ1VSUkVOVF9USU1FKTtcbiAgfVxuICBzZXQgbWVkaWFDdXJyZW50VGltZSh2YWx1ZSkge1xuICAgIHNldE51bWVyaWNBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0NVUlJFTlRfVElNRSwgdmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYVBsYXliYWNrUmF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUExBWUJBQ0tfUkFURSwgMSk7XG4gIH1cbiAgc2V0IG1lZGlhUGxheWJhY2tSYXRlKHZhbHVlKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUExBWUJBQ0tfUkFURSwgdmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYUJ1ZmZlcmVkKCkge1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5nZXRBdHRyaWJ1dGUoTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQlVGRkVSRUQpO1xuICAgIGlmICghYnVmZmVyZWQpXG4gICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIGJ1ZmZlcmVkLnNwbGl0KFwiIFwiKS5tYXAoKHRpbWVQYWlyKSA9PiB0aW1lUGFpci5zcGxpdChcIjpcIikubWFwKCh0aW1lU3RyKSA9PiArdGltZVN0cikpO1xuICB9XG4gIHNldCBtZWRpYUJ1ZmZlcmVkKGxpc3QpIHtcbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0JVRkZFUkVEKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RyVmFsID0gbGlzdC5tYXAoKG4xLCBuMikgPT4gYCR7bjF9OiR7bjJ9YCkuam9pbihcIiBcIik7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfQlVGRkVSRUQsIHN0clZhbCk7XG4gIH1cbiAgZ2V0IG1lZGlhU2Vla2FibGUoKSB7XG4gICAgY29uc3Qgc2Vla2FibGUgPSB0aGlzLmdldEF0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TRUVLQUJMRSk7XG4gICAgaWYgKCFzZWVrYWJsZSlcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHNlZWthYmxlLnNwbGl0KFwiOlwiKS5tYXAoKHRpbWUpID0+ICt0aW1lKTtcbiAgfVxuICBzZXQgbWVkaWFTZWVrYWJsZShyYW5nZSkge1xuICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9TRUVLQUJMRSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NFRUtBQkxFLCByYW5nZS5qb2luKFwiOlwiKSk7XG4gIH1cbiAgZ2V0IG1lZGlhUHJldmlld0ltYWdlKCkge1xuICAgIHJldHVybiBnZXRTdHJpbmdBdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1BSRVZJRVdfSU1BR0UpO1xuICB9XG4gIHNldCBtZWRpYVByZXZpZXdJbWFnZSh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19JTUFHRSwgdmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYVByZXZpZXdUaW1lKCkge1xuICAgIHJldHVybiBnZXROdW1lcmljQXR0cih0aGlzLCBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9QUkVWSUVXX1RJTUUpO1xuICB9XG4gIHNldCBtZWRpYVByZXZpZXdUaW1lKHZhbHVlKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfUFJFVklFV19USU1FLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhRW5kZWQoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0VOREVEKTtcbiAgfVxuICBzZXQgbWVkaWFFbmRlZCh2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX0VOREVELCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmVsYXRpdmVWYWx1ZXMoKSB7XG4gICAgY29uc3QgZGVmYXVsdFJlbGF0aXZlVmFsdWVzID0gc3VwZXIuZ2V0UmVsYXRpdmVWYWx1ZXMoKTtcbiAgICBpZiAoIXRoaXMubWVkaWFFbmRlZClcbiAgICAgIHJldHVybiBkZWZhdWx0UmVsYXRpdmVWYWx1ZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRSZWxhdGl2ZVZhbHVlcyxcbiAgICAgIHJlbGF0aXZlVmFsdWU6IGRlZmF1bHRSZWxhdGl2ZVZhbHVlcy5yZWxhdGl2ZU1heFxuICAgIH07XG4gIH1cbiAgZ2V0QmFyQ29sb3JzKCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgY29sb3JzQXJyYXkgPSBzdXBlci5nZXRCYXJDb2xvcnMoKTtcbiAgICBjb25zdCB7IHJhbmdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlbGF0aXZlTWF4ID0gcmFuZ2UubWF4IC0gcmFuZ2UubWluO1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5tZWRpYUJ1ZmZlcmVkO1xuICAgIGlmICghYnVmZmVyZWQubGVuZ3RoIHx8ICFOdW1iZXIuaXNGaW5pdGUocmVsYXRpdmVNYXgpIHx8IHJlbGF0aXZlTWF4IDw9IDApIHtcbiAgICAgIHJldHVybiBjb2xvcnNBcnJheTtcbiAgICB9XG4gICAgbGV0IHJlbGF0aXZlQnVmZmVyZWRFbmQ7XG4gICAgaWYgKCF0aGlzLm1lZGlhRW5kZWQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYUN1cnJlbnRUaW1lO1xuICAgICAgY29uc3QgWywgYnVmZmVyZWRFbmQgPSByYW5nZS5taW5dID0gKF9hID0gYnVmZmVyZWQuZmluZChcbiAgICAgICAgKFtzdGFydCwgZW5kXSkgPT4gc3RhcnQgPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPD0gZW5kXG4gICAgICApKSAhPSBudWxsID8gX2EgOiBbXTtcbiAgICAgIHJlbGF0aXZlQnVmZmVyZWRFbmQgPSBidWZmZXJlZEVuZCAtIHJhbmdlLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXRpdmVCdWZmZXJlZEVuZCA9IHJlbGF0aXZlTWF4O1xuICAgIH1cbiAgICBjb25zdCBidWZmUGVyY2VudCA9IHJlbGF0aXZlQnVmZmVyZWRFbmQgLyByZWxhdGl2ZU1heCAqIDEwMDtcbiAgICBjb2xvcnNBcnJheS5zcGxpY2UoMSwgMCwgW1xuICAgICAgXCJ2YXIoLS1tZWRpYS10aW1lLXJhbmdlLWJ1ZmZlcmVkLWNvbG9yLCByZ2IoMjU1IDI1NSAyNTUgLyAuNCkpXCIsXG4gICAgICBidWZmUGVyY2VudFxuICAgIF0pO1xuICAgIHJldHVybiBjb2xvcnNBcnJheTtcbiAgfVxuICB1cGRhdGVDdXJyZW50Qm94KCkge1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50Qm94KS5hc3NpZ25lZEVsZW1lbnRzKCkubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJveFJhdGlvID0gdGhpcy5yYW5nZS52YWx1ZSAvICh0aGlzLnJhbmdlLm1heCAtIHRoaXMucmFuZ2UubWluKTtcbiAgICBjb25zdCBib3hQb3MgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldEJveFBvc2l0aW9uLCBnZXRCb3hQb3NpdGlvbl9mbikuY2FsbCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2N1cnJlbnRCb3gpLCBib3hSYXRpbyk7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gZ2V0T3JJbnNlcnRDU1NSdWxlKHRoaXMuc2hhZG93Um9vdCwgXCIjY3VycmVudC1yYWlsXCIpO1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7Ym94UG9zfSlgO1xuICB9XG59XG5fYm94ZXMgPSBuZXcgV2Vha01hcCgpO1xuX3ByZXZpZXdCb3ggPSBuZXcgV2Vha01hcCgpO1xuX2N1cnJlbnRCb3ggPSBuZXcgV2Vha01hcCgpO1xuX2JveFBhZGRpbmdMZWZ0ID0gbmV3IFdlYWtNYXAoKTtcbl9ib3hQYWRkaW5nUmlnaHQgPSBuZXcgV2Vha01hcCgpO1xuX21lZGlhU2Vla2FibGVFbmQgPSBuZXcgV2Vha1NldCgpO1xubWVkaWFTZWVrYWJsZUVuZF9nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBbLCBlbmRdID0gKF9hID0gdGhpcy5tZWRpYVNlZWthYmxlKSAhPSBudWxsID8gX2EgOiBbXTtcbiAgcmV0dXJuIGVuZDtcbn07XG5fbWVkaWFTZWVrYWJsZVN0YXJ0ID0gbmV3IFdlYWtTZXQoKTtcbm1lZGlhU2Vla2FibGVTdGFydF9nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBbc3RhcnRdID0gKF9hID0gdGhpcy5tZWRpYVNlZWthYmxlKSAhPSBudWxsID8gX2EgOiBbXTtcbiAgcmV0dXJuIHN0YXJ0O1xufTtcbl9nZXRCb3hQb3NpdGlvbiA9IG5ldyBXZWFrU2V0KCk7XG5nZXRCb3hQb3NpdGlvbl9mbiA9IGZ1bmN0aW9uKGJveCwgcmF0aW8pIHtcbiAgdmFyIF9hO1xuICBsZXQgcG9zaXRpb24gPSBgJHtyYXRpbyAqIDEwMCAqIDEwMH0lYDtcbiAgY29uc3QgYm94V2lkdGggPSBib3gub2Zmc2V0V2lkdGg7XG4gIGlmICghYm94V2lkdGgpXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICBjb25zdCBib3VuZHMgPSAoX2EgPSB0aGlzLmdldEF0dHJpYnV0ZShcImJvdW5kc1wiKSA/IGNsb3Nlc3RDb21wb3NlZE5vZGUodGhpcywgYCMke3RoaXMuZ2V0QXR0cmlidXRlKFwiYm91bmRzXCIpfWApIDogdGhpcy5wYXJlbnRFbGVtZW50KSAhPSBudWxsID8gX2EgOiB0aGlzO1xuICBjb25zdCByYW5nZVJlY3QgPSB0aGlzLnJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBtZWRpYUJvdW5kc1JlY3QgPSBib3VuZHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGJveE1pbiA9IChfX3ByaXZhdGVHZXQodGhpcywgX2JveFBhZGRpbmdMZWZ0KSAtIChyYW5nZVJlY3QubGVmdCAtIG1lZGlhQm91bmRzUmVjdC5sZWZ0IC0gYm94V2lkdGggLyAyKSkgLyByYW5nZVJlY3Qud2lkdGggKiAxMDA7XG4gIGNvbnN0IGJveE1heCA9IChtZWRpYUJvdW5kc1JlY3QucmlnaHQgLSByYW5nZVJlY3QubGVmdCAtIGJveFdpZHRoIC8gMiAtIF9fcHJpdmF0ZUdldCh0aGlzLCBfYm94UGFkZGluZ1JpZ2h0KSkgLyByYW5nZVJlY3Qud2lkdGggKiAxMDA7XG4gIGlmICghTnVtYmVyLmlzTmFOKGJveE1pbikpXG4gICAgcG9zaXRpb24gPSBgbWF4KCR7Ym94TWluICogMTAwfSUsICR7cG9zaXRpb259KWA7XG4gIGlmICghTnVtYmVyLmlzTmFOKGJveE1heCkpXG4gICAgcG9zaXRpb24gPSBgbWluKCR7cG9zaXRpb259LCAke2JveE1heCAqIDEwMH0lKWA7XG4gIHJldHVybiBwb3NpdGlvbjtcbn07XG5fcG9pbnRlcm1vdmVIYW5kbGVyID0gbmV3IFdlYWtNYXAoKTtcbl9yYW5nZUVudGVyZWQgPSBuZXcgV2Vha01hcCgpO1xuX29mZlJhbmdlSGFuZGxlciA9IG5ldyBXZWFrTWFwKCk7XG5fdHJhY2tNb3VzZSA9IG5ldyBXZWFrTWFwKCk7XG5fc3RvcFRyYWNraW5nTW91c2UgPSBuZXcgV2Vha01hcCgpO1xuX3JhbmdlcG9pbnRlcm1vdmVIYW5kbGVyID0gbmV3IFdlYWtNYXAoKTtcbl9lbmFibGVCb3hlcyA9IG5ldyBXZWFrU2V0KCk7XG5lbmFibGVCb3hlc19mbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX3JhbmdlcG9pbnRlcm1vdmVIYW5kbGVyKSwgZmFsc2UpO1xufTtcbl9kaXNhYmxlQm94ZXMgPSBuZXcgV2Vha1NldCgpO1xuZGlzYWJsZUJveGVzX2ZuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfYTtcbiAgKF9hID0gZ2xvYmFsVGhpcy53aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vZmZSYW5nZUhhbmRsZXIpKTtcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9yYW5nZXBvaW50ZXJtb3ZlSGFuZGxlcikpO1xuICBfX3ByaXZhdGVTZXQodGhpcywgX3JhbmdlRW50ZXJlZCwgZmFsc2UpO1xuICBfX3ByaXZhdGVHZXQodGhpcywgX3N0b3BUcmFja2luZ01vdXNlKS5jYWxsKHRoaXMpO1xufTtcbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS10aW1lLXJhbmdlXCIpKSB7XG4gIGdsb2JhbFRoaXMuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWVkaWEtdGltZS1yYW5nZVwiLCBNZWRpYVRpbWVSYW5nZSk7XG59XG52YXIgbWVkaWFfdGltZV9yYW5nZV9kZWZhdWx0ID0gTWVkaWFUaW1lUmFuZ2U7XG5leHBvcnQge1xuICBtZWRpYV90aW1lX3JhbmdlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-time-range.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/media-volume-range.js":
/*!**************************************************************!*\
  !*** ./node_modules/media-chrome/dist/media-volume-range.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ media_volume_range_default; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./media-chrome-range.js */ \"(app-client)/./node_modules/media-chrome/dist/media-chrome-range.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n/* harmony import */ var _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels/labels.js */ \"(app-client)/./node_modules/media-chrome/dist/labels/labels.js\");\n/* harmony import */ var _utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/element-utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\");\n\n\n\n\n\nconst DEFAULT_MAX_VOLUME = 100;\nconst DEFAULT_VOLUME = 1;\nconst toVolume = (el) => {\n  if (el.mediaMuted)\n    return 0;\n  return Math.round(el.mediaVolume * el.range.max);\n};\nconst formatAsPercentString = ({ value, max }) => `${Math.round(value / max * 100)}%`;\nclass MediaVolumeRange extends _media_chrome_range_js__WEBPACK_IMPORTED_MODULE_1__.MediaChromeRange {\n  static get observedAttributes() {\n    return [\n      ...super.observedAttributes,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_MUTED,\n      _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE\n    ];\n  }\n  constructor() {\n    super();\n    this.range.max = DEFAULT_MAX_VOLUME;\n    this.range.addEventListener(\"input\", () => {\n      const newVolume = this.range.value / this.range.max;\n      const detail = newVolume;\n      const evt = new _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIEvents.MEDIA_VOLUME_REQUEST, {\n        composed: true,\n        bubbles: true,\n        detail\n      });\n      this.dispatchEvent(evt);\n    });\n  }\n  connectedCallback() {\n    this.range.setAttribute(\"aria-label\", _labels_labels_js__WEBPACK_IMPORTED_MODULE_3__.nouns.VOLUME());\n    super.connectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME || attrName === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_MUTED) {\n      const newVolume = toVolume(this);\n      this.range.value = newVolume;\n      this.range.setAttribute(\n        \"aria-valuetext\",\n        formatAsPercentString(this.range)\n      );\n      this.updateBar();\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  get mediaVolume() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME, DEFAULT_VOLUME);\n  }\n  set mediaVolume(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setNumericAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME, value);\n  }\n  get mediaMuted() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_MUTED);\n  }\n  set mediaMuted(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBooleanAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_MUTED, value);\n  }\n  get mediaVolumeUnavailable() {\n    return (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.getStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE);\n  }\n  set mediaVolumeUnavailable(value) {\n    (0,_utils_element_utils_js__WEBPACK_IMPORTED_MODULE_4__.setStringAttr)(this, _constants_js__WEBPACK_IMPORTED_MODULE_2__.MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE, value);\n  }\n}\nif (!_utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.get(\"media-volume-range\")) {\n  _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.customElements.define(\"media-volume-range\", MediaVolumeRange);\n}\nvar media_volume_range_default = MediaVolumeRange;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L21lZGlhLXZvbHVtZS1yYW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEQ7QUFDRDtBQUNPO0FBQ3ZCO0FBUVQ7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWSxRQUFRLDhCQUE4QjtBQUNuRiwrQkFBK0Isb0VBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUVBQVUsYUFBYSx3REFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQyxvREFBSztBQUMvQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWlCLDhCQUE4Qiw0REFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsdUVBQWMsT0FBTyw0REFBaUI7QUFDakQ7QUFDQTtBQUNBLElBQUksdUVBQWMsT0FBTyw0REFBaUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsc0VBQWEsT0FBTyw0REFBaUI7QUFDaEQ7QUFDQTtBQUNBLElBQUksc0VBQWEsT0FBTyw0REFBaUI7QUFDekM7QUFDQTtBQUNBLEtBQUsscUVBQVU7QUFDZixFQUFFLHFFQUFVO0FBQ1o7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC9tZWRpYS12b2x1bWUtcmFuZ2UuanM/NDc2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbG9iYWxUaGlzIH0gZnJvbSBcIi4vdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgTWVkaWFDaHJvbWVSYW5nZSB9IGZyb20gXCIuL21lZGlhLWNocm9tZS1yYW5nZS5qc1wiO1xuaW1wb3J0IHsgTWVkaWFVSUF0dHJpYnV0ZXMsIE1lZGlhVUlFdmVudHMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IG5vdW5zIH0gZnJvbSBcIi4vbGFiZWxzL2xhYmVscy5qc1wiO1xuaW1wb3J0IHtcbiAgZ2V0Qm9vbGVhbkF0dHIsXG4gIGdldE51bWVyaWNBdHRyLFxuICBnZXRTdHJpbmdBdHRyLFxuICBzZXRCb29sZWFuQXR0cixcbiAgc2V0TnVtZXJpY0F0dHIsXG4gIHNldFN0cmluZ0F0dHJcbn0gZnJvbSBcIi4vdXRpbHMvZWxlbWVudC11dGlscy5qc1wiO1xuY29uc3QgREVGQVVMVF9NQVhfVk9MVU1FID0gMTAwO1xuY29uc3QgREVGQVVMVF9WT0xVTUUgPSAxO1xuY29uc3QgdG9Wb2x1bWUgPSAoZWwpID0+IHtcbiAgaWYgKGVsLm1lZGlhTXV0ZWQpXG4gICAgcmV0dXJuIDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKGVsLm1lZGlhVm9sdW1lICogZWwucmFuZ2UubWF4KTtcbn07XG5jb25zdCBmb3JtYXRBc1BlcmNlbnRTdHJpbmcgPSAoeyB2YWx1ZSwgbWF4IH0pID0+IGAke01hdGgucm91bmQodmFsdWUgLyBtYXggKiAxMDApfSVgO1xuY2xhc3MgTWVkaWFWb2x1bWVSYW5nZSBleHRlbmRzIE1lZGlhQ2hyb21lUmFuZ2Uge1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FLFxuICAgICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfTVVURUQsXG4gICAgICBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9WT0xVTUVfVU5BVkFJTEFCTEVcbiAgICBdO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yYW5nZS5tYXggPSBERUZBVUxUX01BWF9WT0xVTUU7XG4gICAgdGhpcy5yYW5nZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbmV3Vm9sdW1lID0gdGhpcy5yYW5nZS52YWx1ZSAvIHRoaXMucmFuZ2UubWF4O1xuICAgICAgY29uc3QgZGV0YWlsID0gbmV3Vm9sdW1lO1xuICAgICAgY29uc3QgZXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoTWVkaWFVSUV2ZW50cy5NRURJQV9WT0xVTUVfUkVRVUVTVCwge1xuICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgZGV0YWlsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmFuZ2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBub3Vucy5WT0xVTUUoKSk7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChhdHRyTmFtZSA9PT0gTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FIHx8IGF0dHJOYW1lID09PSBNZWRpYVVJQXR0cmlidXRlcy5NRURJQV9NVVRFRCkge1xuICAgICAgY29uc3QgbmV3Vm9sdW1lID0gdG9Wb2x1bWUodGhpcyk7XG4gICAgICB0aGlzLnJhbmdlLnZhbHVlID0gbmV3Vm9sdW1lO1xuICAgICAgdGhpcy5yYW5nZS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIFwiYXJpYS12YWx1ZXRleHRcIixcbiAgICAgICAgZm9ybWF0QXNQZXJjZW50U3RyaW5nKHRoaXMucmFuZ2UpXG4gICAgICApO1xuICAgICAgdGhpcy51cGRhdGVCYXIoKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICB9XG4gIGdldCBtZWRpYVZvbHVtZSgpIHtcbiAgICByZXR1cm4gZ2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FLCBERUZBVUxUX1ZPTFVNRSk7XG4gIH1cbiAgc2V0IG1lZGlhVm9sdW1lKHZhbHVlKSB7XG4gICAgc2V0TnVtZXJpY0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhTXV0ZWQoKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX01VVEVEKTtcbiAgfVxuICBzZXQgbWVkaWFNdXRlZCh2YWx1ZSkge1xuICAgIHNldEJvb2xlYW5BdHRyKHRoaXMsIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX01VVEVELCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IG1lZGlhVm9sdW1lVW5hdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIGdldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FX1VOQVZBSUxBQkxFKTtcbiAgfVxuICBzZXQgbWVkaWFWb2x1bWVVbmF2YWlsYWJsZSh2YWx1ZSkge1xuICAgIHNldFN0cmluZ0F0dHIodGhpcywgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfVk9MVU1FX1VOQVZBSUxBQkxFLCB2YWx1ZSk7XG4gIH1cbn1cbmlmICghZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJtZWRpYS12b2x1bWUtcmFuZ2VcIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtZWRpYS12b2x1bWUtcmFuZ2VcIiwgTWVkaWFWb2x1bWVSYW5nZSk7XG59XG52YXIgbWVkaWFfdm9sdW1lX3JhbmdlX2RlZmF1bHQgPSBNZWRpYVZvbHVtZVJhbmdlO1xuZXhwb3J0IHtcbiAgbWVkaWFfdm9sdW1lX3JhbmdlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/media-volume-range.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/attribute-token-list.js":
/*!**********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/attribute-token-list.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttributeTokenList: function() { return /* binding */ AttributeTokenList; }\n/* harmony export */ });\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _el, _attr, _defaultSet, _tokenSet, _tokens, tokens_get;\nclass AttributeTokenList {\n  constructor(el, attr, { defaultValue } = { defaultValue: void 0 }) {\n    __privateAdd(this, _tokens);\n    __privateAdd(this, _el, void 0);\n    __privateAdd(this, _attr, void 0);\n    __privateAdd(this, _defaultSet, void 0);\n    __privateAdd(this, _tokenSet, /* @__PURE__ */ new Set());\n    __privateSet(this, _el, el);\n    __privateSet(this, _attr, attr);\n    __privateSet(this, _defaultSet, new Set(defaultValue));\n  }\n  [Symbol.iterator]() {\n    return __privateGet(this, _tokens, tokens_get).values();\n  }\n  get length() {\n    return __privateGet(this, _tokens, tokens_get).size;\n  }\n  get value() {\n    var _a;\n    return (_a = [...__privateGet(this, _tokens, tokens_get)].join(\" \")) != null ? _a : \"\";\n  }\n  set value(val) {\n    var _a;\n    if (val === this.value)\n      return;\n    __privateSet(this, _tokenSet, /* @__PURE__ */ new Set());\n    this.add(...(_a = val == null ? void 0 : val.split(\" \")) != null ? _a : []);\n  }\n  toString() {\n    return this.value;\n  }\n  item(index) {\n    return [...__privateGet(this, _tokens, tokens_get)][index];\n  }\n  values() {\n    return __privateGet(this, _tokens, tokens_get).values();\n  }\n  forEach(callback) {\n    __privateGet(this, _tokens, tokens_get).forEach(callback);\n  }\n  add(...tokens) {\n    var _a, _b;\n    tokens.forEach((t) => __privateGet(this, _tokenSet).add(t));\n    if (this.value === \"\" && !((_a = __privateGet(this, _el)) == null ? void 0 : _a.hasAttribute(`${__privateGet(this, _attr)}`))) {\n      return;\n    }\n    (_b = __privateGet(this, _el)) == null ? void 0 : _b.setAttribute(`${__privateGet(this, _attr)}`, `${this.value}`);\n  }\n  remove(...tokens) {\n    var _a;\n    tokens.forEach((t) => __privateGet(this, _tokenSet).delete(t));\n    (_a = __privateGet(this, _el)) == null ? void 0 : _a.setAttribute(`${__privateGet(this, _attr)}`, `${this.value}`);\n  }\n  contains(token) {\n    return __privateGet(this, _tokens, tokens_get).has(token);\n  }\n  toggle(token, force) {\n    if (typeof force !== \"undefined\") {\n      if (force) {\n        this.add(token);\n        return true;\n      } else {\n        this.remove(token);\n        return false;\n      }\n    }\n    if (this.contains(token)) {\n      this.remove(token);\n      return false;\n    }\n    this.add(token);\n    return true;\n  }\n  replace(oldToken, newToken) {\n    this.remove(oldToken);\n    this.add(newToken);\n    return oldToken === newToken;\n  }\n}\n_el = new WeakMap();\n_attr = new WeakMap();\n_defaultSet = new WeakMap();\n_tokenSet = new WeakMap();\n_tokens = new WeakSet();\ntokens_get = function() {\n  return __privateGet(this, _tokenSet).size ? __privateGet(this, _tokenSet) : __privateGet(this, _defaultSet);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2F0dHJpYnV0ZS10b2tlbi1saXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsSUFBSSxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRywwQkFBMEI7QUFDOUg7QUFDQTtBQUNBLHlFQUF5RSwwQkFBMEIsTUFBTSxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBCQUEwQixNQUFNLFdBQVc7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2F0dHJpYnV0ZS10b2tlbi1saXN0LmpzPzYxMjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX2VsLCBfYXR0ciwgX2RlZmF1bHRTZXQsIF90b2tlblNldCwgX3Rva2VucywgdG9rZW5zX2dldDtcbmNsYXNzIEF0dHJpYnV0ZVRva2VuTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGVsLCBhdHRyLCB7IGRlZmF1bHRWYWx1ZSB9ID0geyBkZWZhdWx0VmFsdWU6IHZvaWQgMCB9KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90b2tlbnMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZWwsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hdHRyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGVmYXVsdFNldCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Rva2VuU2V0LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2VsLCBlbCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9hdHRyLCBhdHRyKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RlZmF1bHRTZXQsIG5ldyBTZXQoZGVmYXVsdFZhbHVlKSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdG9rZW5zLCB0b2tlbnNfZ2V0KS52YWx1ZXMoKTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3Rva2VucywgdG9rZW5zX2dldCkuc2l6ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBbLi4uX19wcml2YXRlR2V0KHRoaXMsIF90b2tlbnMsIHRva2Vuc19nZXQpXS5qb2luKFwiIFwiKSkgIT0gbnVsbCA/IF9hIDogXCJcIjtcbiAgfVxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh2YWwgPT09IHRoaXMudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90b2tlblNldCwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgdGhpcy5hZGQoLi4uKF9hID0gdmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwuc3BsaXQoXCIgXCIpKSAhPSBudWxsID8gX2EgOiBbXSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbiAgaXRlbShpbmRleCkge1xuICAgIHJldHVybiBbLi4uX19wcml2YXRlR2V0KHRoaXMsIF90b2tlbnMsIHRva2Vuc19nZXQpXVtpbmRleF07XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3Rva2VucywgdG9rZW5zX2dldCkudmFsdWVzKCk7XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdG9rZW5zLCB0b2tlbnNfZ2V0KS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuICBhZGQoLi4udG9rZW5zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0b2tlbnMuZm9yRWFjaCgodCkgPT4gX19wcml2YXRlR2V0KHRoaXMsIF90b2tlblNldCkuYWRkKHQpKTtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJcIiAmJiAhKChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZWwpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKGAke19fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cil9YCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChfYiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZWwpKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2V0QXR0cmlidXRlKGAke19fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cil9YCwgYCR7dGhpcy52YWx1ZX1gKTtcbiAgfVxuICByZW1vdmUoLi4udG9rZW5zKSB7XG4gICAgdmFyIF9hO1xuICAgIHRva2Vucy5mb3JFYWNoKCh0KSA9PiBfX3ByaXZhdGVHZXQodGhpcywgX3Rva2VuU2V0KS5kZWxldGUodCkpO1xuICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZWwpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKGAke19fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cil9YCwgYCR7dGhpcy52YWx1ZX1gKTtcbiAgfVxuICBjb250YWlucyh0b2tlbikge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3Rva2VucywgdG9rZW5zX2dldCkuaGFzKHRva2VuKTtcbiAgfVxuICB0b2dnbGUodG9rZW4sIGZvcmNlKSB7XG4gICAgaWYgKHR5cGVvZiBmb3JjZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuYWRkKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZSh0b2tlbik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGFpbnModG9rZW4pKSB7XG4gICAgICB0aGlzLnJlbW92ZSh0b2tlbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuYWRkKHRva2VuKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXBsYWNlKG9sZFRva2VuLCBuZXdUb2tlbikge1xuICAgIHRoaXMucmVtb3ZlKG9sZFRva2VuKTtcbiAgICB0aGlzLmFkZChuZXdUb2tlbik7XG4gICAgcmV0dXJuIG9sZFRva2VuID09PSBuZXdUb2tlbjtcbiAgfVxufVxuX2VsID0gbmV3IFdlYWtNYXAoKTtcbl9hdHRyID0gbmV3IFdlYWtNYXAoKTtcbl9kZWZhdWx0U2V0ID0gbmV3IFdlYWtNYXAoKTtcbl90b2tlblNldCA9IG5ldyBXZWFrTWFwKCk7XG5fdG9rZW5zID0gbmV3IFdlYWtTZXQoKTtcbnRva2Vuc19nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdG9rZW5TZXQpLnNpemUgPyBfX3ByaXZhdGVHZXQodGhpcywgX3Rva2VuU2V0KSA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVmYXVsdFNldCk7XG59O1xuZXhwb3J0IHtcbiAgQXR0cmlidXRlVG9rZW5MaXN0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/attribute-token-list.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/captions.js":
/*!**********************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/captions.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areSubsOn: function() { return /* binding */ areSubsOn; },\n/* harmony export */   formatTextTrackObj: function() { return /* binding */ formatTextTrackObj; },\n/* harmony export */   getTextTracksList: function() { return /* binding */ getTextTracksList; },\n/* harmony export */   isMatchingPropOf: function() { return /* binding */ isMatchingPropOf; },\n/* harmony export */   parseTextTrackStr: function() { return /* binding */ parseTextTrackStr; },\n/* harmony export */   parseTextTracksStr: function() { return /* binding */ parseTextTracksStr; },\n/* harmony export */   parseTracks: function() { return /* binding */ parseTracks; },\n/* harmony export */   splitTextTracksStr: function() { return /* binding */ splitTextTracksStr; },\n/* harmony export */   stringifyTextTrackList: function() { return /* binding */ stringifyTextTrackList; },\n/* harmony export */   textTrackObjAsPred: function() { return /* binding */ textTrackObjAsPred; },\n/* harmony export */   toggleSubsCaps: function() { return /* binding */ toggleSubsCaps; },\n/* harmony export */   updateTracksModeTo: function() { return /* binding */ updateTracksModeTo; }\n/* harmony export */ });\n/* harmony import */ var _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(app-client)/./node_modules/media-chrome/dist/constants.js\");\n\n\nconst splitTextTracksStr = (textTracksStr = \"\") => textTracksStr.split(/\\s+/);\nconst parseTextTrackStr = (textTrackStr = \"\") => {\n  let [kind, language, encodedLabel] = textTrackStr.split(\":\");\n  const label = encodedLabel ? decodeURIComponent(encodedLabel) : void 0;\n  kind = kind === \"cc\" ? \"captions\" : \"subtitles\";\n  return {\n    kind,\n    language,\n    label\n  };\n};\nconst parseTextTracksStr = (textTracksStr = \"\", textTrackLikeObj = {}) => {\n  return splitTextTracksStr(textTracksStr).map((textTrackStr) => {\n    const textTrackObj = parseTextTrackStr(textTrackStr);\n    return {\n      ...textTrackLikeObj,\n      ...textTrackObj\n    };\n  });\n};\nconst parseTracks = (trackOrTracks) => {\n  if (Array.isArray(trackOrTracks)) {\n    return trackOrTracks.map((trackObjOrStr) => {\n      if (typeof trackObjOrStr === \"string\") {\n        return parseTextTrackStr(trackObjOrStr);\n      }\n      return trackObjOrStr;\n    });\n  }\n  if (typeof trackOrTracks === \"string\") {\n    return parseTextTracksStr(trackOrTracks);\n  }\n  return [trackOrTracks];\n};\nconst formatTextTrackObj = ({ kind, label, language } = { kind: \"subtitles\" }) => {\n  if (!label)\n    return language;\n  return `${kind === \"captions\" ? \"cc\" : \"sb\"}:${language}:${encodeURIComponent(label)}`;\n};\nconst stringifyTextTrackList = (textTracks = []) => {\n  return Array.prototype.map.call(textTracks, formatTextTrackObj).join(\" \");\n};\nconst isMatchingPropOf = (key, value) => (obj) => obj[key] === value;\nconst textTrackObjAsPred = (filterObj) => {\n  const preds = Object.entries(filterObj).map(([key, value]) => {\n    return isMatchingPropOf(key, value);\n  });\n  return (textTrack) => preds.every((pred) => pred(textTrack));\n};\nconst updateTracksModeTo = (mode, tracks = [], tracksToUpdate = []) => {\n  const preds = parseTracks(tracksToUpdate).map(textTrackObjAsPred);\n  const isTrackToUpdate = (textTrack) => {\n    return preds.some((pred) => pred(textTrack));\n  };\n  Array.from(tracks).filter(isTrackToUpdate).forEach((textTrack) => {\n    textTrack.mode = mode;\n  });\n};\nconst getTextTracksList = (media, filterPredOrObj = () => true) => {\n  if (!(media == null ? void 0 : media.textTracks))\n    return [];\n  const filterPred = typeof filterPredOrObj === \"function\" ? filterPredOrObj : textTrackObjAsPred(filterPredOrObj);\n  return Array.from(media.textTracks).filter(filterPred);\n};\nconst areSubsOn = (el) => {\n  const showingSubtitles = !!el.getAttribute(\n    _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING\n  );\n  return showingSubtitles;\n};\nconst toggleSubsCaps = (el, force) => {\n  var _a, _b;\n  const subsOn = areSubsOn(el);\n  if (subsOn || force === false) {\n    const subtitlesShowingStr = el.getAttribute(\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_SUBTITLES_SHOWING\n    );\n    if (subtitlesShowingStr) {\n      const evt = new _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(\n        _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIEvents.MEDIA_DISABLE_SUBTITLES_REQUEST,\n        { composed: true, bubbles: true, detail: subtitlesShowingStr }\n      );\n      el.dispatchEvent(evt);\n    }\n  } else if (!subsOn || force === true) {\n    const [subTrackStr] = (_b = splitTextTracksStr(\n      (_a = el.getAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIAttributes.MEDIA_SUBTITLES_LIST)) != null ? _a : \"\"\n    )) != null ? _b : [];\n    if (subTrackStr) {\n      const evt = new _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.CustomEvent(\n        _constants_js__WEBPACK_IMPORTED_MODULE_1__.MediaUIEvents.MEDIA_SHOW_SUBTITLES_REQUEST,\n        { composed: true, bubbles: true, detail: subTrackStr }\n      );\n      el.dispatchEvent(evt);\n    }\n  } else {\n    console.error(\n      \"Attempting to enable captions or subtitles but none are available! Please verify your media content if this is unexpected.\"\n    );\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2NhcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ2E7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCLElBQUksbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQyxHQUFHLFNBQVMsR0FBRywwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQVU7QUFDaEMsUUFBUSx3REFBYTtBQUNyQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCLDREQUFpQjtBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDLFFBQVEsd0RBQWE7QUFDckIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2NhcHRpb25zLmpzPzQ4OGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xvYmFsVGhpcyB9IGZyb20gXCIuL3NlcnZlci1zYWZlLWdsb2JhbHMuanNcIjtcbmltcG9ydCB7IE1lZGlhVUlFdmVudHMsIE1lZGlhVUlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuY29uc3Qgc3BsaXRUZXh0VHJhY2tzU3RyID0gKHRleHRUcmFja3NTdHIgPSBcIlwiKSA9PiB0ZXh0VHJhY2tzU3RyLnNwbGl0KC9cXHMrLyk7XG5jb25zdCBwYXJzZVRleHRUcmFja1N0ciA9ICh0ZXh0VHJhY2tTdHIgPSBcIlwiKSA9PiB7XG4gIGxldCBba2luZCwgbGFuZ3VhZ2UsIGVuY29kZWRMYWJlbF0gPSB0ZXh0VHJhY2tTdHIuc3BsaXQoXCI6XCIpO1xuICBjb25zdCBsYWJlbCA9IGVuY29kZWRMYWJlbCA/IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkTGFiZWwpIDogdm9pZCAwO1xuICBraW5kID0ga2luZCA9PT0gXCJjY1wiID8gXCJjYXB0aW9uc1wiIDogXCJzdWJ0aXRsZXNcIjtcbiAgcmV0dXJuIHtcbiAgICBraW5kLFxuICAgIGxhbmd1YWdlLFxuICAgIGxhYmVsXG4gIH07XG59O1xuY29uc3QgcGFyc2VUZXh0VHJhY2tzU3RyID0gKHRleHRUcmFja3NTdHIgPSBcIlwiLCB0ZXh0VHJhY2tMaWtlT2JqID0ge30pID0+IHtcbiAgcmV0dXJuIHNwbGl0VGV4dFRyYWNrc1N0cih0ZXh0VHJhY2tzU3RyKS5tYXAoKHRleHRUcmFja1N0cikgPT4ge1xuICAgIGNvbnN0IHRleHRUcmFja09iaiA9IHBhcnNlVGV4dFRyYWNrU3RyKHRleHRUcmFja1N0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRleHRUcmFja0xpa2VPYmosXG4gICAgICAuLi50ZXh0VHJhY2tPYmpcbiAgICB9O1xuICB9KTtcbn07XG5jb25zdCBwYXJzZVRyYWNrcyA9ICh0cmFja09yVHJhY2tzKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYWNrT3JUcmFja3MpKSB7XG4gICAgcmV0dXJuIHRyYWNrT3JUcmFja3MubWFwKCh0cmFja09iak9yU3RyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRyYWNrT2JqT3JTdHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGV4dFRyYWNrU3RyKHRyYWNrT2JqT3JTdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrT2JqT3JTdHI7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmFja09yVHJhY2tzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlVGV4dFRyYWNrc1N0cih0cmFja09yVHJhY2tzKTtcbiAgfVxuICByZXR1cm4gW3RyYWNrT3JUcmFja3NdO1xufTtcbmNvbnN0IGZvcm1hdFRleHRUcmFja09iaiA9ICh7IGtpbmQsIGxhYmVsLCBsYW5ndWFnZSB9ID0geyBraW5kOiBcInN1YnRpdGxlc1wiIH0pID0+IHtcbiAgaWYgKCFsYWJlbClcbiAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gIHJldHVybiBgJHtraW5kID09PSBcImNhcHRpb25zXCIgPyBcImNjXCIgOiBcInNiXCJ9OiR7bGFuZ3VhZ2V9OiR7ZW5jb2RlVVJJQ29tcG9uZW50KGxhYmVsKX1gO1xufTtcbmNvbnN0IHN0cmluZ2lmeVRleHRUcmFja0xpc3QgPSAodGV4dFRyYWNrcyA9IFtdKSA9PiB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodGV4dFRyYWNrcywgZm9ybWF0VGV4dFRyYWNrT2JqKS5qb2luKFwiIFwiKTtcbn07XG5jb25zdCBpc01hdGNoaW5nUHJvcE9mID0gKGtleSwgdmFsdWUpID0+IChvYmopID0+IG9ialtrZXldID09PSB2YWx1ZTtcbmNvbnN0IHRleHRUcmFja09iakFzUHJlZCA9IChmaWx0ZXJPYmopID0+IHtcbiAgY29uc3QgcHJlZHMgPSBPYmplY3QuZW50cmllcyhmaWx0ZXJPYmopLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgcmV0dXJuIGlzTWF0Y2hpbmdQcm9wT2Yoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gKHRleHRUcmFjaykgPT4gcHJlZHMuZXZlcnkoKHByZWQpID0+IHByZWQodGV4dFRyYWNrKSk7XG59O1xuY29uc3QgdXBkYXRlVHJhY2tzTW9kZVRvID0gKG1vZGUsIHRyYWNrcyA9IFtdLCB0cmFja3NUb1VwZGF0ZSA9IFtdKSA9PiB7XG4gIGNvbnN0IHByZWRzID0gcGFyc2VUcmFja3ModHJhY2tzVG9VcGRhdGUpLm1hcCh0ZXh0VHJhY2tPYmpBc1ByZWQpO1xuICBjb25zdCBpc1RyYWNrVG9VcGRhdGUgPSAodGV4dFRyYWNrKSA9PiB7XG4gICAgcmV0dXJuIHByZWRzLnNvbWUoKHByZWQpID0+IHByZWQodGV4dFRyYWNrKSk7XG4gIH07XG4gIEFycmF5LmZyb20odHJhY2tzKS5maWx0ZXIoaXNUcmFja1RvVXBkYXRlKS5mb3JFYWNoKCh0ZXh0VHJhY2spID0+IHtcbiAgICB0ZXh0VHJhY2subW9kZSA9IG1vZGU7XG4gIH0pO1xufTtcbmNvbnN0IGdldFRleHRUcmFja3NMaXN0ID0gKG1lZGlhLCBmaWx0ZXJQcmVkT3JPYmogPSAoKSA9PiB0cnVlKSA9PiB7XG4gIGlmICghKG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS50ZXh0VHJhY2tzKSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGZpbHRlclByZWQgPSB0eXBlb2YgZmlsdGVyUHJlZE9yT2JqID09PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXJQcmVkT3JPYmogOiB0ZXh0VHJhY2tPYmpBc1ByZWQoZmlsdGVyUHJlZE9yT2JqKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obWVkaWEudGV4dFRyYWNrcykuZmlsdGVyKGZpbHRlclByZWQpO1xufTtcbmNvbnN0IGFyZVN1YnNPbiA9IChlbCkgPT4ge1xuICBjb25zdCBzaG93aW5nU3VidGl0bGVzID0gISFlbC5nZXRBdHRyaWJ1dGUoXG4gICAgTWVkaWFVSUF0dHJpYnV0ZXMuTUVESUFfU1VCVElUTEVTX1NIT1dJTkdcbiAgKTtcbiAgcmV0dXJuIHNob3dpbmdTdWJ0aXRsZXM7XG59O1xuY29uc3QgdG9nZ2xlU3Vic0NhcHMgPSAoZWwsIGZvcmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHN1YnNPbiA9IGFyZVN1YnNPbihlbCk7XG4gIGlmIChzdWJzT24gfHwgZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgY29uc3Qgc3VidGl0bGVzU2hvd2luZ1N0ciA9IGVsLmdldEF0dHJpYnV0ZShcbiAgICAgIE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NVQlRJVExFU19TSE9XSU5HXG4gICAgKTtcbiAgICBpZiAoc3VidGl0bGVzU2hvd2luZ1N0cikge1xuICAgICAgY29uc3QgZXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoXG4gICAgICAgIE1lZGlhVUlFdmVudHMuTUVESUFfRElTQUJMRV9TVUJUSVRMRVNfUkVRVUVTVCxcbiAgICAgICAgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiBzdWJ0aXRsZXNTaG93aW5nU3RyIH1cbiAgICAgICk7XG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFzdWJzT24gfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICBjb25zdCBbc3ViVHJhY2tTdHJdID0gKF9iID0gc3BsaXRUZXh0VHJhY2tzU3RyKFxuICAgICAgKF9hID0gZWwuZ2V0QXR0cmlidXRlKE1lZGlhVUlBdHRyaWJ1dGVzLk1FRElBX1NVQlRJVExFU19MSVNUKSkgIT0gbnVsbCA/IF9hIDogXCJcIlxuICAgICkpICE9IG51bGwgPyBfYiA6IFtdO1xuICAgIGlmIChzdWJUcmFja1N0cikge1xuICAgICAgY29uc3QgZXZ0ID0gbmV3IGdsb2JhbFRoaXMuQ3VzdG9tRXZlbnQoXG4gICAgICAgIE1lZGlhVUlFdmVudHMuTUVESUFfU0hPV19TVUJUSVRMRVNfUkVRVUVTVCxcbiAgICAgICAgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiBzdWJUcmFja1N0ciB9XG4gICAgICApO1xuICAgICAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJBdHRlbXB0aW5nIHRvIGVuYWJsZSBjYXB0aW9ucyBvciBzdWJ0aXRsZXMgYnV0IG5vbmUgYXJlIGF2YWlsYWJsZSEgUGxlYXNlIHZlcmlmeSB5b3VyIG1lZGlhIGNvbnRlbnQgaWYgdGhpcyBpcyB1bmV4cGVjdGVkLlwiXG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGFyZVN1YnNPbixcbiAgZm9ybWF0VGV4dFRyYWNrT2JqLFxuICBnZXRUZXh0VHJhY2tzTGlzdCxcbiAgaXNNYXRjaGluZ1Byb3BPZixcbiAgcGFyc2VUZXh0VHJhY2tTdHIsXG4gIHBhcnNlVGV4dFRyYWNrc1N0cixcbiAgcGFyc2VUcmFja3MsXG4gIHNwbGl0VGV4dFRyYWNrc1N0cixcbiAgc3RyaW5naWZ5VGV4dFRyYWNrTGlzdCxcbiAgdGV4dFRyYWNrT2JqQXNQcmVkLFxuICB0b2dnbGVTdWJzQ2FwcyxcbiAgdXBkYXRlVHJhY2tzTW9kZVRvXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/captions.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/element-utils.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestComposedNode: function() { return /* binding */ closestComposedNode; },\n/* harmony export */   containsComposedNode: function() { return /* binding */ containsComposedNode; },\n/* harmony export */   getAllSlotted: function() { return /* binding */ getAllSlotted; },\n/* harmony export */   getBooleanAttr: function() { return /* binding */ getBooleanAttr; },\n/* harmony export */   getNumericAttr: function() { return /* binding */ getNumericAttr; },\n/* harmony export */   getOrInsertCSSRule: function() { return /* binding */ getOrInsertCSSRule; },\n/* harmony export */   getSlotted: function() { return /* binding */ getSlotted; },\n/* harmony export */   getStringAttr: function() { return /* binding */ getStringAttr; },\n/* harmony export */   setBooleanAttr: function() { return /* binding */ setBooleanAttr; },\n/* harmony export */   setNumericAttr: function() { return /* binding */ setNumericAttr; },\n/* harmony export */   setStringAttr: function() { return /* binding */ setStringAttr; },\n/* harmony export */   updateIconText: function() { return /* binding */ updateIconText; }\n/* harmony export */ });\nconst updateIconText = (svg, value, selector = \".value\") => {\n  const node = svg.querySelector(selector);\n  if (!node)\n    return;\n  node.textContent = value;\n};\nconst getAllSlotted = (el, name) => {\n  const slotSelector = `slot[name=\"${name}\"]`;\n  const slot = el.shadowRoot.querySelector(slotSelector);\n  if (!slot)\n    return [];\n  return slot.children;\n};\nconst getSlotted = (el, name) => getAllSlotted(el, name)[0];\nconst containsComposedNode = (rootNode, childNode) => {\n  if (!rootNode || !childNode)\n    return false;\n  if (rootNode.contains(childNode))\n    return true;\n  return containsComposedNode(rootNode, childNode.getRootNode().host);\n};\nconst closestComposedNode = (childNode, selector) => {\n  if (!childNode)\n    return null;\n  const closest = childNode.closest(selector);\n  if (closest)\n    return closest;\n  return closestComposedNode(childNode.getRootNode().host, selector);\n};\nfunction getOrInsertCSSRule(styleParent, selectorText) {\n  var _a;\n  let style;\n  for (style of styleParent.querySelectorAll(\"style\")) {\n    let cssRules;\n    try {\n      cssRules = (_a = style.sheet) == null ? void 0 : _a.cssRules;\n    } catch {\n      continue;\n    }\n    for (let rule of cssRules != null ? cssRules : [])\n      if (rule.selectorText === selectorText)\n        return rule;\n  }\n  if (!(style == null ? void 0 : style.sheet)) {\n    return {\n      style: {\n        setProperty: () => {\n        },\n        removeProperty: () => {\n        }\n      }\n    };\n  }\n  style.sheet.insertRule(`${selectorText}{}`, style.sheet.cssRules.length);\n  return style.sheet.cssRules[style.sheet.cssRules.length - 1];\n}\nfunction getNumericAttr(el, attrName, defaultValue = Number.NaN) {\n  const attrVal = el.getAttribute(attrName);\n  return attrVal != null ? +attrVal : defaultValue;\n}\nfunction setNumericAttr(el, attrName, value) {\n  const nextNumericValue = +value;\n  if (value == null || Number.isNaN(nextNumericValue)) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  if (getNumericAttr(el, attrName, void 0) === nextNumericValue)\n    return;\n  el.setAttribute(attrName, `${nextNumericValue}`);\n}\nfunction getBooleanAttr(el, attrName) {\n  return el.hasAttribute(attrName);\n}\nfunction setBooleanAttr(el, attrName, value) {\n  if (value == null) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  if (getBooleanAttr(el, attrName) == value)\n    return;\n  el.toggleAttribute(attrName, value);\n}\nfunction getStringAttr(el, attrName, defaultValue = null) {\n  var _a;\n  return (_a = el.getAttribute(attrName)) != null ? _a : defaultValue;\n}\nfunction setStringAttr(el, attrName, value) {\n  if (value == null) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  const nextValue = `${value}`;\n  if (getStringAttr(el, attrName, void 0) === nextValue)\n    return;\n  el.setAttribute(attrName, nextValue);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2VsZW1lbnQtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQWNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC91dGlscy9lbGVtZW50LXV0aWxzLmpzP2U5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXBkYXRlSWNvblRleHQgPSAoc3ZnLCB2YWx1ZSwgc2VsZWN0b3IgPSBcIi52YWx1ZVwiKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzdmcucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIGlmICghbm9kZSlcbiAgICByZXR1cm47XG4gIG5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbn07XG5jb25zdCBnZXRBbGxTbG90dGVkID0gKGVsLCBuYW1lKSA9PiB7XG4gIGNvbnN0IHNsb3RTZWxlY3RvciA9IGBzbG90W25hbWU9XCIke25hbWV9XCJdYDtcbiAgY29uc3Qgc2xvdCA9IGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihzbG90U2VsZWN0b3IpO1xuICBpZiAoIXNsb3QpXG4gICAgcmV0dXJuIFtdO1xuICByZXR1cm4gc2xvdC5jaGlsZHJlbjtcbn07XG5jb25zdCBnZXRTbG90dGVkID0gKGVsLCBuYW1lKSA9PiBnZXRBbGxTbG90dGVkKGVsLCBuYW1lKVswXTtcbmNvbnN0IGNvbnRhaW5zQ29tcG9zZWROb2RlID0gKHJvb3ROb2RlLCBjaGlsZE5vZGUpID0+IHtcbiAgaWYgKCFyb290Tm9kZSB8fCAhY2hpbGROb2RlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHJvb3ROb2RlLmNvbnRhaW5zKGNoaWxkTm9kZSkpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBjb250YWluc0NvbXBvc2VkTm9kZShyb290Tm9kZSwgY2hpbGROb2RlLmdldFJvb3ROb2RlKCkuaG9zdCk7XG59O1xuY29uc3QgY2xvc2VzdENvbXBvc2VkTm9kZSA9IChjaGlsZE5vZGUsIHNlbGVjdG9yKSA9PiB7XG4gIGlmICghY2hpbGROb2RlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBjbG9zZXN0ID0gY2hpbGROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICBpZiAoY2xvc2VzdClcbiAgICByZXR1cm4gY2xvc2VzdDtcbiAgcmV0dXJuIGNsb3Nlc3RDb21wb3NlZE5vZGUoY2hpbGROb2RlLmdldFJvb3ROb2RlKCkuaG9zdCwgc2VsZWN0b3IpO1xufTtcbmZ1bmN0aW9uIGdldE9ySW5zZXJ0Q1NTUnVsZShzdHlsZVBhcmVudCwgc2VsZWN0b3JUZXh0KSB7XG4gIHZhciBfYTtcbiAgbGV0IHN0eWxlO1xuICBmb3IgKHN0eWxlIG9mIHN0eWxlUGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVwiKSkge1xuICAgIGxldCBjc3NSdWxlcztcbiAgICB0cnkge1xuICAgICAgY3NzUnVsZXMgPSAoX2EgPSBzdHlsZS5zaGVldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IHJ1bGUgb2YgY3NzUnVsZXMgIT0gbnVsbCA/IGNzc1J1bGVzIDogW10pXG4gICAgICBpZiAocnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dClcbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgaWYgKCEoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnNoZWV0KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBzZXRQcm9wZXJ0eTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVQcm9wZXJ0eTogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdHlsZS5zaGVldC5pbnNlcnRSdWxlKGAke3NlbGVjdG9yVGV4dH17fWAsIHN0eWxlLnNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIHJldHVybiBzdHlsZS5zaGVldC5jc3NSdWxlc1tzdHlsZS5zaGVldC5jc3NSdWxlcy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldE51bWVyaWNBdHRyKGVsLCBhdHRyTmFtZSwgZGVmYXVsdFZhbHVlID0gTnVtYmVyLk5hTikge1xuICBjb25zdCBhdHRyVmFsID0gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgcmV0dXJuIGF0dHJWYWwgIT0gbnVsbCA/ICthdHRyVmFsIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gc2V0TnVtZXJpY0F0dHIoZWwsIGF0dHJOYW1lLCB2YWx1ZSkge1xuICBjb25zdCBuZXh0TnVtZXJpY1ZhbHVlID0gK3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4obmV4dE51bWVyaWNWYWx1ZSkpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXROdW1lcmljQXR0cihlbCwgYXR0ck5hbWUsIHZvaWQgMCkgPT09IG5leHROdW1lcmljVmFsdWUpXG4gICAgcmV0dXJuO1xuICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGAke25leHROdW1lcmljVmFsdWV9YCk7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuQXR0cihlbCwgYXR0ck5hbWUpIHtcbiAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSk7XG59XG5mdW5jdGlvbiBzZXRCb29sZWFuQXR0cihlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0Qm9vbGVhbkF0dHIoZWwsIGF0dHJOYW1lKSA9PSB2YWx1ZSlcbiAgICByZXR1cm47XG4gIGVsLnRvZ2dsZUF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0U3RyaW5nQXR0cihlbCwgYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSA9IG51bGwpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSkgIT0gbnVsbCA/IF9hIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gc2V0U3RyaW5nQXR0cihlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuZXh0VmFsdWUgPSBgJHt2YWx1ZX1gO1xuICBpZiAoZ2V0U3RyaW5nQXR0cihlbCwgYXR0ck5hbWUsIHZvaWQgMCkgPT09IG5leHRWYWx1ZSlcbiAgICByZXR1cm47XG4gIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV4dFZhbHVlKTtcbn1cbmV4cG9ydCB7XG4gIGNsb3Nlc3RDb21wb3NlZE5vZGUsXG4gIGNvbnRhaW5zQ29tcG9zZWROb2RlLFxuICBnZXRBbGxTbG90dGVkLFxuICBnZXRCb29sZWFuQXR0cixcbiAgZ2V0TnVtZXJpY0F0dHIsXG4gIGdldE9ySW5zZXJ0Q1NTUnVsZSxcbiAgZ2V0U2xvdHRlZCxcbiAgZ2V0U3RyaW5nQXR0cixcbiAgc2V0Qm9vbGVhbkF0dHIsXG4gIHNldE51bWVyaWNBdHRyLFxuICBzZXRTdHJpbmdBdHRyLFxuICB1cGRhdGVJY29uVGV4dFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/element-utils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/fullscreen-api.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/fullscreen-api.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fullscreenApi: function() { return /* binding */ fullscreenApi; }\n/* harmony export */ });\n/* harmony import */ var _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n\nconst fullscreenApi = {\n  enter: \"requestFullscreen\",\n  exit: \"exitFullscreen\",\n  rootEvents: [\"fullscreenchange\"],\n  mediaEvents: [],\n  element: \"fullscreenElement\",\n  error: \"fullscreenerror\",\n  enabled: \"fullscreenEnabled\"\n};\nif (_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.fullscreenElement === void 0) {\n  fullscreenApi.enter = \"webkitRequestFullScreen\";\n  fullscreenApi.exit = _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document.webkitExitFullscreen != null ? \"webkitExitFullscreen\" : \"webkitCancelFullScreen\";\n  fullscreenApi.rootEvents = [\"webkitfullscreenchange\"];\n  fullscreenApi.mediaEvents = [\"webkitbeginfullscreen\", \"webkitendfullscreen\"], fullscreenApi.element = \"webkitFullscreenElement\";\n  fullscreenApi.error = \"webkitfullscreenerror\";\n  fullscreenApi.enabled = \"webkitFullscreenEnabled\";\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2Z1bGxzY3JlZW4tYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkRBQVE7QUFDWjtBQUNBLHVCQUF1Qiw2REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL2Z1bGxzY3JlZW4tYXBpLmpzPzQyNTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tIFwiLi9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCBmdWxsc2NyZWVuQXBpID0ge1xuICBlbnRlcjogXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFxuICBleGl0OiBcImV4aXRGdWxsc2NyZWVuXCIsXG4gIHJvb3RFdmVudHM6IFtcImZ1bGxzY3JlZW5jaGFuZ2VcIl0sXG4gIG1lZGlhRXZlbnRzOiBbXSxcbiAgZWxlbWVudDogXCJmdWxsc2NyZWVuRWxlbWVudFwiLFxuICBlcnJvcjogXCJmdWxsc2NyZWVuZXJyb3JcIixcbiAgZW5hYmxlZDogXCJmdWxsc2NyZWVuRW5hYmxlZFwiXG59O1xuaWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ID09PSB2b2lkIDApIHtcbiAgZnVsbHNjcmVlbkFwaS5lbnRlciA9IFwid2Via2l0UmVxdWVzdEZ1bGxTY3JlZW5cIjtcbiAgZnVsbHNjcmVlbkFwaS5leGl0ID0gZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4gIT0gbnVsbCA/IFwid2Via2l0RXhpdEZ1bGxzY3JlZW5cIiA6IFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiO1xuICBmdWxsc2NyZWVuQXBpLnJvb3RFdmVudHMgPSBbXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCJdO1xuICBmdWxsc2NyZWVuQXBpLm1lZGlhRXZlbnRzID0gW1wid2Via2l0YmVnaW5mdWxsc2NyZWVuXCIsIFwid2Via2l0ZW5kZnVsbHNjcmVlblwiXSwgZnVsbHNjcmVlbkFwaS5lbGVtZW50ID0gXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiO1xuICBmdWxsc2NyZWVuQXBpLmVycm9yID0gXCJ3ZWJraXRmdWxsc2NyZWVuZXJyb3JcIjtcbiAgZnVsbHNjcmVlbkFwaS5lbmFibGVkID0gXCJ3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZFwiO1xufVxuZXhwb3J0IHtcbiAgZnVsbHNjcmVlbkFwaVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/fullscreen-api.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/platform-tests.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/platform-tests.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   airplaySupported: function() { return /* binding */ airplaySupported; },\n/* harmony export */   castSupported: function() { return /* binding */ castSupported; },\n/* harmony export */   fullscreenSupported: function() { return /* binding */ fullscreenSupported; },\n/* harmony export */   getTestMediaEl: function() { return /* binding */ getTestMediaEl; },\n/* harmony export */   hasFullscreenSupport: function() { return /* binding */ hasFullscreenSupport; },\n/* harmony export */   hasPipSupport: function() { return /* binding */ hasPipSupport; },\n/* harmony export */   hasVolumeSupportAsync: function() { return /* binding */ hasVolumeSupportAsync; },\n/* harmony export */   pipSupported: function() { return /* binding */ pipSupported; }\n/* harmony export */ });\n/* harmony import */ var _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/utils.js\");\n/* harmony import */ var _fullscreen_api_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fullscreen-api.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/fullscreen-api.js\");\n\n\n\nlet testMediaEl;\nconst getTestMediaEl = () => {\n  var _a, _b;\n  if (testMediaEl)\n    return testMediaEl;\n  testMediaEl = (_b = (_a = _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document) == null ? void 0 : _a.createElement) == null ? void 0 : _b.call(_a, \"video\");\n  return testMediaEl;\n};\nconst hasVolumeSupportAsync = async (mediaEl = getTestMediaEl()) => {\n  if (!mediaEl)\n    return false;\n  const prevVolume = mediaEl.volume;\n  mediaEl.volume = prevVolume / 2 + 0.1;\n  await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.delay)(0);\n  return mediaEl.volume !== prevVolume;\n};\nconst hasPipSupport = (mediaEl = getTestMediaEl()) => typeof (mediaEl == null ? void 0 : mediaEl.requestPictureInPicture) === \"function\";\nconst hasFullscreenSupport = (mediaEl = getTestMediaEl()) => {\n  let fullscreenEnabled = _server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.document[_fullscreen_api_js__WEBPACK_IMPORTED_MODULE_2__.fullscreenApi.enabled];\n  if (!fullscreenEnabled && mediaEl) {\n    fullscreenEnabled = \"webkitSupportsFullscreen\" in mediaEl;\n  }\n  return fullscreenEnabled;\n};\nconst fullscreenSupported = hasFullscreenSupport();\nconst pipSupported = hasPipSupport();\nconst airplaySupported = !!_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.WebKitPlaybackTargetAvailabilityEvent;\nconst castSupported = !!_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.chrome;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3BsYXRmb3JtLXRlc3RzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQzdCO0FBQ2lCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQVEsQ0FBQyw2REFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBVTtBQUNyQyx3QkFBd0IsK0RBQVU7QUFVaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3BsYXRmb3JtLXRlc3RzLmpzPzY3OGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xvYmFsVGhpcywgZG9jdW1lbnQgfSBmcm9tIFwiLi9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBkZWxheSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBmdWxsc2NyZWVuQXBpIH0gZnJvbSBcIi4vZnVsbHNjcmVlbi1hcGkuanNcIjtcbmxldCB0ZXN0TWVkaWFFbDtcbmNvbnN0IGdldFRlc3RNZWRpYUVsID0gKCkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBpZiAodGVzdE1lZGlhRWwpXG4gICAgcmV0dXJuIHRlc3RNZWRpYUVsO1xuICB0ZXN0TWVkaWFFbCA9IChfYiA9IChfYSA9IGRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwidmlkZW9cIik7XG4gIHJldHVybiB0ZXN0TWVkaWFFbDtcbn07XG5jb25zdCBoYXNWb2x1bWVTdXBwb3J0QXN5bmMgPSBhc3luYyAobWVkaWFFbCA9IGdldFRlc3RNZWRpYUVsKCkpID0+IHtcbiAgaWYgKCFtZWRpYUVsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJldlZvbHVtZSA9IG1lZGlhRWwudm9sdW1lO1xuICBtZWRpYUVsLnZvbHVtZSA9IHByZXZWb2x1bWUgLyAyICsgMC4xO1xuICBhd2FpdCBkZWxheSgwKTtcbiAgcmV0dXJuIG1lZGlhRWwudm9sdW1lICE9PSBwcmV2Vm9sdW1lO1xufTtcbmNvbnN0IGhhc1BpcFN1cHBvcnQgPSAobWVkaWFFbCA9IGdldFRlc3RNZWRpYUVsKCkpID0+IHR5cGVvZiAobWVkaWFFbCA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFFbC5yZXF1ZXN0UGljdHVyZUluUGljdHVyZSkgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGhhc0Z1bGxzY3JlZW5TdXBwb3J0ID0gKG1lZGlhRWwgPSBnZXRUZXN0TWVkaWFFbCgpKSA9PiB7XG4gIGxldCBmdWxsc2NyZWVuRW5hYmxlZCA9IGRvY3VtZW50W2Z1bGxzY3JlZW5BcGkuZW5hYmxlZF07XG4gIGlmICghZnVsbHNjcmVlbkVuYWJsZWQgJiYgbWVkaWFFbCkge1xuICAgIGZ1bGxzY3JlZW5FbmFibGVkID0gXCJ3ZWJraXRTdXBwb3J0c0Z1bGxzY3JlZW5cIiBpbiBtZWRpYUVsO1xuICB9XG4gIHJldHVybiBmdWxsc2NyZWVuRW5hYmxlZDtcbn07XG5jb25zdCBmdWxsc2NyZWVuU3VwcG9ydGVkID0gaGFzRnVsbHNjcmVlblN1cHBvcnQoKTtcbmNvbnN0IHBpcFN1cHBvcnRlZCA9IGhhc1BpcFN1cHBvcnQoKTtcbmNvbnN0IGFpcnBsYXlTdXBwb3J0ZWQgPSAhIWdsb2JhbFRoaXMuV2ViS2l0UGxheWJhY2tUYXJnZXRBdmFpbGFiaWxpdHlFdmVudDtcbmNvbnN0IGNhc3RTdXBwb3J0ZWQgPSAhIWdsb2JhbFRoaXMuY2hyb21lO1xuZXhwb3J0IHtcbiAgYWlycGxheVN1cHBvcnRlZCxcbiAgY2FzdFN1cHBvcnRlZCxcbiAgZnVsbHNjcmVlblN1cHBvcnRlZCxcbiAgZ2V0VGVzdE1lZGlhRWwsXG4gIGhhc0Z1bGxzY3JlZW5TdXBwb3J0LFxuICBoYXNQaXBTdXBwb3J0LFxuICBoYXNWb2x1bWVTdXBwb3J0QXN5bmMsXG4gIHBpcFN1cHBvcnRlZFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/platform-tests.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/server-safe-globals.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: function() { return /* binding */ Document; },\n/* harmony export */   GlobalThis: function() { return /* binding */ GlobalThis; },\n/* harmony export */   document: function() { return /* binding */ Document; },\n/* harmony export */   globalThis: function() { return /* binding */ GlobalThis; },\n/* harmony export */   isServer: function() { return /* binding */ isServer; }\n/* harmony export */ });\nclass EventTarget {\n  addEventListener() {\n  }\n  removeEventListener() {\n  }\n  dispatchEvent() {\n    return true;\n  }\n}\nclass ResizeObserver {\n  observe() {\n  }\n}\nconst documentShim = {\n  createElement: function() {\n    return new globalThisShim.HTMLElement();\n  },\n  addEventListener() {\n  },\n  removeEventListener() {\n  }\n};\nconst globalThisShim = {\n  ResizeObserver,\n  document: documentShim,\n  HTMLElement: class HTMLElement extends EventTarget {\n  },\n  DocumentFragment: class DocumentFragment extends EventTarget {\n  },\n  customElements: {\n    get: function() {\n    },\n    define: function() {\n    },\n    whenDefined: function() {\n    }\n  },\n  CustomEvent: function CustomEvent() {\n  },\n  getComputedStyle: function() {\n  }\n};\nconst isServer = typeof window === \"undefined\" || typeof window.customElements === \"undefined\";\nconst isShimmed = Object.keys(globalThisShim).every((key) => key in globalThis);\nconst GlobalThis = isServer && !isShimmed ? globalThisShim : globalThis;\nconst Document = isServer && !isShimmed ? documentShim : globalThis.document;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3NlcnZlci1zYWZlLWdsb2JhbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2hyb21lL2Rpc3QvdXRpbHMvc2VydmVyLXNhZmUtZ2xvYmFscy5qcz9jMzllIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEV2ZW50VGFyZ2V0IHtcbiAgYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICB9XG4gIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFJlc2l6ZU9ic2VydmVyIHtcbiAgb2JzZXJ2ZSgpIHtcbiAgfVxufVxuY29uc3QgZG9jdW1lbnRTaGltID0ge1xuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXNTaGltLkhUTUxFbGVtZW50KCk7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gIH1cbn07XG5jb25zdCBnbG9iYWxUaGlzU2hpbSA9IHtcbiAgUmVzaXplT2JzZXJ2ZXIsXG4gIGRvY3VtZW50OiBkb2N1bWVudFNoaW0sXG4gIEhUTUxFbGVtZW50OiBjbGFzcyBIVE1MRWxlbWVudCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgfSxcbiAgRG9jdW1lbnRGcmFnbWVudDogY2xhc3MgRG9jdW1lbnRGcmFnbWVudCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgfSxcbiAgY3VzdG9tRWxlbWVudHM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIH0sXG4gICAgZGVmaW5lOiBmdW5jdGlvbigpIHtcbiAgICB9LFxuICAgIHdoZW5EZWZpbmVkOiBmdW5jdGlvbigpIHtcbiAgICB9XG4gIH0sXG4gIEN1c3RvbUV2ZW50OiBmdW5jdGlvbiBDdXN0b21FdmVudCgpIHtcbiAgfSxcbiAgZ2V0Q29tcHV0ZWRTdHlsZTogZnVuY3Rpb24oKSB7XG4gIH1cbn07XG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5jdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzU2hpbW1lZCA9IE9iamVjdC5rZXlzKGdsb2JhbFRoaXNTaGltKS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gZ2xvYmFsVGhpcyk7XG5jb25zdCBHbG9iYWxUaGlzID0gaXNTZXJ2ZXIgJiYgIWlzU2hpbW1lZCA/IGdsb2JhbFRoaXNTaGltIDogZ2xvYmFsVGhpcztcbmNvbnN0IERvY3VtZW50ID0gaXNTZXJ2ZXIgJiYgIWlzU2hpbW1lZCA/IGRvY3VtZW50U2hpbSA6IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG5leHBvcnQge1xuICBEb2N1bWVudCxcbiAgR2xvYmFsVGhpcyxcbiAgRG9jdW1lbnQgYXMgZG9jdW1lbnQsXG4gIEdsb2JhbFRoaXMgYXMgZ2xvYmFsVGhpcyxcbiAgaXNTZXJ2ZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/template-parts.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/template-parts.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttrPart: function() { return /* binding */ AttrPart; },\n/* harmony export */   AttrPartList: function() { return /* binding */ AttrPartList; },\n/* harmony export */   ChildNodePart: function() { return /* binding */ ChildNodePart; },\n/* harmony export */   InnerTemplatePart: function() { return /* binding */ InnerTemplatePart; },\n/* harmony export */   Part: function() { return /* binding */ Part; },\n/* harmony export */   TemplateInstance: function() { return /* binding */ TemplateInstance; },\n/* harmony export */   defaultProcessor: function() { return /* binding */ defaultProcessor; },\n/* harmony export */   parse: function() { return /* binding */ parse; },\n/* harmony export */   tokenize: function() { return /* binding */ tokenize; }\n/* harmony export */ });\n/* harmony import */ var _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/server-safe-globals.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/server-safe-globals.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _parts, _processor, _items, _value, _element, _attributeName, _namespaceURI, _list, list_get, _parentNode, _nodes;\n\nconst ELEMENT = 1;\nconst STRING = 0;\nconst PART = 1;\nconst defaultProcessor = {\n  processCallback(instance, parts, state) {\n    if (!state)\n      return;\n    for (const [expression, part] of parts) {\n      if (expression in state) {\n        const value = state[expression];\n        if (typeof value === \"boolean\" && part instanceof AttrPart && typeof part.element[part.attributeName] === \"boolean\") {\n          part.booleanValue = value;\n        } else if (typeof value === \"function\" && part instanceof AttrPart) {\n          part.element[part.attributeName] = value;\n        } else {\n          part.value = value;\n        }\n      }\n    }\n  }\n};\nclass TemplateInstance extends _utils_server_safe_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalThis.DocumentFragment {\n  constructor(template, state, processor = defaultProcessor) {\n    var _a;\n    super();\n    __privateAdd(this, _parts, void 0);\n    __privateAdd(this, _processor, void 0);\n    this.append(template.content.cloneNode(true));\n    __privateSet(this, _parts, parse(this));\n    __privateSet(this, _processor, processor);\n    (_a = processor.createCallback) == null ? void 0 : _a.call(processor, this, __privateGet(this, _parts), state);\n    processor.processCallback(this, __privateGet(this, _parts), state);\n  }\n  update(state) {\n    __privateGet(this, _processor).processCallback(this, __privateGet(this, _parts), state);\n  }\n}\n_parts = new WeakMap();\n_processor = new WeakMap();\nconst parse = (element, parts = []) => {\n  let type, value;\n  for (let attr of element.attributes || []) {\n    if (attr.value.includes(\"{{\")) {\n      const list = new AttrPartList();\n      for ([type, value] of tokenize(attr.value)) {\n        if (!type)\n          list.append(value);\n        else {\n          const part = new AttrPart(element, attr.name, attr.namespaceURI);\n          list.append(part);\n          parts.push([value, part]);\n        }\n      }\n      attr.value = list.toString();\n    }\n  }\n  for (let node of element.childNodes) {\n    if (node.nodeType === ELEMENT && !(node instanceof HTMLTemplateElement)) {\n      parse(node, parts);\n    } else {\n      if (node.nodeType === ELEMENT || node.data.includes(\"{{\")) {\n        const items = [];\n        if (node.data) {\n          for ([type, value] of tokenize(node.data))\n            if (!type)\n              items.push(new Text(value));\n            else {\n              const part = new ChildNodePart(element);\n              items.push(part);\n              parts.push([value, part]);\n            }\n        } else if (node instanceof HTMLTemplateElement) {\n          const part = new InnerTemplatePart(element, node);\n          items.push(part);\n          parts.push([part.expression, part]);\n        }\n        node.replaceWith(\n          ...items.flatMap((part) => part.replacementNodes || [part])\n        );\n      }\n    }\n  }\n  return parts;\n};\nconst mem = {};\nconst tokenize = (text) => {\n  let value = \"\", open = 0, tokens = mem[text], i = 0, c;\n  if (tokens)\n    return tokens;\n  else\n    tokens = [];\n  for (; c = text[i]; i++) {\n    if (c === \"{\" && text[i + 1] === \"{\" && text[i - 1] !== \"\\\\\" && text[i + 2] && ++open == 1) {\n      if (value)\n        tokens.push([STRING, value]);\n      value = \"\";\n      i++;\n    } else if (c === \"}\" && text[i + 1] === \"}\" && text[i - 1] !== \"\\\\\" && !--open) {\n      tokens.push([PART, value.trim()]);\n      value = \"\";\n      i++;\n    } else\n      value += c || \"\";\n  }\n  if (value)\n    tokens.push([STRING, (open > 0 ? \"{{\" : \"\") + value]);\n  return mem[text] = tokens;\n};\nconst FRAGMENT = 11;\nclass Part {\n  get value() {\n    return \"\";\n  }\n  set value(val) {\n  }\n  toString() {\n    return this.value;\n  }\n}\nconst attrPartToList = /* @__PURE__ */ new WeakMap();\nclass AttrPartList {\n  constructor() {\n    __privateAdd(this, _items, []);\n  }\n  [Symbol.iterator]() {\n    return __privateGet(this, _items).values();\n  }\n  get length() {\n    return __privateGet(this, _items).length;\n  }\n  item(index) {\n    return __privateGet(this, _items)[index];\n  }\n  append(...items) {\n    for (const item of items) {\n      if (item instanceof AttrPart) {\n        attrPartToList.set(item, this);\n      }\n      __privateGet(this, _items).push(item);\n    }\n  }\n  toString() {\n    return __privateGet(this, _items).join(\"\");\n  }\n}\n_items = new WeakMap();\nclass AttrPart extends Part {\n  constructor(element, attributeName, namespaceURI) {\n    super();\n    __privateAdd(this, _list);\n    __privateAdd(this, _value, \"\");\n    __privateAdd(this, _element, void 0);\n    __privateAdd(this, _attributeName, void 0);\n    __privateAdd(this, _namespaceURI, void 0);\n    __privateSet(this, _element, element);\n    __privateSet(this, _attributeName, attributeName);\n    __privateSet(this, _namespaceURI, namespaceURI);\n  }\n  get attributeName() {\n    return __privateGet(this, _attributeName);\n  }\n  get attributeNamespace() {\n    return __privateGet(this, _namespaceURI);\n  }\n  get element() {\n    return __privateGet(this, _element);\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(newValue) {\n    if (__privateGet(this, _value) === newValue)\n      return;\n    __privateSet(this, _value, newValue);\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1) {\n      if (newValue == null) {\n        __privateGet(this, _element).removeAttributeNS(\n          __privateGet(this, _namespaceURI),\n          __privateGet(this, _attributeName)\n        );\n      } else {\n        __privateGet(this, _element).setAttributeNS(\n          __privateGet(this, _namespaceURI),\n          __privateGet(this, _attributeName),\n          newValue\n        );\n      }\n    } else {\n      __privateGet(this, _element).setAttributeNS(\n        __privateGet(this, _namespaceURI),\n        __privateGet(this, _attributeName),\n        __privateGet(this, _list, list_get)\n      );\n    }\n  }\n  get booleanValue() {\n    return __privateGet(this, _element).hasAttributeNS(\n      __privateGet(this, _namespaceURI),\n      __privateGet(this, _attributeName)\n    );\n  }\n  set booleanValue(value) {\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1)\n      this.value = value ? \"\" : null;\n    else\n      throw new DOMException(\"Value is not fully templatized\");\n  }\n}\n_value = new WeakMap();\n_element = new WeakMap();\n_attributeName = new WeakMap();\n_namespaceURI = new WeakMap();\n_list = new WeakSet();\nlist_get = function() {\n  return attrPartToList.get(this);\n};\nclass ChildNodePart extends Part {\n  constructor(parentNode, nodes) {\n    super();\n    __privateAdd(this, _parentNode, void 0);\n    __privateAdd(this, _nodes, void 0);\n    __privateSet(this, _parentNode, parentNode);\n    __privateSet(this, _nodes, nodes ? [...nodes] : [new Text()]);\n  }\n  get replacementNodes() {\n    return __privateGet(this, _nodes);\n  }\n  get parentNode() {\n    return __privateGet(this, _parentNode);\n  }\n  get nextSibling() {\n    return __privateGet(this, _nodes)[__privateGet(this, _nodes).length - 1].nextSibling;\n  }\n  get previousSibling() {\n    return __privateGet(this, _nodes)[0].previousSibling;\n  }\n  get value() {\n    return __privateGet(this, _nodes).map((node) => node.textContent).join(\"\");\n  }\n  set value(newValue) {\n    this.replace(newValue);\n  }\n  replace(...nodes) {\n    const normalisedNodes = nodes.flat().flatMap(\n      (node) => node == null ? [new Text()] : node.forEach ? [...node] : node.nodeType === FRAGMENT ? [...node.childNodes] : node.nodeType ? [node] : [new Text(node)]\n    );\n    if (!normalisedNodes.length)\n      normalisedNodes.push(new Text());\n    __privateSet(this, _nodes, swapdom(\n      __privateGet(this, _nodes)[0].parentNode,\n      __privateGet(this, _nodes),\n      normalisedNodes,\n      this.nextSibling\n    ));\n  }\n}\n_parentNode = new WeakMap();\n_nodes = new WeakMap();\nclass InnerTemplatePart extends ChildNodePart {\n  constructor(parentNode, template) {\n    let directive = template.getAttribute(\"directive\") || template.getAttribute(\"type\");\n    let expression = template.getAttribute(\"expression\") || template.getAttribute(directive) || \"\";\n    if (expression.startsWith(\"{{\"))\n      expression = expression.trim().slice(2, -2).trim();\n    super(parentNode);\n    __publicField(this, \"directive\");\n    this.expression = expression;\n    this.template = template;\n    this.directive = directive;\n  }\n}\nfunction swapdom(parent, a, b, end = null) {\n  let i = 0, cur, next, bi, n = b.length, m = a.length;\n  while (i < n && i < m && a[i] == b[i])\n    i++;\n  while (i < n && i < m && b[n - 1] == a[m - 1])\n    end = b[--m, --n];\n  if (i == m)\n    while (i < n)\n      parent.insertBefore(b[i++], end);\n  if (i == n)\n    while (i < m)\n      parent.removeChild(a[i++]);\n  else {\n    cur = a[i];\n    while (i < n) {\n      bi = b[i++], next = cur ? cur.nextSibling : end;\n      if (cur == bi)\n        cur = next;\n      else if (i < n && b[i] == next)\n        parent.replaceChild(bi, cur), cur = next;\n      else\n        parent.insertBefore(bi, cur);\n    }\n    while (cur != end)\n      next = cur.nextSibling, parent.removeChild(cur), cur = next;\n  }\n  return b;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3RlbXBsYXRlLXBhcnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFFQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC91dGlscy90ZW1wbGF0ZS1wYXJ0cy5qcz85MzUwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9wYXJ0cywgX3Byb2Nlc3NvciwgX2l0ZW1zLCBfdmFsdWUsIF9lbGVtZW50LCBfYXR0cmlidXRlTmFtZSwgX25hbWVzcGFjZVVSSSwgX2xpc3QsIGxpc3RfZ2V0LCBfcGFyZW50Tm9kZSwgX25vZGVzO1xuaW1wb3J0IHsgZ2xvYmFsVGhpcyB9IGZyb20gXCIuLi91dGlscy9zZXJ2ZXItc2FmZS1nbG9iYWxzLmpzXCI7XG5jb25zdCBFTEVNRU5UID0gMTtcbmNvbnN0IFNUUklORyA9IDA7XG5jb25zdCBQQVJUID0gMTtcbmNvbnN0IGRlZmF1bHRQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NDYWxsYmFjayhpbnN0YW5jZSwgcGFydHMsIHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtleHByZXNzaW9uLCBwYXJ0XSBvZiBwYXJ0cykge1xuICAgICAgaWYgKGV4cHJlc3Npb24gaW4gc3RhdGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGF0ZVtleHByZXNzaW9uXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgJiYgcGFydCBpbnN0YW5jZW9mIEF0dHJQYXJ0ICYmIHR5cGVvZiBwYXJ0LmVsZW1lbnRbcGFydC5hdHRyaWJ1dGVOYW1lXSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICBwYXJ0LmJvb2xlYW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIHBhcnQgaW5zdGFuY2VvZiBBdHRyUGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudFtwYXJ0LmF0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSBleHRlbmRzIGdsb2JhbFRoaXMuRG9jdW1lbnRGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBzdGF0ZSwgcHJvY2Vzc29yID0gZGVmYXVsdFByb2Nlc3Nvcikge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGFydHMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcm9jZXNzb3IsIHZvaWQgMCk7XG4gICAgdGhpcy5hcHBlbmQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGFydHMsIHBhcnNlKHRoaXMpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Byb2Nlc3NvciwgcHJvY2Vzc29yKTtcbiAgICAoX2EgPSBwcm9jZXNzb3IuY3JlYXRlQ2FsbGJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHByb2Nlc3NvciwgdGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cyksIHN0YXRlKTtcbiAgICBwcm9jZXNzb3IucHJvY2Vzc0NhbGxiYWNrKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpLCBzdGF0ZSk7XG4gIH1cbiAgdXBkYXRlKHN0YXRlKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9wcm9jZXNzb3IpLnByb2Nlc3NDYWxsYmFjayh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKSwgc3RhdGUpO1xuICB9XG59XG5fcGFydHMgPSBuZXcgV2Vha01hcCgpO1xuX3Byb2Nlc3NvciA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwYXJzZSA9IChlbGVtZW50LCBwYXJ0cyA9IFtdKSA9PiB7XG4gIGxldCB0eXBlLCB2YWx1ZTtcbiAgZm9yIChsZXQgYXR0ciBvZiBlbGVtZW50LmF0dHJpYnV0ZXMgfHwgW10pIHtcbiAgICBpZiAoYXR0ci52YWx1ZS5pbmNsdWRlcyhcInt7XCIpKSB7XG4gICAgICBjb25zdCBsaXN0ID0gbmV3IEF0dHJQYXJ0TGlzdCgpO1xuICAgICAgZm9yIChbdHlwZSwgdmFsdWVdIG9mIHRva2VuaXplKGF0dHIudmFsdWUpKSB7XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICBsaXN0LmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgQXR0clBhcnQoZWxlbWVudCwgYXR0ci5uYW1lLCBhdHRyLm5hbWVzcGFjZVVSSSk7XG4gICAgICAgICAgbGlzdC5hcHBlbmQocGFydCk7XG4gICAgICAgICAgcGFydHMucHVzaChbdmFsdWUsIHBhcnRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXR0ci52YWx1ZSA9IGxpc3QudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgbm9kZSBvZiBlbGVtZW50LmNoaWxkTm9kZXMpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVCAmJiAhKG5vZGUgaW5zdGFuY2VvZiBIVE1MVGVtcGxhdGVFbGVtZW50KSkge1xuICAgICAgcGFyc2Uobm9kZSwgcGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVCB8fCBub2RlLmRhdGEuaW5jbHVkZXMoXCJ7e1wiKSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBpZiAobm9kZS5kYXRhKSB7XG4gICAgICAgICAgZm9yIChbdHlwZSwgdmFsdWVdIG9mIHRva2VuaXplKG5vZGUuZGF0YSkpXG4gICAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3IFRleHQodmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IENoaWxkTm9kZVBhcnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goW3ZhbHVlLCBwYXJ0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IElubmVyVGVtcGxhdGVQYXJ0KGVsZW1lbnQsIG5vZGUpO1xuICAgICAgICAgIGl0ZW1zLnB1c2gocGFydCk7XG4gICAgICAgICAgcGFydHMucHVzaChbcGFydC5leHByZXNzaW9uLCBwYXJ0XSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yZXBsYWNlV2l0aChcbiAgICAgICAgICAuLi5pdGVtcy5mbGF0TWFwKChwYXJ0KSA9PiBwYXJ0LnJlcGxhY2VtZW50Tm9kZXMgfHwgW3BhcnRdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuY29uc3QgbWVtID0ge307XG5jb25zdCB0b2tlbml6ZSA9ICh0ZXh0KSA9PiB7XG4gIGxldCB2YWx1ZSA9IFwiXCIsIG9wZW4gPSAwLCB0b2tlbnMgPSBtZW1bdGV4dF0sIGkgPSAwLCBjO1xuICBpZiAodG9rZW5zKVxuICAgIHJldHVybiB0b2tlbnM7XG4gIGVsc2VcbiAgICB0b2tlbnMgPSBbXTtcbiAgZm9yICg7IGMgPSB0ZXh0W2ldOyBpKyspIHtcbiAgICBpZiAoYyA9PT0gXCJ7XCIgJiYgdGV4dFtpICsgMV0gPT09IFwie1wiICYmIHRleHRbaSAtIDFdICE9PSBcIlxcXFxcIiAmJiB0ZXh0W2kgKyAyXSAmJiArK29wZW4gPT0gMSkge1xuICAgICAgaWYgKHZhbHVlKVxuICAgICAgICB0b2tlbnMucHVzaChbU1RSSU5HLCB2YWx1ZV0pO1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJ9XCIgJiYgdGV4dFtpICsgMV0gPT09IFwifVwiICYmIHRleHRbaSAtIDFdICE9PSBcIlxcXFxcIiAmJiAhLS1vcGVuKSB7XG4gICAgICB0b2tlbnMucHVzaChbUEFSVCwgdmFsdWUudHJpbSgpXSk7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICBpKys7XG4gICAgfSBlbHNlXG4gICAgICB2YWx1ZSArPSBjIHx8IFwiXCI7XG4gIH1cbiAgaWYgKHZhbHVlKVxuICAgIHRva2Vucy5wdXNoKFtTVFJJTkcsIChvcGVuID4gMCA/IFwie3tcIiA6IFwiXCIpICsgdmFsdWVdKTtcbiAgcmV0dXJuIG1lbVt0ZXh0XSA9IHRva2Vucztcbn07XG5jb25zdCBGUkFHTUVOVCA9IDExO1xuY2xhc3MgUGFydCB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBzZXQgdmFsdWUodmFsKSB7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn1cbmNvbnN0IGF0dHJQYXJ0VG9MaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBBdHRyUGFydExpc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2l0ZW1zLCBbXSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXRlbXMpLnZhbHVlcygpO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXRlbXMpLmxlbmd0aDtcbiAgfVxuICBpdGVtKGluZGV4KSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXRlbXMpW2luZGV4XTtcbiAgfVxuICBhcHBlbmQoLi4uaXRlbXMpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXR0clBhcnQpIHtcbiAgICAgICAgYXR0clBhcnRUb0xpc3Quc2V0KGl0ZW0sIHRoaXMpO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pdGVtcykucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXRlbXMpLmpvaW4oXCJcIik7XG4gIH1cbn1cbl9pdGVtcyA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBBdHRyUGFydCBleHRlbmRzIFBhcnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGlzdCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF92YWx1ZSwgXCJcIik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbGVtZW50LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYXR0cmlidXRlTmFtZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX25hbWVzcGFjZVVSSSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2VsZW1lbnQsIGVsZW1lbnQpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9uYW1lc3BhY2VVUkksIG5hbWVzcGFjZVVSSSk7XG4gIH1cbiAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgZ2V0IGF0dHJpYnV0ZU5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9uYW1lc3BhY2VVUkkpO1xuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2VsZW1lbnQpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF92YWx1ZSk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfdmFsdWUpID09PSBuZXdWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2xpc3QsIGxpc3RfZ2V0KSB8fCBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3QsIGxpc3RfZ2V0KS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZWxlbWVudCkucmVtb3ZlQXR0cmlidXRlTlMoXG4gICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9uYW1lc3BhY2VVUkkpLFxuICAgICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cmlidXRlTmFtZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZWxlbWVudCkuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9uYW1lc3BhY2VVUkkpLFxuICAgICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9lbGVtZW50KS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9uYW1lc3BhY2VVUkkpLFxuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2F0dHJpYnV0ZU5hbWUpLFxuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3QsIGxpc3RfZ2V0KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJvb2xlYW5WYWx1ZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9lbGVtZW50KS5oYXNBdHRyaWJ1dGVOUyhcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbmFtZXNwYWNlVVJJKSxcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXR0cmlidXRlTmFtZSlcbiAgICApO1xuICB9XG4gIHNldCBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdCwgbGlzdF9nZXQpIHx8IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdCwgbGlzdF9nZXQpLmxlbmd0aCA9PT0gMSlcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSA/IFwiXCIgOiBudWxsO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJWYWx1ZSBpcyBub3QgZnVsbHkgdGVtcGxhdGl6ZWRcIik7XG4gIH1cbn1cbl92YWx1ZSA9IG5ldyBXZWFrTWFwKCk7XG5fZWxlbWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fYXR0cmlidXRlTmFtZSA9IG5ldyBXZWFrTWFwKCk7XG5fbmFtZXNwYWNlVVJJID0gbmV3IFdlYWtNYXAoKTtcbl9saXN0ID0gbmV3IFdlYWtTZXQoKTtcbmxpc3RfZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBhdHRyUGFydFRvTGlzdC5nZXQodGhpcyk7XG59O1xuY2xhc3MgQ2hpbGROb2RlUGFydCBleHRlbmRzIFBhcnQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlLCBub2Rlcykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wYXJlbnROb2RlLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbm9kZXMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wYXJlbnROb2RlLCBwYXJlbnROb2RlKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX25vZGVzLCBub2RlcyA/IFsuLi5ub2Rlc10gOiBbbmV3IFRleHQoKV0pO1xuICB9XG4gIGdldCByZXBsYWNlbWVudE5vZGVzKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX25vZGVzKTtcbiAgfVxuICBnZXQgcGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wYXJlbnROb2RlKTtcbiAgfVxuICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbm9kZXMpW19fcHJpdmF0ZUdldCh0aGlzLCBfbm9kZXMpLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nO1xuICB9XG4gIGdldCBwcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbm9kZXMpWzBdLnByZXZpb3VzU2libGluZztcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbm9kZXMpLm1hcCgobm9kZSkgPT4gbm9kZS50ZXh0Q29udGVudCkuam9pbihcIlwiKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICB0aGlzLnJlcGxhY2UobmV3VmFsdWUpO1xuICB9XG4gIHJlcGxhY2UoLi4ubm9kZXMpIHtcbiAgICBjb25zdCBub3JtYWxpc2VkTm9kZXMgPSBub2Rlcy5mbGF0KCkuZmxhdE1hcChcbiAgICAgIChub2RlKSA9PiBub2RlID09IG51bGwgPyBbbmV3IFRleHQoKV0gOiBub2RlLmZvckVhY2ggPyBbLi4ubm9kZV0gOiBub2RlLm5vZGVUeXBlID09PSBGUkFHTUVOVCA/IFsuLi5ub2RlLmNoaWxkTm9kZXNdIDogbm9kZS5ub2RlVHlwZSA/IFtub2RlXSA6IFtuZXcgVGV4dChub2RlKV1cbiAgICApO1xuICAgIGlmICghbm9ybWFsaXNlZE5vZGVzLmxlbmd0aClcbiAgICAgIG5vcm1hbGlzZWROb2Rlcy5wdXNoKG5ldyBUZXh0KCkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbm9kZXMsIHN3YXBkb20oXG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX25vZGVzKVswXS5wYXJlbnROb2RlLFxuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9ub2RlcyksXG4gICAgICBub3JtYWxpc2VkTm9kZXMsXG4gICAgICB0aGlzLm5leHRTaWJsaW5nXG4gICAgKSk7XG4gIH1cbn1cbl9wYXJlbnROb2RlID0gbmV3IFdlYWtNYXAoKTtcbl9ub2RlcyA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBJbm5lclRlbXBsYXRlUGFydCBleHRlbmRzIENoaWxkTm9kZVBhcnQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlLCB0ZW1wbGF0ZSkge1xuICAgIGxldCBkaXJlY3RpdmUgPSB0ZW1wbGF0ZS5nZXRBdHRyaWJ1dGUoXCJkaXJlY3RpdmVcIikgfHwgdGVtcGxhdGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHRlbXBsYXRlLmdldEF0dHJpYnV0ZShcImV4cHJlc3Npb25cIikgfHwgdGVtcGxhdGUuZ2V0QXR0cmlidXRlKGRpcmVjdGl2ZSkgfHwgXCJcIjtcbiAgICBpZiAoZXhwcmVzc2lvbi5zdGFydHNXaXRoKFwie3tcIikpXG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi50cmltKCkuc2xpY2UoMiwgLTIpLnRyaW0oKTtcbiAgICBzdXBlcihwYXJlbnROb2RlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGlyZWN0aXZlXCIpO1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICB9XG59XG5mdW5jdGlvbiBzd2FwZG9tKHBhcmVudCwgYSwgYiwgZW5kID0gbnVsbCkge1xuICBsZXQgaSA9IDAsIGN1ciwgbmV4dCwgYmksIG4gPSBiLmxlbmd0aCwgbSA9IGEubGVuZ3RoO1xuICB3aGlsZSAoaSA8IG4gJiYgaSA8IG0gJiYgYVtpXSA9PSBiW2ldKVxuICAgIGkrKztcbiAgd2hpbGUgKGkgPCBuICYmIGkgPCBtICYmIGJbbiAtIDFdID09IGFbbSAtIDFdKVxuICAgIGVuZCA9IGJbLS1tLCAtLW5dO1xuICBpZiAoaSA9PSBtKVxuICAgIHdoaWxlIChpIDwgbilcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoYltpKytdLCBlbmQpO1xuICBpZiAoaSA9PSBuKVxuICAgIHdoaWxlIChpIDwgbSlcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChhW2krK10pO1xuICBlbHNlIHtcbiAgICBjdXIgPSBhW2ldO1xuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgYmkgPSBiW2krK10sIG5leHQgPSBjdXIgPyBjdXIubmV4dFNpYmxpbmcgOiBlbmQ7XG4gICAgICBpZiAoY3VyID09IGJpKVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgZWxzZSBpZiAoaSA8IG4gJiYgYltpXSA9PSBuZXh0KVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGJpLCBjdXIpLCBjdXIgPSBuZXh0O1xuICAgICAgZWxzZVxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGJpLCBjdXIpO1xuICAgIH1cbiAgICB3aGlsZSAoY3VyICE9IGVuZClcbiAgICAgIG5leHQgPSBjdXIubmV4dFNpYmxpbmcsIHBhcmVudC5yZW1vdmVDaGlsZChjdXIpLCBjdXIgPSBuZXh0O1xuICB9XG4gIHJldHVybiBiO1xufVxuZXhwb3J0IHtcbiAgQXR0clBhcnQsXG4gIEF0dHJQYXJ0TGlzdCxcbiAgQ2hpbGROb2RlUGFydCxcbiAgSW5uZXJUZW1wbGF0ZVBhcnQsXG4gIFBhcnQsXG4gIFRlbXBsYXRlSW5zdGFuY2UsXG4gIGRlZmF1bHRQcm9jZXNzb3IsXG4gIHBhcnNlLFxuICB0b2tlbml6ZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/template-parts.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/template-processor.js":
/*!********************************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/template-processor.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateExpression: function() { return /* binding */ evaluateExpression; },\n/* harmony export */   getParamValue: function() { return /* binding */ getParamValue; },\n/* harmony export */   processor: function() { return /* binding */ processor; },\n/* harmony export */   tokenizeExpression: function() { return /* binding */ tokenizeExpression; }\n/* harmony export */ });\n/* harmony import */ var _template_parts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-parts.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/template-parts.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/utils.js\");\n\n\nconst pipeModifiers = {\n  string: (value) => String(value)\n};\nclass PartialTemplate {\n  constructor(template) {\n    this.template = template;\n    this.state = void 0;\n  }\n}\nconst templates = /* @__PURE__ */ new WeakMap();\nconst templateInstances = /* @__PURE__ */ new WeakMap();\nconst Directives = {\n  partial: (part, state) => {\n    state[part.expression] = new PartialTemplate(part.template);\n  },\n  if: (part, state) => {\n    var _a;\n    if (evaluateExpression(part.expression, state)) {\n      if (templates.get(part) !== part.template) {\n        templates.set(part, part.template);\n        const tpl = new _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.TemplateInstance(part.template, state, processor);\n        part.replace(tpl);\n        templateInstances.set(part, tpl);\n      } else {\n        (_a = templateInstances.get(part)) == null ? void 0 : _a.update(state);\n      }\n    } else {\n      part.replace(\"\");\n      templates.delete(part);\n      templateInstances.delete(part);\n    }\n  }\n};\nconst DirectiveNames = Object.keys(Directives);\nconst processor = {\n  processCallback(instance, parts, state) {\n    var _a, _b;\n    if (!state)\n      return;\n    for (const [expression, part] of parts) {\n      if (part instanceof _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.InnerTemplatePart) {\n        if (!part.directive) {\n          const directive = DirectiveNames.find((n) => part.template.hasAttribute(n));\n          if (directive) {\n            part.directive = directive;\n            part.expression = part.template.getAttribute(directive);\n          }\n        }\n        (_a = Directives[part.directive]) == null ? void 0 : _a.call(Directives, part, state);\n        continue;\n      }\n      let value = evaluateExpression(expression, state);\n      if (value instanceof PartialTemplate) {\n        if (templates.get(part) !== value.template) {\n          templates.set(part, value.template);\n          value = new _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.TemplateInstance(\n            value.template,\n            value.state,\n            processor\n          );\n          part.value = value;\n          templateInstances.set(part, value);\n        } else {\n          (_b = templateInstances.get(part)) == null ? void 0 : _b.update(value.state);\n        }\n        continue;\n      }\n      if (value) {\n        if (part instanceof _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.AttrPart) {\n          if (part.attributeName.startsWith(\"aria-\")) {\n            value = String(value);\n          }\n        }\n        if (part instanceof _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.AttrPart) {\n          if (typeof value === \"boolean\") {\n            part.booleanValue = value;\n          } else if (typeof value === \"function\") {\n            part.element[part.attributeName] = value;\n          } else {\n            part.value = value;\n          }\n        } else {\n          part.value = value;\n          templates.delete(part);\n          templateInstances.delete(part);\n        }\n      } else {\n        if (part instanceof _template_parts_js__WEBPACK_IMPORTED_MODULE_0__.AttrPart) {\n          part.value = void 0;\n        } else {\n          part.value = void 0;\n          templates.delete(part);\n          templateInstances.delete(part);\n        }\n      }\n    }\n  }\n};\nconst operators = {\n  \"!\": (a) => !a,\n  \"!!\": (a) => !!a,\n  \"==\": (a, b) => a == b,\n  \"!=\": (a, b) => a != b,\n  \">\": (a, b) => a > b,\n  \">=\": (a, b) => a >= b,\n  \"<\": (a, b) => a < b,\n  \"<=\": (a, b) => a <= b,\n  \"??\": (a, b) => a != null ? a : b,\n  \"|\": (a, b) => {\n    var _a;\n    return (_a = pipeModifiers[b]) == null ? void 0 : _a.call(pipeModifiers, a);\n  }\n};\nfunction tokenizeExpression(expr) {\n  return tokenize(expr, {\n    boolean: /true|false/,\n    number: /-?\\d+\\.?\\d*/,\n    string: /([\"'])((?:\\\\.|[^\\\\])*?)\\1/,\n    operator: /[!=><][=!]?|\\?\\?|\\|/,\n    ws: /\\s+/,\n    param: /[$a-z_][$\\w]*/i\n  }).filter(({ type }) => type !== \"ws\");\n}\nfunction evaluateExpression(expr, state = {}) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const tokens = tokenizeExpression(expr);\n  if (tokens.length === 0 || tokens.some(({ type }) => !type)) {\n    return invalidExpression(expr);\n  }\n  if (((_a = tokens[0]) == null ? void 0 : _a.token) === \">\") {\n    const partial = state[(_b = tokens[1]) == null ? void 0 : _b.token];\n    if (!partial) {\n      return invalidExpression(expr);\n    }\n    const partialState = { ...state };\n    partial.state = partialState;\n    const args = tokens.slice(2);\n    for (let i = 0; i < args.length; i += 3) {\n      const name = (_c = args[i]) == null ? void 0 : _c.token;\n      const operator = (_d = args[i + 1]) == null ? void 0 : _d.token;\n      const value = (_e = args[i + 2]) == null ? void 0 : _e.token;\n      if (name && operator === \"=\") {\n        partialState[name] = getParamValue(value, state);\n      }\n    }\n    return partial;\n  }\n  if (tokens.length === 1) {\n    if (!isValidParam(tokens[0])) {\n      return invalidExpression(expr);\n    }\n    return getParamValue(tokens[0].token, state);\n  }\n  if (tokens.length === 2) {\n    const operator = (_f = tokens[0]) == null ? void 0 : _f.token;\n    const run = operators[operator];\n    if (!run || !isValidParam(tokens[1])) {\n      return invalidExpression(expr);\n    }\n    const a = getParamValue(tokens[1].token, state);\n    return run(a);\n  }\n  if (tokens.length === 3) {\n    const operator = (_g = tokens[1]) == null ? void 0 : _g.token;\n    const run = operators[operator];\n    if (!run || !isValidParam(tokens[0]) || !isValidParam(tokens[2])) {\n      return invalidExpression(expr);\n    }\n    const a = getParamValue(tokens[0].token, state);\n    if (operator === \"|\") {\n      return run(a, tokens[2].token);\n    }\n    const b = getParamValue(tokens[2].token, state);\n    return run(a, b);\n  }\n}\nfunction invalidExpression(expr) {\n  console.warn(`Warning: invalid expression \\`${expr}\\``);\n  return false;\n}\nfunction isValidParam({ type }) {\n  return [\"number\", \"boolean\", \"string\", \"param\"].includes(type);\n}\nfunction getParamValue(raw, state) {\n  const firstChar = raw[0];\n  const lastChar = raw.slice(-1);\n  if (raw === \"true\" || raw === \"false\") {\n    return raw === \"true\";\n  }\n  if (firstChar === lastChar && [`'`, `\"`].includes(firstChar)) {\n    return raw.slice(1, -1);\n  }\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumericString)(raw)) {\n    return parseFloat(raw);\n  }\n  return state[raw];\n}\nfunction tokenize(str, parsers) {\n  let len, match, token, tokens = [];\n  while (str) {\n    token = null;\n    len = str.length;\n    for (let key in parsers) {\n      match = parsers[key].exec(str);\n      if (match && match.index < len) {\n        token = {\n          token: match[0],\n          type: key,\n          matches: match.slice(1)\n        };\n        len = match.index;\n      }\n    }\n    if (len) {\n      tokens.push({\n        token: str.substr(0, len),\n        type: void 0\n      });\n    }\n    if (token) {\n      tokens.push(token);\n    }\n    str = str.substr(len + (token ? token.token.length : 0));\n  }\n  return tokens;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3RlbXBsYXRlLXByb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFJNkI7QUFDZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFnQjtBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUFRO0FBQ3BDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsd0RBQVE7QUFDcEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVksTUFBTTtBQUNyQjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3RlbXBsYXRlLXByb2Nlc3Nvci5qcz8zNzBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElubmVyVGVtcGxhdGVQYXJ0LFxuICBUZW1wbGF0ZUluc3RhbmNlLFxuICBBdHRyUGFydFxufSBmcm9tIFwiLi90ZW1wbGF0ZS1wYXJ0cy5qc1wiO1xuaW1wb3J0IHsgaXNOdW1lcmljU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNvbnN0IHBpcGVNb2RpZmllcnMgPSB7XG4gIHN0cmluZzogKHZhbHVlKSA9PiBTdHJpbmcodmFsdWUpXG59O1xuY2xhc3MgUGFydGlhbFRlbXBsYXRlIHtcbiAgY29uc3RydWN0b3IodGVtcGxhdGUpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IHZvaWQgMDtcbiAgfVxufVxuY29uc3QgdGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0ZW1wbGF0ZUluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgRGlyZWN0aXZlcyA9IHtcbiAgcGFydGlhbDogKHBhcnQsIHN0YXRlKSA9PiB7XG4gICAgc3RhdGVbcGFydC5leHByZXNzaW9uXSA9IG5ldyBQYXJ0aWFsVGVtcGxhdGUocGFydC50ZW1wbGF0ZSk7XG4gIH0sXG4gIGlmOiAocGFydCwgc3RhdGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGV2YWx1YXRlRXhwcmVzc2lvbihwYXJ0LmV4cHJlc3Npb24sIHN0YXRlKSkge1xuICAgICAgaWYgKHRlbXBsYXRlcy5nZXQocGFydCkgIT09IHBhcnQudGVtcGxhdGUpIHtcbiAgICAgICAgdGVtcGxhdGVzLnNldChwYXJ0LCBwYXJ0LnRlbXBsYXRlKTtcbiAgICAgICAgY29uc3QgdHBsID0gbmV3IFRlbXBsYXRlSW5zdGFuY2UocGFydC50ZW1wbGF0ZSwgc3RhdGUsIHByb2Nlc3Nvcik7XG4gICAgICAgIHBhcnQucmVwbGFjZSh0cGwpO1xuICAgICAgICB0ZW1wbGF0ZUluc3RhbmNlcy5zZXQocGFydCwgdHBsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfYSA9IHRlbXBsYXRlSW5zdGFuY2VzLmdldChwYXJ0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnQucmVwbGFjZShcIlwiKTtcbiAgICAgIHRlbXBsYXRlcy5kZWxldGUocGFydCk7XG4gICAgICB0ZW1wbGF0ZUluc3RhbmNlcy5kZWxldGUocGFydCk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgRGlyZWN0aXZlTmFtZXMgPSBPYmplY3Qua2V5cyhEaXJlY3RpdmVzKTtcbmNvbnN0IHByb2Nlc3NvciA9IHtcbiAgcHJvY2Vzc0NhbGxiYWNrKGluc3RhbmNlLCBwYXJ0cywgc3RhdGUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghc3RhdGUpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBbZXhwcmVzc2lvbiwgcGFydF0gb2YgcGFydHMpIHtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgSW5uZXJUZW1wbGF0ZVBhcnQpIHtcbiAgICAgICAgaWYgKCFwYXJ0LmRpcmVjdGl2ZSkge1xuICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IERpcmVjdGl2ZU5hbWVzLmZpbmQoKG4pID0+IHBhcnQudGVtcGxhdGUuaGFzQXR0cmlidXRlKG4pKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBwYXJ0LmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIHBhcnQuZXhwcmVzc2lvbiA9IHBhcnQudGVtcGxhdGUuZ2V0QXR0cmlidXRlKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYSA9IERpcmVjdGl2ZXNbcGFydC5kaXJlY3RpdmVdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChEaXJlY3RpdmVzLCBwYXJ0LCBzdGF0ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlID0gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHN0YXRlKTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBhcnRpYWxUZW1wbGF0ZSkge1xuICAgICAgICBpZiAodGVtcGxhdGVzLmdldChwYXJ0KSAhPT0gdmFsdWUudGVtcGxhdGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZXMuc2V0KHBhcnQsIHZhbHVlLnRlbXBsYXRlKTtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBUZW1wbGF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgdmFsdWUudGVtcGxhdGUsXG4gICAgICAgICAgICB2YWx1ZS5zdGF0ZSxcbiAgICAgICAgICAgIHByb2Nlc3NvclxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFydC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRlbXBsYXRlSW5zdGFuY2VzLnNldChwYXJ0LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKF9iID0gdGVtcGxhdGVJbnN0YW5jZXMuZ2V0KHBhcnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudXBkYXRlKHZhbHVlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIEF0dHJQYXJ0KSB7XG4gICAgICAgICAgaWYgKHBhcnQuYXR0cmlidXRlTmFtZS5zdGFydHNXaXRoKFwiYXJpYS1cIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBBdHRyUGFydCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBwYXJ0LmJvb2xlYW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHBhcnQuZWxlbWVudFtwYXJ0LmF0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRlbXBsYXRlcy5kZWxldGUocGFydCk7XG4gICAgICAgICAgdGVtcGxhdGVJbnN0YW5jZXMuZGVsZXRlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIEF0dHJQYXJ0KSB7XG4gICAgICAgICAgcGFydC52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0LnZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgIHRlbXBsYXRlcy5kZWxldGUocGFydCk7XG4gICAgICAgICAgdGVtcGxhdGVJbnN0YW5jZXMuZGVsZXRlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuY29uc3Qgb3BlcmF0b3JzID0ge1xuICBcIiFcIjogKGEpID0+ICFhLFxuICBcIiEhXCI6IChhKSA9PiAhIWEsXG4gIFwiPT1cIjogKGEsIGIpID0+IGEgPT0gYixcbiAgXCIhPVwiOiAoYSwgYikgPT4gYSAhPSBiLFxuICBcIj5cIjogKGEsIGIpID0+IGEgPiBiLFxuICBcIj49XCI6IChhLCBiKSA9PiBhID49IGIsXG4gIFwiPFwiOiAoYSwgYikgPT4gYSA8IGIsXG4gIFwiPD1cIjogKGEsIGIpID0+IGEgPD0gYixcbiAgXCI/P1wiOiAoYSwgYikgPT4gYSAhPSBudWxsID8gYSA6IGIsXG4gIFwifFwiOiAoYSwgYikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gcGlwZU1vZGlmaWVyc1tiXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocGlwZU1vZGlmaWVycywgYSk7XG4gIH1cbn07XG5mdW5jdGlvbiB0b2tlbml6ZUV4cHJlc3Npb24oZXhwcikge1xuICByZXR1cm4gdG9rZW5pemUoZXhwciwge1xuICAgIGJvb2xlYW46IC90cnVlfGZhbHNlLyxcbiAgICBudW1iZXI6IC8tP1xcZCtcXC4/XFxkKi8sXG4gICAgc3RyaW5nOiAvKFtcIiddKSgoPzpcXFxcLnxbXlxcXFxdKSo/KVxcMS8sXG4gICAgb3BlcmF0b3I6IC9bIT0+PF1bPSFdP3xcXD9cXD98XFx8LyxcbiAgICB3czogL1xccysvLFxuICAgIHBhcmFtOiAvWyRhLXpfXVskXFx3XSovaVxuICB9KS5maWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlICE9PSBcIndzXCIpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIsIHN0YXRlID0ge30pIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZUV4cHJlc3Npb24oZXhwcik7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vucy5zb21lKCh7IHR5cGUgfSkgPT4gIXR5cGUpKSB7XG4gICAgcmV0dXJuIGludmFsaWRFeHByZXNzaW9uKGV4cHIpO1xuICB9XG4gIGlmICgoKF9hID0gdG9rZW5zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9rZW4pID09PSBcIj5cIikge1xuICAgIGNvbnN0IHBhcnRpYWwgPSBzdGF0ZVsoX2IgPSB0b2tlbnNbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi50b2tlbl07XG4gICAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgICByZXR1cm4gaW52YWxpZEV4cHJlc3Npb24oZXhwcik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpYWxTdGF0ZSA9IHsgLi4uc3RhdGUgfTtcbiAgICBwYXJ0aWFsLnN0YXRlID0gcGFydGlhbFN0YXRlO1xuICAgIGNvbnN0IGFyZ3MgPSB0b2tlbnMuc2xpY2UoMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjb25zdCBuYW1lID0gKF9jID0gYXJnc1tpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRva2VuO1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSAoX2QgPSBhcmdzW2kgKyAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRva2VuO1xuICAgICAgY29uc3QgdmFsdWUgPSAoX2UgPSBhcmdzW2kgKyAyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnRva2VuO1xuICAgICAgaWYgKG5hbWUgJiYgb3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgIHBhcnRpYWxTdGF0ZVtuYW1lXSA9IGdldFBhcmFtVmFsdWUodmFsdWUsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWw7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoIWlzVmFsaWRQYXJhbSh0b2tlbnNbMF0pKSB7XG4gICAgICByZXR1cm4gaW52YWxpZEV4cHJlc3Npb24oZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBnZXRQYXJhbVZhbHVlKHRva2Vuc1swXS50b2tlbiwgc3RhdGUpO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSAoX2YgPSB0b2tlbnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZi50b2tlbjtcbiAgICBjb25zdCBydW4gPSBvcGVyYXRvcnNbb3BlcmF0b3JdO1xuICAgIGlmICghcnVuIHx8ICFpc1ZhbGlkUGFyYW0odG9rZW5zWzFdKSkge1xuICAgICAgcmV0dXJuIGludmFsaWRFeHByZXNzaW9uKGV4cHIpO1xuICAgIH1cbiAgICBjb25zdCBhID0gZ2V0UGFyYW1WYWx1ZSh0b2tlbnNbMV0udG9rZW4sIHN0YXRlKTtcbiAgICByZXR1cm4gcnVuKGEpO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAzKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSAoX2cgPSB0b2tlbnNbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfZy50b2tlbjtcbiAgICBjb25zdCBydW4gPSBvcGVyYXRvcnNbb3BlcmF0b3JdO1xuICAgIGlmICghcnVuIHx8ICFpc1ZhbGlkUGFyYW0odG9rZW5zWzBdKSB8fCAhaXNWYWxpZFBhcmFtKHRva2Vuc1syXSkpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkRXhwcmVzc2lvbihleHByKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IGdldFBhcmFtVmFsdWUodG9rZW5zWzBdLnRva2VuLCBzdGF0ZSk7XG4gICAgaWYgKG9wZXJhdG9yID09PSBcInxcIikge1xuICAgICAgcmV0dXJuIHJ1bihhLCB0b2tlbnNbMl0udG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBiID0gZ2V0UGFyYW1WYWx1ZSh0b2tlbnNbMl0udG9rZW4sIHN0YXRlKTtcbiAgICByZXR1cm4gcnVuKGEsIGIpO1xuICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkRXhwcmVzc2lvbihleHByKSB7XG4gIGNvbnNvbGUud2FybihgV2FybmluZzogaW52YWxpZCBleHByZXNzaW9uIFxcYCR7ZXhwcn1cXGBgKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZFBhcmFtKHsgdHlwZSB9KSB7XG4gIHJldHVybiBbXCJudW1iZXJcIiwgXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwicGFyYW1cIl0uaW5jbHVkZXModHlwZSk7XG59XG5mdW5jdGlvbiBnZXRQYXJhbVZhbHVlKHJhdywgc3RhdGUpIHtcbiAgY29uc3QgZmlyc3RDaGFyID0gcmF3WzBdO1xuICBjb25zdCBsYXN0Q2hhciA9IHJhdy5zbGljZSgtMSk7XG4gIGlmIChyYXcgPT09IFwidHJ1ZVwiIHx8IHJhdyA9PT0gXCJmYWxzZVwiKSB7XG4gICAgcmV0dXJuIHJhdyA9PT0gXCJ0cnVlXCI7XG4gIH1cbiAgaWYgKGZpcnN0Q2hhciA9PT0gbGFzdENoYXIgJiYgW2AnYCwgYFwiYF0uaW5jbHVkZXMoZmlyc3RDaGFyKSkge1xuICAgIHJldHVybiByYXcuc2xpY2UoMSwgLTEpO1xuICB9XG4gIGlmIChpc051bWVyaWNTdHJpbmcocmF3KSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHJhdyk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW3Jhd107XG59XG5mdW5jdGlvbiB0b2tlbml6ZShzdHIsIHBhcnNlcnMpIHtcbiAgbGV0IGxlbiwgbWF0Y2gsIHRva2VuLCB0b2tlbnMgPSBbXTtcbiAgd2hpbGUgKHN0cikge1xuICAgIHRva2VuID0gbnVsbDtcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJzZXJzKSB7XG4gICAgICBtYXRjaCA9IHBhcnNlcnNba2V5XS5leGVjKHN0cik7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBsZW4pIHtcbiAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgdG9rZW46IG1hdGNoWzBdLFxuICAgICAgICAgIHR5cGU6IGtleSxcbiAgICAgICAgICBtYXRjaGVzOiBtYXRjaC5zbGljZSgxKVxuICAgICAgICB9O1xuICAgICAgICBsZW4gPSBtYXRjaC5pbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlbikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0b2tlbjogc3RyLnN1YnN0cigwLCBsZW4pLFxuICAgICAgICB0eXBlOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgc3RyID0gc3RyLnN1YnN0cihsZW4gKyAodG9rZW4gPyB0b2tlbi50b2tlbi5sZW5ndGggOiAwKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cbmV4cG9ydCB7XG4gIGV2YWx1YXRlRXhwcmVzc2lvbixcbiAgZ2V0UGFyYW1WYWx1ZSxcbiAgcHJvY2Vzc29yLFxuICB0b2tlbml6ZUV4cHJlc3Npb25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/template-processor.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/time.js":
/*!******************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/time.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emptyTimeRanges: function() { return /* binding */ emptyTimeRanges; },\n/* harmony export */   formatAsTimePhrase: function() { return /* binding */ formatAsTimePhrase; },\n/* harmony export */   formatTime: function() { return /* binding */ formatTime; },\n/* harmony export */   serializeTimeRanges: function() { return /* binding */ serializeTimeRanges; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-client)/./node_modules/media-chrome/dist/utils/utils.js\");\n\nconst UnitLabels = [\n  {\n    singular: \"hour\",\n    plural: \"hours\"\n  },\n  {\n    singular: \"minute\",\n    plural: \"minutes\"\n  },\n  {\n    singular: \"second\",\n    plural: \"seconds\"\n  }\n];\nconst toTimeUnitPhrase = (timeUnitValue, unitIndex) => {\n  const unitLabel = timeUnitValue === 1 ? UnitLabels[unitIndex].singular : UnitLabels[unitIndex].plural;\n  return `${timeUnitValue} ${unitLabel}`;\n};\nconst formatAsTimePhrase = (seconds) => {\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidNumber)(seconds))\n    return \"\";\n  const positiveSeconds = Math.abs(seconds);\n  const negative = positiveSeconds !== seconds;\n  const secondsDateTime = new Date(0, 0, 0, 0, 0, positiveSeconds, 0);\n  const timeParts = [\n    secondsDateTime.getHours(),\n    secondsDateTime.getMinutes(),\n    secondsDateTime.getSeconds()\n  ];\n  const timeString = timeParts.map(\n    (timeUnitValue, index) => timeUnitValue && toTimeUnitPhrase(timeUnitValue, index)\n  ).filter((x) => x).join(\", \");\n  const negativeSuffix = negative ? \" remaining\" : \"\";\n  return `${timeString}${negativeSuffix}`;\n};\nfunction formatTime(seconds, guide) {\n  let negative = false;\n  if (seconds < 0) {\n    negative = true;\n    seconds = 0 - seconds;\n  }\n  seconds = seconds < 0 ? 0 : seconds;\n  let s = Math.floor(seconds % 60);\n  let m = Math.floor(seconds / 60 % 60);\n  let h = Math.floor(seconds / 3600);\n  const gm = Math.floor(guide / 60 % 60);\n  const gh = Math.floor(guide / 3600);\n  if (isNaN(seconds) || seconds === Infinity) {\n    h = m = s = \"-\";\n  }\n  h = h > 0 || gh > 0 ? h + \":\" : \"\";\n  m = ((h || gm >= 10) && m < 10 ? \"0\" + m : m) + \":\";\n  s = s < 10 ? \"0\" + s : s;\n  return (negative ? \"-\" : \"\") + h + m + s;\n}\nconst emptyTimeRanges = Object.freeze({\n  length: 0,\n  start(index) {\n    const unsignedIdx = index >>> 0;\n    if (unsignedIdx >= this.length) {\n      throw new DOMException(\n        `Failed to execute 'start' on 'TimeRanges': The index provided (${unsignedIdx}) is greater than or equal to the maximum bound (${this.length}).`\n      );\n    }\n    return 0;\n  },\n  end(index) {\n    const unsignedIdx = index >>> 0;\n    if (unsignedIdx >= this.length) {\n      throw new DOMException(\n        `Failed to execute 'end' on 'TimeRanges': The index provided (${unsignedIdx}) is greater than or equal to the maximum bound (${this.length}).`\n      );\n    }\n    return 0;\n  }\n});\nfunction serializeTimeRanges(timeRanges = emptyTimeRanges) {\n  return Array.from(timeRanges).map((_, i) => [\n    Number(timeRanges.start(i).toFixed(3)),\n    Number(timeRanges.end(i).toFixed(3))\n  ].join(\":\")).join(\" \");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3RpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlLEVBQUUsVUFBVTtBQUN2QztBQUNBO0FBQ0EsT0FBTyx3REFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVyxFQUFFLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVksbURBQW1ELFlBQVk7QUFDcko7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksbURBQW1ELFlBQVk7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3RpbWUuanM/NGY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1ZhbGlkTnVtYmVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNvbnN0IFVuaXRMYWJlbHMgPSBbXG4gIHtcbiAgICBzaW5ndWxhcjogXCJob3VyXCIsXG4gICAgcGx1cmFsOiBcImhvdXJzXCJcbiAgfSxcbiAge1xuICAgIHNpbmd1bGFyOiBcIm1pbnV0ZVwiLFxuICAgIHBsdXJhbDogXCJtaW51dGVzXCJcbiAgfSxcbiAge1xuICAgIHNpbmd1bGFyOiBcInNlY29uZFwiLFxuICAgIHBsdXJhbDogXCJzZWNvbmRzXCJcbiAgfVxuXTtcbmNvbnN0IHRvVGltZVVuaXRQaHJhc2UgPSAodGltZVVuaXRWYWx1ZSwgdW5pdEluZGV4KSA9PiB7XG4gIGNvbnN0IHVuaXRMYWJlbCA9IHRpbWVVbml0VmFsdWUgPT09IDEgPyBVbml0TGFiZWxzW3VuaXRJbmRleF0uc2luZ3VsYXIgOiBVbml0TGFiZWxzW3VuaXRJbmRleF0ucGx1cmFsO1xuICByZXR1cm4gYCR7dGltZVVuaXRWYWx1ZX0gJHt1bml0TGFiZWx9YDtcbn07XG5jb25zdCBmb3JtYXRBc1RpbWVQaHJhc2UgPSAoc2Vjb25kcykgPT4ge1xuICBpZiAoIWlzVmFsaWROdW1iZXIoc2Vjb25kcykpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHBvc2l0aXZlU2Vjb25kcyA9IE1hdGguYWJzKHNlY29uZHMpO1xuICBjb25zdCBuZWdhdGl2ZSA9IHBvc2l0aXZlU2Vjb25kcyAhPT0gc2Vjb25kcztcbiAgY29uc3Qgc2Vjb25kc0RhdGVUaW1lID0gbmV3IERhdGUoMCwgMCwgMCwgMCwgMCwgcG9zaXRpdmVTZWNvbmRzLCAwKTtcbiAgY29uc3QgdGltZVBhcnRzID0gW1xuICAgIHNlY29uZHNEYXRlVGltZS5nZXRIb3VycygpLFxuICAgIHNlY29uZHNEYXRlVGltZS5nZXRNaW51dGVzKCksXG4gICAgc2Vjb25kc0RhdGVUaW1lLmdldFNlY29uZHMoKVxuICBdO1xuICBjb25zdCB0aW1lU3RyaW5nID0gdGltZVBhcnRzLm1hcChcbiAgICAodGltZVVuaXRWYWx1ZSwgaW5kZXgpID0+IHRpbWVVbml0VmFsdWUgJiYgdG9UaW1lVW5pdFBocmFzZSh0aW1lVW5pdFZhbHVlLCBpbmRleClcbiAgKS5maWx0ZXIoKHgpID0+IHgpLmpvaW4oXCIsIFwiKTtcbiAgY29uc3QgbmVnYXRpdmVTdWZmaXggPSBuZWdhdGl2ZSA/IFwiIHJlbWFpbmluZ1wiIDogXCJcIjtcbiAgcmV0dXJuIGAke3RpbWVTdHJpbmd9JHtuZWdhdGl2ZVN1ZmZpeH1gO1xufTtcbmZ1bmN0aW9uIGZvcm1hdFRpbWUoc2Vjb25kcywgZ3VpZGUpIHtcbiAgbGV0IG5lZ2F0aXZlID0gZmFsc2U7XG4gIGlmIChzZWNvbmRzIDwgMCkge1xuICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICBzZWNvbmRzID0gMCAtIHNlY29uZHM7XG4gIH1cbiAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gIGxldCBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICBsZXQgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICBsZXQgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICBjb25zdCBnbSA9IE1hdGguZmxvb3IoZ3VpZGUgLyA2MCAlIDYwKTtcbiAgY29uc3QgZ2ggPSBNYXRoLmZsb29yKGd1aWRlIC8gMzYwMCk7XG4gIGlmIChpc05hTihzZWNvbmRzKSB8fCBzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgIGggPSBtID0gcyA9IFwiLVwiO1xuICB9XG4gIGggPSBoID4gMCB8fCBnaCA+IDAgPyBoICsgXCI6XCIgOiBcIlwiO1xuICBtID0gKChoIHx8IGdtID49IDEwKSAmJiBtIDwgMTAgPyBcIjBcIiArIG0gOiBtKSArIFwiOlwiO1xuICBzID0gcyA8IDEwID8gXCIwXCIgKyBzIDogcztcbiAgcmV0dXJuIChuZWdhdGl2ZSA/IFwiLVwiIDogXCJcIikgKyBoICsgbSArIHM7XG59XG5jb25zdCBlbXB0eVRpbWVSYW5nZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydChpbmRleCkge1xuICAgIGNvbnN0IHVuc2lnbmVkSWR4ID0gaW5kZXggPj4+IDA7XG4gICAgaWYgKHVuc2lnbmVkSWR4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ3N0YXJ0JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHt1bnNpZ25lZElkeH0pIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF4aW11bSBib3VuZCAoJHt0aGlzLmxlbmd0aH0pLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBlbmQoaW5kZXgpIHtcbiAgICBjb25zdCB1bnNpZ25lZElkeCA9IGluZGV4ID4+PiAwO1xuICAgIGlmICh1bnNpZ25lZElkeCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdlbmQnIG9uICdUaW1lUmFuZ2VzJzogVGhlIGluZGV4IHByb3ZpZGVkICgke3Vuc2lnbmVkSWR4fSkgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIGJvdW5kICgke3RoaXMubGVuZ3RofSkuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn0pO1xuZnVuY3Rpb24gc2VyaWFsaXplVGltZVJhbmdlcyh0aW1lUmFuZ2VzID0gZW1wdHlUaW1lUmFuZ2VzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRpbWVSYW5nZXMpLm1hcCgoXywgaSkgPT4gW1xuICAgIE51bWJlcih0aW1lUmFuZ2VzLnN0YXJ0KGkpLnRvRml4ZWQoMykpLFxuICAgIE51bWJlcih0aW1lUmFuZ2VzLmVuZChpKS50b0ZpeGVkKDMpKVxuICBdLmpvaW4oXCI6XCIpKS5qb2luKFwiIFwiKTtcbn1cbmV4cG9ydCB7XG4gIGVtcHR5VGltZVJhbmdlcyxcbiAgZm9ybWF0QXNUaW1lUGhyYXNlLFxuICBmb3JtYXRUaW1lLFxuICBzZXJpYWxpemVUaW1lUmFuZ2VzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/time.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/media-chrome/dist/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-chrome/dist/utils/utils.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelCase: function() { return /* binding */ camelCase; },\n/* harmony export */   constToCamel: function() { return /* binding */ constToCamel; },\n/* harmony export */   dashedToCamel: function() { return /* binding */ dashedToCamel; },\n/* harmony export */   delay: function() { return /* binding */ delay; },\n/* harmony export */   isNumericString: function() { return /* binding */ isNumericString; },\n/* harmony export */   isValidNumber: function() { return /* binding */ isValidNumber; }\n/* harmony export */ });\nfunction dashedToCamel(word) {\n  return word.split(\"-\").map(function(x, i) {\n    return (i ? x[0].toUpperCase() : x[0].toLowerCase()) + x.slice(1).toLowerCase();\n  }).join(\"\");\n}\nfunction constToCamel(word, upperFirst = false) {\n  return word.split(\"_\").map(function(x, i) {\n    return (i || upperFirst ? x[0].toUpperCase() : x[0].toLowerCase()) + x.slice(1).toLowerCase();\n  }).join(\"\");\n}\nfunction camelCase(name) {\n  return name.replace(/[-_]([a-z])/g, ($0, $1) => $1.toUpperCase());\n}\nfunction isValidNumber(x) {\n  return typeof x === \"number\" && !Number.isNaN(x) && Number.isFinite(x);\n}\nfunction isNumericString(str) {\n  if (typeof str != \"string\")\n    return false;\n  return !isNaN(str) && !isNaN(parseFloat(str));\n}\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lZGlhLWNocm9tZS9kaXN0L3V0aWxzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jaHJvbWUvZGlzdC91dGlscy91dGlscy5qcz84MDhjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRhc2hlZFRvQ2FtZWwod29yZCkge1xuICByZXR1cm4gd29yZC5zcGxpdChcIi1cIikubWFwKGZ1bmN0aW9uKHgsIGkpIHtcbiAgICByZXR1cm4gKGkgPyB4WzBdLnRvVXBwZXJDYXNlKCkgOiB4WzBdLnRvTG93ZXJDYXNlKCkpICsgeC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29uc3RUb0NhbWVsKHdvcmQsIHVwcGVyRmlyc3QgPSBmYWxzZSkge1xuICByZXR1cm4gd29yZC5zcGxpdChcIl9cIikubWFwKGZ1bmN0aW9uKHgsIGkpIHtcbiAgICByZXR1cm4gKGkgfHwgdXBwZXJGaXJzdCA/IHhbMF0udG9VcHBlckNhc2UoKSA6IHhbMF0udG9Mb3dlckNhc2UoKSkgKyB4LnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjYW1lbENhc2UobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bLV9dKFthLXpdKS9nLCAoJDAsICQxKSA9PiAkMS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXIoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeCk7XG59XG5mdW5jdGlvbiBpc051bWVyaWNTdHJpbmcoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIWlzTmFOKHN0cikgJiYgIWlzTmFOKHBhcnNlRmxvYXQoc3RyKSk7XG59XG5jb25zdCBkZWxheSA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbmV4cG9ydCB7XG4gIGNhbWVsQ2FzZSxcbiAgY29uc3RUb0NhbWVsLFxuICBkYXNoZWRUb0NhbWVsLFxuICBkZWxheSxcbiAgaXNOdW1lcmljU3RyaW5nLFxuICBpc1ZhbGlkTnVtYmVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/media-chrome/dist/utils/utils.js\n"));

/***/ })

});